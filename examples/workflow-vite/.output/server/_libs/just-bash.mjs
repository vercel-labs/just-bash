import { s as sprintfExports } from "./sprintf-js.mjs";
import { m as minimatch } from "./minimatch.mjs";
import { gunzipSync, gzipSync, constants } from "node:zlib";
import { c as createTwoFilesPatch } from "./diff.mjs";
import { T as TurndownService } from "./turndown.mjs";
import { l as libExports } from "../_chunks/_libs/@mongodb-js/zstd.mjs";
import { A as Ae$4 } from "./compressjs.mjs";
import { fileURLToPath } from "node:url";
import { Worker } from "node:worker_threads";
import { E as E$d } from "../_chunks/_libs/sql.js.mjs";
var n$6 = class n extends Error {
  stdout;
  stderr;
  constructor(t4, s3 = "", e5 = "") {
    super(t4), this.stdout = s3, this.stderr = e5;
  }
  prependOutput(t4, s3) {
    this.stdout = t4 + this.stdout, this.stderr = s3 + this.stderr;
  }
}, c$7 = class c extends n$6 {
  levels;
  name = "BreakError";
  constructor(t4 = 1, s3 = "", e5 = "") {
    super("break", s3, e5), this.levels = t4;
  }
}, a$1 = class a extends n$6 {
  levels;
  name = "ContinueError";
  constructor(t4 = 1, s3 = "", e5 = "") {
    super("continue", s3, e5), this.levels = t4;
  }
}, i$6 = class i extends n$6 {
  exitCode;
  name = "ReturnError";
  constructor(t4 = 0, s3 = "", e5 = "") {
    super("return", s3, e5), this.exitCode = t4;
  }
}, u$8 = class u extends n$6 {
  exitCode;
  name = "ErrexitError";
  constructor(t4, s3 = "", e5 = "") {
    super(`errexit: command exited with status ${t4}`, s3, e5), this.exitCode = t4;
  }
}, x$h = class x extends n$6 {
  varName;
  name = "NounsetError";
  constructor(t4, s3 = "") {
    super(`${t4}: unbound variable`, s3, `bash: ${t4}: unbound variable
`), this.varName = t4;
  }
}, d$8 = class d extends n$6 {
  exitCode;
  name = "ExitError";
  constructor(t4, s3 = "", e5 = "") {
    super("exit", s3, e5), this.exitCode = t4;
  }
}, p$f = class p extends n$6 {
  name = "ArithmeticError";
  fatal;
  constructor(t4, s3 = "", e5 = "", o2 = false) {
    super(t4, s3, e5), this.stderr = e5 || `bash: ${t4}
`, this.fatal = o2;
  }
}, h$f = class h extends n$6 {
  name = "BadSubstitutionError";
  constructor(t4, s3 = "", e5 = "") {
    super(t4, s3, e5), this.stderr = e5 || `bash: ${t4}: bad substitution
`;
  }
}, l$7 = class l extends n$6 {
  name = "GlobError";
  constructor(t4, s3 = "", e5 = "") {
    super(`no match: ${t4}`, s3, e5), this.stderr = e5 || `bash: no match: ${t4}
`;
  }
}, m$e = class m extends n$6 {
  name = "BraceExpansionError";
  constructor(t4, s3 = "", e5 = "") {
    super(t4, s3, e5), this.stderr = e5 || `bash: ${t4}
`;
  }
}, b$i = class b extends n$6 {
  limitType;
  name = "ExecutionLimitError";
  static EXIT_CODE = 126;
  constructor(t4, s3, e5 = "", o2 = "") {
    super(t4, e5, o2), this.limitType = s3, this.stderr = o2 || `bash: ${t4}
`;
  }
}, $$a = class $ extends n$6 {
  name = "SubshellExitError";
  constructor(t4 = "", s3 = "") {
    super("subshell exit", t4, s3);
  }
};
function C$h(r2) {
  return r2 instanceof c$7 || r2 instanceof a$1 || r2 instanceof i$6;
}
var f$7 = class f extends n$6 {
  exitCode;
  name = "PosixFatalError";
  constructor(t4, s3 = "", e5 = "") {
    super("posix fatal error", s3, e5), this.exitCode = t4;
  }
};
function $$9(e5, t4) {
  for (; t4 < e5.length; ) {
    if (e5[t4] === "\\" && e5[t4 + 1] === `
`) {
      t4 += 2;
      continue;
    }
    if (/\s/.test(e5[t4])) {
      t4++;
      continue;
    }
    break;
  }
  return t4;
}
var Ne$3 = ["=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", "&=", "|=", "^="];
function fe$6(e5) {
  if (e5.includes("#")) {
    let [t4, r2] = e5.split("#"), s3 = Number.parseInt(t4, 10);
    if (s3 < 2 || s3 > 64) return Number.NaN;
    if (s3 <= 36) return Number.parseInt(r2, s3);
    let n3 = 0;
    for (let a3 of r2) {
      let i4;
      if (/[0-9]/.test(a3)) i4 = a3.charCodeAt(0) - 48;
      else if (/[a-z]/.test(a3)) i4 = a3.charCodeAt(0) - 97 + 10;
      else if (/[A-Z]/.test(a3)) i4 = a3.charCodeAt(0) - 65 + 36;
      else if (a3 === "@") i4 = 62;
      else if (a3 === "_") i4 = 63;
      else return Number.NaN;
      if (i4 >= s3) return Number.NaN;
      n3 = n3 * s3 + i4;
    }
    return n3;
  }
  return e5.startsWith("0x") || e5.startsWith("0X") ? Number.parseInt(e5.slice(2), 16) : e5.startsWith("0") && e5.length > 1 && /^[0-9]+$/.test(e5) ? /[89]/.test(e5) ? Number.NaN : Number.parseInt(e5, 8) : Number.parseInt(e5, 10);
}
function Pt$2(e5, t4, r2, s3) {
  if (r2.slice(s3, s3 + 3) !== "$((") return null;
  let n3 = s3 + 3, a3 = 1, i4 = n3;
  for (; n3 < r2.length - 1 && a3 > 0; ) r2[n3] === "(" && r2[n3 + 1] === "(" ? (a3++, n3 += 2) : r2[n3] === ")" && r2[n3 + 1] === ")" ? (a3--, a3 > 0 && (n3 += 2)) : n3++;
  let l3 = r2.slice(i4, n3), { expr: o2 } = e5(t4, l3, 0);
  return n3 += 2, { expr: { type: "ArithNested", expression: o2 }, pos: n3 };
}
function Rt$2(e5, t4) {
  if (e5.slice(t4, t4 + 2) !== "$'") return null;
  let r2 = t4 + 2, s3 = "";
  for (; r2 < e5.length && e5[r2] !== "'"; ) if (e5[r2] === "\\" && r2 + 1 < e5.length) {
    let a3 = e5[r2 + 1];
    switch (a3) {
      case "n":
        s3 += `
`;
        break;
      case "t":
        s3 += "	";
        break;
      case "r":
        s3 += "\r";
        break;
      case "\\":
        s3 += "\\";
        break;
      case "'":
        s3 += "'";
        break;
      default:
        s3 += a3;
    }
    r2 += 2;
  } else s3 += e5[r2], r2++;
  e5[r2] === "'" && r2++;
  let n3 = Number.parseInt(s3, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(n3) ? 0 : n3 }, pos: r2 };
}
function It$2(e5, t4) {
  if (e5.slice(t4, t4 + 2) !== '$"') return null;
  let r2 = t4 + 2, s3 = "";
  for (; r2 < e5.length && e5[r2] !== '"'; ) e5[r2] === "\\" && r2 + 1 < e5.length ? (s3 += e5[r2 + 1], r2 += 2) : (s3 += e5[r2], r2++);
  e5[r2] === '"' && r2++;
  let n3 = Number.parseInt(s3, 10);
  return { expr: { type: "ArithNumber", value: Number.isNaN(n3) ? 0 : n3 }, pos: r2 };
}
function Ar$1(e5) {
  let t4 = "", r2 = 0;
  for (; r2 < e5.length; ) if (e5[r2] === '"') {
    for (r2++; r2 < e5.length && e5[r2] !== '"'; ) e5[r2] === "\\" && r2 + 1 < e5.length ? (t4 += e5[r2 + 1], r2 += 2) : (t4 += e5[r2], r2++);
    r2 < e5.length && r2++;
  } else t4 += e5[r2], r2++;
  return t4;
}
function W$d(e5, t4) {
  let r2 = Ar$1(t4), { expr: s3, pos: n3 } = F$b(e5, r2, 0), a3 = $$9(r2, n3);
  if (a3 < r2.length) {
    let i4 = t4.slice(a3).trim();
    if (i4) return { type: "ArithmeticExpression", originalText: t4, expression: { type: "ArithSyntaxError", errorToken: i4, message: `${i4}: syntax error: invalid arithmetic operator (error token is "${i4}")` } };
  }
  return { type: "ArithmeticExpression", expression: s3, originalText: t4 };
}
function q$e(e5, t4) {
  return { expr: { type: "ArithSyntaxError", errorToken: e5, message: `syntax error: operand expected (error token is "${e5}")` }, pos: t4 };
}
function B$c(e5, t4) {
  return $$9(e5, t4) >= e5.length;
}
function F$b(e5, t4, r2) {
  return Sr$2(e5, t4, r2);
}
function Sr$2(e5, t4, r2) {
  let { expr: s3, pos: n3 } = pe$5(e5, t4, r2);
  for (n3 = $$9(t4, n3); t4[n3] === ","; ) {
    if (n3++, B$c(t4, n3)) return q$e(",", n3);
    let { expr: i4, pos: l3 } = pe$5(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: ",", left: s3, right: i4 }, n3 = $$9(t4, l3);
  }
  return { expr: s3, pos: n3 };
}
function pe$5(e5, t4, r2) {
  let { expr: s3, pos: n3 } = br$1(e5, t4, r2);
  if (n3 = $$9(t4, n3), t4[n3] === "?") {
    n3++;
    let { expr: a3, pos: i4 } = F$b(e5, t4, n3);
    if (n3 = $$9(t4, i4), t4[n3] === ":") {
      n3++;
      let { expr: l3, pos: o2 } = F$b(e5, t4, n3);
      return { expr: { type: "ArithTernary", condition: s3, consequent: a3, alternate: l3 }, pos: o2 };
    }
  }
  return { expr: s3, pos: n3 };
}
function br$1(e5, t4, r2) {
  let { expr: s3, pos: n3 } = vt$3(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4.slice(n3, n3 + 2) === "||"; ) {
    if (n3 += 2, B$c(t4, n3)) return q$e("||", n3);
    let { expr: i4, pos: l3 } = vt$3(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "||", left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function vt$3(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Dt$1(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4.slice(n3, n3 + 2) === "&&"; ) {
    if (n3 += 2, B$c(t4, n3)) return q$e("&&", n3);
    let { expr: i4, pos: l3 } = Dt$1(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "&&", left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function Dt$1(e5, t4, r2) {
  let { expr: s3, pos: n3 } = xt$2(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4[n3] === "|" && t4[n3 + 1] !== "|"; ) {
    if (n3++, B$c(t4, n3)) return q$e("|", n3);
    let { expr: i4, pos: l3 } = xt$2(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "|", left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function xt$2(e5, t4, r2) {
  let { expr: s3, pos: n3 } = $t$2(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4[n3] === "^"; ) {
    if (n3++, B$c(t4, n3)) return q$e("^", n3);
    let { expr: i4, pos: l3 } = $t$2(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "^", left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function $t$2(e5, t4, r2) {
  let { expr: s3, pos: n3 } = _t$2(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4[n3] === "&" && t4[n3 + 1] !== "&"; ) {
    if (n3++, B$c(t4, n3)) return q$e("&", n3);
    let { expr: i4, pos: l3 } = _t$2(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "&", left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function _t$2(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Ct$1(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4.slice(n3, n3 + 2) === "==" || t4.slice(n3, n3 + 2) === "!="; ) {
    let a3 = t4.slice(n3, n3 + 2);
    if (n3 += 2, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = Ct$1(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function Ct$1(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Be$6(e5, t4, r2);
  for (; ; ) if (n3 = $$9(t4, n3), t4.slice(n3, n3 + 2) === "<=" || t4.slice(n3, n3 + 2) === ">=") {
    let a3 = t4.slice(n3, n3 + 2);
    if (n3 += 2, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = Be$6(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  } else if (t4[n3] === "<" || t4[n3] === ">") {
    let a3 = t4[n3];
    if (n3++, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = Be$6(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  } else break;
  return { expr: s3, pos: n3 };
}
function Be$6(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Ot$2(e5, t4, r2);
  for (; n3 = $$9(t4, n3), t4.slice(n3, n3 + 2) === "<<" || t4.slice(n3, n3 + 2) === ">>"; ) {
    let a3 = t4.slice(n3, n3 + 2);
    if (n3 += 2, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = Ot$2(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function Ot$2(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Lt$1(e5, t4, r2);
  for (; n3 = $$9(t4, n3), (t4[n3] === "+" || t4[n3] === "-") && t4[n3 + 1] !== t4[n3]; ) {
    let a3 = t4[n3];
    if (n3++, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = Lt$1(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  }
  return { expr: s3, pos: n3 };
}
function Lt$1(e5, t4, r2) {
  let { expr: s3, pos: n3 } = ke$7(e5, t4, r2);
  for (; ; ) if (n3 = $$9(t4, n3), t4[n3] === "*" && t4[n3 + 1] !== "*") {
    if (n3++, B$c(t4, n3)) return q$e("*", n3);
    let { expr: i4, pos: l3 } = ke$7(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: "*", left: s3, right: i4 }, n3 = l3;
  } else if (t4[n3] === "/" || t4[n3] === "%") {
    let a3 = t4[n3];
    if (n3++, B$c(t4, n3)) return q$e(a3, n3);
    let { expr: i4, pos: l3 } = ke$7(e5, t4, n3);
    s3 = { type: "ArithBinary", operator: a3, left: s3, right: i4 }, n3 = l3;
  } else break;
  return { expr: s3, pos: n3 };
}
function ke$7(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Fe$6(e5, t4, r2), a3 = $$9(t4, n3);
  if (t4.slice(a3, a3 + 2) === "**") {
    if (a3 += 2, B$c(t4, a3)) return q$e("**", a3);
    let { expr: l3, pos: o2 } = ke$7(e5, t4, a3);
    return { expr: { type: "ArithBinary", operator: "**", left: s3, right: l3 }, pos: o2 };
  }
  return { expr: s3, pos: n3 };
}
function Fe$6(e5, t4, r2) {
  let s3 = $$9(t4, r2);
  if (t4.slice(s3, s3 + 2) === "++" || t4.slice(s3, s3 + 2) === "--") {
    let n3 = t4.slice(s3, s3 + 2);
    s3 += 2;
    let { expr: a3, pos: i4 } = Fe$6(e5, t4, s3);
    return { expr: { type: "ArithUnary", operator: n3, operand: a3, prefix: true }, pos: i4 };
  }
  if (t4[s3] === "+" || t4[s3] === "-" || t4[s3] === "!" || t4[s3] === "~") {
    let n3 = t4[s3];
    s3++;
    let { expr: a3, pos: i4 } = Fe$6(e5, t4, s3);
    return { expr: { type: "ArithUnary", operator: n3, operand: a3, prefix: true }, pos: i4 };
  }
  return Nr$1(e5, t4, s3);
}
function wr$1(e5, t4) {
  let r2 = e5[t4];
  return r2 === "$" || r2 === "`";
}
function Nr$1(e5, t4, r2) {
  let { expr: s3, pos: n3 } = Wt$1(e5, t4, r2, false), a3 = [s3];
  for (; wr$1(t4, n3); ) {
    let { expr: l3, pos: o2 } = Wt$1(e5, t4, n3, true);
    a3.push(l3), n3 = o2;
  }
  a3.length > 1 && (s3 = { type: "ArithConcat", parts: a3 });
  let i4;
  if (t4[n3] === "[" && s3.type === "ArithConcat") {
    n3++;
    let { expr: l3, pos: o2 } = F$b(e5, t4, n3);
    i4 = l3, n3 = o2, t4[n3] === "]" && n3++;
  }
  if (i4 && s3.type === "ArithConcat" && (s3 = { type: "ArithDynamicElement", nameExpr: s3, subscript: i4 }, i4 = void 0), n3 = $$9(t4, n3), s3.type === "ArithConcat" || s3.type === "ArithVariable" || s3.type === "ArithDynamicElement") {
    for (let l3 of Ne$3) if (t4.slice(n3, n3 + l3.length) === l3 && t4.slice(n3, n3 + l3.length + 1) !== "==") {
      n3 += l3.length;
      let { expr: o2, pos: c3 } = pe$5(e5, t4, n3);
      return s3.type === "ArithDynamicElement" ? { expr: { type: "ArithDynamicAssignment", operator: l3, target: s3.nameExpr, subscript: s3.subscript, value: o2 }, pos: c3 } : s3.type === "ArithConcat" ? { expr: { type: "ArithDynamicAssignment", operator: l3, target: s3, value: o2 }, pos: c3 } : { expr: { type: "ArithAssignment", operator: l3, variable: s3.name, value: o2 }, pos: c3 };
    }
  }
  if (t4.slice(n3, n3 + 2) === "++" || t4.slice(n3, n3 + 2) === "--") {
    let l3 = t4.slice(n3, n3 + 2);
    return n3 += 2, { expr: { type: "ArithUnary", operator: l3, operand: s3, prefix: false }, pos: n3 };
  }
  return { expr: s3, pos: n3 };
}
function Wt$1(e5, t4, r2, s3 = false) {
  let n3 = $$9(t4, r2), a3 = Pt$2(F$b, e5, t4, n3);
  if (a3) return a3;
  let i4 = Rt$2(t4, n3);
  if (i4) return i4;
  let l3 = It$2(t4, n3);
  if (l3) return l3;
  if (t4.slice(n3, n3 + 2) === "$(" && t4[n3 + 2] !== "(") {
    n3 += 2;
    let c3 = 1, u3 = n3;
    for (; n3 < t4.length && c3 > 0; ) t4[n3] === "(" ? c3++ : t4[n3] === ")" && c3--, c3 > 0 && n3++;
    let f3 = t4.slice(u3, n3);
    return n3++, { expr: { type: "ArithCommandSubst", command: f3 }, pos: n3 };
  }
  if (t4[n3] === "`") {
    n3++;
    let c3 = n3;
    for (; n3 < t4.length && t4[n3] !== "`"; ) n3++;
    let u3 = t4.slice(c3, n3);
    return t4[n3] === "`" && n3++, { expr: { type: "ArithCommandSubst", command: u3 }, pos: n3 };
  }
  if (t4[n3] === "(") {
    n3++;
    let { expr: c3, pos: u3 } = F$b(e5, t4, n3);
    return n3 = $$9(t4, u3), t4[n3] === ")" && n3++, { expr: { type: "ArithGroup", expression: c3 }, pos: n3 };
  }
  if (t4[n3] === "'") {
    n3++;
    let c3 = "";
    for (; n3 < t4.length && t4[n3] !== "'"; ) c3 += t4[n3], n3++;
    t4[n3] === "'" && n3++;
    let u3 = Number.parseInt(c3, 10);
    return { expr: { type: "ArithSingleQuote", content: c3, value: Number.isNaN(u3) ? 0 : u3 }, pos: n3 };
  }
  if (t4[n3] === '"') {
    n3++;
    let c3 = "";
    for (; n3 < t4.length && t4[n3] !== '"'; ) t4[n3] === "\\" && n3 + 1 < t4.length ? (c3 += t4[n3 + 1], n3 += 2) : (c3 += t4[n3], n3++);
    t4[n3] === '"' && n3++;
    let u3 = c3.trim();
    if (!u3) return { expr: { type: "ArithNumber", value: 0 }, pos: n3 };
    let { expr: f3 } = F$b(e5, u3, 0);
    return { expr: f3, pos: n3 };
  }
  if (/[0-9]/.test(t4[n3])) {
    let c3 = "", u3 = false, f3 = false;
    for (; n3 < t4.length; ) {
      let d3 = t4[n3];
      if (u3) if (/[0-9a-zA-Z@_]/.test(d3)) c3 += d3, n3++;
      else break;
      else if (d3 === "#") u3 = true, c3 += d3, n3++;
      else if (c3 === "0" && (d3 === "x" || d3 === "X") && n3 + 1 < t4.length && /[0-9a-fA-F]/.test(t4[n3 + 1])) f3 = true, c3 += d3, n3++;
      else if (f3 && /[0-9a-fA-F]/.test(d3)) c3 += d3, n3++;
      else if (!f3 && /[0-9]/.test(d3)) c3 += d3, n3++;
      else break;
    }
    if (n3 < t4.length && /[a-zA-Z_]/.test(t4[n3])) {
      let d3 = c3;
      for (; n3 < t4.length && /[a-zA-Z0-9_]/.test(t4[n3]); ) d3 += t4[n3], n3++;
      return { expr: { type: "ArithSyntaxError", errorToken: d3, message: `${d3}: value too great for base (error token is "${d3}")` }, pos: n3 };
    }
    if (t4[n3] === "." && /[0-9]/.test(t4[n3 + 1])) throw new p$f(`${c3}.${t4[n3 + 1]}...: syntax error: invalid arithmetic operator`);
    if (t4[n3] === "[") {
      let d3 = t4.slice(n3).trim();
      return { expr: { type: "ArithNumberSubscript", number: c3, errorToken: d3 }, pos: t4.length };
    }
    return { expr: { type: "ArithNumber", value: fe$6(c3) }, pos: n3 };
  }
  if (t4[n3] === "$" && t4[n3 + 1] === "{") {
    let c3 = n3 + 2, u3 = 1, f3 = c3;
    for (; f3 < t4.length && u3 > 0; ) t4[f3] === "{" ? u3++ : t4[f3] === "}" && u3--, u3 > 0 && f3++;
    let h3 = t4.slice(c3, f3), d3 = f3 + 1;
    if (t4[d3] === "#") {
      let y2 = d3 + 1;
      for (; y2 < t4.length && /[0-9a-zA-Z@_]/.test(t4[y2]); ) y2++;
      let g2 = t4.slice(d3 + 1, y2);
      return { expr: { type: "ArithDynamicBase", baseExpr: h3, value: g2 }, pos: y2 };
    }
    if (/[0-9]/.test(t4[d3]) || t4[d3] === "x" || t4[d3] === "X") {
      let y2 = d3;
      if (t4[d3] === "x" || t4[d3] === "X") for (y2++; y2 < t4.length && /[0-9a-fA-F]/.test(t4[y2]); ) y2++;
      else for (; y2 < t4.length && /[0-9]/.test(t4[y2]); ) y2++;
      let g2 = t4.slice(d3, y2);
      return { expr: { type: "ArithDynamicNumber", prefix: h3, suffix: g2 }, pos: y2 };
    }
    return n3 = d3, { expr: { type: "ArithBracedExpansion", content: h3 }, pos: n3 };
  }
  if (t4[n3] === "$" && n3 + 1 < t4.length && /[0-9]/.test(t4[n3 + 1])) {
    n3++;
    let c3 = "";
    for (; n3 < t4.length && /[0-9]/.test(t4[n3]); ) c3 += t4[n3], n3++;
    return { expr: { type: "ArithVariable", name: c3, hasDollarPrefix: true }, pos: n3 };
  }
  if (t4[n3] === "$" && n3 + 1 < t4.length && /[*@#?\-!$]/.test(t4[n3 + 1])) {
    let c3 = t4[n3 + 1];
    return n3 += 2, { expr: { type: "ArithSpecialVar", name: c3 }, pos: n3 };
  }
  let o2 = false;
  if (t4[n3] === "$" && n3 + 1 < t4.length && /[a-zA-Z_]/.test(t4[n3 + 1]) && (o2 = true, n3++), n3 < t4.length && /[a-zA-Z_]/.test(t4[n3])) {
    let c3 = "";
    for (; n3 < t4.length && /[a-zA-Z0-9_]/.test(t4[n3]); ) c3 += t4[n3], n3++;
    if (t4[n3] === "[" && !s3) {
      n3++;
      let u3;
      if (t4[n3] === "'" || t4[n3] === '"') {
        let h3 = t4[n3];
        for (n3++, u3 = ""; n3 < t4.length && t4[n3] !== h3; ) u3 += t4[n3], n3++;
        t4[n3] === h3 && n3++, n3 = $$9(t4, n3), t4[n3] === "]" && n3++;
      }
      let f3;
      if (u3 === void 0) {
        let { expr: h3, pos: d3 } = F$b(e5, t4, n3);
        f3 = h3, n3 = d3, t4[n3] === "]" && n3++;
      }
      if (n3 = $$9(t4, n3), t4[n3] === "[" && f3) return { expr: { type: "ArithDoubleSubscript", array: c3, index: f3 }, pos: n3 };
      if (!s3) {
        for (let h3 of Ne$3) if (t4.slice(n3, n3 + h3.length) === h3 && t4.slice(n3, n3 + h3.length + 1) !== "==") {
          n3 += h3.length;
          let { expr: d3, pos: y2 } = pe$5(e5, t4, n3);
          return { expr: { type: "ArithAssignment", operator: h3, variable: c3, subscript: f3, stringKey: u3, value: d3 }, pos: y2 };
        }
      }
      return { expr: { type: "ArithArrayElement", array: c3, index: f3, stringKey: u3 }, pos: n3 };
    }
    if (n3 = $$9(t4, n3), !s3) {
      for (let u3 of Ne$3) if (t4.slice(n3, n3 + u3.length) === u3 && t4.slice(n3, n3 + u3.length + 1) !== "==") {
        n3 += u3.length;
        let { expr: f3, pos: h3 } = pe$5(e5, t4, n3);
        return { expr: { type: "ArithAssignment", operator: u3, variable: c3, value: f3 }, pos: h3 };
      }
    }
    return { expr: { type: "ArithVariable", name: c3, hasDollarPrefix: o2 }, pos: n3 };
  }
  if (t4[n3] === "#") {
    let c3 = n3 + 1;
    for (; c3 < t4.length && t4[c3] !== `
`; ) c3++;
    let u3 = t4.slice(n3, c3).trim() || "#";
    return { expr: { type: "ArithSyntaxError", errorToken: u3, message: `${u3}: syntax error: invalid arithmetic operator (error token is "${u3}")` }, pos: t4.length };
  }
  return { expr: { type: "ArithNumber", value: 0 }, pos: n3 };
}
var b$h = { script(e5) {
  return { type: "Script", statements: e5 };
}, statement(e5, t4 = [], r2 = false, s3, n3) {
  let a3 = { type: "Statement", pipelines: e5, operators: t4, background: r2 };
  return s3 && (a3.deferredError = s3), n3 !== void 0 && (a3.sourceText = n3), a3;
}, pipeline(e5, t4 = false, r2 = false, s3 = false, n3) {
  return { type: "Pipeline", commands: e5, negated: t4, timed: r2, timePosix: s3, pipeStderr: n3 };
}, simpleCommand(e5, t4 = [], r2 = [], s3 = []) {
  return { type: "SimpleCommand", name: e5, args: t4, assignments: r2, redirections: s3 };
}, word(e5) {
  return { type: "Word", parts: e5 };
}, literal(e5) {
  return { type: "Literal", value: e5 };
}, singleQuoted(e5) {
  return { type: "SingleQuoted", value: e5 };
}, doubleQuoted(e5) {
  return { type: "DoubleQuoted", parts: e5 };
}, escaped(e5) {
  return { type: "Escaped", value: e5 };
}, parameterExpansion(e5, t4 = null) {
  return { type: "ParameterExpansion", parameter: e5, operation: t4 };
}, commandSubstitution(e5, t4 = false) {
  return { type: "CommandSubstitution", body: e5, legacy: t4 };
}, arithmeticExpansion(e5) {
  return { type: "ArithmeticExpansion", expression: e5 };
}, assignment(e5, t4, r2 = false, s3 = null) {
  return { type: "Assignment", name: e5, value: t4, append: r2, array: s3 };
}, redirection(e5, t4, r2 = null, s3) {
  let n3 = { type: "Redirection", fd: r2, operator: e5, target: t4 };
  return s3 && (n3.fdVariable = s3), n3;
}, hereDoc(e5, t4, r2 = false, s3 = false) {
  return { type: "HereDoc", delimiter: e5, content: t4, stripTabs: r2, quoted: s3 };
}, ifNode(e5, t4 = null, r2 = []) {
  return { type: "If", clauses: e5, elseBody: t4, redirections: r2 };
}, forNode(e5, t4, r2, s3 = []) {
  return { type: "For", variable: e5, words: t4, body: r2, redirections: s3 };
}, whileNode(e5, t4, r2 = []) {
  return { type: "While", condition: e5, body: t4, redirections: r2 };
}, untilNode(e5, t4, r2 = []) {
  return { type: "Until", condition: e5, body: t4, redirections: r2 };
}, caseNode(e5, t4, r2 = []) {
  return { type: "Case", word: e5, items: t4, redirections: r2 };
}, caseItem(e5, t4, r2 = ";;") {
  return { type: "CaseItem", patterns: e5, body: t4, terminator: r2 };
}, subshell(e5, t4 = []) {
  return { type: "Subshell", body: e5, redirections: t4 };
}, group(e5, t4 = []) {
  return { type: "Group", body: e5, redirections: t4 };
}, functionDef(e5, t4, r2 = [], s3) {
  return { type: "FunctionDef", name: e5, body: t4, redirections: r2, sourceFile: s3 };
}, conditionalCommand(e5, t4 = [], r2) {
  return { type: "ConditionalCommand", expression: e5, redirections: t4, line: r2 };
}, arithmeticCommand(e5, t4 = [], r2) {
  return { type: "ArithmeticCommand", expression: e5, redirections: t4, line: r2 };
} };
var p$e;
(function(e5) {
  e5.EOF = "EOF", e5.NEWLINE = "NEWLINE", e5.SEMICOLON = "SEMICOLON", e5.AMP = "AMP", e5.PIPE = "PIPE", e5.PIPE_AMP = "PIPE_AMP", e5.AND_AND = "AND_AND", e5.OR_OR = "OR_OR", e5.BANG = "BANG", e5.LESS = "LESS", e5.GREAT = "GREAT", e5.DLESS = "DLESS", e5.DGREAT = "DGREAT", e5.LESSAND = "LESSAND", e5.GREATAND = "GREATAND", e5.LESSGREAT = "LESSGREAT", e5.DLESSDASH = "DLESSDASH", e5.CLOBBER = "CLOBBER", e5.TLESS = "TLESS", e5.AND_GREAT = "AND_GREAT", e5.AND_DGREAT = "AND_DGREAT", e5.LPAREN = "LPAREN", e5.RPAREN = "RPAREN", e5.LBRACE = "LBRACE", e5.RBRACE = "RBRACE", e5.DSEMI = "DSEMI", e5.SEMI_AND = "SEMI_AND", e5.SEMI_SEMI_AND = "SEMI_SEMI_AND", e5.DBRACK_START = "DBRACK_START", e5.DBRACK_END = "DBRACK_END", e5.DPAREN_START = "DPAREN_START", e5.DPAREN_END = "DPAREN_END", e5.IF = "IF", e5.THEN = "THEN", e5.ELSE = "ELSE", e5.ELIF = "ELIF", e5.FI = "FI", e5.FOR = "FOR", e5.WHILE = "WHILE", e5.UNTIL = "UNTIL", e5.DO = "DO", e5.DONE = "DONE", e5.CASE = "CASE", e5.ESAC = "ESAC", e5.IN = "IN", e5.FUNCTION = "FUNCTION", e5.SELECT = "SELECT", e5.TIME = "TIME", e5.COPROC = "COPROC", e5.WORD = "WORD", e5.NAME = "NAME", e5.NUMBER = "NUMBER", e5.ASSIGNMENT_WORD = "ASSIGNMENT_WORD", e5.FD_VARIABLE = "FD_VARIABLE", e5.COMMENT = "COMMENT", e5.HEREDOC_CONTENT = "HEREDOC_CONTENT";
})(p$e || (p$e = {}));
var he$6 = class he extends Error {
  line;
  column;
  constructor(t4, r2, s3) {
    super(`line ${r2}: ${t4}`), this.line = r2, this.column = s3, this.name = "LexerError";
  }
}, Pe$5 = { if: p$e.IF, then: p$e.THEN, else: p$e.ELSE, elif: p$e.ELIF, fi: p$e.FI, for: p$e.FOR, while: p$e.WHILE, until: p$e.UNTIL, do: p$e.DO, done: p$e.DONE, case: p$e.CASE, esac: p$e.ESAC, in: p$e.IN, function: p$e.FUNCTION, select: p$e.SELECT, time: p$e.TIME, coproc: p$e.COPROC };
function Mt(e5) {
  let t4 = e5.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t4) return false;
  let r2 = e5.slice(t4[0].length);
  if (r2 === "" || r2 === "+") return true;
  if (r2[0] === "[") {
    let s3 = 0, n3 = 0;
    for (; n3 < r2.length; n3++) if (r2[n3] === "[") s3++;
    else if (r2[n3] === "]" && (s3--, s3 === 0)) break;
    if (s3 !== 0 || n3 >= r2.length) return false;
    let a3 = r2.slice(n3 + 1);
    return a3 === "" || a3 === "+";
  }
  return false;
}
function Vt(e5) {
  let t4 = 0;
  for (let r2 = 0; r2 < e5.length; r2++) {
    let s3 = e5[r2];
    if (s3 === "[") t4++;
    else if (s3 === "]") t4--;
    else {
      if (t4 === 0 && s3 === "=") return r2;
      if (t4 === 0 && s3 === "+" && e5[r2 + 1] === "=") return r2 + 1;
    }
  }
  return -1;
}
var kr$1 = [[";", ";", "&", p$e.SEMI_SEMI_AND], ["<", "<", "<", p$e.TLESS], ["&", ">", ">", p$e.AND_DGREAT]], Pr$1 = [["[", "[", p$e.DBRACK_START], ["]", "]", p$e.DBRACK_END], ["(", "(", p$e.DPAREN_START], [")", ")", p$e.DPAREN_END], ["&", "&", p$e.AND_AND], ["|", "|", p$e.OR_OR], [";", ";", p$e.DSEMI], [";", "&", p$e.SEMI_AND], ["|", "&", p$e.PIPE_AMP], [">", ">", p$e.DGREAT], ["<", "&", p$e.LESSAND], [">", "&", p$e.GREATAND], ["<", ">", p$e.LESSGREAT], [">", "|", p$e.CLOBBER], ["&", ">", p$e.AND_GREAT]], Rr = { "|": p$e.PIPE, "&": p$e.AMP, ";": p$e.SEMICOLON, "(": p$e.LPAREN, ")": p$e.RPAREN, "<": p$e.LESS, ">": p$e.GREAT };
function Ir$1(e5) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e5);
}
function qt$1(e5) {
  return e5 === " " || e5 === "	" || e5 === `
` || e5 === ";" || e5 === "&" || e5 === "|" || e5 === "(" || e5 === ")" || e5 === "<" || e5 === ">";
}
var Re$3 = class Re {
  input;
  pos = 0;
  line = 1;
  column = 1;
  tokens = [];
  pendingHeredocs = [];
  dparenDepth = 0;
  constructor(t4) {
    this.input = t4;
  }
  tokenize() {
    let r2 = this.input.length, s3 = this.tokens, n3 = this.pendingHeredocs;
    for (; this.pos < r2; ) {
      if (n3.length > 0 && s3.length > 0 && s3[s3.length - 1].type === p$e.NEWLINE) {
        this.readHeredocContent();
        continue;
      }
      if (this.skipWhitespace(), this.pos >= r2) break;
      let a3 = this.nextToken();
      a3 && s3.push(a3);
    }
    return s3.push({ type: p$e.EOF, value: "", start: this.pos, end: this.pos, line: this.line, column: this.column }), s3;
  }
  skipWhitespace() {
    let t4 = this.input, r2 = t4.length, s3 = this.pos, n3 = this.column, a3 = this.line;
    for (; s3 < r2; ) {
      let i4 = t4[s3];
      if (i4 === " " || i4 === "	") s3++, n3++;
      else if (i4 === "\\" && t4[s3 + 1] === `
`) s3 += 2, a3++, n3 = 1;
      else break;
    }
    this.pos = s3, this.column = n3, this.line = a3;
  }
  nextToken() {
    let t4 = this.input, r2 = this.pos, s3 = this.line, n3 = this.column, a3 = t4[r2], i4 = t4[r2 + 1], l3 = t4[r2 + 2];
    if (a3 === "#" && this.dparenDepth === 0) return this.readComment(r2, s3, n3);
    if (a3 === `
`) return this.pos = r2 + 1, this.line++, this.column = 1, { type: p$e.NEWLINE, value: `
`, start: r2, end: r2 + 1, line: s3, column: n3 };
    if (a3 === "<" && i4 === "<" && l3 === "-") return this.pos = r2 + 3, this.column = n3 + 3, this.registerHeredocFromLookahead(true), this.makeToken(p$e.DLESSDASH, "<<-", r2, s3, n3);
    for (let [c3, u3, f3, h3] of kr$1) if (a3 === c3 && i4 === u3 && l3 === f3) return this.pos = r2 + 3, this.column = n3 + 3, this.makeToken(h3, c3 + u3 + f3, r2, s3, n3);
    if (a3 === "<" && i4 === "<") return this.pos = r2 + 2, this.column = n3 + 2, this.registerHeredocFromLookahead(false), this.makeToken(p$e.DLESS, "<<", r2, s3, n3);
    if (a3 === "(" && i4 === "(") return this.dparenDepth > 0 ? (this.pos = r2 + 1, this.column = n3 + 1, this.dparenDepth++, this.makeToken(p$e.LPAREN, "(", r2, s3, n3)) : this.looksLikeNestedSubshells(r2 + 2) || this.dparenClosesWithSpacedParens(r2 + 2) ? (this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(p$e.LPAREN, "(", r2, s3, n3)) : (this.pos = r2 + 2, this.column = n3 + 2, this.dparenDepth = 1, this.makeToken(p$e.DPAREN_START, "((", r2, s3, n3));
    if (a3 === ")" && i4 === ")") return this.dparenDepth === 1 ? (this.pos = r2 + 2, this.column = n3 + 2, this.dparenDepth = 0, this.makeToken(p$e.DPAREN_END, "))", r2, s3, n3)) : this.dparenDepth > 1 ? (this.pos = r2 + 1, this.column = n3 + 1, this.dparenDepth--, this.makeToken(p$e.RPAREN, ")", r2, s3, n3)) : (this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(p$e.RPAREN, ")", r2, s3, n3));
    for (let [c3, u3, f3] of Pr$1) if (!(c3 === "(" && u3 === "(" || c3 === ")" && u3 === ")") && !(this.dparenDepth > 0 && c3 === ";" && (f3 === p$e.DSEMI || f3 === p$e.SEMI_AND || f3 === p$e.SEMI_SEMI_AND)) && a3 === c3 && i4 === u3) {
      if (f3 === p$e.DBRACK_START || f3 === p$e.DBRACK_END) {
        let h3 = t4[r2 + 2];
        if (h3 !== void 0 && h3 !== " " && h3 !== "	" && h3 !== `
` && h3 !== ";" && h3 !== "&" && h3 !== "|" && h3 !== "(" && h3 !== ")" && h3 !== "<" && h3 !== ">") break;
      }
      return this.pos = r2 + 2, this.column = n3 + 2, this.makeToken(f3, c3 + u3, r2, s3, n3);
    }
    if (a3 === "(" && this.dparenDepth > 0) return this.pos = r2 + 1, this.column = n3 + 1, this.dparenDepth++, this.makeToken(p$e.LPAREN, "(", r2, s3, n3);
    if (a3 === ")" && this.dparenDepth > 1) return this.pos = r2 + 1, this.column = n3 + 1, this.dparenDepth--, this.makeToken(p$e.RPAREN, ")", r2, s3, n3);
    let o2 = Rr[a3];
    if (o2) return this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(o2, a3, r2, s3, n3);
    if (a3 === "{") {
      let c3 = this.scanFdVariable(r2);
      return c3 !== null ? (this.pos = c3.end, this.column = n3 + (c3.end - r2), { type: p$e.FD_VARIABLE, value: c3.varname, start: r2, end: c3.end, line: s3, column: n3 }) : i4 === "}" ? (this.pos = r2 + 2, this.column = n3 + 2, { type: p$e.WORD, value: "{}", start: r2, end: r2 + 2, line: s3, column: n3, quoted: false, singleQuoted: false }) : this.scanBraceExpansion(r2) !== null ? this.readWordWithBraceExpansion(r2, s3, n3) : this.scanLiteralBraceWord(r2) !== null ? this.readWordWithBraceExpansion(r2, s3, n3) : i4 !== void 0 && i4 !== " " && i4 !== "	" && i4 !== `
` ? this.readWord(r2, s3, n3) : (this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(p$e.LBRACE, "{", r2, s3, n3));
    }
    return a3 === "}" ? this.isWordCharFollowing(r2 + 1) ? this.readWord(r2, s3, n3) : (this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(p$e.RBRACE, "}", r2, s3, n3)) : a3 === "!" ? i4 === "=" ? (this.pos = r2 + 2, this.column = n3 + 2, this.makeToken(p$e.WORD, "!=", r2, s3, n3)) : (this.pos = r2 + 1, this.column = n3 + 1, this.makeToken(p$e.BANG, "!", r2, s3, n3)) : this.readWord(r2, s3, n3);
  }
  looksLikeNestedSubshells(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4;
    for (; n3 < s3 && (r2[n3] === " " || r2[n3] === "	"); ) n3++;
    if (n3 >= s3) return false;
    let a3 = r2[n3];
    if (a3 === "(") return this.looksLikeNestedSubshells(n3 + 1);
    let i4 = /[a-zA-Z_]/.test(a3), l3 = a3 === "!" || a3 === "[";
    if (!i4 && !l3) return false;
    let o2 = n3;
    for (; o2 < s3 && /[a-zA-Z0-9_\-.]/.test(r2[o2]); ) o2++;
    if (o2 === n3) return l3;
    let c3 = o2;
    for (; c3 < s3 && (r2[c3] === " " || r2[c3] === "	"); ) c3++;
    if (c3 >= s3) return false;
    let u3 = r2[c3];
    if (u3 === "=" && r2[c3 + 1] !== "=" || u3 === `
` || o2 === c3 && /[+\-*/%<>&|^!~?:]/.test(u3) && u3 !== "-" || u3 === ")" && r2[c3 + 1] === ")") return false;
    if (c3 > o2 && (u3 === "-" || u3 === '"' || u3 === "'" || u3 === "$" || /[a-zA-Z_/.]/.test(u3))) {
      let f3 = c3;
      for (; f3 < s3 && r2[f3] !== `
`; ) {
        if (r2[f3] === ")") return true;
        f3++;
      }
      return false;
    }
    if (u3 === ")") {
      let f3 = c3 + 1;
      for (; f3 < s3 && (r2[f3] === " " || r2[f3] === "	"); ) f3++;
      if (r2[f3] === "|" && r2[f3 + 1] === "|" || r2[f3] === "&" && r2[f3 + 1] === "&" || r2[f3] === ";" || r2[f3] === "|" && r2[f3 + 1] !== "|") return true;
    }
    return false;
  }
  makeToken(t4, r2, s3, n3, a3) {
    return { type: t4, value: r2, start: s3, end: this.pos, line: n3, column: a3 };
  }
  readComment(t4, r2, s3) {
    let n3 = this.input, a3 = n3.length, i4 = this.pos;
    for (; i4 < a3 && n3[i4] !== `
`; ) i4++;
    let l3 = n3.slice(t4, i4);
    return this.pos = i4, this.column = s3 + (i4 - t4), { type: p$e.COMMENT, value: l3, start: t4, end: i4, line: r2, column: s3 };
  }
  readWord(t4, r2, s3) {
    let n3 = this.input, a3 = n3.length, i4 = this.pos, l3 = i4;
    for (; i4 < a3; ) {
      let m3 = n3[i4];
      if (m3 === " " || m3 === "	" || m3 === `
` || m3 === ";" || m3 === "&" || m3 === "|" || m3 === "(" || m3 === ")" || m3 === "<" || m3 === ">" || m3 === "'" || m3 === '"' || m3 === "\\" || m3 === "$" || m3 === "`" || m3 === "{" || m3 === "}" || m3 === "~" || m3 === "*" || m3 === "?" || m3 === "[") break;
      i4++;
    }
    if (i4 > l3) {
      let m3 = n3[i4];
      if (!(m3 === "(" && i4 > l3 && "@*+?!".includes(n3[i4 - 1]))) {
        if (i4 >= a3 || m3 === " " || m3 === "	" || m3 === `
` || m3 === ";" || m3 === "&" || m3 === "|" || m3 === "(" || m3 === ")" || m3 === "<" || m3 === ">") {
          let A2 = n3.slice(l3, i4);
          if (this.pos = i4, this.column = s3 + (i4 - l3), Pe$5[A2]) return { type: Pe$5[A2], value: A2, start: t4, end: i4, line: r2, column: s3 };
          let w4 = Vt(A2);
          return w4 > 0 && Mt(A2.slice(0, w4)) ? { type: p$e.ASSIGNMENT_WORD, value: A2, start: t4, end: i4, line: r2, column: s3 } : /^[0-9]+$/.test(A2) ? { type: p$e.NUMBER, value: A2, start: t4, end: i4, line: r2, column: s3 } : /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(A2) ? { type: p$e.NAME, value: A2, start: t4, end: i4, line: r2, column: s3, quoted: false, singleQuoted: false } : { type: p$e.WORD, value: A2, start: t4, end: i4, line: r2, column: s3, quoted: false, singleQuoted: false };
        }
      }
    }
    i4 = this.pos;
    let o2 = this.column, c3 = this.line, u3 = "", f3 = false, h3 = false, d3 = false, y2 = false, g2 = n3[i4] === '"' || n3[i4] === "'", E2 = false, S3 = 0;
    for (; i4 < a3; ) {
      let m3 = n3[i4];
      if (!d3 && !y2) {
        if (m3 === "(" && u3.length > 0 && "@*+?!".includes(u3[u3.length - 1])) {
          let A2 = this.scanExtglobPattern(i4);
          if (A2 !== null) {
            u3 += A2.content, i4 = A2.end, o2 += A2.content.length;
            continue;
          }
        }
        if (m3 === "[" && S3 === 0) {
          if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(u3)) {
            let A2 = i4 + 1 < a3 ? n3[i4 + 1] : "";
            if (A2 === "^" || A2 === "!") {
              u3 += m3, i4++, o2++;
              continue;
            }
            S3 = 1, u3 += m3, i4++, o2++;
            continue;
          }
        } else if (m3 === "[" && S3 > 0) {
          u3.length > 0 && u3[u3.length - 1] !== "\\" && S3++, u3 += m3, i4++, o2++;
          continue;
        } else if (m3 === "]" && S3 > 0) {
          u3.length > 0 && u3[u3.length - 1] !== "\\" && S3--, u3 += m3, i4++, o2++;
          continue;
        }
        if (S3 > 0) {
          if (m3 === `
`) break;
          u3 += m3, i4++, o2++;
          continue;
        }
        if (m3 === " " || m3 === "	" || m3 === `
` || m3 === ";" || m3 === "&" || m3 === "|" || m3 === "(" || m3 === ")" || m3 === "<" || m3 === ">") break;
      }
      if (m3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "'" && !d3 && !y2) {
        for (u3 += "$'", i4 += 2, o2 += 2; i4 < a3 && n3[i4] !== "'"; ) n3[i4] === "\\" && i4 + 1 < a3 ? (u3 += n3[i4] + n3[i4 + 1], i4 += 2, o2 += 2) : (u3 += n3[i4], i4++, o2++);
        i4 < a3 && (u3 += "'", i4++, o2++);
        continue;
      }
      if (m3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === '"' && !d3 && !y2) {
        i4++, o2++, y2 = true, f3 = true, u3 === "" && (g2 = true), i4++, o2++;
        continue;
      }
      if (m3 === "'" && !y2) {
        if (d3) if (d3 = false, !g2 || E2) u3 += m3;
        else {
          let A2 = i4 + 1 < a3 ? n3[i4 + 1] : "";
          A2 && !qt$1(A2) && A2 !== "'" && (A2 === '"' ? (E2 = true, u3 += m3, h3 = false, f3 = false) : (E2 = true, u3 += m3));
        }
        else d3 = true, g2 && !E2 ? (h3 = true, f3 = true) : u3 += m3;
        i4++, o2++;
        continue;
      }
      if (m3 === '"' && !d3) {
        if (y2) if (y2 = false, !g2 || E2) u3 += m3;
        else {
          let A2 = i4 + 1 < a3 ? n3[i4 + 1] : "";
          A2 && !qt$1(A2) && A2 !== '"' && (A2 === "'" ? (E2 = true, u3 += m3, h3 = false, f3 = false) : (E2 = true, u3 += m3));
        }
        else y2 = true, g2 && !E2 ? f3 = true : u3 += m3;
        i4++, o2++;
        continue;
      }
      if (m3 === "\\" && !d3 && i4 + 1 < a3) {
        let A2 = n3[i4 + 1];
        if (A2 === `
`) {
          i4 += 2, c3++, o2 = 1;
          continue;
        }
        if (y2) {
          if (A2 === '"' || A2 === "\\" || A2 === "$" || A2 === "`" || A2 === `
`) {
            if (A2 === `
`) {
              i4 += 2, o2 = 1, c3++;
              continue;
            }
            u3 += m3 + A2, i4 += 2, o2 += 2;
            continue;
          }
        } else {
          A2 === "\\" || A2 === '"' || A2 === "'" || A2 === "`" || A2 === "*" || A2 === "?" || A2 === "[" || A2 === "]" || A2 === "(" || A2 === ")" || A2 === "$" || A2 === "-" || A2 === "." || A2 === "^" || A2 === "+" || A2 === "{" || A2 === "}" ? u3 += m3 + A2 : u3 += A2, i4 += 2, o2 += 2;
          continue;
        }
      }
      if (m3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "(" && !d3) {
        u3 += m3, i4++, o2++, u3 += n3[i4], i4++, o2++;
        let A2 = 1, w4 = false, L4 = false, H2 = 0, K2 = false, V4 = "", Ae2 = n3[i4] === "(" && !this.dollarDparenIsSubshell(i4);
        for (; A2 > 0 && i4 < a3; ) {
          let x4 = n3[i4];
          if (u3 += x4, w4) x4 === "'" && (w4 = false);
          else if (L4) x4 === "\\" && i4 + 1 < a3 ? (u3 += n3[i4 + 1], i4++, o2++) : x4 === '"' && (L4 = false);
          else if (x4 === "'") w4 = true, V4 = "";
          else if (x4 === '"') L4 = true, V4 = "";
          else if (x4 === "\\" && i4 + 1 < a3) u3 += n3[i4 + 1], i4++, o2++, V4 = "";
          else if (x4 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "{") {
            i4++, o2++, u3 += n3[i4], i4++, o2++;
            let Ve3 = 1, Se2 = false, qe2 = false;
            for (; Ve3 > 0 && i4 < a3; ) {
              let X3 = n3[i4];
              if (X3 === "\\" && i4 + 1 < a3 && !Se2) {
                u3 += X3, i4++, o2++, u3 += n3[i4], i4++, o2++;
                continue;
              }
              u3 += X3, Se2 ? X3 === "'" && (Se2 = false) : qe2 ? X3 === '"' && (qe2 = false) : X3 === "'" ? Se2 = true : X3 === '"' ? qe2 = true : X3 === "{" ? Ve3++ : X3 === "}" && Ve3--, X3 === `
` ? (c3++, o2 = 0) : o2++, i4++;
            }
            V4 = "";
            continue;
          } else if (x4 === "#" && !Ae2 && (V4 === "" || /\s/.test(n3[i4 - 1] || ""))) {
            for (; i4 + 1 < a3 && n3[i4 + 1] !== `
`; ) i4++, o2++, u3 += n3[i4];
            V4 = "";
          } else /[a-zA-Z_]/.test(x4) ? V4 += x4 : (V4 === "case" ? (H2++, K2 = false) : V4 === "in" && H2 > 0 ? K2 = true : V4 === "esac" && H2 > 0 && (H2--, K2 = false), V4 = "", x4 === "(" ? i4 > 0 && n3[i4 - 1] === "$" ? A2++ : K2 || A2++ : x4 === ")" ? K2 ? K2 = false : A2-- : x4 === ";" && H2 > 0 && i4 + 1 < a3 && n3[i4 + 1] === ";" && (K2 = true));
          x4 === `
` && (c3++, o2 = 0, V4 = ""), i4++, o2++;
        }
        continue;
      }
      if (m3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "[" && !d3) {
        u3 += m3, i4++, o2++, u3 += n3[i4], i4++, o2++;
        let A2 = 1;
        for (; A2 > 0 && i4 < a3; ) {
          let w4 = n3[i4];
          u3 += w4, w4 === "[" ? A2++ : w4 === "]" ? A2-- : w4 === `
` && (c3++, o2 = 0), i4++, o2++;
        }
        continue;
      }
      if (m3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "{" && !d3) {
        u3 += m3, i4++, o2++, u3 += n3[i4], i4++, o2++;
        let A2 = 1, w4 = false, L4 = false, H2 = c3, K2 = o2, V4 = c3, Ae2 = o2;
        for (; A2 > 0 && i4 < a3; ) {
          let x4 = n3[i4];
          if (x4 === "\\" && i4 + 1 < a3 && n3[i4 + 1] === `
`) {
            i4 += 2, c3++, o2 = 1;
            continue;
          }
          if (x4 === "\\" && i4 + 1 < a3 && !w4) {
            u3 += x4, i4++, o2++, u3 += n3[i4], i4++, o2++;
            continue;
          }
          u3 += x4, w4 ? x4 === "'" && (w4 = false) : L4 ? x4 === '"' && (L4 = false) : x4 === "'" ? (w4 = true, H2 = c3, K2 = o2) : x4 === '"' ? (L4 = true, V4 = c3, Ae2 = o2) : x4 === "{" ? A2++ : x4 === "}" && A2--, x4 === `
` && (c3++, o2 = 0), i4++, o2++;
        }
        if (w4) throw new he$6("unexpected EOF while looking for matching `''", H2, K2);
        if (L4) throw new he$6("unexpected EOF while looking for matching `\"'", V4, Ae2);
        continue;
      }
      if (m3 === "$" && i4 + 1 < a3 && !d3) {
        let A2 = n3[i4 + 1];
        if (A2 === "#" || A2 === "?" || A2 === "$" || A2 === "!" || A2 === "@" || A2 === "*" || A2 === "-" || A2 >= "0" && A2 <= "9") {
          u3 += m3 + A2, i4 += 2, o2 += 2;
          continue;
        }
      }
      if (m3 === "`" && !d3) {
        for (u3 += m3, i4++, o2++; i4 < a3 && n3[i4] !== "`"; ) {
          let A2 = n3[i4];
          u3 += A2, A2 === "\\" && i4 + 1 < a3 && (u3 += n3[i4 + 1], i4++, o2++), A2 === `
` && (c3++, o2 = 0), i4++, o2++;
        }
        i4 < a3 && (u3 += n3[i4], i4++, o2++);
        continue;
      }
      u3 += m3, i4++, m3 === `
` ? (c3++, o2 = 1) : o2++;
    }
    if (this.pos = i4, this.column = o2, this.line = c3, E2 && g2 && (u3 = n3[t4] + u3, f3 = false, h3 = false), d3 || y2) {
      let m3 = d3 ? "'" : '"';
      throw new he$6(`unexpected EOF while looking for matching \`${m3}'`, r2, s3);
    }
    if (!g2 && u3.length >= 2) {
      if (u3[0] === "'" && u3[u3.length - 1] === "'") {
        let m3 = u3.slice(1, -1);
        !m3.includes("'") && !m3.includes('"') && (u3 = m3, f3 = true, h3 = true);
      } else if (u3[0] === '"' && u3[u3.length - 1] === '"') {
        let m3 = u3.slice(1, -1), A2 = false;
        for (let w4 = 0; w4 < m3.length; w4++) {
          if (m3[w4] === '"') {
            A2 = true;
            break;
          }
          m3[w4] === "\\" && w4 + 1 < m3.length && w4++;
        }
        A2 || (u3 = m3, f3 = true, h3 = false);
      }
    }
    if (u3 === "") return { type: p$e.WORD, value: "", start: t4, end: i4, line: r2, column: s3, quoted: f3, singleQuoted: h3 };
    if (!f3 && Pe$5[u3]) return { type: Pe$5[u3], value: u3, start: t4, end: i4, line: r2, column: s3 };
    if (!g2) {
      let m3 = Vt(u3);
      if (m3 > 0 && Mt(u3.slice(0, m3))) return { type: p$e.ASSIGNMENT_WORD, value: u3, start: t4, end: i4, line: r2, column: s3, quoted: f3, singleQuoted: h3 };
    }
    return /^[0-9]+$/.test(u3) ? { type: p$e.NUMBER, value: u3, start: t4, end: i4, line: r2, column: s3 } : Ir$1(u3) ? { type: p$e.NAME, value: u3, start: t4, end: i4, line: r2, column: s3, quoted: f3, singleQuoted: h3 } : { type: p$e.WORD, value: u3, start: t4, end: i4, line: r2, column: s3, quoted: f3, singleQuoted: h3 };
  }
  readHeredocContent() {
    for (; this.pendingHeredocs.length > 0; ) {
      let t4 = this.pendingHeredocs.shift();
      if (!t4) break;
      let r2 = this.pos, s3 = this.line, n3 = this.column, a3 = "";
      for (; this.pos < this.input.length; ) {
        this.pos;
        let l3 = "";
        for (; this.pos < this.input.length && this.input[this.pos] !== `
`; ) l3 += this.input[this.pos], this.pos++, this.column++;
        if ((t4.stripTabs ? l3.replace(/^\t+/, "") : l3) === t4.delimiter) {
          this.pos < this.input.length && this.input[this.pos] === `
` && (this.pos++, this.line++, this.column = 1);
          break;
        }
        a3 += l3, this.pos < this.input.length && this.input[this.pos] === `
` && (a3 += `
`, this.pos++, this.line++, this.column = 1);
      }
      this.tokens.push({ type: p$e.HEREDOC_CONTENT, value: a3, start: r2, end: this.pos, line: s3, column: n3 });
    }
  }
  addPendingHeredoc(t4, r2, s3) {
    this.pendingHeredocs.push({ delimiter: t4, stripTabs: r2, quoted: s3 });
  }
  registerHeredocFromLookahead(t4) {
    let r2 = this.pos, s3 = this.column;
    for (; this.pos < this.input.length && (this.input[this.pos] === " " || this.input[this.pos] === "	"); ) this.pos++, this.column++;
    let n3 = "", a3 = false;
    for (; this.pos < this.input.length; ) {
      let i4 = this.input[this.pos];
      if (/[\s;<>&|()]/.test(i4)) break;
      if (i4 === "'" || i4 === '"') {
        a3 = true;
        let l3 = i4;
        for (this.pos++, this.column++; this.pos < this.input.length && this.input[this.pos] !== l3; ) n3 += this.input[this.pos], this.pos++, this.column++;
        this.pos < this.input.length && this.input[this.pos] === l3 && (this.pos++, this.column++);
      } else i4 === "\\" ? (a3 = true, this.pos++, this.column++, this.pos < this.input.length && (n3 += this.input[this.pos], this.pos++, this.column++)) : (n3 += i4, this.pos++, this.column++);
    }
    this.pos = r2, this.column = s3, n3 && this.pendingHeredocs.push({ delimiter: n3, stripTabs: t4, quoted: a3 });
  }
  isWordCharFollowing(t4) {
    if (t4 >= this.input.length) return false;
    let r2 = this.input[t4];
    return !(r2 === " " || r2 === "	" || r2 === `
` || r2 === ";" || r2 === "&" || r2 === "|" || r2 === "(" || r2 === ")" || r2 === "<" || r2 === ">");
  }
  readWordWithBraceExpansion(t4, r2, s3) {
    let n3 = this.input, a3 = n3.length, i4 = t4, l3 = s3;
    for (; i4 < a3; ) {
      let c3 = n3[i4];
      if (c3 === " " || c3 === "	" || c3 === `
` || c3 === ";" || c3 === "&" || c3 === "|" || c3 === "(" || c3 === ")" || c3 === "<" || c3 === ">") break;
      if (c3 === "{") {
        if (this.scanBraceExpansion(i4) !== null) {
          let f3 = 1;
          for (i4++, l3++; i4 < a3 && f3 > 0; ) n3[i4] === "{" ? f3++ : n3[i4] === "}" && f3--, i4++, l3++;
          continue;
        }
        i4++, l3++;
        continue;
      }
      if (c3 === "}") {
        i4++, l3++;
        continue;
      }
      if (c3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "(") {
        i4++, l3++, i4++, l3++;
        let u3 = 1;
        for (; u3 > 0 && i4 < a3; ) n3[i4] === "(" ? u3++ : n3[i4] === ")" && u3--, i4++, l3++;
        continue;
      }
      if (c3 === "$" && i4 + 1 < a3 && n3[i4 + 1] === "{") {
        i4++, l3++, i4++, l3++;
        let u3 = 1;
        for (; u3 > 0 && i4 < a3; ) n3[i4] === "{" ? u3++ : n3[i4] === "}" && u3--, i4++, l3++;
        continue;
      }
      if (c3 === "`") {
        for (i4++, l3++; i4 < a3 && n3[i4] !== "`"; ) n3[i4] === "\\" && i4 + 1 < a3 ? (i4 += 2, l3 += 2) : (i4++, l3++);
        i4 < a3 && (i4++, l3++);
        continue;
      }
      i4++, l3++;
    }
    let o2 = n3.slice(t4, i4);
    return this.pos = i4, this.column = l3, { type: p$e.WORD, value: o2, start: t4, end: i4, line: r2, column: s3, quoted: false, singleQuoted: false };
  }
  scanBraceExpansion(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4 + 1, a3 = 1, i4 = false, l3 = false;
    for (; n3 < s3 && a3 > 0; ) {
      let o2 = r2[n3];
      if (o2 === "{") a3++, n3++;
      else if (o2 === "}") a3--, n3++;
      else if (o2 === "," && a3 === 1) i4 = true, n3++;
      else if (o2 === "." && n3 + 1 < s3 && r2[n3 + 1] === ".") l3 = true, n3 += 2;
      else {
        if (o2 === " " || o2 === "	" || o2 === `
` || o2 === ";" || o2 === "&" || o2 === "|") return null;
        n3++;
      }
    }
    return a3 === 0 && (i4 || l3) ? r2.slice(t4, n3) : null;
  }
  scanLiteralBraceWord(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4 + 1, a3 = 1;
    for (; n3 < s3 && a3 > 0; ) {
      let i4 = r2[n3];
      if (i4 === "{") a3++, n3++;
      else if (i4 === "}") {
        if (a3--, a3 === 0) return r2.slice(t4, n3 + 1);
        n3++;
      } else {
        if (i4 === " " || i4 === "	" || i4 === `
` || i4 === ";" || i4 === "&" || i4 === "|") return null;
        n3++;
      }
    }
    return null;
  }
  scanExtglobPattern(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4 + 1, a3 = 1;
    for (; n3 < s3 && a3 > 0; ) {
      let i4 = r2[n3];
      if (i4 === "\\" && n3 + 1 < s3) {
        n3 += 2;
        continue;
      }
      if ("@*+?!".includes(i4) && n3 + 1 < s3 && r2[n3 + 1] === "(") {
        n3++, a3++, n3++;
        continue;
      }
      if (i4 === "(") a3++, n3++;
      else if (i4 === ")") a3--, n3++;
      else {
        if (i4 === `
`) return null;
        n3++;
      }
    }
    return a3 === 0 ? { content: r2.slice(t4, n3), end: n3 } : null;
  }
  scanFdVariable(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4 + 1, a3 = n3;
    for (; n3 < s3; ) {
      let u3 = r2[n3];
      if (n3 === a3) {
        if (!(u3 >= "a" && u3 <= "z" || u3 >= "A" && u3 <= "Z" || u3 === "_")) return null;
      } else if (!(u3 >= "a" && u3 <= "z" || u3 >= "A" && u3 <= "Z" || u3 >= "0" && u3 <= "9" || u3 === "_")) break;
      n3++;
    }
    if (n3 === a3) return null;
    let i4 = r2.slice(a3, n3);
    if (n3 >= s3 || r2[n3] !== "}" || (n3++, n3 >= s3)) return null;
    let l3 = r2[n3], o2 = n3 + 1 < s3 ? r2[n3 + 1] : "";
    return l3 === ">" || l3 === "<" || l3 === "&" && (o2 === ">" || o2 === "<") ? { varname: i4, end: n3 } : null;
  }
  dollarDparenIsSubshell(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4 + 1, a3 = 2, i4 = false, l3 = false, o2 = false;
    for (; n3 < s3 && a3 > 0; ) {
      let c3 = r2[n3];
      if (i4) {
        c3 === "'" && (i4 = false), c3 === `
` && (o2 = true), n3++;
        continue;
      }
      if (l3) {
        if (c3 === "\\") {
          n3 += 2;
          continue;
        }
        c3 === '"' && (l3 = false), c3 === `
` && (o2 = true), n3++;
        continue;
      }
      if (c3 === "'") {
        i4 = true, n3++;
        continue;
      }
      if (c3 === '"') {
        l3 = true, n3++;
        continue;
      }
      if (c3 === "\\") {
        n3 += 2;
        continue;
      }
      if (c3 === `
` && (o2 = true), c3 === "(") {
        a3++, n3++;
        continue;
      }
      if (c3 === ")") {
        if (a3--, a3 === 1) {
          let u3 = n3 + 1;
          if (u3 < s3 && r2[u3] === ")") return false;
          let f3 = u3, h3 = false;
          for (; f3 < s3 && (r2[f3] === " " || r2[f3] === "	" || r2[f3] === `
`); ) h3 = true, f3++;
          if (h3 && f3 < s3 && r2[f3] === ")" || o2) return true;
        }
        if (a3 === 0) return false;
        n3++;
        continue;
      }
      n3++;
    }
    return false;
  }
  dparenClosesWithSpacedParens(t4) {
    let r2 = this.input, s3 = r2.length, n3 = t4, a3 = 2, i4 = false, l3 = false;
    for (; n3 < s3 && a3 > 0; ) {
      let o2 = r2[n3];
      if (i4) {
        o2 === "'" && (i4 = false), n3++;
        continue;
      }
      if (l3) {
        if (o2 === "\\") {
          n3 += 2;
          continue;
        }
        o2 === '"' && (l3 = false), n3++;
        continue;
      }
      if (o2 === "'") {
        i4 = true, n3++;
        continue;
      }
      if (o2 === '"') {
        l3 = true, n3++;
        continue;
      }
      if (o2 === "\\") {
        n3 += 2;
        continue;
      }
      if (o2 === "(") {
        a3++, n3++;
        continue;
      }
      if (o2 === ")") {
        if (a3--, a3 === 1) {
          let c3 = n3 + 1;
          if (c3 < s3 && r2[c3] === ")") return false;
          let u3 = c3, f3 = false;
          for (; u3 < s3 && (r2[u3] === " " || r2[u3] === "	" || r2[u3] === `
`); ) f3 = true, u3++;
          if (f3 && u3 < s3 && r2[u3] === ")") return true;
        }
        if (a3 === 0) return false;
        n3++;
        continue;
      }
      if (a3 === 1 && (o2 === "|" && n3 + 1 < s3 && r2[n3 + 1] === "|" || o2 === "&" && n3 + 1 < s3 && r2[n3 + 1] === "&" || o2 === "|" && n3 + 1 < s3 && r2[n3 + 1] !== "|")) return true;
      n3++;
    }
    return false;
  }
};
var Qe$6 = 1e6, ze$4 = 1e5, Bt = 1e6, Ft = /* @__PURE__ */ new Set([p$e.LESS, p$e.GREAT, p$e.DLESS, p$e.DGREAT, p$e.LESSAND, p$e.GREATAND, p$e.LESSGREAT, p$e.DLESSDASH, p$e.CLOBBER, p$e.TLESS, p$e.AND_GREAT, p$e.AND_DGREAT]), Qt$2 = /* @__PURE__ */ new Set([p$e.LESS, p$e.GREAT, p$e.DLESS, p$e.DGREAT, p$e.LESSAND, p$e.GREATAND, p$e.LESSGREAT, p$e.DLESSDASH, p$e.CLOBBER, p$e.TLESS]), zt = /* @__PURE__ */ new Set([p$e.LESS, p$e.GREAT, p$e.DLESS, p$e.DGREAT, p$e.LESSAND, p$e.GREATAND, p$e.LESSGREAT, p$e.DLESSDASH, p$e.CLOBBER, p$e.TLESS, p$e.AND_GREAT, p$e.AND_DGREAT]), Q$9 = class Q extends Error {
  line;
  column;
  token;
  constructor(t4, r2, s3, n3 = void 0) {
    super(`Parse error at ${r2}:${s3}: ${t4}`), this.line = r2, this.column = s3, this.token = n3, this.name = "ParseException";
  }
};
function vr$1(e5) {
  let t4 = "", r2 = 0;
  for (; r2 < e5.length; ) {
    let s3 = e5[r2];
    if (s3 < 128) {
      t4 += String.fromCharCode(s3), r2++;
      continue;
    }
    if ((s3 & 224) === 192) {
      if (r2 + 1 < e5.length && (e5[r2 + 1] & 192) === 128 && s3 >= 194) {
        let n3 = (s3 & 31) << 6 | e5[r2 + 1] & 63;
        t4 += String.fromCharCode(n3), r2 += 2;
        continue;
      }
      t4 += String.fromCharCode(s3), r2++;
      continue;
    }
    if ((s3 & 240) === 224) {
      if (r2 + 2 < e5.length && (e5[r2 + 1] & 192) === 128 && (e5[r2 + 2] & 192) === 128) {
        if (s3 === 224 && e5[r2 + 1] < 160) {
          t4 += String.fromCharCode(s3), r2++;
          continue;
        }
        let n3 = (s3 & 15) << 12 | (e5[r2 + 1] & 63) << 6 | e5[r2 + 2] & 63;
        if (n3 >= 55296 && n3 <= 57343) {
          t4 += String.fromCharCode(s3), r2++;
          continue;
        }
        t4 += String.fromCharCode(n3), r2 += 3;
        continue;
      }
      t4 += String.fromCharCode(s3), r2++;
      continue;
    }
    if ((s3 & 248) === 240 && s3 <= 244) {
      if (r2 + 3 < e5.length && (e5[r2 + 1] & 192) === 128 && (e5[r2 + 2] & 192) === 128 && (e5[r2 + 3] & 192) === 128) {
        if (s3 === 240 && e5[r2 + 1] < 144) {
          t4 += String.fromCharCode(s3), r2++;
          continue;
        }
        let n3 = (s3 & 7) << 18 | (e5[r2 + 1] & 63) << 12 | (e5[r2 + 2] & 63) << 6 | e5[r2 + 3] & 63;
        if (n3 > 1114111) {
          t4 += String.fromCharCode(s3), r2++;
          continue;
        }
        t4 += String.fromCodePoint(n3), r2 += 4;
        continue;
      }
      t4 += String.fromCharCode(s3), r2++;
      continue;
    }
    t4 += String.fromCharCode(s3), r2++;
  }
  return t4;
}
function Gt$2(e5, t4, r2) {
  let s3 = r2 + 1;
  for (; s3 < t4.length && /[a-zA-Z0-9_-]/.test(t4[s3]); ) s3++;
  return s3;
}
function Ze$4(e5, t4, r2, s3, n3) {
  let a3 = 1, i4 = r2 + 1;
  for (; i4 < t4.length && a3 > 0; ) t4[i4] === s3 ? a3++ : t4[i4] === n3 && a3--, a3 > 0 && i4++;
  return a3 === 0 ? i4 : -1;
}
function oe$8(e5, t4, r2) {
  let s3 = r2, n3 = 1;
  for (; s3 < t4.length && n3 > 0; ) {
    let a3 = t4[s3];
    if (a3 === "\\" && s3 + 1 < t4.length) {
      s3 += 2;
      continue;
    }
    if (a3 === "'") {
      let i4 = t4.indexOf("'", s3 + 1);
      if (i4 !== -1) {
        s3 = i4 + 1;
        continue;
      }
    }
    if (a3 === '"') {
      for (s3++; s3 < t4.length && t4[s3] !== '"'; ) t4[s3] === "\\" && s3 + 1 < t4.length ? s3 += 2 : s3++;
      s3 < t4.length && s3++;
      continue;
    }
    a3 === "{" ? n3++ : a3 === "}" && n3--, n3 > 0 && s3++;
  }
  return s3;
}
function Ut$2(e5, t4, r2) {
  let s3 = r2, n3 = false;
  for (; s3 < t4.length; ) {
    let a3 = t4[s3];
    if (a3 === "/" && n3 || a3 === "}") break;
    if (a3 === "'") {
      let i4 = t4.indexOf("'", s3 + 1);
      if (i4 !== -1) {
        s3 = i4 + 1, n3 = true;
        continue;
      }
    }
    if (a3 === '"') {
      for (s3++; s3 < t4.length && t4[s3] !== '"'; ) t4[s3] === "\\" && s3 + 1 < t4.length ? s3 += 2 : s3++;
      s3 < t4.length && s3++, n3 = true;
      continue;
    }
    a3 === "\\" ? (s3 += 2, n3 = true) : (s3++, n3 = true);
  }
  return s3;
}
function jt(e5, t4, r2) {
  let s3 = r2, n3 = "";
  for (; s3 < t4.length; ) {
    let a3 = t4[s3];
    if (a3 === "*" || a3 === "?") n3 += a3, s3++;
    else if (a3 === "[") {
      let i4 = Dr$2(t4, s3);
      i4 === -1 ? (n3 += a3, s3++) : (n3 += t4.slice(s3, i4 + 1), s3 = i4 + 1);
    } else break;
  }
  return { pattern: n3, endIndex: s3 };
}
function Dr$2(e5, t4) {
  let r2 = t4 + 1;
  for (r2 < e5.length && e5[r2] === "^" && r2++, r2 < e5.length && e5[r2] === "]" && r2++; r2 < e5.length; ) {
    let s3 = e5[r2];
    if (s3 === "\\" && r2 + 1 < e5.length) {
      let n3 = e5[r2 + 1];
      if (n3 === '"' || n3 === "'") return -1;
      r2 += 2;
      continue;
    }
    if (s3 === "]") return r2;
    if (s3 === '"' || s3 === "$" || s3 === "`") return -1;
    if (s3 === "'") {
      let n3 = e5.indexOf("'", r2 + 1);
      if (n3 !== -1) {
        r2 = n3 + 1;
        continue;
      }
    }
    if (s3 === "[" && r2 + 1 < e5.length && e5[r2 + 1] === ":") {
      let n3 = e5.indexOf(":]", r2 + 2);
      if (n3 !== -1) {
        r2 = n3 + 2;
        continue;
      }
    }
    if (s3 === "[" && r2 + 1 < e5.length && (e5[r2 + 1] === "." || e5[r2 + 1] === "=")) {
      let a3 = `${e5[r2 + 1]}]`, i4 = e5.indexOf(a3, r2 + 2);
      if (i4 !== -1) {
        r2 = i4 + 2;
        continue;
      }
    }
    r2++;
  }
  return -1;
}
function Ht$1(e5, t4, r2) {
  let s3 = "", n3 = r2;
  for (; n3 < t4.length && t4[n3] !== "'"; ) {
    let a3 = t4[n3];
    if (a3 === "\\" && n3 + 1 < t4.length) switch (t4[n3 + 1]) {
      case "n":
        s3 += `
`, n3 += 2;
        break;
      case "t":
        s3 += "	", n3 += 2;
        break;
      case "r":
        s3 += "\r", n3 += 2;
        break;
      case "\\":
        s3 += "\\", n3 += 2;
        break;
      case "'":
        s3 += "'", n3 += 2;
        break;
      case '"':
        s3 += '"', n3 += 2;
        break;
      case "a":
        s3 += "\x07", n3 += 2;
        break;
      case "b":
        s3 += "\b", n3 += 2;
        break;
      case "e":
      case "E":
        s3 += "\x1B", n3 += 2;
        break;
      case "f":
        s3 += "\f", n3 += 2;
        break;
      case "v":
        s3 += "\v", n3 += 2;
        break;
      case "x": {
        let l3 = [], o2 = n3;
        for (; o2 + 1 < t4.length && t4[o2] === "\\" && t4[o2 + 1] === "x"; ) {
          let c3 = t4.slice(o2 + 2, o2 + 4), u3 = parseInt(c3, 16);
          if (!Number.isNaN(u3) && c3.length > 0) l3.push(u3), o2 += 2 + c3.length;
          else break;
        }
        l3.length > 0 ? (s3 += vr$1(l3), n3 = o2) : (s3 += "\\x", n3 += 2);
        break;
      }
      case "u": {
        let l3 = t4.slice(n3 + 2, n3 + 6), o2 = parseInt(l3, 16);
        Number.isNaN(o2) ? (s3 += "\\u", n3 += 2) : (s3 += String.fromCharCode(o2), n3 += 6);
        break;
      }
      case "c": {
        if (n3 + 2 < t4.length) {
          let o2 = t4[n3 + 2].charCodeAt(0) & 31;
          s3 += String.fromCharCode(o2), n3 += 3;
        } else s3 += "\\c", n3 += 2;
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7": {
        let l3 = "", o2 = n3 + 1;
        for (; o2 < t4.length && o2 < n3 + 4 && /[0-7]/.test(t4[o2]); ) l3 += t4[o2], o2++;
        let c3 = parseInt(l3, 8);
        s3 += String.fromCharCode(c3), n3 = o2;
        break;
      }
      default:
        s3 += a3, n3++;
    }
    else s3 += a3, n3++;
  }
  return n3 < t4.length && t4[n3] === "'" && n3++, { part: b$h.literal(s3), endIndex: n3 };
}
function Ge$4(e5, t4) {
  let r2 = t4.trim();
  return r2 === "" ? { type: "ArithmeticExpression", expression: { type: "ArithNumber", value: 0 } } : W$d(e5, r2);
}
function Zt$3(e5) {
  let t4 = [], r2 = "", s3 = 0;
  for (let n3 = 0; n3 < e5.length; n3++) {
    let a3 = e5[n3];
    a3 === "{" ? (s3++, r2 += a3) : a3 === "}" ? (s3--, r2 += a3) : a3 === "," && s3 === 0 ? (t4.push(r2), r2 = "") : r2 += a3;
  }
  return t4.push(r2), t4;
}
function Kt$1(e5, t4, r2, s3) {
  let n3 = Ze$4(e5, t4, r2, "{", "}");
  if (n3 === -1) return null;
  let a3 = t4.slice(r2 + 1, n3), i4 = a3.match(/^(-?\d+)\.\.(-?\d+)(?:\.\.(-?\d+))?$/);
  if (i4) return { part: { type: "BraceExpansion", items: [{ type: "Range", start: Number.parseInt(i4[1], 10), end: Number.parseInt(i4[2], 10), step: i4[3] ? Number.parseInt(i4[3], 10) : void 0, startStr: i4[1], endStr: i4[2] }] }, endIndex: n3 + 1 };
  let l3 = a3.match(/^([a-zA-Z])\.\.([a-zA-Z])(?:\.\.(-?\d+))?$/);
  return l3 ? { part: { type: "BraceExpansion", items: [{ type: "Range", start: l3[1], end: l3[2], step: l3[3] ? Number.parseInt(l3[3], 10) : void 0 }] }, endIndex: n3 + 1 } : a3.includes(",") && s3 ? { part: { type: "BraceExpansion", items: Zt$3(a3).map((u3) => ({ type: "Word", word: b$h.word(s3(e5, u3, false, false, false)) })) }, endIndex: n3 + 1 } : a3.includes(",") ? { part: { type: "BraceExpansion", items: Zt$3(a3).map((u3) => ({ type: "Word", word: b$h.word([b$h.literal(u3)]) })) }, endIndex: n3 + 1 } : null;
}
function Ue$4(e5, t4) {
  let r2 = "";
  for (let s3 of t4.parts) switch (s3.type) {
    case "Literal":
      r2 += s3.value;
      break;
    case "SingleQuoted":
      r2 += `'${s3.value}'`;
      break;
    case "Escaped":
      r2 += s3.value;
      break;
    case "DoubleQuoted":
      r2 += '"';
      for (let n3 of s3.parts) n3.type === "Literal" || n3.type === "Escaped" ? r2 += n3.value : n3.type === "ParameterExpansion" && (r2 += `\${${n3.parameter}}`);
      r2 += '"';
      break;
    case "ParameterExpansion":
      r2 += `\${${s3.parameter}}`;
      break;
    case "Glob":
      r2 += s3.pattern;
      break;
    case "TildeExpansion":
      r2 += "~", s3.user && (r2 += s3.user);
      break;
    case "BraceExpansion": {
      r2 += "{";
      let n3 = [];
      for (let a3 of s3.items) if (a3.type === "Range") {
        let i4 = a3.startStr ?? String(a3.start), l3 = a3.endStr ?? String(a3.end);
        a3.step !== void 0 ? n3.push(`${i4}..${l3}..${a3.step}`) : n3.push(`${i4}..${l3}`);
      } else n3.push(Ue$4(e5, a3.word));
      n3.length === 1 && s3.items[0].type === "Range" ? r2 += n3[0] : r2 += n3.join(","), r2 += "}";
      break;
    }
    default:
      r2 += s3.type;
  }
  return r2;
}
function Xt$2(e5, t4) {
  return { [p$e.LESS]: "<", [p$e.GREAT]: ">", [p$e.DGREAT]: ">>", [p$e.LESSAND]: "<&", [p$e.GREATAND]: ">&", [p$e.LESSGREAT]: "<>", [p$e.CLOBBER]: ">|", [p$e.TLESS]: "<<<", [p$e.AND_GREAT]: "&>", [p$e.AND_DGREAT]: "&>>", [p$e.DLESS]: "<", [p$e.DLESSDASH]: "<" }[t4] || ">";
}
function Ie$5(e5) {
  let t4 = e5.current(), r2 = t4.type;
  if (r2 === p$e.NUMBER) {
    let s3 = e5.peek(1);
    return t4.end !== s3.start ? false : Qt$2.has(s3.type);
  }
  if (r2 === p$e.FD_VARIABLE) {
    let s3 = e5.peek(1);
    return zt.has(s3.type);
  }
  return Ft.has(r2);
}
function ve$5(e5) {
  let t4 = null, r2;
  e5.check(p$e.NUMBER) ? t4 = Number.parseInt(e5.advance().value, 10) : e5.check(p$e.FD_VARIABLE) && (r2 = e5.advance().value);
  let s3 = e5.advance(), n3 = Xt$2(e5, s3.type);
  if (s3.type === p$e.DLESS || s3.type === p$e.DLESSDASH) return xr(e5, n3, t4, s3.type === p$e.DLESSDASH);
  e5.isWord() || e5.error("Expected redirection target");
  let a3 = e5.parseWord();
  return b$h.redirection(n3, a3, t4, r2);
}
function xr(e5, t4, r2, s3) {
  e5.isWord() || e5.error("Expected here-document delimiter");
  let n3 = e5.advance(), a3 = n3.value, i4 = n3.quoted || false;
  (a3.startsWith("'") && a3.endsWith("'") || a3.startsWith('"') && a3.endsWith('"')) && (a3 = a3.slice(1, -1));
  let l3 = b$h.redirection(s3 ? "<<-" : "<<", b$h.hereDoc(a3, b$h.word([]), s3, i4), r2);
  return e5.addPendingHeredoc(l3, a3, s3, i4), l3;
}
function Yt$1(e5) {
  let t4 = e5.current().line, r2 = [], s3 = null, n3 = [], a3 = [];
  for (; e5.check(p$e.ASSIGNMENT_WORD) || Ie$5(e5); ) e5.checkIterationLimit(), e5.check(p$e.ASSIGNMENT_WORD) ? r2.push($r$1(e5)) : a3.push(ve$5(e5));
  if (e5.isWord()) s3 = e5.parseWord();
  else if (r2.length > 0 && (e5.check(p$e.DBRACK_START) || e5.check(p$e.DPAREN_START))) {
    let l3 = e5.advance();
    s3 = b$h.word([b$h.literal(l3.value)]);
  }
  for (; (!e5.isStatementEnd() || e5.check(p$e.RBRACE)) && !e5.check(p$e.PIPE, p$e.PIPE_AMP); ) if (e5.checkIterationLimit(), Ie$5(e5)) a3.push(ve$5(e5));
  else if (e5.check(p$e.RBRACE)) {
    let l3 = e5.advance();
    n3.push(e5.parseWordFromString(l3.value, false, false));
  } else if (e5.check(p$e.LBRACE)) {
    let l3 = e5.advance();
    n3.push(e5.parseWordFromString(l3.value, false, false));
  } else if (e5.check(p$e.DBRACK_END)) {
    let l3 = e5.advance();
    n3.push(e5.parseWordFromString(l3.value, false, false));
  } else if (e5.isWord()) n3.push(e5.parseWord());
  else if (e5.check(p$e.ASSIGNMENT_WORD)) {
    let l3 = e5.advance(), o2 = l3.value, c3 = o2.endsWith("="), u3 = o2.endsWith("=(");
    if ((c3 || u3) && (u3 || e5.check(p$e.LPAREN))) {
      let f3 = u3 ? o2.slice(0, -2) : o2.slice(0, -1);
      u3 || e5.expect(p$e.LPAREN);
      let h3 = je$6(e5);
      e5.expect(p$e.RPAREN);
      let d3 = h3.map((g2) => Ue$4(e5, g2)), y2 = `${f3}=(${d3.join(" ")})`;
      n3.push(e5.parseWordFromString(y2, false, false));
    } else n3.push(e5.parseWordFromString(o2, l3.quoted, l3.singleQuoted));
  } else if (e5.check(p$e.LPAREN)) e5.error("syntax error near unexpected token `('");
  else break;
  let i4 = b$h.simpleCommand(s3, n3, r2, a3);
  return i4.line = t4, i4;
}
function $r$1(e5) {
  let t4 = e5.expect(p$e.ASSIGNMENT_WORD), r2 = t4.value, s3 = r2.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  s3 || e5.error(`Invalid assignment: ${r2}`);
  let n3 = s3[0], a3, i4 = n3.length;
  if (r2[i4] === "[") {
    let f3 = 0, h3 = i4 + 1;
    for (; i4 < r2.length; i4++) if (r2[i4] === "[") f3++;
    else if (r2[i4] === "]" && (f3--, f3 === 0)) break;
    f3 !== 0 && e5.error(`Invalid assignment: ${r2}`), a3 = r2.slice(h3, i4), i4++;
  }
  let l3 = r2[i4] === "+";
  l3 && i4++, r2[i4] !== "=" && e5.error(`Invalid assignment: ${r2}`), i4++;
  let o2 = r2.slice(i4);
  if (o2 === "(") {
    let f3 = je$6(e5);
    e5.expect(p$e.RPAREN);
    let h3 = a3 !== void 0 ? `${n3}[${a3}]` : n3;
    return b$h.assignment(h3, null, l3, f3);
  }
  if (o2 === "" && e5.check(p$e.LPAREN)) {
    let f3 = e5.current();
    if (t4.end === f3.start) {
      e5.advance();
      let h3 = je$6(e5);
      e5.expect(p$e.RPAREN);
      let d3 = a3 !== void 0 ? `${n3}[${a3}]` : n3;
      return b$h.assignment(d3, null, l3, h3);
    }
  }
  let c3 = o2 ? e5.parseWordFromString(o2, t4.quoted, t4.singleQuoted, true) : null, u3 = a3 !== void 0 ? `${n3}[${a3}]` : n3;
  return b$h.assignment(u3, c3, l3, null);
}
var _r$1 = /* @__PURE__ */ new Set([p$e.AMP, p$e.PIPE, p$e.PIPE_AMP, p$e.SEMICOLON, p$e.AND_AND, p$e.OR_OR, p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND]);
function je$6(e5) {
  let t4 = [];
  for (e5.skipNewlines(); !e5.check(p$e.RPAREN, p$e.EOF); ) e5.checkIterationLimit(), e5.isWord() ? t4.push(e5.parseWord()) : _r$1.has(e5.current().type) ? e5.error(`syntax error near unexpected token \`${e5.current().value}'`) : e5.advance(), e5.skipNewlines();
  return t4;
}
function He$5(e5, t4) {
  e5.expect(p$e.IF);
  let r2 = [], s3 = e5.parseCompoundList();
  e5.expect(p$e.THEN);
  let n3 = e5.parseCompoundList();
  if (n3.length === 0) {
    let l3 = e5.check(p$e.FI) ? "fi" : e5.check(p$e.ELSE) ? "else" : e5.check(p$e.ELIF) ? "elif" : "fi";
    e5.error(`syntax error near unexpected token \`${l3}'`);
  }
  for (r2.push({ condition: s3, body: n3 }); e5.check(p$e.ELIF); ) {
    e5.advance();
    let l3 = e5.parseCompoundList();
    e5.expect(p$e.THEN);
    let o2 = e5.parseCompoundList();
    if (o2.length === 0) {
      let c3 = e5.check(p$e.FI) ? "fi" : e5.check(p$e.ELSE) ? "else" : e5.check(p$e.ELIF) ? "elif" : "fi";
      e5.error(`syntax error near unexpected token \`${c3}'`);
    }
    r2.push({ condition: l3, body: o2 });
  }
  let a3 = null;
  e5.check(p$e.ELSE) && (e5.advance(), a3 = e5.parseCompoundList(), a3.length === 0 && e5.error("syntax error near unexpected token `fi'")), e5.expect(p$e.FI);
  let i4 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.ifNode(r2, a3, i4);
}
function Ke$4(e5, t4) {
  let r2 = e5.expect(p$e.FOR);
  if (e5.check(p$e.DPAREN_START)) return Or$1(e5, t4, r2.line);
  e5.isWord() || e5.error("Expected variable name in for loop");
  let n3 = e5.advance().value, a3 = null;
  if (e5.skipNewlines(), e5.check(p$e.IN)) for (e5.advance(), a3 = []; !e5.check(p$e.SEMICOLON, p$e.NEWLINE, p$e.DO, p$e.EOF) && e5.isWord(); ) a3.push(e5.parseWord());
  e5.check(p$e.SEMICOLON) && e5.advance(), e5.skipNewlines(), e5.expect(p$e.DO);
  let i4 = e5.parseCompoundList();
  e5.expect(p$e.DONE);
  let l3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.forNode(n3, a3, i4, l3);
}
function Or$1(e5, t4, r2) {
  e5.expect(p$e.DPAREN_START);
  let s3 = null, n3 = null, a3 = null, i4 = ["", "", ""], l3 = 0, o2 = 0;
  for (; !e5.check(p$e.DPAREN_END, p$e.EOF); ) {
    let f3 = e5.advance();
    if (f3.type === p$e.SEMICOLON && o2 === 0) {
      if (l3++, l3 > 2) break;
    } else f3.value === "(" && o2++, f3.value === ")" && o2--, i4[l3] += f3.value;
  }
  e5.expect(p$e.DPAREN_END), i4[0].trim() && (s3 = W$d(e5, i4[0].trim())), i4[1].trim() && (n3 = W$d(e5, i4[1].trim())), i4[2].trim() && (a3 = W$d(e5, i4[2].trim())), e5.skipNewlines(), e5.check(p$e.SEMICOLON) && e5.advance(), e5.skipNewlines();
  let c3;
  e5.check(p$e.LBRACE) ? (e5.advance(), c3 = e5.parseCompoundList(), e5.expect(p$e.RBRACE)) : (e5.expect(p$e.DO), c3 = e5.parseCompoundList(), e5.expect(p$e.DONE));
  let u3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return { type: "CStyleFor", init: s3, condition: n3, update: a3, body: c3, redirections: u3, line: r2 };
}
function Xe$4(e5, t4) {
  e5.expect(p$e.WHILE);
  let r2 = e5.parseCompoundList();
  e5.expect(p$e.DO);
  let s3 = e5.parseCompoundList();
  s3.length === 0 && e5.error("syntax error near unexpected token `done'"), e5.expect(p$e.DONE);
  let n3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.whileNode(r2, s3, n3);
}
function Je$6(e5, t4) {
  e5.expect(p$e.UNTIL);
  let r2 = e5.parseCompoundList();
  e5.expect(p$e.DO);
  let s3 = e5.parseCompoundList();
  s3.length === 0 && e5.error("syntax error near unexpected token `done'"), e5.expect(p$e.DONE);
  let n3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.untilNode(r2, s3, n3);
}
function Ye$5(e5, t4) {
  e5.expect(p$e.CASE), e5.isWord() || e5.error("Expected word after 'case'");
  let r2 = e5.parseWord();
  e5.skipNewlines(), e5.expect(p$e.IN), e5.skipNewlines();
  let s3 = [];
  for (; !e5.check(p$e.ESAC, p$e.EOF); ) {
    e5.checkIterationLimit();
    let a3 = e5.getPos(), i4 = Lr(e5);
    if (i4 && s3.push(i4), e5.skipNewlines(), e5.getPos() === a3 && !i4) break;
  }
  e5.expect(p$e.ESAC);
  let n3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.caseNode(r2, s3, n3);
}
function Lr(e5) {
  e5.check(p$e.LPAREN) && e5.advance();
  let t4 = [];
  for (; e5.isWord() && (t4.push(e5.parseWord()), e5.check(p$e.PIPE)); ) e5.advance();
  if (t4.length === 0) return null;
  e5.expect(p$e.RPAREN), e5.skipNewlines();
  let r2 = [];
  for (; !e5.check(p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND, p$e.ESAC, p$e.EOF); ) {
    e5.checkIterationLimit(), e5.isWord() && e5.peek(1).type === p$e.RPAREN && e5.error("syntax error near unexpected token `)'"), e5.check(p$e.LPAREN) && e5.peek(1).type === p$e.WORD && e5.error(`syntax error near unexpected token \`${e5.peek(1).value}'`);
    let n3 = e5.getPos(), a3 = e5.parseStatement();
    if (a3 && r2.push(a3), e5.skipSeparators(false), e5.getPos() === n3 && !a3) break;
  }
  let s3 = ";;";
  return e5.check(p$e.DSEMI) ? (e5.advance(), s3 = ";;") : e5.check(p$e.SEMI_AND) ? (e5.advance(), s3 = ";&") : e5.check(p$e.SEMI_SEMI_AND) && (e5.advance(), s3 = ";;&"), b$h.caseItem(t4, r2, s3);
}
function et$7(e5, t4) {
  e5.expect(p$e.LPAREN);
  let r2 = e5.parseCompoundList();
  e5.expect(p$e.RPAREN);
  let s3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.subshell(r2, s3);
}
function tt$6(e5, t4) {
  e5.expect(p$e.LBRACE);
  let r2 = e5.parseCompoundList();
  e5.expect(p$e.RBRACE);
  let s3 = t4?.skipRedirections ? [] : e5.parseOptionalRedirections();
  return b$h.group(r2, s3);
}
var Tr$1 = ["-a", "-b", "-c", "-d", "-e", "-f", "-g", "-h", "-k", "-p", "-r", "-s", "-t", "-u", "-w", "-x", "-G", "-L", "-N", "-O", "-S", "-z", "-n", "-o", "-v", "-R"], Mr = ["==", "!=", "=~", "<", ">", "-eq", "-ne", "-lt", "-le", "-gt", "-ge", "-nt", "-ot", "-ef"];
function en$2(e5) {
  return e5.isWord() || e5.check(p$e.LBRACE) || e5.check(p$e.RBRACE) || e5.check(p$e.ASSIGNMENT_WORD);
}
function tn(e5) {
  if (e5.check(p$e.BANG) && e5.peek(1).type === p$e.LPAREN) {
    e5.advance(), e5.advance();
    let t4 = 1, r2 = "!(";
    for (; t4 > 0 && !e5.check(p$e.EOF); ) if (e5.check(p$e.LPAREN)) t4++, r2 += "(", e5.advance();
    else if (e5.check(p$e.RPAREN)) t4--, t4 > 0 && (r2 += ")"), e5.advance();
    else if (e5.isWord()) r2 += e5.advance().value;
    else if (e5.check(p$e.PIPE)) r2 += "|", e5.advance();
    else break;
    return r2 += ")", e5.parseWordFromString(r2, false, false, false, false, true);
  }
  return e5.parseWordNoBraceExpansion();
}
function rt$2(e5) {
  return e5.skipNewlines(), Vr$1(e5);
}
function Vr$1(e5) {
  let t4 = nn$1(e5);
  for (e5.skipNewlines(); e5.check(p$e.OR_OR); ) {
    e5.advance(), e5.skipNewlines();
    let r2 = nn$1(e5);
    t4 = { type: "CondOr", left: t4, right: r2 }, e5.skipNewlines();
  }
  return t4;
}
function nn$1(e5) {
  let t4 = nt$5(e5);
  for (e5.skipNewlines(); e5.check(p$e.AND_AND); ) {
    e5.advance(), e5.skipNewlines();
    let r2 = nt$5(e5);
    t4 = { type: "CondAnd", left: t4, right: r2 }, e5.skipNewlines();
  }
  return t4;
}
function nt$5(e5) {
  return e5.skipNewlines(), e5.check(p$e.BANG) ? (e5.advance(), e5.skipNewlines(), { type: "CondNot", operand: nt$5(e5) }) : qr$1(e5);
}
function qr$1(e5) {
  if (e5.check(p$e.LPAREN)) {
    e5.advance();
    let t4 = rt$2(e5);
    return e5.expect(p$e.RPAREN), { type: "CondGroup", expression: t4 };
  }
  if (en$2(e5)) {
    let t4 = e5.current(), r2 = t4.value;
    if (Tr$1.includes(r2) && !t4.quoted) {
      if (e5.advance(), e5.check(p$e.DBRACK_END) && e5.error(`Expected operand after ${r2}`), en$2(e5)) {
        let a3 = e5.parseWordNoBraceExpansion();
        return { type: "CondUnary", operator: r2, operand: a3 };
      }
      let n3 = e5.current();
      e5.error(`unexpected argument \`${n3.value}' to conditional unary operator`);
    }
    let s3 = e5.parseWordNoBraceExpansion();
    if (e5.isWord() && Mr.includes(e5.current().value)) {
      let n3 = e5.advance().value, a3;
      return n3 === "=~" ? a3 = Br$1(e5) : n3 === "==" || n3 === "!=" ? a3 = tn(e5) : a3 = e5.parseWordNoBraceExpansion(), { type: "CondBinary", operator: n3, left: s3, right: a3 };
    }
    if (e5.check(p$e.LESS)) {
      e5.advance();
      let n3 = e5.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: "<", left: s3, right: n3 };
    }
    if (e5.check(p$e.GREAT)) {
      e5.advance();
      let n3 = e5.parseWordNoBraceExpansion();
      return { type: "CondBinary", operator: ">", left: s3, right: n3 };
    }
    if (e5.isWord() && e5.current().value === "=") {
      e5.advance();
      let n3 = tn(e5);
      return { type: "CondBinary", operator: "==", left: s3, right: n3 };
    }
    return { type: "CondWord", word: s3 };
  }
  e5.error("Expected conditional expression");
}
function Br$1(e5) {
  let t4 = [], r2 = 0, s3 = -1, n3 = e5.getInput(), a3 = () => e5.check(p$e.DBRACK_END) || e5.check(p$e.AND_AND) || e5.check(p$e.OR_OR) || e5.check(p$e.NEWLINE) || e5.check(p$e.EOF);
  for (; !a3(); ) {
    let i4 = e5.current(), l3 = s3 >= 0 && i4.start > s3;
    if (r2 === 0 && l3) break;
    if (r2 > 0 && l3) {
      let o2 = n3.slice(s3, i4.start);
      t4.push({ type: "Literal", value: o2 });
    }
    if (e5.isWord() || e5.check(p$e.ASSIGNMENT_WORD)) {
      let o2 = e5.parseWordForRegex();
      t4.push(...o2.parts), s3 = e5.peek(-1).end;
    } else if (e5.check(p$e.LPAREN)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "(" }), r2++, s3 = o2.end;
    } else if (e5.check(p$e.DPAREN_START)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "((" }), r2 += 2, s3 = o2.end;
    } else if (e5.check(p$e.DPAREN_END)) if (r2 >= 2) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "))" }), r2 -= 2, s3 = o2.end;
    } else {
      if (r2 === 1) break;
      break;
    }
    else if (e5.check(p$e.RPAREN)) if (r2 > 0) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ")" }), r2--, s3 = o2.end;
    } else break;
    else if (e5.check(p$e.PIPE)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "|" }), s3 = o2.end;
    } else if (e5.check(p$e.SEMICOLON)) if (r2 > 0) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ";" }), s3 = o2.end;
    } else break;
    else if (r2 > 0 && e5.check(p$e.LESS)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "<" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.GREAT)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ">" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.DGREAT)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ">>" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.DLESS)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "<<" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.LESSAND)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "<&" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.GREATAND)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ">&" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.LESSGREAT)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "<>" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.CLOBBER)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: ">|" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.TLESS)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "<<<" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.AMP)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "&" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.LBRACE)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "{" }), s3 = o2.end;
    } else if (r2 > 0 && e5.check(p$e.RBRACE)) {
      let o2 = e5.advance();
      t4.push({ type: "Literal", value: "}" }), s3 = o2.end;
    } else break;
  }
  return t4.length === 0 && e5.error("Expected regex pattern after =~"), { type: "Word", parts: t4 };
}
function Qr$1(e5, t4) {
  let r2 = 1, s3 = t4 + 1;
  for (; s3 < e5.length && r2 > 0; ) {
    let n3 = e5[s3];
    if (n3 === "\\") {
      s3 += 2;
      continue;
    }
    if ("@*+?!".includes(n3) && s3 + 1 < e5.length && e5[s3 + 1] === "(") {
      s3++, r2++, s3++;
      continue;
    }
    if (n3 === "(") r2++;
    else if (n3 === ")" && (r2--, r2 === 0)) return s3;
    s3++;
  }
  return -1;
}
function zr$2(e5, t4, r2) {
  let s3 = r2 + 1, n3 = t4[s3];
  if ("@*#?$!-0123456789".includes(n3)) return { part: b$h.parameterExpansion(n3), endIndex: s3 + 1 };
  let a3 = "";
  for (; s3 < t4.length && /[a-zA-Z0-9_]/.test(t4[s3]); ) a3 += t4[s3], s3++;
  return { part: b$h.parameterExpansion(a3), endIndex: s3 };
}
function Zr$1(e5, t4, r2, s3 = false) {
  let n3 = r2 + 2, a3 = false;
  t4[n3] === "!" && (a3 = true, n3++);
  let i4 = false;
  t4[n3] === "#" && !/[}:#%/^,]/.test(t4[n3 + 1] || "}") && (i4 = true, n3++);
  let l3 = "", o2 = t4[n3];
  if (/[@*#?$!-]/.test(o2) && !/[a-zA-Z0-9_]/.test(t4[n3 + 1] || "")) l3 = o2, n3++;
  else for (; n3 < t4.length && /[a-zA-Z0-9_]/.test(t4[n3]); ) l3 += t4[n3], n3++;
  if (t4[n3] === "[") {
    let u3 = Ze$4(e5, t4, n3, "[", "]");
    if (l3 += t4.slice(n3, u3 + 1), n3 = u3 + 1, t4[n3] === "[") {
      let f3 = 1, h3 = n3;
      for (; h3 < t4.length && f3 > 0; ) t4[h3] === "{" ? f3++ : t4[h3] === "}" && f3--, f3 > 0 && h3++;
      let d3 = t4.slice(r2 + 2, h3);
      return { part: b$h.parameterExpansion("", { type: "BadSubstitution", text: d3 }), endIndex: h3 + 1 };
    }
  }
  if (l3 === "" && !a3 && !i4 && t4[n3] !== "}") {
    let u3 = 1, f3 = n3;
    for (; f3 < t4.length && u3 > 0; ) t4[f3] === "{" ? u3++ : t4[f3] === "}" && u3--, u3 > 0 && f3++;
    if (u3 > 0) throw new Q$9("unexpected EOF while looking for matching '}'", 0, 0);
    let h3 = t4.slice(r2 + 2, f3);
    return { part: b$h.parameterExpansion("", { type: "BadSubstitution", text: h3 }), endIndex: f3 + 1 };
  }
  let c3 = null;
  if (a3) {
    let u3 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (u3) if (n3 < t4.length && t4[n3] !== "}" && /[:=\-+?#%/^,@]/.test(t4[n3])) {
      let f3 = st$6(e5, t4, n3, l3, s3);
      f3.operation ? (c3 = { type: "Indirection", innerOp: f3.operation }, n3 = f3.endIndex) : (c3 = { type: "ArrayKeys", array: u3[1], star: u3[2] === "*" }, l3 = "");
    } else c3 = { type: "ArrayKeys", array: u3[1], star: u3[2] === "*" }, l3 = "";
    else if (t4[n3] === "*" || t4[n3] === "@" && !/[QPaAEKkuUL]/.test(t4[n3 + 1] || "")) {
      let f3 = t4[n3];
      n3++, c3 = { type: "VarNamePrefix", prefix: l3, star: f3 === "*" }, l3 = "";
    } else if (n3 < t4.length && t4[n3] !== "}" && /[:=\-+?#%/^,@]/.test(t4[n3])) {
      let f3 = st$6(e5, t4, n3, l3, s3);
      f3.operation ? (c3 = { type: "Indirection", innerOp: f3.operation }, n3 = f3.endIndex) : c3 = { type: "Indirection" };
    } else c3 = { type: "Indirection" };
  } else if (i4) if (t4[n3] === ":") for (c3 = { type: "LengthSliceError" }; n3 < t4.length && t4[n3] !== "}"; ) n3++;
  else t4[n3] !== "}" && /[-+=?]/.test(t4[n3]) ? e5.error(`\${#${l3}${t4.slice(n3, t4.indexOf("}", n3))}}: bad substitution`) : t4[n3] === "/" ? e5.error(`\${#${l3}${t4.slice(n3, t4.indexOf("}", n3))}}: bad substitution`) : c3 = { type: "Length" };
  if (!c3 && n3 < t4.length && t4[n3] !== "}") {
    let u3 = st$6(e5, t4, n3, l3, s3);
    c3 = u3.operation, n3 = u3.endIndex;
  }
  if (n3 < t4.length && t4[n3] !== "}") {
    let u3 = t4[n3];
    if (!/[:\-+=?#%/^,@[]/.test(u3)) {
      let f3 = n3;
      for (; f3 < t4.length && t4[f3] !== "}"; ) f3++;
      let h3 = t4.slice(r2, f3 + 1);
      e5.error(`\${${h3.slice(2, -1)}}: bad substitution`);
    }
  }
  for (; n3 < t4.length && t4[n3] !== "}"; ) n3++;
  if (n3 >= t4.length) throw new Q$9("unexpected EOF while looking for matching '}'", 0, 0);
  return { part: b$h.parameterExpansion(l3, c3), endIndex: n3 + 1 };
}
function st$6(e5, t4, r2, s3, n3 = false) {
  let a3 = r2, i4 = t4[a3], l3 = t4[a3 + 1] || "";
  if (i4 === ":") {
    let o2 = l3;
    if ("-=?+".includes(o2)) {
      a3 += 2;
      let S3 = oe$8(e5, t4, a3), m3 = t4.slice(a3, S3), A2 = re$5(e5, m3, false, false, true, false, n3, false, false, true), w4 = b$h.word(A2.length > 0 ? A2 : [b$h.literal("")]);
      if (o2 === "-") return { operation: { type: "DefaultValue", word: w4, checkEmpty: true }, endIndex: S3 };
      if (o2 === "=") return { operation: { type: "AssignDefault", word: w4, checkEmpty: true }, endIndex: S3 };
      if (o2 === "?") return { operation: { type: "ErrorIfUnset", word: w4, checkEmpty: true }, endIndex: S3 };
      if (o2 === "+") return { operation: { type: "UseAlternative", word: w4, checkEmpty: true }, endIndex: S3 };
    }
    a3++;
    let c3 = oe$8(e5, t4, a3), u3 = t4.slice(a3, c3), f3 = -1, h3 = 0, d3 = 0;
    for (let E2 = 0; E2 < u3.length; E2++) {
      let S3 = u3[E2];
      if (S3 === "(" || S3 === "[") h3++;
      else if (S3 === ")" || S3 === "]") h3--;
      else if (S3 === "?" && h3 === 0) d3++;
      else if (S3 === ":" && h3 === 0) if (d3 > 0) d3--;
      else {
        f3 = E2;
        break;
      }
    }
    let y2 = f3 >= 0 ? u3.slice(0, f3) : u3, g2 = f3 >= 0 ? u3.slice(f3 + 1) : null;
    return { operation: { type: "Substring", offset: Ge$4(e5, y2), length: g2 !== null ? Ge$4(e5, g2) : null }, endIndex: c3 };
  }
  if ("-=?+".includes(i4)) {
    a3++;
    let o2 = oe$8(e5, t4, a3), c3 = t4.slice(a3, o2), u3 = re$5(e5, c3, false, false, true, false, n3, false, false, true), f3 = b$h.word(u3.length > 0 ? u3 : [b$h.literal("")]);
    if (i4 === "-") return { operation: { type: "DefaultValue", word: f3, checkEmpty: false }, endIndex: o2 };
    if (i4 === "=") return { operation: { type: "AssignDefault", word: f3, checkEmpty: false }, endIndex: o2 };
    if (i4 === "?") return { operation: { type: "ErrorIfUnset", word: c3 ? f3 : null, checkEmpty: false }, endIndex: o2 };
    if (i4 === "+") return { operation: { type: "UseAlternative", word: f3, checkEmpty: false }, endIndex: o2 };
  }
  if (i4 === "#" || i4 === "%") {
    let o2 = l3 === i4, c3 = i4 === "#" ? "prefix" : "suffix";
    a3 += o2 ? 2 : 1;
    let u3 = oe$8(e5, t4, a3), f3 = t4.slice(a3, u3), h3 = re$5(e5, f3, false, false, false);
    return { operation: { type: "PatternRemoval", pattern: b$h.word(h3.length > 0 ? h3 : [b$h.literal("")]), side: c3, greedy: o2 }, endIndex: u3 };
  }
  if (i4 === "/") {
    let o2 = l3 === "/";
    a3 += o2 ? 2 : 1;
    let c3 = null;
    t4[a3] === "#" ? (c3 = "start", a3++) : t4[a3] === "%" && (c3 = "end", a3++);
    let u3;
    c3 !== null && (t4[a3] === "/" || t4[a3] === "}") ? u3 = a3 : u3 = Ut$2(e5, t4, a3);
    let f3 = t4.slice(a3, u3), h3 = re$5(e5, f3, false, false, false), d3 = b$h.word(h3.length > 0 ? h3 : [b$h.literal("")]), y2 = null, g2 = u3;
    if (t4[u3] === "/") {
      let E2 = u3 + 1, S3 = oe$8(e5, t4, E2), m3 = t4.slice(E2, S3), A2 = re$5(e5, m3, false, false, false);
      y2 = b$h.word(A2.length > 0 ? A2 : [b$h.literal("")]), g2 = S3;
    }
    return { operation: { type: "PatternReplacement", pattern: d3, replacement: y2, all: o2, anchor: c3 }, endIndex: g2 };
  }
  if (i4 === "^" || i4 === ",") {
    let o2 = l3 === i4, c3 = i4 === "^" ? "upper" : "lower";
    a3 += o2 ? 2 : 1;
    let u3 = oe$8(e5, t4, a3), f3 = t4.slice(a3, u3), h3 = f3 ? b$h.word([b$h.literal(f3)]) : null;
    return { operation: { type: "CaseModification", direction: c3, all: o2, pattern: h3 }, endIndex: u3 };
  }
  return i4 === "@" && /[QPaAEKkuUL]/.test(l3) ? { operation: { type: "Transform", operator: l3 }, endIndex: a3 + 2 } : { operation: null, endIndex: a3 };
}
function it$4(e5, t4, r2, s3 = false) {
  let n3 = r2 + 1;
  if (n3 >= t4.length) return { part: b$h.literal("$"), endIndex: n3 };
  let a3 = t4[n3];
  if (a3 === "(" && t4[n3 + 1] === "(") return e5.isDollarDparenSubshell(t4, r2) ? e5.parseCommandSubstitution(t4, r2) : e5.parseArithmeticExpansion(t4, r2);
  if (a3 === "[") {
    let i4 = 1, l3 = n3 + 1;
    for (; l3 < t4.length && i4 > 0; ) t4[l3] === "[" ? i4++ : t4[l3] === "]" && i4--, i4 > 0 && l3++;
    if (i4 === 0) {
      let o2 = t4.slice(n3 + 1, l3), c3 = W$d(e5, o2);
      return { part: b$h.arithmeticExpansion(c3), endIndex: l3 + 1 };
    }
  }
  return a3 === "(" ? e5.parseCommandSubstitution(t4, r2) : a3 === "{" ? Zr$1(e5, t4, r2, s3) : /[a-zA-Z_0-9@*#?$!-]/.test(a3) ? zr$2(e5, t4, r2) : { part: b$h.literal("$"), endIndex: n3 };
}
function rn$1(e5, t4) {
  let r2 = [], s3 = 0, n3 = "", a3 = () => {
    n3 && (r2.push(b$h.literal(n3)), n3 = "");
  };
  for (; s3 < t4.length; ) {
    let i4 = t4[s3];
    if (i4 === "\\" && s3 + 1 < t4.length) {
      let l3 = t4[s3 + 1];
      if (l3 === "$" || l3 === "`" || l3 === '"' || l3 === "\\") {
        n3 += l3, s3 += 2;
        continue;
      }
      n3 += i4, s3++;
      continue;
    }
    if (i4 === "$") {
      a3();
      let { part: l3, endIndex: o2 } = it$4(e5, t4, s3, true);
      l3 && r2.push(l3), s3 = o2;
      continue;
    }
    if (i4 === "`") {
      a3();
      let { part: l3, endIndex: o2 } = e5.parseBacktickSubstitution(t4, s3, true);
      r2.push(l3), s3 = o2;
      continue;
    }
    n3 += i4, s3++;
  }
  return a3(), r2;
}
function Gr$1(e5, t4, r2) {
  let s3 = [], n3 = r2, a3 = "", i4 = () => {
    a3 && (s3.push(b$h.literal(a3)), a3 = "");
  };
  for (; n3 < t4.length && t4[n3] !== '"'; ) {
    let l3 = t4[n3];
    if (l3 === "\\" && n3 + 1 < t4.length) {
      let o2 = t4[n3 + 1];
      if ('"\\$`\n'.includes(o2)) {
        a3 += o2, n3 += 2;
        continue;
      }
      a3 += l3, n3++;
      continue;
    }
    if (l3 === "$") {
      i4();
      let { part: o2, endIndex: c3 } = it$4(e5, t4, n3, true);
      o2 && s3.push(o2), n3 = c3;
      continue;
    }
    if (l3 === "`") {
      i4();
      let { part: o2, endIndex: c3 } = e5.parseBacktickSubstitution(t4, n3, true);
      s3.push(o2), n3 = c3;
      continue;
    }
    a3 += l3, n3++;
  }
  return i4(), { part: b$h.doubleQuoted(s3), endIndex: n3 };
}
function re$5(e5, t4, r2 = false, s3 = false, n3 = false, a3 = false, i4 = false, l3 = false, o2 = false, c3 = false) {
  if (s3) return [b$h.singleQuoted(t4)];
  if (r2) {
    let y2 = rn$1(e5, t4);
    return [b$h.doubleQuoted(y2)];
  }
  if (t4.length >= 2 && t4[0] === '"' && t4[t4.length - 1] === '"') {
    let y2 = t4.slice(1, -1), g2 = false;
    for (let E2 = 0; E2 < y2.length; E2++) {
      if (y2[E2] === '"') {
        g2 = true;
        break;
      }
      y2[E2] === "\\" && E2 + 1 < y2.length && E2++;
    }
    if (!g2) {
      let E2 = rn$1(e5, y2);
      return [b$h.doubleQuoted(E2)];
    }
  }
  let u3 = [], f3 = 0, h3 = "", d3 = () => {
    h3 && (u3.push(b$h.literal(h3)), h3 = "");
  };
  for (; f3 < t4.length; ) {
    let y2 = t4[f3];
    if (y2 === "\\" && f3 + 1 < t4.length) {
      let g2 = t4[f3 + 1];
      if (o2) {
        d3(), u3.push(b$h.escaped(g2)), f3 += 2;
        continue;
      }
      let E2 = a3 ? g2 === "$" || g2 === "`" || g2 === `
` : g2 === "$" || g2 === "`" || g2 === '"' || g2 === "'" || g2 === `
` || c3 && g2 === "}", S3 = i4 ? "*?[]\\".includes(g2) : "*?[]\\(){}.^+".includes(g2);
      E2 ? h3 += g2 : S3 ? (d3(), u3.push(b$h.escaped(g2))) : h3 += `\\${g2}`, f3 += 2;
      continue;
    }
    if (y2 === "'" && !i4 && !a3) {
      d3();
      let g2 = t4.indexOf("'", f3 + 1);
      if (g2 === -1) {
        h3 += t4.slice(f3);
        break;
      }
      u3.push(b$h.singleQuoted(t4.slice(f3 + 1, g2))), f3 = g2 + 1;
      continue;
    }
    if (y2 === '"' && !a3) {
      d3();
      let { part: g2, endIndex: E2 } = Gr$1(e5, t4, f3 + 1);
      u3.push(g2), f3 = E2 + 1;
      continue;
    }
    if (y2 === "$" && t4[f3 + 1] === "'") {
      d3();
      let { part: g2, endIndex: E2 } = Ht$1(e5, t4, f3 + 2);
      u3.push(g2), f3 = E2;
      continue;
    }
    if (y2 === "$") {
      d3();
      let { part: g2, endIndex: E2 } = it$4(e5, t4, f3);
      g2 && u3.push(g2), f3 = E2;
      continue;
    }
    if (y2 === "`") {
      d3();
      let { part: g2, endIndex: E2 } = e5.parseBacktickSubstitution(t4, f3);
      u3.push(g2), f3 = E2;
      continue;
    }
    if (y2 === "~") {
      let g2 = f3 > 0 ? t4[f3 - 1] : "";
      if (f3 === 0 || g2 === "=" || n3 && g2 === ":") {
        let S3 = Gt$2(e5, t4, f3), m3 = t4[S3];
        if (m3 === void 0 || m3 === "/" || m3 === ":") {
          d3();
          let A2 = t4.slice(f3 + 1, S3) || null;
          u3.push({ type: "TildeExpansion", user: A2 }), f3 = S3;
          continue;
        }
      }
    }
    if ("@*+?!".includes(y2) && f3 + 1 < t4.length && t4[f3 + 1] === "(") {
      let g2 = Qr$1(t4, f3 + 1);
      if (g2 !== -1) {
        d3();
        let E2 = t4.slice(f3, g2 + 1);
        u3.push({ type: "Glob", pattern: E2 }), f3 = g2 + 1;
        continue;
      }
    }
    if (y2 === "*" || y2 === "?" || y2 === "[") {
      d3();
      let { pattern: g2, endIndex: E2 } = jt(e5, t4, f3);
      u3.push({ type: "Glob", pattern: g2 }), f3 = E2;
      continue;
    }
    if (y2 === "{" && !n3 && !l3) {
      let g2 = Kt$1(e5, t4, f3, re$5);
      if (g2) {
        d3(), u3.push(g2.part), f3 = g2.endIndex;
        continue;
      }
    }
    h3 += y2, f3++;
  }
  return d3(), u3;
}
function sn(e5, t4) {
  let r2 = e5.length, s3 = t4 + 3, n3 = 2, a3 = false, i4 = false;
  for (; s3 < r2 && n3 > 0; ) {
    let l3 = e5[s3];
    if (a3) {
      l3 === "'" && (a3 = false), s3++;
      continue;
    }
    if (i4) {
      if (l3 === "\\") {
        s3 += 2;
        continue;
      }
      l3 === '"' && (i4 = false), s3++;
      continue;
    }
    if (l3 === "'") {
      a3 = true, s3++;
      continue;
    }
    if (l3 === '"') {
      i4 = true, s3++;
      continue;
    }
    if (l3 === "\\") {
      s3 += 2;
      continue;
    }
    if (l3 === "(") {
      n3++, s3++;
      continue;
    }
    if (l3 === ")") {
      if (n3--, n3 === 1) {
        let o2 = s3 + 1;
        return !(o2 < r2 && e5[o2] === ")");
      }
      if (n3 === 0) return false;
      s3++;
      continue;
    }
    if (n3 === 1 && (l3 === "|" && s3 + 1 < r2 && e5[s3 + 1] === "|" || l3 === "&" && s3 + 1 < r2 && e5[s3 + 1] === "&" || l3 === "|" && s3 + 1 < r2 && e5[s3 + 1] !== "|")) return true;
    s3++;
  }
  return false;
}
function an$1(e5, t4, r2, s3) {
  let n3 = t4 + 2, a3 = 1, i4 = n3, l3 = false, o2 = false, c3 = 0, u3 = false, f3 = "";
  for (; i4 < e5.length && a3 > 0; ) {
    let g2 = e5[i4];
    l3 ? g2 === "'" && (l3 = false) : o2 ? g2 === "\\" && i4 + 1 < e5.length ? i4++ : g2 === '"' && (o2 = false) : g2 === "'" ? (l3 = true, f3 = "") : g2 === '"' ? (o2 = true, f3 = "") : g2 === "\\" && i4 + 1 < e5.length ? (i4++, f3 = "") : /[a-zA-Z_]/.test(g2) ? f3 += g2 : (f3 === "case" ? (c3++, u3 = false) : f3 === "in" && c3 > 0 ? u3 = true : f3 === "esac" && c3 > 0 && (c3--, u3 = false), f3 = "", g2 === "(" ? i4 > 0 && e5[i4 - 1] === "$" ? a3++ : u3 || a3++ : g2 === ")" ? u3 ? u3 = false : a3-- : g2 === ";" && c3 > 0 && i4 + 1 < e5.length && e5[i4 + 1] === ";" && (u3 = true)), a3 > 0 && i4++;
  }
  a3 > 0 && s3("unexpected EOF while looking for matching `)'");
  let h3 = e5.slice(n3, i4), y2 = r2().parse(h3);
  return { part: b$h.commandSubstitution(y2, false), endIndex: i4 + 1 };
}
function on$2(e5, t4, r2, s3, n3) {
  let i4 = t4 + 1, l3 = "";
  for (; i4 < e5.length && e5[i4] !== "`"; ) if (e5[i4] === "\\") {
    let u3 = e5[i4 + 1];
    u3 === "$" || u3 === "`" || u3 === "\\" || u3 === `
` || r2 && u3 === '"' ? (u3 !== `
` && (l3 += u3), i4 += 2) : (l3 += e5[i4], i4++);
  } else l3 += e5[i4], i4++;
  i4 >= e5.length && n3("unexpected EOF while looking for matching ``'");
  let c3 = s3().parse(l3);
  return { part: b$h.commandSubstitution(c3, true), endIndex: i4 + 1 };
}
var T$9 = class e {
  tokens = [];
  pos = 0;
  pendingHeredocs = [];
  parseIterations = 0;
  _input = "";
  getInput() {
    return this._input;
  }
  checkIterationLimit() {
    if (this.parseIterations++, this.parseIterations > Bt) throw new Q$9("Maximum parse iterations exceeded (possible infinite loop)", this.current().line, this.current().column);
  }
  parse(t4) {
    if (t4.length > Qe$6) throw new Q$9(`Input too large: ${t4.length} bytes exceeds limit of ${Qe$6}`, 1, 1);
    this._input = t4;
    let r2 = new Re$3(t4);
    if (this.tokens = r2.tokenize(), this.tokens.length > ze$4) throw new Q$9(`Too many tokens: ${this.tokens.length} exceeds limit of ${ze$4}`, 1, 1);
    return this.pos = 0, this.pendingHeredocs = [], this.parseIterations = 0, this.parseScript();
  }
  parseTokens(t4) {
    return this.tokens = t4, this.pos = 0, this.pendingHeredocs = [], this.parseScript();
  }
  current() {
    return this.tokens[this.pos] || this.tokens[this.tokens.length - 1];
  }
  peek(t4 = 0) {
    return this.tokens[this.pos + t4] || this.tokens[this.tokens.length - 1];
  }
  advance() {
    let t4 = this.current();
    return this.pos < this.tokens.length - 1 && this.pos++, t4;
  }
  getPos() {
    return this.pos;
  }
  check(t4, r2, s3, n3, ...a3) {
    let i4 = this.tokens[this.pos]?.type;
    return i4 === t4 || r2 !== void 0 && i4 === r2 || s3 !== void 0 && i4 === s3 || n3 !== void 0 && i4 === n3 ? true : a3.length > 0 ? a3.includes(i4) : false;
  }
  expect(t4, r2) {
    if (this.check(t4)) return this.advance();
    let s3 = this.current();
    throw new Q$9(r2 || `Expected ${t4}, got ${s3.type}`, s3.line, s3.column, s3);
  }
  error(t4) {
    let r2 = this.current();
    throw new Q$9(t4, r2.line, r2.column, r2);
  }
  skipNewlines() {
    for (; this.check(p$e.NEWLINE, p$e.COMMENT); ) this.check(p$e.NEWLINE) ? (this.advance(), this.processHeredocs()) : this.advance();
  }
  skipSeparators(t4 = true) {
    for (; ; ) {
      if (this.check(p$e.NEWLINE)) {
        this.advance(), this.processHeredocs();
        continue;
      }
      if (this.check(p$e.SEMICOLON, p$e.COMMENT)) {
        this.advance();
        continue;
      }
      if (t4 && this.check(p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND)) {
        this.advance();
        continue;
      }
      break;
    }
  }
  addPendingHeredoc(t4, r2, s3, n3) {
    this.pendingHeredocs.push({ redirect: t4, delimiter: r2, stripTabs: s3, quoted: n3 });
  }
  processHeredocs() {
    for (let t4 of this.pendingHeredocs) if (this.check(p$e.HEREDOC_CONTENT)) {
      let r2 = this.advance(), s3;
      t4.quoted ? s3 = b$h.word([b$h.literal(r2.value)]) : s3 = this.parseWordFromString(r2.value, false, false, false, true), t4.redirect.target = b$h.hereDoc(t4.delimiter, s3, t4.stripTabs, t4.quoted);
    }
    this.pendingHeredocs = [];
  }
  isStatementEnd() {
    return this.check(p$e.EOF, p$e.NEWLINE, p$e.SEMICOLON, p$e.AMP, p$e.AND_AND, p$e.OR_OR, p$e.RPAREN, p$e.RBRACE, p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND);
  }
  isCommandStart() {
    let t4 = this.current().type;
    return t4 === p$e.WORD || t4 === p$e.NAME || t4 === p$e.NUMBER || t4 === p$e.ASSIGNMENT_WORD || t4 === p$e.IF || t4 === p$e.FOR || t4 === p$e.WHILE || t4 === p$e.UNTIL || t4 === p$e.CASE || t4 === p$e.LPAREN || t4 === p$e.LBRACE || t4 === p$e.DPAREN_START || t4 === p$e.DBRACK_START || t4 === p$e.FUNCTION || t4 === p$e.BANG || t4 === p$e.TIME || t4 === p$e.IN || t4 === p$e.LESS || t4 === p$e.GREAT || t4 === p$e.DLESS || t4 === p$e.DGREAT || t4 === p$e.LESSAND || t4 === p$e.GREATAND || t4 === p$e.LESSGREAT || t4 === p$e.DLESSDASH || t4 === p$e.CLOBBER || t4 === p$e.TLESS || t4 === p$e.AND_GREAT || t4 === p$e.AND_DGREAT;
  }
  parseScript() {
    let t4 = [], s3 = 0;
    for (this.skipNewlines(); !this.check(p$e.EOF); ) {
      s3++, s3 > 1e4 && this.error("Parser stuck: too many iterations (>10000)");
      let n3 = this.checkUnexpectedToken();
      if (n3) {
        t4.push(n3), this.skipSeparators(false);
        continue;
      }
      let a3 = this.pos, i4 = this.parseStatement();
      i4 && t4.push(i4), this.skipSeparators(false), this.check(p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${this.current().value}'`), this.pos === a3 && !this.check(p$e.EOF) && this.advance();
    }
    return b$h.script(t4);
  }
  checkUnexpectedToken() {
    let t4 = this.current().type, r2 = this.current().value;
    if ((t4 === p$e.DO || t4 === p$e.DONE || t4 === p$e.THEN || t4 === p$e.ELSE || t4 === p$e.ELIF || t4 === p$e.FI || t4 === p$e.ESAC) && this.error(`syntax error near unexpected token \`${r2}'`), t4 === p$e.RBRACE || t4 === p$e.RPAREN) {
      let s3 = `syntax error near unexpected token \`${r2}'`;
      return this.advance(), b$h.statement([b$h.pipeline([b$h.simpleCommand(null, [], [], [])])], [], false, { message: s3, token: r2 });
    }
    return (t4 === p$e.DSEMI || t4 === p$e.SEMI_AND || t4 === p$e.SEMI_SEMI_AND) && this.error(`syntax error near unexpected token \`${r2}'`), t4 === p$e.SEMICOLON && this.error(`syntax error near unexpected token \`${r2}'`), (t4 === p$e.PIPE || t4 === p$e.PIPE_AMP) && this.error(`syntax error near unexpected token \`${r2}'`), null;
  }
  parseStatement() {
    if (this.skipNewlines(), !this.isCommandStart()) return null;
    let t4 = this.current().start, r2 = [], s3 = [], n3 = false, a3 = this.parsePipeline();
    for (r2.push(a3); this.check(p$e.AND_AND, p$e.OR_OR); ) {
      let o2 = this.advance();
      s3.push(o2.type === p$e.AND_AND ? "&&" : "||"), this.skipNewlines();
      let c3 = this.parsePipeline();
      r2.push(c3);
    }
    this.check(p$e.AMP) && (this.advance(), n3 = true);
    let i4 = this.pos > 0 ? this.tokens[this.pos - 1].end : t4, l3 = this._input.slice(t4, i4);
    return b$h.statement(r2, s3, n3, void 0, l3);
  }
  parsePipeline() {
    let t4 = false, r2 = false;
    this.check(p$e.TIME) && (this.advance(), t4 = true, this.check(p$e.WORD, p$e.NAME) && this.current().value === "-p" && (this.advance(), r2 = true));
    let s3 = 0;
    for (; this.check(p$e.BANG); ) this.advance(), s3++;
    let n3 = s3 % 2 === 1, a3 = [], i4 = [], l3 = this.parseCommand();
    for (a3.push(l3); this.check(p$e.PIPE, p$e.PIPE_AMP); ) {
      let o2 = this.advance();
      this.skipNewlines(), i4.push(o2.type === p$e.PIPE_AMP);
      let c3 = this.parseCommand();
      a3.push(c3);
    }
    return b$h.pipeline(a3, n3, t4, r2, i4.length > 0 ? i4 : void 0);
  }
  parseCommand() {
    return this.check(p$e.IF) ? He$5(this) : this.check(p$e.FOR) ? Ke$4(this) : this.check(p$e.WHILE) ? Xe$4(this) : this.check(p$e.UNTIL) ? Je$6(this) : this.check(p$e.CASE) ? Ye$5(this) : this.check(p$e.LPAREN) ? et$7(this) : this.check(p$e.LBRACE) ? tt$6(this) : this.check(p$e.DPAREN_START) ? this.dparenClosesWithSpacedParens() ? this.parseNestedSubshellsFromDparen() : this.parseArithmeticCommand() : this.check(p$e.DBRACK_START) ? this.parseConditionalCommand() : this.check(p$e.FUNCTION) ? this.parseFunctionDef() : this.check(p$e.NAME, p$e.WORD) && this.peek(1).type === p$e.LPAREN && this.peek(2).type === p$e.RPAREN ? this.parseFunctionDef() : Yt$1(this);
  }
  dparenClosesWithSpacedParens() {
    let t4 = 1, r2 = 1;
    for (; r2 < this.tokens.length - this.pos; ) {
      let s3 = this.peek(r2);
      if (s3.type === p$e.EOF) return false;
      if (s3.type === p$e.DPAREN_START || s3.type === p$e.LPAREN) t4++;
      else if (s3.type === p$e.DPAREN_END) {
        if (t4 -= 2, t4 <= 0) return false;
      } else if (s3.type === p$e.RPAREN && (t4--, t4 === 0 && this.peek(r2 + 1).type === p$e.RPAREN)) return true;
      r2++;
    }
    return false;
  }
  parseNestedSubshellsFromDparen() {
    this.advance();
    let t4 = this.parseCompoundList();
    this.expect(p$e.RPAREN), this.expect(p$e.RPAREN);
    let r2 = this.parseOptionalRedirections(), s3 = b$h.subshell(t4, []);
    return b$h.subshell([b$h.statement([b$h.pipeline([s3], false, false, false)])], r2);
  }
  isWord() {
    let t4 = this.current().type;
    return t4 === p$e.WORD || t4 === p$e.NAME || t4 === p$e.NUMBER || t4 === p$e.IF || t4 === p$e.FOR || t4 === p$e.WHILE || t4 === p$e.UNTIL || t4 === p$e.CASE || t4 === p$e.FUNCTION || t4 === p$e.ELSE || t4 === p$e.ELIF || t4 === p$e.FI || t4 === p$e.THEN || t4 === p$e.DO || t4 === p$e.DONE || t4 === p$e.ESAC || t4 === p$e.IN || t4 === p$e.SELECT || t4 === p$e.TIME || t4 === p$e.COPROC || t4 === p$e.BANG;
  }
  parseWord() {
    let t4 = this.advance();
    return this.parseWordFromString(t4.value, t4.quoted, t4.singleQuoted);
  }
  parseWordNoBraceExpansion() {
    let t4 = this.advance();
    return this.parseWordFromString(t4.value, t4.quoted, t4.singleQuoted, false, false, true);
  }
  parseWordForRegex() {
    let t4 = this.advance();
    return this.parseWordFromString(t4.value, t4.quoted, t4.singleQuoted, false, false, true, true);
  }
  parseWordFromString(t4, r2 = false, s3 = false, n3 = false, a3 = false, i4 = false, l3 = false) {
    let o2 = re$5(this, t4, r2, s3, n3, a3, false, i4, l3);
    return b$h.word(o2);
  }
  parseCommandSubstitution(t4, r2) {
    return an$1(t4, r2, () => new e(), (s3) => this.error(s3));
  }
  parseBacktickSubstitution(t4, r2, s3 = false) {
    return on$2(t4, r2, s3, () => new e(), (n3) => this.error(n3));
  }
  isDollarDparenSubshell(t4, r2) {
    return sn(t4, r2);
  }
  parseArithmeticExpansion(t4, r2) {
    let s3 = r2 + 3, n3 = 1, a3 = 0, i4 = s3;
    for (; i4 < t4.length - 1 && n3 > 0; ) t4[i4] === "$" && t4[i4 + 1] === "(" ? t4[i4 + 2] === "(" ? (n3++, i4 += 3) : (a3++, i4 += 2) : t4[i4] === "(" && t4[i4 + 1] === "(" ? (n3++, i4 += 2) : t4[i4] === ")" && t4[i4 + 1] === ")" ? a3 > 0 ? (a3--, i4++) : (n3--, n3 > 0 && (i4 += 2)) : t4[i4] === "(" ? (a3++, i4++) : (t4[i4] === ")" && a3 > 0 && a3--, i4++);
    let l3 = t4.slice(s3, i4), o2 = this.parseArithmeticExpression(l3);
    return { part: b$h.arithmeticExpansion(o2), endIndex: i4 + 2 };
  }
  parseArithmeticCommand() {
    let t4 = this.expect(p$e.DPAREN_START), r2 = "", s3 = 1, n3 = 0, a3 = false, i4 = false;
    for (; s3 > 0 && !this.check(p$e.EOF); ) {
      if (a3) {
        if (a3 = false, n3 > 0) {
          n3--, r2 += ")";
          continue;
        }
        if (this.check(p$e.RPAREN)) {
          s3--, i4 = true, this.advance();
          continue;
        }
        if (this.check(p$e.DPAREN_END)) {
          s3--, i4 = true;
          continue;
        }
        r2 += ")";
        continue;
      }
      if (this.check(p$e.DPAREN_START)) s3++, r2 += "((", this.advance();
      else if (this.check(p$e.DPAREN_END)) n3 >= 2 ? (n3 -= 2, r2 += "))", this.advance()) : n3 === 1 ? (n3--, r2 += ")", a3 = true, this.advance()) : (s3--, i4 = true, s3 > 0 && (r2 += "))"), this.advance());
      else if (this.check(p$e.LPAREN)) n3++, r2 += "(", this.advance();
      else if (this.check(p$e.RPAREN)) n3 > 0 && n3--, r2 += ")", this.advance();
      else {
        let c3 = this.current().value, u3 = r2.length > 0 ? r2[r2.length - 1] : "";
        r2.length > 0 && !r2.endsWith(" ") && !(c3 === "=" && /[|&^+\-*/%<>]$/.test(r2)) && !(c3 === "<" && u3 === "<") && !(c3 === ">" && u3 === ">") && (r2 += " "), r2 += c3, this.advance();
      }
    }
    i4 || this.expect(p$e.DPAREN_END);
    let l3 = this.parseArithmeticExpression(r2.trim()), o2 = this.parseOptionalRedirections();
    return b$h.arithmeticCommand(l3, o2, t4.line);
  }
  parseConditionalCommand() {
    let t4 = this.expect(p$e.DBRACK_START), r2 = rt$2(this);
    this.expect(p$e.DBRACK_END);
    let s3 = this.parseOptionalRedirections();
    return b$h.conditionalCommand(r2, s3, t4.line);
  }
  parseFunctionDef() {
    let t4;
    if (this.check(p$e.FUNCTION)) {
      if (this.advance(), this.check(p$e.NAME) || this.check(p$e.WORD)) t4 = this.advance().value;
      else {
        let n3 = this.current();
        throw new Q$9("Expected function name", n3.line, n3.column, n3);
      }
      this.check(p$e.LPAREN) && (this.advance(), this.expect(p$e.RPAREN));
    } else t4 = this.advance().value, t4.includes("$") && this.error(`\`${t4}': not a valid identifier`), this.expect(p$e.LPAREN), this.expect(p$e.RPAREN);
    this.skipNewlines();
    let r2 = this.parseCompoundCommandBody({ forFunctionBody: true }), s3 = this.parseOptionalRedirections();
    return b$h.functionDef(t4, r2, s3);
  }
  parseCompoundCommandBody(t4) {
    let r2 = t4?.forFunctionBody;
    if (this.check(p$e.LBRACE)) return tt$6(this, { skipRedirections: r2 });
    if (this.check(p$e.LPAREN)) return et$7(this, { skipRedirections: r2 });
    if (this.check(p$e.IF)) return He$5(this, { skipRedirections: r2 });
    if (this.check(p$e.FOR)) return Ke$4(this, { skipRedirections: r2 });
    if (this.check(p$e.WHILE)) return Xe$4(this, { skipRedirections: r2 });
    if (this.check(p$e.UNTIL)) return Je$6(this, { skipRedirections: r2 });
    if (this.check(p$e.CASE)) return Ye$5(this, { skipRedirections: r2 });
    this.error("Expected compound command for function body");
  }
  parseCompoundList() {
    let t4 = [];
    for (this.skipNewlines(); !this.check(p$e.EOF, p$e.FI, p$e.ELSE, p$e.ELIF, p$e.THEN, p$e.DO, p$e.DONE, p$e.ESAC, p$e.RPAREN, p$e.RBRACE, p$e.DSEMI, p$e.SEMI_AND, p$e.SEMI_SEMI_AND) && this.isCommandStart(); ) {
      this.checkIterationLimit();
      let r2 = this.pos, s3 = this.parseStatement();
      if (s3 && t4.push(s3), this.skipSeparators(), this.pos === r2 && !s3) break;
    }
    return t4;
  }
  parseOptionalRedirections() {
    let t4 = [];
    for (; Ie$5(this); ) {
      this.checkIterationLimit();
      let r2 = this.pos;
      if (t4.push(ve$5(this)), this.pos === r2) break;
    }
    return t4;
  }
  parseArithmeticExpression(t4) {
    return W$d(this, t4);
  }
};
function ci$1(e5) {
  return new T$9().parse(e5);
}
var jr$1 = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9a-fA-F" };
function at$4(e5) {
  return jr$1[e5] || "";
}
function ln$1(e5) {
  let t4 = [], r2 = "", s3 = 0;
  for (; s3 < e5.length; ) {
    let n3 = e5[s3];
    if (n3 === "[") {
      for (r2 += n3, s3++, s3 < e5.length && (e5[s3] === "!" || e5[s3] === "^") && (r2 += e5[s3], s3++), s3 < e5.length && e5[s3] === "]" && (r2 += e5[s3], s3++); s3 < e5.length && e5[s3] !== "]"; ) {
        if (e5[s3] === "[" && s3 + 1 < e5.length && e5[s3 + 1] === ":") {
          let a3 = e5.indexOf(":]", s3 + 2);
          if (a3 !== -1) {
            r2 += e5.slice(s3, a3 + 2), s3 = a3 + 2;
            continue;
          }
        }
        if (e5[s3] === "\\" && s3 + 1 < e5.length) {
          r2 += e5[s3] + e5[s3 + 1], s3 += 2;
          continue;
        }
        r2 += e5[s3], s3++;
      }
      s3 < e5.length && e5[s3] === "]" && (r2 += e5[s3], s3++);
    } else n3 === ":" ? (r2 !== "" && t4.push(r2), r2 = "", s3++) : n3 === "\\" && s3 + 1 < e5.length ? (r2 += n3 + e5[s3 + 1], s3 += 2) : (r2 += n3, s3++);
  }
  return r2 !== "" && t4.push(r2), t4;
}
function un$1(e5) {
  let t4 = "^";
  for (let r2 = 0; r2 < e5.length; r2++) {
    let s3 = e5[r2];
    if (s3 === "*") t4 += "[^/]*";
    else if (s3 === "?") t4 += "[^/]";
    else if (s3 === "[") {
      let n3 = r2 + 1, a3 = "[";
      n3 < e5.length && (e5[n3] === "^" || e5[n3] === "!") && (a3 += "^", n3++), n3 < e5.length && e5[n3] === "]" && (a3 += "\\]", n3++);
      let i4 = n3;
      for (; i4 < e5.length; ) {
        if (e5[i4] === "\\" && i4 + 1 < e5.length) {
          i4 += 2;
          continue;
        }
        if (e5[i4] === "[" && i4 + 1 < e5.length && e5[i4 + 1] === ":") {
          let o2 = e5.indexOf(":]", i4 + 2);
          if (o2 !== -1) {
            i4 = o2 + 2;
            continue;
          }
        }
        if (e5[i4] === "]") break;
        i4++;
      }
      let l3 = n3;
      for (; n3 < e5.length && e5[n3] !== "]"; ) {
        if (e5[n3] === "[" && n3 + 1 < e5.length && e5[n3 + 1] === ":") {
          let o2 = e5.indexOf(":]", n3 + 2);
          if (o2 !== -1) {
            let c3 = e5.slice(n3 + 2, o2), u3 = at$4(c3);
            a3 += u3, n3 = o2 + 2;
            continue;
          }
        }
        if (e5[n3] === "\\" && n3 + 1 < e5.length) {
          a3 += `\\${e5[n3 + 1]}`, n3 += 2;
          continue;
        }
        if (e5[n3] === "-") {
          let o2 = n3 === l3, c3 = n3 + 1 === i4;
          o2 || c3 ? a3 += "\\-" : a3 += "-";
        } else a3 += e5[n3];
        n3++;
      }
      a3 += "]", t4 += a3, r2 = n3;
    } else if (s3 === "\\" && r2 + 1 < e5.length) {
      let n3 = e5[r2 + 1];
      /[.+^${}()|\\*?[\]]/.test(n3) ? t4 += `\\${n3}` : t4 += n3, r2++;
    } else /[.+^${}()|]/.test(s3) ? t4 += `\\${s3}` : t4 += s3;
  }
  return t4 += "$", new RegExp(t4);
}
function ot$3(e5, t4) {
  let r2 = 1, s3 = t4 + 1;
  for (; s3 < e5.length && r2 > 0; ) {
    let n3 = e5[s3];
    if (n3 === "\\") {
      s3 += 2;
      continue;
    }
    if (n3 === "(") r2++;
    else if (n3 === ")" && (r2--, r2 === 0)) return s3;
    s3++;
  }
  return -1;
}
function lt$2(e5) {
  let t4 = [], r2 = "", s3 = 0, n3 = false, a3 = 0;
  for (; a3 < e5.length; ) {
    let i4 = e5[a3];
    if (i4 === "'" && !n3) {
      n3 = true, r2 += "\0QUOTE_START\0", a3++;
      continue;
    }
    if (i4 === "'" && n3) {
      n3 = false, r2 += "\0QUOTE_END\0", a3++;
      continue;
    }
    if (n3) {
      r2 += i4, a3++;
      continue;
    }
    if (i4 === "\\") {
      r2 += i4, a3 + 1 < e5.length ? (r2 += e5[a3 + 1], a3 += 2) : a3++;
      continue;
    }
    i4 === "(" ? (s3++, r2 += i4) : i4 === ")" ? (s3--, r2 += i4) : i4 === "|" && s3 === 0 ? (t4.push(r2), r2 = "") : r2 += i4, a3++;
  }
  return t4.push(r2), t4;
}
var se$7 = class se {
  fs;
  cwd;
  globignorePatterns = [];
  hasGlobignore = false;
  globstar = false;
  nullglob = false;
  failglob = false;
  dotglob = false;
  extglob = false;
  globskipdots = true;
  constructor(t4, r2, s3, n3) {
    this.fs = t4, this.cwd = r2, typeof n3 == "boolean" ? this.globstar = n3 : n3 && (this.globstar = n3.globstar ?? false, this.nullglob = n3.nullglob ?? false, this.failglob = n3.failglob ?? false, this.dotglob = n3.dotglob ?? false, this.extglob = n3.extglob ?? false, this.globskipdots = n3.globskipdots ?? true);
    let a3 = s3?.GLOBIGNORE;
    a3 !== void 0 && a3 !== "" && (this.hasGlobignore = true, this.globignorePatterns = ln$1(a3));
  }
  hasNullglob() {
    return this.nullglob;
  }
  hasFailglob() {
    return this.failglob;
  }
  filterGlobignore(t4) {
    return !this.hasGlobignore && !this.globskipdots ? t4 : t4.filter((r2) => {
      let s3 = r2.split("/").pop() || r2;
      if ((this.hasGlobignore || this.globskipdots) && (s3 === "." || s3 === "..")) return false;
      if (this.hasGlobignore) {
        for (let n3 of this.globignorePatterns) if (this.matchGlobignorePattern(r2, n3)) return false;
      }
      return true;
    });
  }
  matchGlobignorePattern(t4, r2) {
    return un$1(r2).test(t4);
  }
  isGlobPattern(t4) {
    return !!(t4.includes("*") || t4.includes("?") || /\[.*\]/.test(t4) || this.extglob && /[@*+?!]\(/.test(t4));
  }
  async expandArgs(t4, r2) {
    let s3 = t4.map((i4, l3) => (r2?.[l3] ?? false) || !this.isGlobPattern(i4) ? null : this.expand(i4)), n3 = await Promise.all(s3.map((i4) => i4 || Promise.resolve(null))), a3 = [];
    for (let i4 = 0; i4 < t4.length; i4++) {
      let l3 = n3[i4];
      l3 === null ? a3.push(t4[i4]) : l3.length > 0 ? a3.push(...l3) : a3.push(t4[i4]);
    }
    return a3;
  }
  async expand(t4) {
    let r2;
    if (t4.includes("**") && this.globstar && this.isGlobstarValid(t4)) r2 = await this.expandRecursive(t4);
    else {
      let s3 = t4.replace(/\*\*+/g, "*");
      r2 = await this.expandSimple(s3);
    }
    return this.filterGlobignore(r2);
  }
  isGlobstarValid(t4) {
    let r2 = t4.split("/");
    for (let s3 of r2) if (s3.includes("**") && s3 !== "**") return false;
    return true;
  }
  hasGlobChars(t4) {
    return !!(t4.includes("*") || t4.includes("?") || /\[.*\]/.test(t4) || this.extglob && /[@*+?!]\(/.test(t4));
  }
  async expandSimple(t4) {
    let r2 = t4.startsWith("/"), s3 = t4.split("/").filter((c3) => c3 !== ""), n3 = -1;
    for (let c3 = 0; c3 < s3.length; c3++) if (this.hasGlobChars(s3[c3])) {
      n3 = c3;
      break;
    }
    if (n3 === -1) return [t4];
    let a3, i4;
    if (n3 === 0) r2 ? (a3 = "/", i4 = "/") : (a3 = this.cwd, i4 = "");
    else {
      let c3 = s3.slice(0, n3);
      r2 ? (a3 = `/${c3.join("/")}`, i4 = `/${c3.join("/")}`) : (a3 = this.fs.resolvePath(this.cwd, c3.join("/")), i4 = c3.join("/"));
    }
    let l3 = s3.slice(n3);
    return (await this.expandSegments(a3, i4, l3)).sort();
  }
  async expandSegments(t4, r2, s3) {
    if (s3.length === 0) return [r2];
    let [n3, ...a3] = s3, i4 = [];
    try {
      if (this.fs.readdirWithFileTypes) {
        let l3 = await this.fs.readdirWithFileTypes(t4), o2 = [], c3 = [...l3], u3 = this.dotglob || this.hasGlobignore;
        if (n3.startsWith(".") || this.dotglob) {
          let h3 = l3.some((y2) => y2.name === "."), d3 = l3.some((y2) => y2.name === "..");
          h3 || c3.push({ name: ".", isFile: false, isDirectory: true, isSymbolicLink: false }), d3 || c3.push({ name: "..", isFile: false, isDirectory: true, isSymbolicLink: false });
        }
        for (let h3 of c3) if (!(h3.name.startsWith(".") && !n3.startsWith(".") && !u3) && this.matchPattern(h3.name, n3)) {
          let d3 = t4 === "/" ? `/${h3.name}` : `${t4}/${h3.name}`, y2;
          r2 === "" ? y2 = h3.name : r2 === "/" ? y2 = `/${h3.name}` : y2 = `${r2}/${h3.name}`, a3.length === 0 ? o2.push(Promise.resolve([y2])) : h3.isDirectory && o2.push(this.expandSegments(d3, y2, a3));
        }
        let f3 = await Promise.all(o2);
        for (let h3 of f3) i4.push(...h3);
      } else {
        let l3 = await this.fs.readdir(t4), o2 = [], c3 = [...l3], u3 = this.dotglob || this.hasGlobignore;
        (n3.startsWith(".") || this.dotglob) && (l3.includes(".") || c3.push("."), l3.includes("..") || c3.push(".."));
        for (let h3 of c3) if (!(h3.startsWith(".") && !n3.startsWith(".") && !u3) && this.matchPattern(h3, n3)) {
          let d3 = t4 === "/" ? `/${h3}` : `${t4}/${h3}`, y2;
          r2 === "" ? y2 = h3 : r2 === "/" ? y2 = `/${h3}` : y2 = `${r2}/${h3}`, a3.length === 0 ? o2.push(Promise.resolve([y2])) : o2.push((async () => {
            try {
              if ((await this.fs.stat(d3)).isDirectory) return this.expandSegments(d3, y2, a3);
            } catch {
            }
            return [];
          })());
        }
        let f3 = await Promise.all(o2);
        for (let h3 of f3) i4.push(...h3);
      }
    } catch {
    }
    return i4;
  }
  async expandRecursive(t4) {
    let r2 = [], s3 = t4.indexOf("**"), n3 = t4.slice(0, s3).replace(/\/$/, "") || ".", i4 = t4.slice(s3 + 2).replace(/^\//, "");
    return i4.includes("**") && this.isGlobstarValid(i4) ? (await this.walkDirectoryMultiGlobstar(n3, i4, r2), [...new Set(r2)].sort()) : (await this.walkDirectory(n3, i4, r2), r2.sort());
  }
  async walkDirectoryMultiGlobstar(t4, r2, s3) {
    let n3 = this.fs.resolvePath(this.cwd, t4);
    try {
      let a3 = this.fs.readdirWithFileTypes ? await this.fs.readdirWithFileTypes(n3) : null;
      if (a3) {
        let i4 = [];
        for (let c3 of a3) {
          let u3 = t4 === "." ? c3.name : `${t4}/${c3.name}`;
          c3.isDirectory && i4.push(u3);
        }
        let l3 = t4 === "." ? r2 : `${t4}/${r2}`, o2 = await this.expandRecursive(l3);
        s3.push(...o2);
        for (let c3 = 0; c3 < i4.length; c3 += 100) {
          let u3 = i4.slice(c3, c3 + 100);
          await Promise.all(u3.map((f3) => this.walkDirectoryMultiGlobstar(f3, r2, s3)));
        }
      } else {
        let i4 = await this.fs.readdir(n3), l3 = [];
        for (let u3 of i4) {
          let f3 = t4 === "." ? u3 : `${t4}/${u3}`, h3 = this.fs.resolvePath(this.cwd, f3);
          try {
            (await this.fs.stat(h3)).isDirectory && l3.push(f3);
          } catch {
          }
        }
        let o2 = t4 === "." ? r2 : `${t4}/${r2}`, c3 = await this.expandRecursive(o2);
        s3.push(...c3);
        for (let u3 = 0; u3 < l3.length; u3 += 100) {
          let f3 = l3.slice(u3, u3 + 100);
          await Promise.all(f3.map((h3) => this.walkDirectoryMultiGlobstar(h3, r2, s3)));
        }
      }
    } catch {
    }
  }
  async walkDirectory(t4, r2, s3) {
    let n3 = this.fs.resolvePath(this.cwd, t4);
    try {
      if (this.fs.readdirWithFileTypes) {
        let a3 = await this.fs.readdirWithFileTypes(n3), i4 = [], l3 = [];
        for (let o2 of a3) {
          let c3 = t4 === "." ? o2.name : `${t4}/${o2.name}`;
          o2.isDirectory ? l3.push(c3) : r2 && this.matchPattern(o2.name, r2) && i4.push(c3);
        }
        s3.push(...i4);
        for (let o2 = 0; o2 < l3.length; o2 += 100) {
          let c3 = l3.slice(o2, o2 + 100);
          await Promise.all(c3.map((u3) => this.walkDirectory(u3, r2, s3)));
        }
      } else {
        let a3 = await this.fs.readdir(n3), i4 = [];
        for (let o2 = 0; o2 < a3.length; o2 += 100) {
          let c3 = a3.slice(o2, o2 + 100), u3 = await Promise.all(c3.map(async (f3) => {
            let h3 = t4 === "." ? f3 : `${t4}/${f3}`, d3 = this.fs.resolvePath(this.cwd, h3);
            try {
              let y2 = await this.fs.stat(d3);
              return { name: f3, path: h3, isDirectory: y2.isDirectory };
            } catch {
              return null;
            }
          }));
          i4.push(...u3.filter((f3) => f3 !== null));
        }
        for (let o2 of i4) !o2.isDirectory && r2 && this.matchPattern(o2.name, r2) && s3.push(o2.path);
        let l3 = i4.filter((o2) => o2.isDirectory);
        for (let o2 = 0; o2 < l3.length; o2 += 100) {
          let c3 = l3.slice(o2, o2 + 100);
          await Promise.all(c3.map((u3) => this.walkDirectory(u3.path, r2, s3)));
        }
      }
    } catch {
    }
  }
  matchPattern(t4, r2) {
    return this.patternToRegex(r2).test(t4);
  }
  patternToRegex(t4) {
    let r2 = this.patternToRegexStr(t4);
    return new RegExp(`^${r2}$`);
  }
  patternToRegexStr(t4) {
    let r2 = "", s3 = false;
    for (let n3 = 0; n3 < t4.length; n3++) {
      if (t4.slice(n3, n3 + 13) === "\0QUOTE_START\0") {
        s3 = true, n3 += 12;
        continue;
      }
      if (t4.slice(n3, n3 + 11) === "\0QUOTE_END\0") {
        s3 = false, n3 += 10;
        continue;
      }
      let a3 = t4[n3];
      if (s3) {
        /[.+^${}()|\\*?[\]]/.test(a3) ? r2 += `\\${a3}` : r2 += a3;
        continue;
      }
      if (this.extglob && (a3 === "@" || a3 === "*" || a3 === "+" || a3 === "?" || a3 === "!") && n3 + 1 < t4.length && t4[n3 + 1] === "(") {
        let i4 = ot$3(t4, n3 + 1);
        if (i4 !== -1) {
          let l3 = t4.slice(n3 + 2, i4), o2 = lt$2(l3), c3 = o2.map((f3) => this.patternToRegexStr(f3)), u3 = c3.length > 0 ? c3.join("|") : "(?:)";
          if (a3 === "@") r2 += `(?:${u3})`;
          else if (a3 === "*") r2 += `(?:${u3})*`;
          else if (a3 === "+") r2 += `(?:${u3})+`;
          else if (a3 === "?") r2 += `(?:${u3})?`;
          else if (a3 === "!") if (i4 < t4.length - 1) {
            let h3 = o2.map((y2) => this.computePatternLength(y2));
            if (h3.every((y2) => y2 !== null) && h3.every((y2) => y2 === h3[0]) && h3[0] !== null) {
              let y2 = h3[0];
              if (y2 === 0) r2 += "(?:.+)";
              else {
                let g2 = [];
                y2 > 0 && g2.push(`.{0,${y2 - 1}}`), g2.push(`.{${y2 + 1},}`), g2.push(`(?!(?:${u3})).{${y2}}`), r2 += `(?:${g2.join("|")})`;
              }
            } else r2 += `(?:(?!(?:${u3})).)*?`;
          } else r2 += `(?!(?:${u3})$).*`;
          n3 = i4;
          continue;
        }
      }
      if (a3 === "*") r2 += ".*";
      else if (a3 === "?") r2 += ".";
      else if (a3 === "[") {
        let i4 = n3 + 1, l3 = "[";
        i4 < t4.length && (t4[i4] === "^" || t4[i4] === "!") && (l3 += "^", i4++), i4 < t4.length && t4[i4] === "]" && (l3 += "\\]", i4++);
        let o2 = i4;
        for (; o2 < t4.length; ) {
          if (t4[o2] === "\\" && o2 + 1 < t4.length) {
            o2 += 2;
            continue;
          }
          if (t4[o2] === "[" && o2 + 1 < t4.length && t4[o2 + 1] === ":") {
            let u3 = t4.indexOf(":]", o2 + 2);
            if (u3 !== -1) {
              o2 = u3 + 2;
              continue;
            }
          }
          if (t4[o2] === "]") break;
          o2++;
        }
        let c3 = i4;
        for (; i4 < t4.length && t4[i4] !== "]"; ) {
          if (t4[i4] === "[" && i4 + 1 < t4.length && t4[i4 + 1] === ":") {
            let u3 = t4.indexOf(":]", i4 + 2);
            if (u3 !== -1) {
              let f3 = t4.slice(i4 + 2, u3), h3 = at$4(f3);
              l3 += h3, i4 = u3 + 2;
              continue;
            }
          }
          if (t4[i4] === "\\" && i4 + 1 < t4.length) {
            l3 += `\\${t4[i4 + 1]}`, i4 += 2;
            continue;
          }
          if (t4[i4] === "-") {
            let u3 = i4 === c3, f3 = i4 + 1 === o2;
            u3 || f3 ? l3 += "\\-" : l3 += "-";
          } else l3 += t4[i4];
          i4++;
        }
        l3 += "]", r2 += l3, n3 = i4;
      } else if (a3 === "\\" && n3 + 1 < t4.length) {
        let i4 = t4[n3 + 1];
        /[.+^${}()|\\*?[\]]/.test(i4) ? r2 += `\\${i4}` : r2 += i4, n3++;
      } else /[.+^${}()|]/.test(a3) ? r2 += `\\${a3}` : r2 += a3;
    }
    return r2;
  }
  computePatternLength(t4) {
    let r2 = 0, s3 = 0, n3 = false;
    for (; s3 < t4.length; ) {
      if (t4.slice(s3, s3 + 13) === "\0QUOTE_START\0") {
        n3 = true, s3 += 13;
        continue;
      }
      if (t4.slice(s3, s3 + 11) === "\0QUOTE_END\0") {
        n3 = false, s3 += 11;
        continue;
      }
      let a3 = t4[s3];
      if (n3) {
        r2 += 1, s3++;
        continue;
      }
      if ((a3 === "@" || a3 === "*" || a3 === "+" || a3 === "?" || a3 === "!") && s3 + 1 < t4.length && t4[s3 + 1] === "(") {
        let i4 = ot$3(t4, s3 + 1);
        if (i4 !== -1) {
          if (a3 === "@") {
            let l3 = t4.slice(s3 + 2, i4), c3 = lt$2(l3).map((u3) => this.computePatternLength(u3));
            if (c3.every((u3) => u3 !== null) && c3.every((u3) => u3 === c3[0])) {
              r2 += c3[0], s3 = i4 + 1;
              continue;
            }
            return null;
          }
          return null;
        }
      }
      if (a3 === "*") return null;
      if (a3 === "?") {
        r2 += 1, s3++;
        continue;
      }
      if (a3 === "[") {
        let i4 = t4.indexOf("]", s3 + 1);
        if (i4 !== -1) {
          r2 += 1, s3 = i4 + 1;
          continue;
        }
        r2 += 1, s3++;
        continue;
      }
      if (a3 === "\\") {
        r2 += 1, s3 += 2;
        continue;
      }
      r2 += 1, s3++;
    }
    return r2;
  }
};
function Hr$2(e5, t4, r2) {
  switch (r2) {
    case "+":
      return e5 + t4;
    case "-":
      return e5 - t4;
    case "*":
      return e5 * t4;
    case "/":
      if (t4 === 0) throw new p$f("division by 0");
      return Math.trunc(e5 / t4);
    case "%":
      if (t4 === 0) throw new p$f("division by 0");
      return e5 % t4;
    case "**":
      if (t4 < 0) throw new p$f("exponent less than 0");
      return e5 ** t4;
    case "<<":
      return e5 << t4;
    case ">>":
      return e5 >> t4;
    case "<":
      return e5 < t4 ? 1 : 0;
    case "<=":
      return e5 <= t4 ? 1 : 0;
    case ">":
      return e5 > t4 ? 1 : 0;
    case ">=":
      return e5 >= t4 ? 1 : 0;
    case "==":
      return e5 === t4 ? 1 : 0;
    case "!=":
      return e5 !== t4 ? 1 : 0;
    case "&":
      return e5 & t4;
    case "|":
      return e5 | t4;
    case "^":
      return e5 ^ t4;
    case ",":
      return t4;
    default:
      return 0;
  }
}
function cn$1(e5, t4, r2) {
  switch (r2) {
    case "=":
      return t4;
    case "+=":
      return e5 + t4;
    case "-=":
      return e5 - t4;
    case "*=":
      return e5 * t4;
    case "/=":
      return t4 !== 0 ? Math.trunc(e5 / t4) : 0;
    case "%=":
      return t4 !== 0 ? e5 % t4 : 0;
    case "<<=":
      return e5 << t4;
    case ">>=":
      return e5 >> t4;
    case "&=":
      return e5 & t4;
    case "|=":
      return e5 | t4;
    case "^=":
      return e5 ^ t4;
    default:
      return t4;
  }
}
function Kr$1(e5, t4) {
  switch (t4) {
    case "-":
      return -e5;
    case "+":
      return +e5;
    case "!":
      return e5 === 0 ? 1 : 0;
    case "~":
      return ~e5;
    default:
      return e5;
  }
}
async function Xr$1(e5, t4) {
  let r2 = e5.state.env[t4];
  if (r2 !== void 0) return r2;
  let s3 = e5.state.env[`${t4}_0`];
  return s3 !== void 0 ? s3 : await v$b(e5, t4);
}
function Jr$1(e5) {
  if (!e5) return 0;
  let t4 = Number.parseInt(e5, 10);
  if (!Number.isNaN(t4) && /^-?\d+$/.test(e5.trim())) return t4;
  let r2 = e5.trim();
  if (!r2) return 0;
  try {
    let s3 = new T$9(), { expr: n3, pos: a3 } = F$b(s3, r2, 0);
    if (a3 < r2.length) {
      let i4 = r2.slice(a3).trim().split(/\s+/)[0];
      throw new p$f(`${r2}: syntax error in expression (error token is "${i4}")`);
    }
    return n3.type === "ArithNumber" ? n3.value : t4 || 0;
  } catch (s3) {
    if (s3 instanceof p$f) throw s3;
    let n3 = r2.split(/\s+/).slice(1)[0] || r2;
    throw new p$f(`${r2}: syntax error in expression (error token is "${n3}")`);
  }
}
async function ut$4(e5, t4) {
  if (!t4) return 0;
  let r2 = Number.parseInt(t4, 10);
  if (!Number.isNaN(r2) && /^-?\d+$/.test(t4.trim())) return r2;
  let s3 = t4.trim();
  if (!s3) return 0;
  let n3 = new T$9(), { expr: a3, pos: i4 } = F$b(n3, s3, 0);
  if (i4 < s3.length) {
    let l3 = s3.slice(i4).trim(), o2 = l3.split(/\s+/)[0] || l3;
    throw new p$f(`syntax error in expression (error token is "${o2}")`, "", "");
  }
  return await R$a(e5, a3);
}
async function ct$2(e5, t4, r2 = /* @__PURE__ */ new Set()) {
  if (r2.has(t4)) return 0;
  r2.add(t4);
  let s3 = await Xr$1(e5, t4);
  if (!s3) return 0;
  let n3 = Number.parseInt(s3, 10);
  if (!Number.isNaN(n3) && /^-?\d+$/.test(s3.trim())) return n3;
  let a3 = s3.trim();
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(a3)) return await ct$2(e5, a3, r2);
  let i4 = new T$9(), { expr: l3, pos: o2 } = F$b(i4, a3, 0);
  if (o2 < a3.length) {
    let c3 = a3.slice(o2).trim(), u3 = c3.split(/\s+/)[0] || c3;
    throw new p$f(`${a3}: syntax error in expression (error token is "${u3}")`);
  }
  return await R$a(e5, l3);
}
async function De$5(e5, t4) {
  if (t4.startsWith("#")) {
    let f3 = t4.slice(1), h3 = f3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
    if (h3) {
      let y2 = h3[1], g2 = P$g(e5, y2);
      return String(g2.length);
    }
    let d3 = e5.state.env[f3] || "";
    return String(d3.length);
  }
  if (t4.startsWith("!")) {
    let f3 = t4.slice(1), h3 = e5.state.env[f3] || "";
    return e5.state.env[h3] || "";
  }
  let r2 = [":-", ":=", ":?", ":+", "-", "=", "?", "+"], s3 = -1, n3 = "";
  for (let f3 of r2) {
    let h3 = t4.indexOf(f3);
    h3 > 0 && (s3 === -1 || h3 < s3) && (s3 = h3, n3 = f3);
  }
  if (s3 === -1) return await v$b(e5, t4);
  let a3 = t4.slice(0, s3), i4 = t4.slice(s3 + n3.length), l3 = e5.state.env[a3], o2 = l3 === void 0, c3 = l3 === "", u3 = n3.startsWith(":");
  switch (n3) {
    case ":-":
    case "-":
      return o2 || u3 && c3 ? i4 : l3 || "";
    case ":=":
    case "=":
      return o2 || u3 && c3 ? (e5.state.env[a3] = i4, i4) : l3 || "";
    case ":+":
    case "+":
      return !(o2 || u3 && c3) ? i4 : "";
    case ":?":
    case "?": {
      if (o2 || u3 && c3) throw new Error(i4 || `${a3}: parameter null or not set`);
      return l3 || "";
    }
    default:
      return l3 || "";
  }
}
async function R$a(e5, t4, r2 = false) {
  switch (t4.type) {
    case "ArithNumber":
      if (Number.isNaN(t4.value)) throw new p$f("value too great for base");
      return t4.value;
    case "ArithVariable":
      return await ct$2(e5, t4.name);
    case "ArithSpecialVar": {
      let n3 = (await v$b(e5, t4.name)).trim();
      if (!n3) return 0;
      let a3 = Number.parseInt(n3, 10);
      if (!Number.isNaN(a3) && /^-?\d+$/.test(n3)) return a3;
      let i4 = new T$9(), { expr: l3 } = F$b(i4, n3, 0);
      return await R$a(e5, l3);
    }
    case "ArithNested":
      return await R$a(e5, t4.expression);
    case "ArithCommandSubst": {
      if (e5.execFn) {
        let s3 = await e5.execFn(t4.command);
        s3.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + s3.stderr);
        let n3 = s3.stdout.trim();
        return Number.parseInt(n3, 10) || 0;
      }
      return 0;
    }
    case "ArithBracedExpansion": {
      let s3 = await De$5(e5, t4.content);
      return Number.parseInt(s3, 10) || 0;
    }
    case "ArithDynamicBase": {
      let s3 = await De$5(e5, t4.baseExpr), n3 = Number.parseInt(s3, 10);
      if (n3 < 2 || n3 > 64) return 0;
      let a3 = `${n3}#${t4.value}`;
      return fe$6(a3);
    }
    case "ArithDynamicNumber": {
      let n3 = await De$5(e5, t4.prefix) + t4.suffix;
      return fe$6(n3);
    }
    case "ArithArrayElement": {
      let s3 = e5.state.associativeArrays?.has(t4.array), n3 = async (a3) => {
        let i4 = e5.state.env[a3];
        return i4 !== void 0 ? await ut$4(e5, i4) : 0;
      };
      if (t4.stringKey !== void 0) return await n3(`${t4.array}_${t4.stringKey}`);
      if (s3 && t4.index?.type === "ArithVariable" && !t4.index.hasDollarPrefix) return await n3(`${t4.array}_${t4.index.name}`);
      if (s3 && t4.index?.type === "ArithVariable" && t4.index.hasDollarPrefix) {
        let a3 = await v$b(e5, t4.index.name);
        return await n3(`${t4.array}_${a3}`);
      }
      if (t4.index) {
        let a3 = await R$a(e5, t4.index, r2);
        if (a3 < 0) {
          let o2 = P$g(e5, t4.array), c3 = e5.state.currentLine;
          if (o2.length === 0) return e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${c3}: ${t4.array}: bad array subscript
`, 0;
          let f3 = Math.max(...o2.map(([h3]) => typeof h3 == "number" ? h3 : 0)) + 1 + a3;
          if (f3 < 0) return e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${c3}: ${t4.array}: bad array subscript
`, 0;
          a3 = f3;
        }
        let i4 = `${t4.array}_${a3}`, l3 = e5.state.env[i4];
        if (l3 !== void 0) return ut$4(e5, l3);
        if (a3 === 0) {
          let o2 = e5.state.env[t4.array];
          if (o2 !== void 0) return ut$4(e5, o2);
        }
        if (e5.state.options.nounset && !Object.keys(e5.state.env).some((c3) => c3 === t4.array || c3.startsWith(`${t4.array}_`))) throw new x$h(`${t4.array}[${a3}]`);
        return 0;
      }
      return 0;
    }
    case "ArithDoubleSubscript":
      throw new p$f("double subscript", "", "");
    case "ArithNumberSubscript":
      throw new p$f(`${t4.number}${t4.errorToken}: syntax error: invalid arithmetic operator (error token is "${t4.errorToken}")`);
    case "ArithSyntaxError":
      throw new p$f(t4.message, "", "", true);
    case "ArithSingleQuote": {
      if (r2) throw new p$f(`syntax error: operand expected (error token is "'${t4.content}'")`);
      return t4.value;
    }
    case "ArithBinary": {
      if (t4.operator === "||") return await R$a(e5, t4.left, r2) || await R$a(e5, t4.right, r2) ? 1 : 0;
      if (t4.operator === "&&") return await R$a(e5, t4.left, r2) && await R$a(e5, t4.right, r2) ? 1 : 0;
      let s3 = await R$a(e5, t4.left, r2), n3 = await R$a(e5, t4.right, r2);
      return Hr$2(s3, n3, t4.operator);
    }
    case "ArithUnary": {
      let s3 = await R$a(e5, t4.operand, r2);
      if (t4.operator === "++" || t4.operator === "--") {
        if (t4.operand.type === "ArithVariable") {
          let n3 = t4.operand.name, a3 = Number.parseInt(await v$b(e5, n3), 10) || 0, i4 = t4.operator === "++" ? a3 + 1 : a3 - 1;
          return e5.state.env[n3] = String(i4), t4.prefix ? i4 : a3;
        }
        if (t4.operand.type === "ArithArrayElement") {
          let n3 = t4.operand.array, a3 = e5.state.associativeArrays?.has(n3), i4;
          if (t4.operand.stringKey !== void 0) i4 = `${n3}_${t4.operand.stringKey}`;
          else if (a3 && t4.operand.index?.type === "ArithVariable" && !t4.operand.index.hasDollarPrefix) i4 = `${n3}_${t4.operand.index.name}`;
          else if (a3 && t4.operand.index?.type === "ArithVariable" && t4.operand.index.hasDollarPrefix) {
            let c3 = await v$b(e5, t4.operand.index.name);
            i4 = `${n3}_${c3}`;
          } else if (t4.operand.index) {
            let c3 = await R$a(e5, t4.operand.index, r2);
            i4 = `${n3}_${c3}`;
          } else return s3;
          let l3 = Number.parseInt(e5.state.env[i4] || "0", 10) || 0, o2 = t4.operator === "++" ? l3 + 1 : l3 - 1;
          return e5.state.env[i4] = String(o2), t4.prefix ? o2 : l3;
        }
        if (t4.operand.type === "ArithConcat") {
          let n3 = "";
          for (let a3 of t4.operand.parts) n3 += await ue$7(e5, a3, r2);
          if (n3 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n3)) {
            let a3 = Number.parseInt(e5.state.env[n3] || "0", 10) || 0, i4 = t4.operator === "++" ? a3 + 1 : a3 - 1;
            return e5.state.env[n3] = String(i4), t4.prefix ? i4 : a3;
          }
        }
        if (t4.operand.type === "ArithDynamicElement") {
          let n3 = "";
          if (t4.operand.nameExpr.type === "ArithConcat") for (let a3 of t4.operand.nameExpr.parts) n3 += await ue$7(e5, a3, r2);
          else t4.operand.nameExpr.type === "ArithVariable" && (n3 = t4.operand.nameExpr.hasDollarPrefix ? await v$b(e5, t4.operand.nameExpr.name) : t4.operand.nameExpr.name);
          if (n3 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n3)) {
            let a3 = await R$a(e5, t4.operand.subscript, r2), i4 = `${n3}_${a3}`, l3 = Number.parseInt(e5.state.env[i4] || "0", 10) || 0, o2 = t4.operator === "++" ? l3 + 1 : l3 - 1;
            return e5.state.env[i4] = String(o2), t4.prefix ? o2 : l3;
          }
        }
        return s3;
      }
      return Kr$1(s3, t4.operator);
    }
    case "ArithTernary":
      return await R$a(e5, t4.condition, r2) ? await R$a(e5, t4.consequent, r2) : await R$a(e5, t4.alternate, r2);
    case "ArithAssignment": {
      let s3 = t4.variable, n3 = s3;
      if (t4.stringKey !== void 0) n3 = `${s3}_${t4.stringKey}`;
      else if (t4.subscript) {
        let o2 = e5.state.associativeArrays?.has(s3);
        if (o2 && t4.subscript.type === "ArithVariable" && !t4.subscript.hasDollarPrefix) n3 = `${s3}_${t4.subscript.name}`;
        else if (o2 && t4.subscript.type === "ArithVariable" && t4.subscript.hasDollarPrefix) {
          let c3 = await v$b(e5, t4.subscript.name);
          n3 = `${s3}_${c3 || "\\"}`;
        } else if (o2) {
          let c3 = await R$a(e5, t4.subscript, r2);
          n3 = `${s3}_${c3}`;
        } else {
          let c3 = await R$a(e5, t4.subscript, r2);
          if (c3 < 0) {
            let u3 = P$g(e5, s3);
            u3.length > 0 && (c3 = Math.max(...u3.map(([h3]) => typeof h3 == "number" ? h3 : 0)) + 1 + c3);
          }
          n3 = `${s3}_${c3}`;
        }
      }
      let a3 = Number.parseInt(e5.state.env[n3] || "0", 10) || 0, i4 = await R$a(e5, t4.value, r2), l3 = cn$1(a3, i4, t4.operator);
      return e5.state.env[n3] = String(l3), l3;
    }
    case "ArithGroup":
      return await R$a(e5, t4.expression, r2);
    case "ArithConcat": {
      let s3 = "";
      for (let n3 of t4.parts) s3 += await ue$7(e5, n3, r2);
      return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s3) ? await ct$2(e5, s3) : Number.parseInt(s3, 10) || 0;
    }
    case "ArithDynamicAssignment": {
      let s3 = "";
      if (t4.target.type === "ArithConcat") for (let o2 of t4.target.parts) s3 += await ue$7(e5, o2, r2);
      else t4.target.type === "ArithVariable" && (s3 = t4.target.hasDollarPrefix ? await v$b(e5, t4.target.name) : t4.target.name);
      if (!s3 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s3)) return 0;
      let n3 = s3;
      if (t4.subscript) {
        let o2 = await R$a(e5, t4.subscript, r2);
        n3 = `${s3}_${o2}`;
      }
      let a3 = Number.parseInt(e5.state.env[n3] || "0", 10) || 0, i4 = await R$a(e5, t4.value, r2), l3 = cn$1(a3, i4, t4.operator);
      return e5.state.env[n3] = String(l3), l3;
    }
    case "ArithDynamicElement": {
      let s3 = "";
      if (t4.nameExpr.type === "ArithConcat") for (let l3 of t4.nameExpr.parts) s3 += await ue$7(e5, l3, r2);
      else t4.nameExpr.type === "ArithVariable" && (s3 = t4.nameExpr.hasDollarPrefix ? await v$b(e5, t4.nameExpr.name) : t4.nameExpr.name);
      if (!s3 || !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s3)) return 0;
      let n3 = await R$a(e5, t4.subscript, r2), a3 = `${s3}_${n3}`, i4 = e5.state.env[a3];
      return i4 !== void 0 ? Jr$1(i4) : 0;
    }
    default:
      return 0;
  }
}
async function ue$7(e5, t4, r2 = false) {
  switch (t4.type) {
    case "ArithNumber":
      return String(t4.value);
    case "ArithSingleQuote":
      return String(await R$a(e5, t4, r2));
    case "ArithVariable":
      return t4.hasDollarPrefix ? await v$b(e5, t4.name) : t4.name;
    case "ArithSpecialVar":
      return await v$b(e5, t4.name);
    case "ArithBracedExpansion":
      return await De$5(e5, t4.content);
    case "ArithCommandSubst":
      return e5.execFn ? (await e5.execFn(t4.command)).stdout.trim() : "0";
    case "ArithConcat": {
      let s3 = "";
      for (let n3 of t4.parts) s3 += await ue$7(e5, n3, r2);
      return s3;
    }
    default:
      return String(await R$a(e5, t4, r2));
  }
}
function ft$3(e5) {
  for (let t4 = 0; t4 < e5.length; t4++) {
    if (e5[t4] === "\\") {
      t4++;
      continue;
    }
    if (e5[t4] === "$") {
      let r2 = e5[t4 + 1];
      if (r2 === "{" || r2 && /[a-zA-Z_]/.test(r2)) return true;
    }
  }
  return false;
}
function Yr$1(e5) {
  if (!e5.operation) return false;
  let t4 = e5.operation, r2;
  if ((t4.type === "DefaultValue" || t4.type === "AssignDefault" || t4.type === "UseAlternative" || t4.type === "ErrorIfUnset") && (r2 = t4.word?.parts), !r2) return false;
  for (let s3 of r2) if (s3.type === "DoubleQuoted" || s3.type === "SingleQuoted") return true;
  return false;
}
function fn$3(e5) {
  if (!e5.operation) return false;
  let t4 = e5.operation, r2;
  if ((t4.type === "DefaultValue" || t4.type === "AssignDefault" || t4.type === "UseAlternative" || t4.type === "ErrorIfUnset") && (r2 = t4.word?.parts), !r2 || r2.length === 0) return false;
  for (let s3 of r2) if (s3.type !== "DoubleQuoted" && s3.type !== "SingleQuoted") return false;
  return true;
}
function de$5(e5) {
  let t4 = false, r2 = false, s3 = false, n3 = false, a3 = false, i4 = false, l3 = false;
  for (let o2 of e5) {
    if ((o2.type === "SingleQuoted" || o2.type === "DoubleQuoted") && (t4 = true, o2.type === "DoubleQuoted")) for (let c3 of o2.parts) c3.type === "ParameterExpansion" && (c3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/) && (!c3.operation || c3.operation.type === "PatternRemoval" || c3.operation.type === "PatternReplacement") && (n3 = true), (c3.operation?.type === "VarNamePrefix" || c3.operation?.type === "ArrayKeys") && (i4 = true), c3.operation?.type === "Indirection" && (l3 = true));
    o2.type === "CommandSubstitution" && (r2 = true), o2.type === "ParameterExpansion" && (a3 = true, (o2.parameter === "@" || o2.parameter === "*") && (s3 = true), Yr$1(o2) && (t4 = true), (o2.operation?.type === "VarNamePrefix" || o2.operation?.type === "ArrayKeys") && (i4 = true), o2.operation?.type === "Indirection" && (l3 = true)), o2.type === "Glob" && ft$3(o2.pattern) && (a3 = true);
  }
  return { hasQuoted: t4, hasCommandSub: r2, hasArrayVar: s3, hasArrayAtExpansion: n3, hasParamExpansion: a3, hasVarNamePrefixExpansion: i4, hasIndirection: l3 };
}
var pn$2 = "5.1.0(1)-release", Ni$2 = "Linux version 5.15.0-generic (just-bash) #1 SMP PREEMPT";
function me$4() {
  return { pid: process.pid, ppid: process.ppid, uid: process.getuid?.() ?? 1e3, gid: process.getgid?.() ?? 1e3 };
}
function ki$2() {
  let { pid: e5, ppid: t4, uid: r2, gid: s3 } = me$4();
  return `Name:	bash
State:	R (running)
Pid:	${e5}
PPid:	${t4}
Uid:	${r2}	${r2}	${r2}	${r2}
Gid:	${s3}	${s3}	${s3}	${s3}
`;
}
function pt$2(e5, t4) {
  let r2 = `${t4}_`, s3 = [];
  for (let n3 of Object.keys(e5.state.env)) if (n3.startsWith(r2)) {
    let a3 = n3.slice(r2.length), i4 = Number.parseInt(a3, 10);
    !Number.isNaN(i4) && String(i4) === a3 && s3.push(i4);
  }
  return s3.sort((n3, a3) => n3 - a3);
}
function Ri$1(e5, t4) {
  let r2 = `${t4}_`;
  for (let s3 of Object.keys(e5.state.env)) s3.startsWith(r2) && delete e5.state.env[s3];
}
function ht$4(e5, t4) {
  let r2 = `${t4}_`, s3 = `${t4}__length`, n3 = [];
  for (let a3 of Object.keys(e5.state.env)) if (a3 !== s3 && a3.startsWith(r2)) {
    let i4 = a3.slice(r2.length);
    if (i4.startsWith("_length")) continue;
    n3.push(i4);
  }
  return n3.sort();
}
function xe$9(e5) {
  return e5.startsWith("'") && e5.endsWith("'") || e5.startsWith('"') && e5.endsWith('"') ? e5.slice(1, -1) : e5;
}
function Ii$2(e5) {
  if (e5.parts.length < 2) return null;
  let t4 = e5.parts[0], r2 = e5.parts[1];
  if (t4.type !== "Glob" || !t4.pattern.startsWith("[")) return null;
  let s3, n3 = r2, a3 = 1;
  if (r2.type === "Literal" && r2.value.startsWith("]")) {
    let f3 = r2.value.slice(1);
    if (f3.startsWith("+=") || f3.startsWith("=")) s3 = t4.pattern.slice(1);
    else if (f3 === "") {
      if (e5.parts.length < 3) return null;
      let h3 = e5.parts[2];
      if (h3.type !== "Literal" || !h3.value.startsWith("=") && !h3.value.startsWith("+=")) return null;
      s3 = t4.pattern.slice(1), n3 = h3, a3 = 2;
    } else return null;
  } else if (t4.pattern === "[" && (r2.type === "DoubleQuoted" || r2.type === "SingleQuoted")) {
    if (e5.parts.length < 3) return null;
    let f3 = e5.parts[2];
    if (f3.type !== "Literal" || !f3.value.startsWith("]=") && !f3.value.startsWith("]+=")) return null;
    if (r2.type === "SingleQuoted") s3 = r2.value;
    else {
      s3 = "";
      for (let h3 of r2.parts) (h3.type === "Literal" || h3.type === "Escaped") && (s3 += h3.value);
    }
    n3 = f3, a3 = 2;
  } else if (t4.pattern.endsWith("]")) {
    if (r2.type !== "Literal" || !r2.value.startsWith("=") && !r2.value.startsWith("+=")) return null;
    s3 = t4.pattern.slice(1, -1);
  } else return null;
  s3 = xe$9(s3);
  let i4;
  if (n3.type !== "Literal") return null;
  n3.value.startsWith("]=") || n3.value.startsWith("]+=") ? i4 = n3.value.slice(1) : i4 = n3.value;
  let l3 = i4.startsWith("+=");
  if (!l3 && !i4.startsWith("=")) return null;
  let o2 = [], c3 = l3 ? 2 : 1, u3 = i4.slice(c3);
  u3 && o2.push({ type: "Literal", value: u3 });
  for (let f3 = a3 + 1; f3 < e5.parts.length; f3++) {
    let h3 = e5.parts[f3];
    h3.type === "BraceExpansion" ? o2.push({ type: "Literal", value: es$1(h3) }) : o2.push(h3);
  }
  return { key: s3, valueParts: o2, append: l3 };
}
function es$1(e5) {
  return `{${e5.items.map((r2) => {
    if (r2.type === "Range") {
      let s3 = r2.startStr ?? String(r2.start), n3 = r2.endStr ?? String(r2.end), a3 = `${s3}..${n3}`;
      return r2.step && (a3 += `..${r2.step}`), a3;
    }
    return hn$1(r2.word);
  }).join(",")}}`;
}
function hn$1(e5) {
  let t4 = "";
  for (let r2 of e5.parts) switch (r2.type) {
    case "Literal":
      t4 += r2.value;
      break;
    case "Glob":
      t4 += r2.pattern;
      break;
    case "SingleQuoted":
      t4 += r2.value;
      break;
    case "DoubleQuoted":
      for (let s3 of r2.parts) (s3.type === "Literal" || s3.type === "Escaped") && (t4 += s3.value);
      break;
    case "Escaped":
      t4 += r2.value;
      break;
    case "BraceExpansion":
      t4 += "{", t4 += r2.items.map((s3) => s3.type === "Range" ? `${s3.startStr}..${s3.endStr}${s3.step ? `..${s3.step}` : ""}` : hn$1(s3.word)).join(","), t4 += "}";
      break;
    case "TildeExpansion":
      t4 += "~", r2.user && (t4 += r2.user);
      break;
  }
  return t4;
}
function O$e(e5) {
  return e5.IFS ?? ` 	
`;
}
function M$c(e5) {
  return e5.IFS === "";
}
function $e$5(e5) {
  let t4 = O$e(e5);
  if (t4 === "") return true;
  for (let r2 of t4) if (r2 !== " " && r2 !== "	" && r2 !== `
`) return false;
  return true;
}
function dn$2(e5) {
  return e5.split("").map((t4) => /[\\^$.*+?()[\]{}|-]/.test(t4) ? `\\${t4}` : t4 === "	" ? "\\t" : t4 === `
` ? "\\n" : t4).join("");
}
function N$b(e5) {
  let t4 = e5.IFS;
  return t4 === void 0 ? " " : t4[0] || "";
}
var ts$1 = ` 	
`;
function ns$1(e5) {
  return ts$1.includes(e5);
}
function dt$4(e5) {
  let t4 = /* @__PURE__ */ new Set(), r2 = /* @__PURE__ */ new Set();
  for (let s3 of e5) ns$1(s3) ? t4.add(s3) : r2.add(s3);
  return { whitespace: t4, nonWhitespace: r2 };
}
function Di$1(e5, t4, r2, s3) {
  if (t4 === "") return e5 === "" ? { words: [], wordStarts: [] } : { words: [e5], wordStarts: [0] };
  let { whitespace: n3, nonWhitespace: a3 } = dt$4(t4), i4 = [], l3 = [], o2 = 0;
  for (; o2 < e5.length && n3.has(e5[o2]); ) o2++;
  if (o2 >= e5.length) return { words: [], wordStarts: [] };
  if (a3.has(e5[o2])) for (i4.push(""), l3.push(o2), o2++; o2 < e5.length && n3.has(e5[o2]); ) o2++;
  for (; o2 < e5.length && !(r2 !== void 0 && i4.length >= r2); ) {
    let c3 = o2;
    for (l3.push(c3); o2 < e5.length; ) {
      let u3 = e5[o2];
      if (!s3 && u3 === "\\") {
        o2++, o2 < e5.length && o2++;
        continue;
      }
      if (n3.has(u3) || a3.has(u3)) break;
      o2++;
    }
    if (i4.push(e5.substring(c3, o2)), o2 >= e5.length) break;
    for (; o2 < e5.length && n3.has(e5[o2]); ) o2++;
    if (o2 < e5.length && a3.has(e5[o2])) {
      for (o2++; o2 < e5.length && n3.has(e5[o2]); ) o2++;
      for (; o2 < e5.length && a3.has(e5[o2]) && !(r2 !== void 0 && i4.length >= r2); ) for (i4.push(""), l3.push(o2), o2++; o2 < e5.length && n3.has(e5[o2]); ) o2++;
    }
  }
  return { words: i4, wordStarts: l3 };
}
function _e$5(e5, t4) {
  if (t4 === "") return { words: e5 ? [e5] : [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  if (e5 === "") return { words: [], hadLeadingDelimiter: false, hadTrailingDelimiter: false };
  let { whitespace: r2, nonWhitespace: s3 } = dt$4(t4), n3 = [], a3 = 0, i4 = false, l3 = false, o2 = a3;
  for (; a3 < e5.length && r2.has(e5[a3]); ) a3++;
  if (a3 > o2 && (i4 = true), a3 >= e5.length) return { words: [], hadLeadingDelimiter: true, hadTrailingDelimiter: true };
  if (s3.has(e5[a3])) for (n3.push(""), a3++; a3 < e5.length && r2.has(e5[a3]); ) a3++;
  for (; a3 < e5.length; ) {
    let c3 = a3;
    for (; a3 < e5.length; ) {
      let f3 = e5[a3];
      if (r2.has(f3) || s3.has(f3)) break;
      a3++;
    }
    if (n3.push(e5.substring(c3, a3)), a3 >= e5.length) {
      l3 = false;
      break;
    }
    let u3 = a3;
    for (; a3 < e5.length && r2.has(e5[a3]); ) a3++;
    if (a3 < e5.length && s3.has(e5[a3])) {
      for (a3++; a3 < e5.length && r2.has(e5[a3]); ) a3++;
      for (; a3 < e5.length && s3.has(e5[a3]); ) for (n3.push(""), a3++; a3 < e5.length && r2.has(e5[a3]); ) a3++;
    }
    a3 >= e5.length && a3 > u3 && (l3 = true);
  }
  return { words: n3, hadLeadingDelimiter: i4, hadTrailingDelimiter: l3 };
}
function D$e(e5, t4) {
  return _e$5(e5, t4).words;
}
function rs$2(e5, t4) {
  for (let r2 of e5) if (t4.has(r2)) return true;
  return false;
}
function xi$2(e5, t4, r2) {
  if (t4 === "") return e5;
  let { whitespace: s3, nonWhitespace: n3 } = dt$4(t4), a3 = e5.length;
  for (; a3 > 0 && s3.has(e5[a3 - 1]); ) {
    if (!r2 && a3 >= 2) {
      let l3 = 0, o2 = a3 - 2;
      for (; o2 >= 0 && e5[o2] === "\\"; ) l3++, o2--;
      if (l3 % 2 === 1) break;
    }
    a3--;
  }
  let i4 = e5.substring(0, a3);
  if (i4.length >= 1 && n3.has(i4[i4.length - 1])) {
    if (!r2 && i4.length >= 2) {
      let o2 = 0, c3 = i4.length - 2;
      for (; c3 >= 0 && i4[c3] === "\\"; ) o2++, c3--;
      if (o2 % 2 === 1) return i4;
    }
    let l3 = i4.substring(0, i4.length - 1);
    if (!rs$2(l3, n3)) return l3;
  }
  return i4;
}
function C$g(e5, t4) {
  return e5.state.namerefs?.has(t4) ?? false;
}
function _i$2(e5, t4) {
  e5.state.namerefs ??= /* @__PURE__ */ new Set(), e5.state.namerefs.add(t4);
}
function Ci$2(e5, t4) {
  e5.state.namerefs?.delete(t4), e5.state.boundNamerefs?.delete(t4), e5.state.invalidNamerefs?.delete(t4);
}
function Oi$1(e5, t4) {
  e5.state.invalidNamerefs ??= /* @__PURE__ */ new Set(), e5.state.invalidNamerefs.add(t4);
}
function mn$1(e5, t4) {
  return e5.state.invalidNamerefs?.has(t4) ?? false;
}
function Li$2(e5, t4) {
  e5.state.boundNamerefs ??= /* @__PURE__ */ new Set(), e5.state.boundNamerefs.add(t4);
}
function ss$1(e5, t4) {
  let r2 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (r2) {
    let n3 = r2[1], a3 = Object.keys(e5.state.env).some((l3) => l3.startsWith(`${n3}_`) && !l3.includes("__")), i4 = e5.state.associativeArrays?.has(n3) ?? false;
    return a3 || i4;
  }
  return Object.keys(e5.state.env).some((n3) => n3.startsWith(`${t4}_`) && !n3.includes("__")) ? true : e5.state.env[t4] !== void 0;
}
function le$8(e5, t4, r2 = 100) {
  if (!C$g(e5, t4) || mn$1(e5, t4)) return t4;
  let s3 = /* @__PURE__ */ new Set(), n3 = t4;
  for (; r2-- > 0; ) {
    if (s3.has(n3)) return;
    if (s3.add(n3), !C$g(e5, n3)) return n3;
    let a3 = e5.state.env[n3];
    if (a3 === void 0 || a3 === "" || !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(a3)) return n3;
    n3 = a3;
  }
}
function ge$5(e5, t4) {
  if (C$g(e5, t4)) return e5.state.env[t4];
}
function Wi$2(e5, t4, r2, s3 = 100) {
  if (!C$g(e5, t4) || mn$1(e5, t4)) return t4;
  let n3 = /* @__PURE__ */ new Set(), a3 = t4;
  for (; s3-- > 0; ) {
    if (n3.has(a3)) return;
    if (n3.add(a3), !C$g(e5, a3)) return a3;
    let i4 = e5.state.env[a3];
    if (i4 === void 0 || i4 === "") return r2 !== void 0 ? /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2) && ss$1(e5, r2) ? a3 : null : a3;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(i4)) return a3;
    a3 = i4;
  }
}
function is$1(e5, t4) {
  let r2 = t4.replace(/\$\{([a-zA-Z_][a-zA-Z0-9_]*)\}/g, (s3, n3) => e5.state.env[n3] ?? "");
  return r2 = r2.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (s3, n3) => e5.state.env[n3] ?? ""), r2;
}
function P$g(e5, t4) {
  return t4 === "FUNCNAME" ? (e5.state.funcNameStack ?? []).map((a3, i4) => [i4, a3]) : t4 === "BASH_LINENO" ? (e5.state.callLineStack ?? []).map((a3, i4) => [i4, String(a3)]) : t4 === "BASH_SOURCE" ? (e5.state.sourceStack ?? []).map((a3, i4) => [i4, a3]) : e5.state.associativeArrays?.has(t4) ? ht$4(e5, t4).map((a3) => [a3, e5.state.env[`${t4}_${a3}`]]) : pt$2(e5, t4).map((n3) => [n3, e5.state.env[`${t4}_${n3}`]]);
}
function ye$5(e5, t4) {
  return t4 === "FUNCNAME" ? (e5.state.funcNameStack?.length ?? 0) > 0 : t4 === "BASH_LINENO" ? (e5.state.callLineStack?.length ?? 0) > 0 : t4 === "BASH_SOURCE" ? (e5.state.sourceStack?.length ?? 0) > 0 : e5.state.associativeArrays?.has(t4) ? ht$4(e5, t4).length > 0 : pt$2(e5, t4).length > 0;
}
async function v$b(e5, t4, r2 = true, s3 = false) {
  switch (t4) {
    case "?":
      return String(e5.state.lastExitCode);
    case "$":
      return String(process.pid);
    case "#":
      return e5.state.env["#"] || "0";
    case "@":
      return e5.state.env["@"] || "";
    case "_":
      return e5.state.lastArg;
    case "-": {
      let i4 = "";
      return i4 += "h", e5.state.options.errexit && (i4 += "e"), e5.state.options.noglob && (i4 += "f"), e5.state.options.nounset && (i4 += "u"), e5.state.options.verbose && (i4 += "v"), e5.state.options.xtrace && (i4 += "x"), i4 += "B", e5.state.options.noclobber && (i4 += "C"), i4 += "s", i4;
    }
    case "*": {
      let i4 = Number.parseInt(e5.state.env["#"] || "0", 10);
      if (i4 === 0) return "";
      let l3 = [];
      for (let o2 = 1; o2 <= i4; o2++) l3.push(e5.state.env[String(o2)] || "");
      return l3.join(N$b(e5.state.env));
    }
    case "0":
      return e5.state.env[0] || "bash";
    case "PWD":
      return e5.state.env.PWD !== void 0 ? e5.state.env.PWD : "";
    case "OLDPWD":
      return e5.state.env.OLDPWD !== void 0 ? e5.state.env.OLDPWD : "";
    case "PPID": {
      let { ppid: i4 } = me$4();
      return String(i4);
    }
    case "UID": {
      let { uid: i4 } = me$4();
      return String(i4);
    }
    case "EUID":
      return String(process.geteuid?.() ?? me$4().uid);
    case "RANDOM":
      return String(Math.floor(Math.random() * 32768));
    case "SECONDS":
      return String(Math.floor((Date.now() - e5.state.startTime) / 1e3));
    case "BASH_VERSION":
      return pn$2;
    case "!":
      return String(e5.state.lastBackgroundPid);
    case "BASHPID":
      return String(e5.state.bashPid);
    case "LINENO":
      return String(e5.state.currentLine);
    case "FUNCNAME": {
      let i4 = e5.state.funcNameStack?.[0];
      if (i4 !== void 0) return i4;
      if (r2 && e5.state.options.nounset) throw new x$h("FUNCNAME");
      return "";
    }
    case "BASH_LINENO": {
      let i4 = e5.state.callLineStack?.[0];
      if (i4 !== void 0) return String(i4);
      if (r2 && e5.state.options.nounset) throw new x$h("BASH_LINENO");
      return "";
    }
    case "BASH_SOURCE": {
      let i4 = e5.state.sourceStack?.[0];
      if (i4 !== void 0) return i4;
      if (r2 && e5.state.options.nounset) throw new x$h("BASH_SOURCE");
      return "";
    }
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*\[\]$/.test(t4)) throw new h$f(`\${${t4}}`);
  let n3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (n3) {
    let i4 = n3[1], l3 = n3[2];
    if (C$g(e5, i4)) {
      let f3 = le$8(e5, i4);
      if (f3 && f3 !== i4) {
        if (f3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return "";
        i4 = f3;
      }
    }
    if (l3 === "@" || l3 === "*") {
      let f3 = P$g(e5, i4);
      if (f3.length > 0) return f3.map(([, d3]) => d3).join(" ");
      let h3 = e5.state.env[i4];
      return h3 !== void 0 ? h3 : "";
    }
    if (i4 === "FUNCNAME") {
      let f3 = Number.parseInt(l3, 10);
      return !Number.isNaN(f3) && f3 >= 0 ? e5.state.funcNameStack?.[f3] ?? "" : "";
    }
    if (i4 === "BASH_LINENO") {
      let f3 = Number.parseInt(l3, 10);
      if (!Number.isNaN(f3) && f3 >= 0) {
        let h3 = e5.state.callLineStack?.[f3];
        return h3 !== void 0 ? String(h3) : "";
      }
      return "";
    }
    if (i4 === "BASH_SOURCE") {
      let f3 = Number.parseInt(l3, 10);
      return !Number.isNaN(f3) && f3 >= 0 ? e5.state.sourceStack?.[f3] ?? "" : "";
    }
    if (e5.state.associativeArrays?.has(i4)) {
      let f3 = xe$9(l3);
      f3 = is$1(e5, f3);
      let h3 = e5.state.env[`${i4}_${f3}`];
      if (h3 === void 0 && r2 && e5.state.options.nounset) throw new x$h(`${i4}[${l3}]`);
      return h3 || "";
    }
    let c3;
    if (/^-?\d+$/.test(l3)) c3 = Number.parseInt(l3, 10);
    else try {
      let f3 = new T$9(), h3 = W$d(f3, l3);
      c3 = await R$a(e5, h3.expression);
    } catch {
      let f3 = e5.state.env[l3];
      c3 = f3 ? Number.parseInt(f3, 10) : 0, Number.isNaN(c3) && (c3 = 0);
    }
    if (c3 < 0) {
      let f3 = P$g(e5, i4), h3 = e5.state.currentLine;
      if (f3.length === 0) return e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${h3}: ${i4}: bad array subscript
`, "";
      let y2 = Math.max(...f3.map(([E2]) => typeof E2 == "number" ? E2 : 0)) + 1 + c3;
      return y2 < 0 ? (e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${h3}: ${i4}: bad array subscript
`, "") : e5.state.env[`${i4}_${y2}`] || "";
    }
    let u3 = e5.state.env[`${i4}_${c3}`];
    if (u3 !== void 0) return u3;
    if (c3 === 0) {
      let f3 = e5.state.env[i4];
      if (f3 !== void 0) return f3;
    }
    if (r2 && e5.state.options.nounset) throw new x$h(`${i4}[${c3}]`);
    return "";
  }
  if (/^[1-9][0-9]*$/.test(t4)) {
    let i4 = e5.state.env[t4];
    if (i4 === void 0 && r2 && e5.state.options.nounset) throw new x$h(t4);
    return i4 || "";
  }
  if (C$g(e5, t4)) {
    let i4 = le$8(e5, t4);
    if (i4 === void 0) return "";
    if (i4 !== t4) return await v$b(e5, i4, r2, s3);
    let l3 = e5.state.env[t4];
    if ((l3 === void 0 || l3 === "") && r2 && e5.state.options.nounset) throw new x$h(t4);
    return l3 || "";
  }
  let a3 = e5.state.env[t4];
  if (a3 !== void 0) return e5.state.tempEnvBindings?.some((i4) => i4.has(t4)) && (e5.state.accessedTempEnvVars = e5.state.accessedTempEnvVars || /* @__PURE__ */ new Set(), e5.state.accessedTempEnvVars.add(t4)), a3;
  if (ye$5(e5, t4)) {
    let i4 = e5.state.env[`${t4}_0`];
    return i4 !== void 0 ? i4 : "";
  }
  if (r2 && e5.state.options.nounset) throw new x$h(t4);
  return "";
}
async function Y$a(e5, t4) {
  if ((/* @__PURE__ */ new Set(["?", "$", "#", "_", "-", "0", "PPID", "UID", "EUID", "RANDOM", "SECONDS", "BASH_VERSION", "!", "BASHPID", "LINENO"])).has(t4)) return true;
  if (t4 === "@" || t4 === "*") return Number.parseInt(e5.state.env["#"] || "0", 10) > 0;
  if (t4 === "PWD" || t4 === "OLDPWD") return t4 in e5.state.env;
  let s3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (s3) {
    let n3 = s3[1], a3 = s3[2];
    if (C$g(e5, n3)) {
      let o2 = le$8(e5, n3);
      if (o2 && o2 !== n3) {
        if (o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/)) return false;
        n3 = o2;
      }
    }
    if (a3 === "@" || a3 === "*") return P$g(e5, n3).length > 0 ? true : n3 in e5.state.env;
    if (e5.state.associativeArrays?.has(n3)) {
      let o2 = xe$9(a3);
      return `${n3}_${o2}` in e5.state.env;
    }
    let l3;
    if (/^-?\d+$/.test(a3)) l3 = Number.parseInt(a3, 10);
    else try {
      let o2 = new T$9(), c3 = W$d(o2, a3);
      l3 = await R$a(e5, c3.expression);
    } catch {
      let o2 = e5.state.env[a3];
      l3 = o2 ? Number.parseInt(o2, 10) : 0, Number.isNaN(l3) && (l3 = 0);
    }
    if (l3 < 0) {
      let o2 = P$g(e5, n3);
      if (o2.length === 0) return false;
      let u3 = Math.max(...o2.map(([f3]) => typeof f3 == "number" ? f3 : 0)) + 1 + l3;
      return u3 < 0 ? false : `${n3}_${u3}` in e5.state.env;
    }
    return `${n3}_${l3}` in e5.state.env;
  }
  if (C$g(e5, t4)) {
    let n3 = le$8(e5, t4);
    return n3 === void 0 || n3 === t4 ? t4 in e5.state.env : Y$a(e5, n3);
  }
  return !!(t4 in e5.state.env || ye$5(e5, t4));
}
async function gn$1(e5, t4) {
  let r2 = "", s3 = 0;
  for (; s3 < t4.length; ) {
    if (t4[s3] === "$") {
      if (t4[s3 + 1] === "{") {
        let n3 = 1, a3 = s3 + 2;
        for (; a3 < t4.length && n3 > 0; ) t4[a3] === "{" ? n3++ : t4[a3] === "}" && n3--, a3++;
        r2 += t4.slice(s3, a3), s3 = a3;
        continue;
      }
      if (t4[s3 + 1] === "(") {
        let n3 = 1, a3 = s3 + 2;
        for (; a3 < t4.length && n3 > 0; ) t4[a3] === "(" ? n3++ : t4[a3] === ")" && n3--, a3++;
        r2 += t4.slice(s3, a3), s3 = a3;
        continue;
      }
      if (/[a-zA-Z_]/.test(t4[s3 + 1] || "")) {
        let n3 = s3 + 1;
        for (; n3 < t4.length && /[a-zA-Z0-9_]/.test(t4[n3]); ) n3++;
        let a3 = t4.slice(s3 + 1, n3), i4 = await v$b(e5, a3);
        r2 += i4, s3 = n3;
        continue;
      }
      if (/[0-9]/.test(t4[s3 + 1] || "")) {
        let n3 = s3 + 1;
        for (; n3 < t4.length && /[0-9]/.test(t4[n3]); ) n3++;
        let a3 = t4.slice(s3 + 1, n3), i4 = await v$b(e5, a3);
        r2 += i4, s3 = n3;
        continue;
      }
      if (/[*@#?\-!$]/.test(t4[s3 + 1] || "")) {
        let n3 = t4[s3 + 1], a3 = await v$b(e5, n3);
        r2 += a3, s3 += 2;
        continue;
      }
    }
    if (t4[s3] === '"') {
      for (r2 += '"', s3++; s3 < t4.length && t4[s3] !== '"'; ) if (t4[s3] === "$" && /[a-zA-Z_]/.test(t4[s3 + 1] || "")) {
        let n3 = s3 + 1;
        for (; n3 < t4.length && /[a-zA-Z0-9_]/.test(t4[n3]); ) n3++;
        let a3 = t4.slice(s3 + 1, n3), i4 = await v$b(e5, a3);
        r2 += i4, s3 = n3;
      } else t4[s3] === "\\" ? (r2 += t4[s3], s3++, s3 < t4.length && (r2 += t4[s3], s3++)) : (r2 += t4[s3], s3++);
      s3 < t4.length && (r2 += '"', s3++);
      continue;
    }
    r2 += t4[s3], s3++;
  }
  return r2;
}
async function mt$3(e5, t4) {
  let r2 = t4, s3 = t4.startsWith('"') && t4.endsWith('"'), n3 = t4.startsWith("'") && t4.endsWith("'");
  if ((s3 || n3) && (r2 = t4.slice(1, -1)), n3) return r2;
  let a3 = "", i4 = 0;
  for (; i4 < r2.length; ) if (r2[i4] === "$") if (r2[i4 + 1] === "(") {
    let l3 = 1, o2 = i4 + 2;
    for (; o2 < r2.length && l3 > 0; ) r2[o2] === "(" && r2[o2 - 1] === "$" || r2[o2] === "(" ? l3++ : r2[o2] === ")" && l3--, o2++;
    let c3 = r2.slice(i4 + 2, o2 - 1);
    if (e5.execFn) {
      let u3 = await e5.execFn(c3);
      a3 += u3.stdout.replace(/\n+$/, ""), u3.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + u3.stderr);
    }
    i4 = o2;
  } else if (r2[i4 + 1] === "{") {
    let l3 = 1, o2 = i4 + 2;
    for (; o2 < r2.length && l3 > 0; ) r2[o2] === "{" ? l3++ : r2[o2] === "}" && l3--, o2++;
    let c3 = r2.slice(i4 + 2, o2 - 1), u3 = await v$b(e5, c3);
    a3 += u3, i4 = o2;
  } else if (/[a-zA-Z_]/.test(r2[i4 + 1] || "")) {
    let l3 = i4 + 1;
    for (; l3 < r2.length && /[a-zA-Z0-9_]/.test(r2[l3]); ) l3++;
    let o2 = r2.slice(i4 + 1, l3), c3 = await v$b(e5, o2);
    a3 += c3, i4 = l3;
  } else a3 += r2[i4], i4++;
  else if (r2[i4] === "`") {
    let l3 = i4 + 1;
    for (; l3 < r2.length && r2[l3] !== "`"; ) l3++;
    let o2 = r2.slice(i4 + 1, l3);
    if (e5.execFn) {
      let c3 = await e5.execFn(o2);
      a3 += c3.stdout.replace(/\n+$/, ""), c3.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + c3.stderr);
    }
    i4 = l3 + 1;
  } else a3 += r2[i4], i4++;
  return a3;
}
var Ce$3 = 1e4;
function as$1(e5, t4, r2, s3, n3) {
  let a3 = r2 ?? 1;
  a3 === 0 && (a3 = 1);
  let i4 = Math.abs(a3), l3 = [], o2 = 0;
  s3?.match(/^-?0\d/) && (o2 = Math.max(o2, s3.replace(/^-/, "").length)), n3?.match(/^-?0\d/) && (o2 = Math.max(o2, n3.replace(/^-/, "").length));
  let c3 = (u3) => {
    if (o2 > 0) {
      let f3 = u3 < 0, h3 = String(Math.abs(u3)).padStart(o2, "0");
      return f3 ? `-${h3}` : h3;
    }
    return String(u3);
  };
  if (e5 <= t4) for (let u3 = e5, f3 = 0; u3 <= t4 && f3 < Ce$3; u3 += i4, f3++) l3.push(c3(u3));
  else for (let u3 = e5, f3 = 0; u3 >= t4 && f3 < Ce$3; u3 -= i4, f3++) l3.push(c3(u3));
  return l3;
}
function os$1(e5, t4, r2) {
  let s3 = r2 ?? 1;
  s3 === 0 && (s3 = 1);
  let n3 = e5.charCodeAt(0), a3 = t4.charCodeAt(0), i4 = Math.abs(s3), l3 = e5 >= "A" && e5 <= "Z", o2 = e5 >= "a" && e5 <= "z", c3 = t4 >= "A" && t4 <= "Z", u3 = t4 >= "a" && t4 <= "z";
  if (l3 && u3 || o2 && c3) {
    let h3 = r2 !== void 0 ? `..${r2}` : "";
    throw new m$e(`{${e5}..${t4}${h3}}: invalid sequence`);
  }
  let f3 = [];
  if (n3 <= a3) for (let h3 = n3, d3 = 0; h3 <= a3 && d3 < Ce$3; h3 += i4, d3++) f3.push(String.fromCharCode(h3));
  else for (let h3 = n3, d3 = 0; h3 >= a3 && d3 < Ce$3; h3 -= i4, d3++) f3.push(String.fromCharCode(h3));
  return f3;
}
function gt$4(e5, t4, r2, s3, n3) {
  let a3 = r2 !== void 0 ? `..${r2}` : "";
  return typeof e5 == "number" && typeof t4 == "number" ? { expanded: as$1(e5, t4, r2, s3, n3), literal: `{${e5}..${t4}${a3}}` } : typeof e5 == "string" && typeof t4 == "string" ? { expanded: os$1(e5, t4, r2), literal: `{${e5}..${t4}${a3}}` } : { expanded: null, literal: `{${e5}..${t4}${a3}}` };
}
function yn$1(e5) {
  if (e5.statements.length !== 1) return null;
  let t4 = e5.statements[0];
  if (t4.operators.length !== 0 || t4.pipelines.length !== 1) return null;
  let r2 = t4.pipelines[0];
  if (r2.negated || r2.commands.length !== 1) return null;
  let s3 = r2.commands[0];
  if (s3.type !== "SimpleCommand") return null;
  let n3 = s3;
  if (n3.name !== null || n3.args.length !== 0 || n3.assignments.length !== 0 || n3.redirections.length !== 1) return null;
  let a3 = n3.redirections[0];
  return a3.operator !== "<" || a3.target.type !== "Word" ? null : { target: a3.target };
}
function ee$4(e5, t4) {
  return !!(/[*?[]/.test(e5) || t4 && /[@*+?!]\(/.test(e5));
}
function yt$4(e5) {
  let t4 = "", r2 = 0;
  for (; r2 < e5.length; ) e5[r2] === "\\" && r2 + 1 < e5.length ? (t4 += e5[r2 + 1], r2 += 2) : (t4 += e5[r2], r2++);
  return t4;
}
function U$8(e5) {
  return e5.replace(/([*?[\]\\()|])/g, "\\$1");
}
function Et$3(e5) {
  return e5.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
}
function I$e(e5) {
  return e5.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function k$b(e5, t4, r2 = false) {
  let s3 = "", n3 = 0;
  for (; n3 < e5.length; ) {
    let a3 = e5[n3];
    if (r2 && (a3 === "@" || a3 === "*" || a3 === "+" || a3 === "?" || a3 === "!") && n3 + 1 < e5.length && e5[n3 + 1] === "(") {
      let i4 = ls$1(e5, n3 + 1);
      if (i4 !== -1) {
        let l3 = e5.slice(n3 + 2, i4), c3 = us$1(l3).map((f3) => k$b(f3, t4, r2)), u3 = c3.length > 0 ? c3.join("|") : "(?:)";
        a3 === "@" ? s3 += `(?:${u3})` : a3 === "*" ? s3 += `(?:${u3})*` : a3 === "+" ? s3 += `(?:${u3})+` : a3 === "?" ? s3 += `(?:${u3})?` : a3 === "!" && (s3 += `(?!(?:${u3})$).*`), n3 = i4 + 1;
        continue;
      }
    }
    if (a3 === "\\") if (n3 + 1 < e5.length) {
      let i4 = e5[n3 + 1];
      /[\\^$.|+(){}[\]*?]/.test(i4) ? s3 += `\\${i4}` : s3 += i4, n3 += 2;
    } else s3 += "\\\\", n3++;
    else if (a3 === "*") s3 += t4 ? ".*" : ".*?", n3++;
    else if (a3 === "?") s3 += ".", n3++;
    else if (a3 === "[") {
      let i4 = cs$1(e5, n3);
      if (i4 === -1) s3 += "\\[", n3++;
      else {
        let l3 = e5.slice(n3 + 1, i4);
        s3 += fs$1(l3), n3 = i4 + 1;
      }
    } else /[\^$.|+(){}]/.test(a3) ? (s3 += `\\${a3}`, n3++) : (s3 += a3, n3++);
  }
  return s3;
}
function ls$1(e5, t4) {
  let r2 = 1, s3 = t4 + 1;
  for (; s3 < e5.length && r2 > 0; ) {
    let n3 = e5[s3];
    if (n3 === "\\") {
      s3 += 2;
      continue;
    }
    if (n3 === "(") r2++;
    else if (n3 === ")" && (r2--, r2 === 0)) return s3;
    s3++;
  }
  return -1;
}
function us$1(e5) {
  let t4 = [], r2 = "", s3 = 0, n3 = 0;
  for (; n3 < e5.length; ) {
    let a3 = e5[n3];
    if (a3 === "\\") {
      r2 += a3, n3 + 1 < e5.length ? (r2 += e5[n3 + 1], n3 += 2) : n3++;
      continue;
    }
    a3 === "(" ? (s3++, r2 += a3) : a3 === ")" ? (s3--, r2 += a3) : a3 === "|" && s3 === 0 ? (t4.push(r2), r2 = "") : r2 += a3, n3++;
  }
  return t4.push(r2), t4;
}
function cs$1(e5, t4) {
  let r2 = t4 + 1;
  for (r2 < e5.length && e5[r2] === "^" && r2++, r2 < e5.length && e5[r2] === "]" && r2++; r2 < e5.length; ) {
    if (e5[r2] === "\\" && r2 + 1 < e5.length) {
      r2 += 2;
      continue;
    }
    if (e5[r2] === "]") return r2;
    if (e5[r2] === "'") {
      let s3 = e5.indexOf("'", r2 + 1);
      if (s3 !== -1) {
        r2 = s3 + 1;
        continue;
      }
    }
    if (e5[r2] === "[" && r2 + 1 < e5.length && e5[r2 + 1] === ":") {
      let s3 = e5.indexOf(":]", r2 + 2);
      if (s3 !== -1) {
        r2 = s3 + 2;
        continue;
      }
    }
    r2++;
  }
  return -1;
}
function fs$1(e5) {
  let t4 = "[", r2 = 0;
  for ((e5[0] === "^" || e5[0] === "!") && (t4 += "^", r2++); r2 < e5.length; ) {
    if (e5[r2] === "'") {
      let n3 = e5.indexOf("'", r2 + 1);
      if (n3 !== -1) {
        let a3 = e5.slice(r2 + 1, n3);
        for (let i4 of a3) i4 === "\\" ? t4 += "\\\\" : i4 === "]" ? t4 += "\\]" : i4 === "^" && t4 === "[" ? t4 += "\\^" : t4 += i4;
        r2 = n3 + 1;
        continue;
      }
    }
    if (e5[r2] === "[" && r2 + 1 < e5.length && e5[r2 + 1] === ":") {
      let n3 = e5.indexOf(":]", r2 + 2);
      if (n3 !== -1) {
        let a3 = e5.slice(r2 + 2, n3);
        t4 += hs$1(a3), r2 = n3 + 2;
        continue;
      }
    }
    let s3 = e5[r2];
    s3 === "\\" ? r2 + 1 < e5.length ? (t4 += `\\${e5[r2 + 1]}`, r2 += 2) : (t4 += "\\\\", r2++) : s3 === "-" && r2 > 0 && r2 < e5.length - 1 ? (t4 += "-", r2++) : s3 === "^" && r2 === 0 ? (t4 += "^", r2++) : (s3 === "]" && r2 === 0 ? t4 += "\\]" : t4 += s3, r2++);
  }
  return t4 += "]", t4;
}
var ps$1 = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" };
function hs$1(e5) {
  return ps$1[e5] ?? "";
}
function ne$7(e5, t4, r2, s3) {
  if (r2 === "prefix") return e5.replace(new RegExp(`^${t4}`, "s"), "");
  let n3 = new RegExp(`${t4}$`, "s");
  if (s3) return e5.replace(n3, "");
  for (let a3 = e5.length; a3 >= 0; a3--) {
    let i4 = e5.slice(a3);
    if (n3.test(i4)) return e5.slice(0, a3);
  }
  return e5;
}
function ce$9(e5, t4) {
  let r2 = Object.keys(e5.state.env), s3 = /* @__PURE__ */ new Set(), n3 = e5.state.associativeArrays ?? /* @__PURE__ */ new Set(), a3 = /* @__PURE__ */ new Set();
  for (let l3 of r2) {
    let o2 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
    o2 && a3.add(o2[1]);
    let c3 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
    c3 && a3.add(c3[1]);
  }
  let i4 = (l3) => {
    for (let o2 of n3) {
      let c3 = `${o2}_`;
      if (l3.startsWith(c3) && l3 !== o2) return true;
    }
    return false;
  };
  for (let l3 of r2) if (l3.startsWith(t4)) if (l3.includes("__")) {
    let o2 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
    o2?.[1].startsWith(t4) && s3.add(o2[1]);
  } else if (/_\d+$/.test(l3)) {
    let o2 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_\d+$/);
    o2?.[1].startsWith(t4) && s3.add(o2[1]);
  } else i4(l3) || s3.add(l3);
  return [...s3].sort();
}
function ds$1(e5, t4) {
  let r2 = (a3, i4 = 2) => String(a3).padStart(i4, "0");
  if (e5 === "") {
    let a3 = r2(t4.getHours()), i4 = r2(t4.getMinutes()), l3 = r2(t4.getSeconds());
    return `${a3}:${i4}:${l3}`;
  }
  let s3 = "", n3 = 0;
  for (; n3 < e5.length; ) if (e5[n3] === "%") {
    if (n3 + 1 >= e5.length) {
      s3 += "%", n3++;
      continue;
    }
    let a3 = e5[n3 + 1];
    switch (a3) {
      case "H":
        s3 += r2(t4.getHours());
        break;
      case "M":
        s3 += r2(t4.getMinutes());
        break;
      case "S":
        s3 += r2(t4.getSeconds());
        break;
      case "d":
        s3 += r2(t4.getDate());
        break;
      case "m":
        s3 += r2(t4.getMonth() + 1);
        break;
      case "Y":
        s3 += t4.getFullYear();
        break;
      case "y":
        s3 += r2(t4.getFullYear() % 100);
        break;
      case "I": {
        let i4 = t4.getHours() % 12;
        i4 === 0 && (i4 = 12), s3 += r2(i4);
        break;
      }
      case "p":
        s3 += t4.getHours() < 12 ? "AM" : "PM";
        break;
      case "P":
        s3 += t4.getHours() < 12 ? "am" : "pm";
        break;
      case "%":
        s3 += "%";
        break;
      case "a": {
        s3 += ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][t4.getDay()];
        break;
      }
      case "b": {
        s3 += ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][t4.getMonth()];
        break;
      }
      default:
        s3 += `%${a3}`;
    }
    n3 += 2;
  } else s3 += e5[n3], n3++;
  return s3;
}
function Ee$6(e5, t4) {
  let r2 = "", s3 = 0, n3 = e5.state.env.USER || e5.state.env.LOGNAME || "user", a3 = e5.state.env.HOSTNAME || "localhost", i4 = a3.split(".")[0], l3 = e5.state.env.PWD || "/", o2 = e5.state.env.HOME || "/", c3 = l3.startsWith(o2) ? `~${l3.slice(o2.length)}` : l3, u3 = l3.split("/").pop() || l3, f3 = /* @__PURE__ */ new Date(), h3 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], d3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], y2 = e5.state.env.__COMMAND_NUMBER || "1";
  for (; s3 < t4.length; ) {
    let g2 = t4[s3];
    if (g2 === "\\") {
      if (s3 + 1 >= t4.length) {
        r2 += "\\", s3++;
        continue;
      }
      let E2 = t4[s3 + 1];
      if (E2 >= "0" && E2 <= "7") {
        let S3 = "", m3 = s3 + 1;
        for (; m3 < t4.length && m3 < s3 + 4 && t4[m3] >= "0" && t4[m3] <= "7"; ) S3 += t4[m3], m3++;
        let A2 = Number.parseInt(S3, 8) % 256;
        r2 += String.fromCharCode(A2), s3 = m3;
        continue;
      }
      switch (E2) {
        case "\\":
          r2 += "\\", s3 += 2;
          break;
        case "a":
          r2 += "\x07", s3 += 2;
          break;
        case "e":
          r2 += "\x1B", s3 += 2;
          break;
        case "n":
          r2 += `
`, s3 += 2;
          break;
        case "r":
          r2 += "\r", s3 += 2;
          break;
        case "$":
          r2 += "$", s3 += 2;
          break;
        case "[":
        case "]":
          s3 += 2;
          break;
        case "u":
          r2 += n3, s3 += 2;
          break;
        case "h":
          r2 += i4, s3 += 2;
          break;
        case "H":
          r2 += a3, s3 += 2;
          break;
        case "w":
          r2 += c3, s3 += 2;
          break;
        case "W":
          r2 += u3, s3 += 2;
          break;
        case "d": {
          let S3 = String(f3.getDate()).padStart(2, " ");
          r2 += `${h3[f3.getDay()]} ${d3[f3.getMonth()]} ${S3}`, s3 += 2;
          break;
        }
        case "t": {
          let S3 = String(f3.getHours()).padStart(2, "0"), m3 = String(f3.getMinutes()).padStart(2, "0"), A2 = String(f3.getSeconds()).padStart(2, "0");
          r2 += `${S3}:${m3}:${A2}`, s3 += 2;
          break;
        }
        case "T": {
          let S3 = f3.getHours() % 12;
          S3 === 0 && (S3 = 12);
          let m3 = String(S3).padStart(2, "0"), A2 = String(f3.getMinutes()).padStart(2, "0"), w4 = String(f3.getSeconds()).padStart(2, "0");
          r2 += `${m3}:${A2}:${w4}`, s3 += 2;
          break;
        }
        case "@": {
          let S3 = f3.getHours() % 12;
          S3 === 0 && (S3 = 12);
          let m3 = String(S3).padStart(2, "0"), A2 = String(f3.getMinutes()).padStart(2, "0"), w4 = f3.getHours() < 12 ? "AM" : "PM";
          r2 += `${m3}:${A2} ${w4}`, s3 += 2;
          break;
        }
        case "A": {
          let S3 = String(f3.getHours()).padStart(2, "0"), m3 = String(f3.getMinutes()).padStart(2, "0");
          r2 += `${S3}:${m3}`, s3 += 2;
          break;
        }
        case "D":
          if (s3 + 2 < t4.length && t4[s3 + 2] === "{") {
            let S3 = t4.indexOf("}", s3 + 3);
            if (S3 !== -1) {
              let m3 = t4.slice(s3 + 3, S3);
              r2 += ds$1(m3, f3), s3 = S3 + 1;
            } else r2 += "\\D", s3 += 2;
          } else r2 += "\\D", s3 += 2;
          break;
        case "s":
          r2 += "bash", s3 += 2;
          break;
        case "v":
          r2 += "5.0", s3 += 2;
          break;
        case "V":
          r2 += "5.0.0", s3 += 2;
          break;
        case "j":
          r2 += "0", s3 += 2;
          break;
        case "l":
          r2 += "tty", s3 += 2;
          break;
        case "#":
          r2 += y2, s3 += 2;
          break;
        case "!":
          r2 += y2, s3 += 2;
          break;
        case "x":
          r2 += "\\x", s3 += 2;
          break;
        default:
          r2 += `\\${E2}`, s3 += 2;
      }
    } else r2 += g2, s3++;
  }
  return r2;
}
function ie$8(e5) {
  if (e5 === "") return "''";
  if (/[\n\r\t\x00-\x1f\x7f']/.test(e5)) {
    let r2 = "$'";
    for (let s3 of e5) switch (s3) {
      case "'":
        r2 += "\\'";
        break;
      case "\\":
        r2 += "\\\\";
        break;
      case `
`:
        r2 += "\\n";
        break;
      case "\r":
        r2 += "\\r";
        break;
      case "	":
        r2 += "\\t";
        break;
      default: {
        let n3 = s3.charCodeAt(0);
        n3 < 32 || n3 === 127 ? r2 += `\\${n3.toString(8).padStart(3, "0")}` : r2 += s3;
      }
    }
    return `${r2}'`;
  }
  return `'${e5}'`;
}
function ia$1(e5, t4) {
  e5.state.readonlyVars = e5.state.readonlyVars || /* @__PURE__ */ new Set(), e5.state.readonlyVars.add(t4);
}
function At$4(e5, t4) {
  return e5.state.readonlyVars?.has(t4) ?? false;
}
function aa(e5, t4, r2 = "bash") {
  if (At$4(e5, t4)) {
    let s3 = `${r2}: ${t4}: readonly variable
`;
    throw new d$8(1, "", s3);
  }
  return null;
}
function oa$1(e5, t4) {
  let r2 = e5.state.exportedVars?.has(t4) ?? false;
  if (e5.state.exportedVars = e5.state.exportedVars || /* @__PURE__ */ new Set(), e5.state.exportedVars.add(t4), e5.state.localScopes.length > 0 && e5.state.localScopes[e5.state.localScopes.length - 1].has(t4) && !r2) {
    for (e5.state.localExportedVars || (e5.state.localExportedVars = []); e5.state.localExportedVars.length < e5.state.localScopes.length; ) e5.state.localExportedVars.push(/* @__PURE__ */ new Set());
    e5.state.localExportedVars[e5.state.localExportedVars.length - 1].add(t4);
  }
}
function la(e5, t4) {
  e5.state.exportedVars?.delete(t4);
}
function ae$5(e5, t4) {
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t4)) return "";
  let r2 = "", s3 = e5.state.env[`${t4}__length`] !== void 0 || Object.keys(e5.state.env).some((a3) => a3.startsWith(`${t4}_`) && /^[0-9]+$/.test(a3.slice(t4.length + 1))), n3 = e5.state.associativeArrays?.has(t4) ?? false;
  return s3 && !n3 && (r2 += "a"), n3 && (r2 += "A"), e5.state.integerVars?.has(t4) && (r2 += "i"), C$g(e5, t4) && (r2 += "n"), At$4(e5, t4) && (r2 += "r"), e5.state.exportedVars?.has(t4) && (r2 += "x"), r2;
}
async function En$2(e5, t4, r2, s3) {
  return (r2.isUnset || t4.checkEmpty && r2.isEmpty) && t4.word ? s3(e5, t4.word.parts, r2.inDoubleQuotes) : r2.effectiveValue;
}
async function An$1(e5, t4, r2, s3, n3) {
  if ((s3.isUnset || r2.checkEmpty && s3.isEmpty) && r2.word) {
    let i4 = await n3(e5, r2.word.parts, s3.inDoubleQuotes), l3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (l3) {
      let [, o2, c3] = l3, u3;
      if (/^\d+$/.test(c3)) u3 = Number.parseInt(c3, 10);
      else {
        try {
          let h3 = new T$9(), d3 = W$d(h3, c3);
          u3 = await R$a(e5, d3.expression);
        } catch {
          let h3 = e5.state.env[c3];
          u3 = h3 ? Number.parseInt(h3, 10) : 0;
        }
        Number.isNaN(u3) && (u3 = 0);
      }
      e5.state.env[`${o2}_${u3}`] = i4;
      let f3 = Number.parseInt(e5.state.env[`${o2}__length`] || "0", 10);
      u3 >= f3 && (e5.state.env[`${o2}__length`] = String(u3 + 1));
    } else e5.state.env[t4] = i4;
    return i4;
  }
  return s3.effectiveValue;
}
async function Sn$1(e5, t4, r2, s3, n3) {
  if (s3.isUnset || r2.checkEmpty && s3.isEmpty) {
    let i4 = r2.word ? await n3(e5, r2.word.parts, s3.inDoubleQuotes) : `${t4}: parameter null or not set`;
    throw new d$8(1, "", `bash: ${i4}
`);
  }
  return s3.effectiveValue;
}
async function bn$2(e5, t4, r2, s3) {
  return !(r2.isUnset || t4.checkEmpty && r2.isEmpty) && t4.word ? s3(e5, t4.word.parts, r2.inDoubleQuotes) : "";
}
async function wn$1(e5, t4, r2, s3, n3) {
  let a3 = "", i4 = e5.state.shoptOptions.extglob;
  if (r2.pattern) for (let o2 of r2.pattern.parts) if (o2.type === "Glob") a3 += k$b(o2.pattern, r2.greedy, i4);
  else if (o2.type === "Literal") a3 += k$b(o2.value, r2.greedy, i4);
  else if (o2.type === "SingleQuoted" || o2.type === "Escaped") a3 += I$e(o2.value);
  else if (o2.type === "DoubleQuoted") {
    let c3 = await s3(e5, o2.parts);
    a3 += I$e(c3);
  } else if (o2.type === "ParameterExpansion") {
    let c3 = await n3(e5, o2);
    a3 += k$b(c3, r2.greedy, i4);
  } else {
    let c3 = await n3(e5, o2);
    a3 += I$e(c3);
  }
  if (r2.side === "prefix") return t4.replace(new RegExp(`^${a3}`, "s"), "");
  let l3 = new RegExp(`${a3}$`, "s");
  if (r2.greedy) return t4.replace(l3, "");
  for (let o2 = t4.length; o2 >= 0; o2--) {
    let c3 = t4.slice(o2);
    if (l3.test(c3)) return t4.slice(0, o2);
  }
  return t4;
}
async function Nn$1(e5, t4, r2, s3, n3) {
  let a3 = "", i4 = e5.state.shoptOptions.extglob;
  if (r2.pattern) for (let c3 of r2.pattern.parts) if (c3.type === "Glob") a3 += k$b(c3.pattern, true, i4);
  else if (c3.type === "Literal") a3 += k$b(c3.value, true, i4);
  else if (c3.type === "SingleQuoted" || c3.type === "Escaped") a3 += I$e(c3.value);
  else if (c3.type === "DoubleQuoted") {
    let u3 = await s3(e5, c3.parts);
    a3 += I$e(u3);
  } else if (c3.type === "ParameterExpansion") {
    let u3 = await n3(e5, c3);
    a3 += k$b(u3, true, i4);
  } else {
    let u3 = await n3(e5, c3);
    a3 += I$e(u3);
  }
  let l3 = r2.replacement ? await s3(e5, r2.replacement.parts) : "";
  if (r2.anchor === "start" ? a3 = `^${a3}` : r2.anchor === "end" && (a3 = `${a3}$`), a3 === "") return t4;
  let o2 = r2.all ? "gs" : "s";
  try {
    let c3 = new RegExp(a3, o2);
    if (r2.all) {
      let u3 = "", f3 = 0, h3 = c3.exec(t4);
      for (; h3 !== null && !(h3[0].length === 0 && h3.index === t4.length); ) u3 += t4.slice(f3, h3.index) + l3, f3 = h3.index + h3[0].length, h3[0].length === 0 && f3++, h3 = c3.exec(t4);
      return u3 += t4.slice(f3), u3;
    }
    return t4.replace(c3, l3);
  } catch {
    return t4;
  }
}
function kn$2(e5, t4, r2) {
  let s3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (s3) {
    let n3 = s3[1], a3 = P$g(e5, n3);
    return a3.length > 0 ? String(a3.length) : e5.state.env[n3] !== void 0 ? "1" : "0";
  }
  if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t4) && ye$5(e5, t4)) {
    if (t4 === "FUNCNAME") {
      let a3 = e5.state.funcNameStack?.[0] || "";
      return String([...a3].length);
    }
    if (t4 === "BASH_LINENO") {
      let a3 = e5.state.callLineStack?.[0];
      return String(a3 !== void 0 ? [...String(a3)].length : 0);
    }
    let n3 = e5.state.env[`${t4}_0`] || "";
    return String([...n3].length);
  }
  return String([...r2].length);
}
async function Pn$1(e5, t4, r2, s3) {
  let n3 = await R$a(e5, s3.offset.expression), a3 = s3.length ? await R$a(e5, s3.length.expression) : void 0;
  if (t4 === "@" || t4 === "*") {
    let c3 = Number.parseInt(e5.state.env["#"] || "0", 10), u3 = [];
    for (let y2 = 1; y2 <= c3; y2++) u3.push(e5.state.env[String(y2)] || "");
    let f3 = e5.state.env[0] || "bash", h3, d3;
    if (n3 <= 0) if (h3 = [f3, ...u3], n3 < 0) {
      if (d3 = h3.length + n3, d3 < 0) return "";
    } else d3 = 0;
    else h3 = u3, d3 = n3 - 1;
    if (d3 < 0 || d3 >= h3.length) return "";
    if (a3 !== void 0) {
      let y2 = a3 < 0 ? h3.length + a3 : d3 + a3;
      return h3.slice(d3, Math.max(d3, y2)).join(" ");
    }
    return h3.slice(d3).join(" ");
  }
  let i4 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (i4) {
    let c3 = i4[1];
    if (e5.state.associativeArrays?.has(c3)) throw new d$8(1, "", `bash: \${${c3}[@]: 0: 3}: bad substitution
`);
    let u3 = P$g(e5, c3), f3 = 0;
    if (n3 < 0) {
      if (u3.length > 0) {
        let h3 = u3[u3.length - 1][0], y2 = (typeof h3 == "number" ? h3 : 0) + 1 + n3;
        if (y2 < 0 || (f3 = u3.findIndex(([g2]) => typeof g2 == "number" && g2 >= y2), f3 < 0)) return "";
      }
    } else if (f3 = u3.findIndex(([h3]) => typeof h3 == "number" && h3 >= n3), f3 < 0) return "";
    if (a3 !== void 0) {
      if (a3 < 0) throw new p$f(`${i4[1]}[@]: substring expression < 0`);
      return u3.slice(f3, f3 + a3).map(([, h3]) => h3).join(" ");
    }
    return u3.slice(f3).map(([, h3]) => h3).join(" ");
  }
  let l3 = [...r2], o2 = n3;
  if (o2 < 0 && (o2 = Math.max(0, l3.length + o2)), a3 !== void 0) {
    if (a3 < 0) {
      let c3 = l3.length + a3;
      return l3.slice(o2, Math.max(o2, c3)).join("");
    }
    return l3.slice(o2, o2 + a3).join("");
  }
  return l3.slice(o2).join("");
}
async function Rn$1(e5, t4, r2, s3, n3) {
  if (r2.pattern) {
    let a3 = e5.state.shoptOptions.extglob, i4 = "";
    for (let f3 of r2.pattern.parts) if (f3.type === "Glob") i4 += k$b(f3.pattern, true, a3);
    else if (f3.type === "Literal") i4 += k$b(f3.value, true, a3);
    else if (f3.type === "SingleQuoted" || f3.type === "Escaped") i4 += I$e(f3.value);
    else if (f3.type === "DoubleQuoted") {
      let h3 = await s3(e5, f3.parts);
      i4 += I$e(h3);
    } else if (f3.type === "ParameterExpansion") {
      let h3 = await n3(e5, f3);
      i4 += k$b(h3, true, a3);
    }
    let l3 = new RegExp(`^(?:${i4})$`), o2 = r2.direction === "upper" ? (f3) => f3.toUpperCase() : (f3) => f3.toLowerCase(), c3 = "", u3 = false;
    for (let f3 of t4) !r2.all && u3 ? c3 += f3 : l3.test(f3) ? (c3 += o2(f3), u3 = true) : c3 += f3;
    return c3;
  }
  return r2.direction === "upper" ? r2.all ? t4.toUpperCase() : t4.charAt(0).toUpperCase() + t4.slice(1) : r2.all ? t4.toLowerCase() : t4.charAt(0).toLowerCase() + t4.slice(1);
}
function In$1(e5, t4, r2, s3, n3) {
  let a3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[[@*]\]$/);
  if (a3 && n3.operator === "Q") return P$g(e5, a3[1]).map(([, c3]) => ie$8(c3)).join(" ");
  if (a3 && n3.operator === "a") return ae$5(e5, a3[1]);
  let i4 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[.+\]$/);
  if (i4 && n3.operator === "a") return ae$5(e5, i4[1]);
  switch (n3.operator) {
    case "Q":
      return s3 ? "" : ie$8(r2);
    case "P":
      return Ee$6(e5, r2);
    case "a":
      return ae$5(e5, t4);
    case "A":
      return s3 ? "" : `${t4}=${ie$8(r2)}`;
    case "E":
      return r2.replace(/\\([\\abefnrtv'"?])/g, (l3, o2) => {
        switch (o2) {
          case "\\":
            return "\\";
          case "a":
            return "\x07";
          case "b":
            return "\b";
          case "e":
            return "\x1B";
          case "f":
            return "\f";
          case "n":
            return `
`;
          case "r":
            return "\r";
          case "t":
            return "	";
          case "v":
            return "\v";
          case "'":
            return "'";
          case '"':
            return '"';
          case "?":
            return "?";
          default:
            return o2;
        }
      });
    case "K":
    case "k":
      return s3 ? "" : ie$8(r2);
    case "u":
      return r2.charAt(0).toUpperCase() + r2.slice(1);
    case "U":
      return r2.toUpperCase();
    case "L":
      return r2.toLowerCase();
    default:
      return r2;
  }
}
async function vn$1(e5, t4, r2, s3, n3, a3, i4 = false) {
  if (C$g(e5, t4)) return ge$5(e5, t4) || "";
  let l3 = /^[a-zA-Z_][a-zA-Z0-9_]*\[([@*])\]$/.test(t4);
  if (s3) {
    if (n3.innerOp?.type === "UseAlternative") return "";
    throw new h$f(`\${!${t4}}`);
  }
  let o2 = r2;
  if (l3 && (o2 === "" || o2.includes(" "))) throw new h$f(`\${!${t4}}`);
  let c3 = o2.match(/^[a-zA-Z_][a-zA-Z0-9_]*\[(.+)\]$/);
  if (c3 && c3[1].includes("~")) throw new h$f(`\${!${t4}}`);
  if (n3.innerOp) {
    let u3 = { type: "ParameterExpansion", parameter: o2, operation: n3.innerOp };
    return a3(e5, u3, i4);
  }
  return await v$b(e5, o2);
}
function Dn$2(e5, t4) {
  let s3 = P$g(e5, t4.array).map(([n3]) => String(n3));
  return t4.star ? s3.join(N$b(e5.state.env)) : s3.join(" ");
}
function xn$1(e5, t4) {
  let r2 = ce$9(e5, t4.prefix);
  return t4.star ? r2.join(N$b(e5.state.env)) : r2.join(" ");
}
function $n$1(e5, t4, r2, s3) {
  let n3 = Number.parseInt(e5.state.env["#"] || "0", 10), a3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (t4 === "*") return { isEmpty: n3 === 0, effectiveValue: r2 };
  if (t4 === "@") return { isEmpty: n3 === 0 || n3 === 1 && e5.state.env[1] === "", effectiveValue: r2 };
  if (a3) {
    let [, i4, l3] = a3, o2 = P$g(e5, i4);
    if (o2.length === 0) return { isEmpty: true, effectiveValue: "" };
    if (l3 === "*") {
      let c3 = N$b(e5.state.env), u3 = o2.map(([, f3]) => f3).join(c3);
      return { isEmpty: s3 ? u3 === "" : false, effectiveValue: u3 };
    }
    return { isEmpty: o2.length === 1 && o2.every(([, c3]) => c3 === ""), effectiveValue: o2.map(([, c3]) => c3).join(" ") };
  }
  return { isEmpty: r2 === "", effectiveValue: r2 };
}
function _n$1(e5) {
  let t4 = 0;
  for (; t4 < e5.length; ) {
    let r2 = e5[t4];
    if (r2 === "\\" && t4 + 1 < e5.length) {
      t4 += 2;
      continue;
    }
    if (r2 === "'") {
      let s3 = e5.indexOf("'", t4 + 1);
      if (s3 !== -1) {
        t4 = s3 + 1;
        continue;
      }
    }
    if (r2 === "$" && t4 + 1 < e5.length && e5[t4 + 1] === "(" || r2 === "`") return true;
    t4++;
  }
  return false;
}
function Cn$1(e5, t4) {
  let r2 = 1, s3 = t4, n3 = false, a3 = false;
  for (; s3 < e5.length && r2 > 0; ) {
    let i4 = e5[s3];
    if (i4 === "\\" && !n3 && s3 + 1 < e5.length) {
      s3 += 2;
      continue;
    }
    if (i4 === "'" && !a3) {
      n3 = !n3, s3++;
      continue;
    }
    if (i4 === '"' && !n3) {
      a3 = !a3, s3++;
      continue;
    }
    if (!n3 && !a3) {
      if (i4 === "(") r2++;
      else if (i4 === ")" && (r2--, r2 === 0)) return s3;
    }
    s3++;
  }
  return -1;
}
async function Oe$6(e5, t4) {
  let r2 = new T$9(), s3;
  try {
    s3 = r2.parse(t4);
  } catch {
    return "";
  }
  let n3 = e5.state.bashPid;
  e5.state.bashPid = e5.state.nextVirtualPid++;
  let a3 = { ...e5.state.env }, i4 = e5.state.cwd, l3 = e5.state.suppressVerbose;
  e5.state.suppressVerbose = true;
  try {
    let o2 = await e5.executeScript(s3), c3 = o2.exitCode;
    return e5.state.env = a3, e5.state.cwd = i4, e5.state.suppressVerbose = l3, e5.state.lastExitCode = c3, e5.state.env["?"] = String(c3), o2.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + o2.stderr), e5.state.bashPid = n3, o2.stdout.replace(/\n+$/, "");
  } catch (o2) {
    if (e5.state.env = a3, e5.state.cwd = i4, e5.state.bashPid = n3, e5.state.suppressVerbose = l3, o2 instanceof b$i) throw o2;
    return o2 instanceof d$8 ? (e5.state.lastExitCode = o2.exitCode, e5.state.env["?"] = String(o2.exitCode), o2.stdout?.replace(/\n+$/, "") ?? "") : "";
  }
}
function St$3(e5, t4) {
  let r2 = "", s3 = 0;
  for (; s3 < t4.length; ) {
    let n3 = t4[s3];
    if (n3 === "'") {
      let a3 = t4.indexOf("'", s3 + 1);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 1, a3);
        r2 += U$8(i4), s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === '"') {
      let a3 = -1, i4 = s3 + 1;
      for (; i4 < t4.length; ) {
        if (t4[i4] === "\\") {
          i4 += 2;
          continue;
        }
        if (t4[i4] === '"') {
          a3 = i4;
          break;
        }
        i4++;
      }
      if (a3 !== -1) {
        let l3 = t4.slice(s3 + 1, a3), o2 = ms$2(e5, l3);
        r2 += U$8(o2), s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "$" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "{") {
        let i4 = t4.indexOf("}", s3 + 2);
        if (i4 !== -1) {
          let l3 = t4.slice(s3 + 2, i4);
          r2 += e5.state.env[l3] ?? "", s3 = i4 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(a3)) {
        let i4 = s3 + 1;
        for (; i4 < t4.length && /[a-zA-Z0-9_]/.test(t4[i4]); ) i4++;
        let l3 = t4.slice(s3 + 1, i4);
        r2 += e5.state.env[l3] ?? "", s3 = i4;
        continue;
      }
    }
    if (n3 === "\\" && s3 + 1 < t4.length) {
      r2 += n3 + t4[s3 + 1], s3 += 2;
      continue;
    }
    r2 += n3, s3++;
  }
  return r2;
}
function ms$2(e5, t4) {
  let r2 = "", s3 = 0;
  for (; s3 < t4.length; ) {
    let n3 = t4[s3];
    if (n3 === "\\" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "$" || a3 === "`" || a3 === "\\" || a3 === '"') {
        r2 += a3, s3 += 2;
        continue;
      }
      r2 += n3, s3++;
      continue;
    }
    if (n3 === "$" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "{") {
        let i4 = t4.indexOf("}", s3 + 2);
        if (i4 !== -1) {
          let l3 = t4.slice(s3 + 2, i4);
          r2 += e5.state.env[l3] ?? "", s3 = i4 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(a3)) {
        let i4 = s3 + 1;
        for (; i4 < t4.length && /[a-zA-Z0-9_]/.test(t4[i4]); ) i4++;
        let l3 = t4.slice(s3 + 1, i4);
        r2 += e5.state.env[l3] ?? "", s3 = i4;
        continue;
      }
    }
    r2 += n3, s3++;
  }
  return r2;
}
async function On$1(e5, t4) {
  let r2 = "", s3 = 0;
  for (; s3 < t4.length; ) {
    let n3 = t4[s3];
    if (n3 === "'") {
      let a3 = t4.indexOf("'", s3 + 1);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 1, a3);
        r2 += U$8(i4), s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === '"') {
      let a3 = -1, i4 = s3 + 1;
      for (; i4 < t4.length; ) {
        if (t4[i4] === "\\") {
          i4 += 2;
          continue;
        }
        if (t4[i4] === '"') {
          a3 = i4;
          break;
        }
        i4++;
      }
      if (a3 !== -1) {
        let l3 = t4.slice(s3 + 1, a3), o2 = await gs$1(e5, l3);
        r2 += U$8(o2), s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "$" && s3 + 1 < t4.length && t4[s3 + 1] === "(") {
      let a3 = Cn$1(t4, s3 + 2);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 2, a3), l3 = await Oe$6(e5, i4);
        r2 += l3, s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "`") {
      let a3 = t4.indexOf("`", s3 + 1);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 1, a3), l3 = await Oe$6(e5, i4);
        r2 += l3, s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "$" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "{") {
        let i4 = t4.indexOf("}", s3 + 2);
        if (i4 !== -1) {
          let l3 = t4.slice(s3 + 2, i4);
          r2 += e5.state.env[l3] ?? "", s3 = i4 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(a3)) {
        let i4 = s3 + 1;
        for (; i4 < t4.length && /[a-zA-Z0-9_]/.test(t4[i4]); ) i4++;
        let l3 = t4.slice(s3 + 1, i4);
        r2 += e5.state.env[l3] ?? "", s3 = i4;
        continue;
      }
    }
    if (n3 === "\\" && s3 + 1 < t4.length) {
      r2 += n3 + t4[s3 + 1], s3 += 2;
      continue;
    }
    r2 += n3, s3++;
  }
  return r2;
}
async function gs$1(e5, t4) {
  let r2 = "", s3 = 0;
  for (; s3 < t4.length; ) {
    let n3 = t4[s3];
    if (n3 === "\\" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "$" || a3 === "`" || a3 === "\\" || a3 === '"') {
        r2 += a3, s3 += 2;
        continue;
      }
      r2 += n3, s3++;
      continue;
    }
    if (n3 === "$" && s3 + 1 < t4.length && t4[s3 + 1] === "(") {
      let a3 = Cn$1(t4, s3 + 2);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 2, a3), l3 = await Oe$6(e5, i4);
        r2 += l3, s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "`") {
      let a3 = t4.indexOf("`", s3 + 1);
      if (a3 !== -1) {
        let i4 = t4.slice(s3 + 1, a3), l3 = await Oe$6(e5, i4);
        r2 += l3, s3 = a3 + 1;
        continue;
      }
    }
    if (n3 === "$" && s3 + 1 < t4.length) {
      let a3 = t4[s3 + 1];
      if (a3 === "{") {
        let i4 = t4.indexOf("}", s3 + 2);
        if (i4 !== -1) {
          let l3 = t4.slice(s3 + 2, i4);
          r2 += e5.state.env[l3] ?? "", s3 = i4 + 1;
          continue;
        }
      } else if (/[a-zA-Z_]/.test(a3)) {
        let i4 = s3 + 1;
        for (; i4 < t4.length && /[a-zA-Z0-9_]/.test(t4[i4]); ) i4++;
        let l3 = t4.slice(s3 + 1, i4);
        r2 += e5.state.env[l3] ?? "", s3 = i4;
        continue;
      }
    }
    r2 += n3, s3++;
  }
  return r2;
}
function Ln$1(e5, t4) {
  if (!t4.startsWith("~")) return t4;
  let r2 = e5.state.env.HOME !== void 0 ? e5.state.env.HOME : "/home/user";
  if (t4 === "~" || t4.startsWith("~/")) return r2 + t4.slice(1);
  let s3 = 1;
  for (; s3 < t4.length && /[a-zA-Z0-9_-]/.test(t4[s3]); ) s3++;
  let n3 = t4.slice(1, s3), a3 = t4.slice(s3);
  return a3 !== "" && !a3.startsWith("/") ? t4 : n3 === "root" ? `/root${a3}` : t4;
}
async function ys$1(e5, t4, r2, s3) {
  let n3 = "";
  for (let a3 of t4.parts) if (a3.type === "Glob") n3 += k$b(a3.pattern, true, e5.state.shoptOptions.extglob);
  else if (a3.type === "Literal") n3 += k$b(a3.value, true, e5.state.shoptOptions.extglob);
  else if (a3.type === "SingleQuoted" || a3.type === "Escaped") n3 += I$e(a3.value);
  else if (a3.type === "DoubleQuoted") {
    let i4 = await r2(e5, a3.parts);
    n3 += I$e(i4);
  } else if (a3.type === "ParameterExpansion") {
    let i4 = await s3(e5, a3);
    n3 += k$b(i4, true, e5.state.shoptOptions.extglob);
  } else {
    let i4 = await s3(e5, a3);
    n3 += I$e(i4);
  }
  return n3;
}
async function Wn$2(e5, t4, r2, s3) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0];
  if (n3.parts.length !== 1 || n3.parts[0].type !== "ParameterExpansion" || n3.parts[0].operation?.type !== "PatternReplacement") return null;
  let a3 = n3.parts[0], i4 = a3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!i4) return null;
  let l3 = i4[1], o2 = i4[2] === "*", c3 = a3.operation, u3 = P$g(e5, l3), f3 = u3.map(([, E2]) => E2);
  if (u3.length === 0) {
    let E2 = e5.state.env[l3];
    E2 !== void 0 && f3.push(E2);
  }
  if (f3.length === 0) return { values: [], quoted: true };
  let h3 = "";
  c3.pattern && (h3 = await ys$1(e5, c3.pattern, r2, s3));
  let d3 = c3.replacement ? await r2(e5, c3.replacement.parts) : "", y2 = h3;
  c3.anchor === "start" ? y2 = `^${h3}` : c3.anchor === "end" && (y2 = `${h3}$`);
  let g2 = [];
  try {
    let E2 = new RegExp(y2, c3.all ? "g" : "");
    for (let S3 of f3) g2.push(S3.replace(E2, d3));
  } catch {
    g2.push(...f3);
  }
  if (o2) {
    let E2 = N$b(e5.state.env);
    return { values: [g2.join(E2)], quoted: true };
  }
  return { values: g2, quoted: true };
}
async function Tn$1(e5, t4, r2, s3) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0];
  if (n3.parts.length !== 1 || n3.parts[0].type !== "ParameterExpansion" || n3.parts[0].operation?.type !== "PatternRemoval") return null;
  let a3 = n3.parts[0], i4 = a3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!i4) return null;
  let l3 = i4[1], o2 = i4[2] === "*", c3 = a3.operation, u3 = P$g(e5, l3), f3 = u3.map(([, g2]) => g2);
  if (u3.length === 0) {
    let g2 = e5.state.env[l3];
    g2 !== void 0 && f3.push(g2);
  }
  if (f3.length === 0) return { values: [], quoted: true };
  let h3 = "", d3 = e5.state.shoptOptions.extglob;
  if (c3.pattern) for (let g2 of c3.pattern.parts) if (g2.type === "Glob") h3 += k$b(g2.pattern, c3.greedy, d3);
  else if (g2.type === "Literal") h3 += k$b(g2.value, c3.greedy, d3);
  else if (g2.type === "SingleQuoted" || g2.type === "Escaped") h3 += I$e(g2.value);
  else if (g2.type === "DoubleQuoted") {
    let E2 = await r2(e5, g2.parts);
    h3 += I$e(E2);
  } else if (g2.type === "ParameterExpansion") {
    let E2 = await s3(e5, g2);
    h3 += k$b(E2, c3.greedy, d3);
  } else {
    let E2 = await s3(e5, g2);
    h3 += I$e(E2);
  }
  let y2 = [];
  for (let g2 of f3) y2.push(ne$7(g2, h3, c3.side, c3.greedy));
  if (o2) {
    let g2 = N$b(e5.state.env);
    return { values: [y2.join(g2)], quoted: true };
  }
  return { values: y2, quoted: true };
}
async function Mn$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let r2 = t4[0];
  if (r2.parts.length !== 1 || r2.parts[0].type !== "ParameterExpansion" || r2.parts[0].operation?.type !== "DefaultValue" && r2.parts[0].operation?.type !== "UseAlternative" && r2.parts[0].operation?.type !== "AssignDefault") return null;
  let s3 = r2.parts[0], n3 = s3.operation, a3 = s3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/), i4, l3 = false;
  if (a3) {
    let o2 = a3[1];
    l3 = a3[2] === "*";
    let c3 = P$g(e5, o2), u3 = c3.length > 0 || e5.state.env[o2] !== void 0, f3 = c3.length === 0 || c3.length === 1 && c3.every(([, d3]) => d3 === ""), h3 = n3.checkEmpty ?? false;
    if (n3.type === "UseAlternative" ? i4 = u3 && !(h3 && f3) : i4 = !u3 || h3 && f3, !i4) {
      if (c3.length > 0) {
        let y2 = c3.map(([, g2]) => g2);
        if (l3) {
          let g2 = N$b(e5.state.env);
          return { values: [y2.join(g2)], quoted: true };
        }
        return { values: y2, quoted: true };
      }
      let d3 = e5.state.env[o2];
      return d3 !== void 0 ? { values: [d3], quoted: true } : { values: [], quoted: true };
    }
  } else {
    let o2 = s3.parameter, c3 = await Y$a(e5, o2), u3 = await v$b(e5, o2), f3 = u3 === "", h3 = n3.checkEmpty ?? false;
    if (n3.type === "UseAlternative" ? i4 = c3 && !(h3 && f3) : i4 = !c3 || h3 && f3, !i4) return { values: [u3], quoted: true };
  }
  if (i4 && n3.word) {
    let o2 = n3.word.parts, c3 = null, u3 = false;
    for (let f3 of o2) if (f3.type === "ParameterExpansion" && !f3.operation) {
      let h3 = f3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (h3) {
        c3 = h3[1], u3 = h3[2] === "*";
        break;
      }
    }
    if (c3) {
      let f3 = P$g(e5, c3);
      if (f3.length > 0) {
        let d3 = f3.map(([, y2]) => y2);
        if (u3 || l3) {
          let y2 = N$b(e5.state.env);
          return { values: [d3.join(y2)], quoted: true };
        }
        return { values: d3, quoted: true };
      }
      let h3 = e5.state.env[c3];
      return h3 !== void 0 ? { values: [h3], quoted: true } : { values: [], quoted: true };
    }
  }
  return null;
}
async function Vn$1(e5, t4, r2, s3, n3) {
  if (!r2 || t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let a3 = t4[0], i4 = -1, l3 = "", o2 = false, c3 = null;
  for (let g2 = 0; g2 < a3.parts.length; g2++) {
    let E2 = a3.parts[g2];
    if (E2.type === "ParameterExpansion" && (E2.operation?.type === "PatternRemoval" || E2.operation?.type === "PatternReplacement")) {
      let S3 = E2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (S3) {
        i4 = g2, l3 = S3[1], o2 = S3[2] === "*", c3 = E2.operation;
        break;
      }
    }
  }
  if (i4 === -1 || i4 === 0 && i4 === a3.parts.length - 1) return null;
  let u3 = "";
  for (let g2 = 0; g2 < i4; g2++) u3 += await s3(e5, a3.parts[g2]);
  let f3 = "";
  for (let g2 = i4 + 1; g2 < a3.parts.length; g2++) f3 += await s3(e5, a3.parts[g2]);
  let h3 = P$g(e5, l3), d3 = h3.map(([, g2]) => g2);
  if (h3.length === 0) {
    let g2 = e5.state.env[l3];
    if (g2 !== void 0) d3 = [g2];
    else {
      if (o2) return { values: [u3 + f3], quoted: true };
      let E2 = u3 + f3;
      return { values: E2 ? [E2] : [], quoted: true };
    }
  }
  if (c3?.type === "PatternRemoval") {
    let g2 = c3, E2 = "", S3 = e5.state.shoptOptions.extglob;
    if (g2.pattern) for (let m3 of g2.pattern.parts) if (m3.type === "Glob") E2 += k$b(m3.pattern, g2.greedy, S3);
    else if (m3.type === "Literal") E2 += k$b(m3.value, g2.greedy, S3);
    else if (m3.type === "SingleQuoted" || m3.type === "Escaped") E2 += I$e(m3.value);
    else if (m3.type === "DoubleQuoted") {
      let A2 = await n3(e5, m3.parts);
      E2 += I$e(A2);
    } else if (m3.type === "ParameterExpansion") {
      let A2 = await s3(e5, m3);
      E2 += k$b(A2, g2.greedy, S3);
    } else {
      let A2 = await s3(e5, m3);
      E2 += I$e(A2);
    }
    d3 = d3.map((m3) => ne$7(m3, E2, g2.side, g2.greedy));
  } else if (c3?.type === "PatternReplacement") {
    let g2 = c3, E2 = "";
    if (g2.pattern) for (let A2 of g2.pattern.parts) if (A2.type === "Glob") E2 += k$b(A2.pattern, true, e5.state.shoptOptions.extglob);
    else if (A2.type === "Literal") E2 += k$b(A2.value, true, e5.state.shoptOptions.extglob);
    else if (A2.type === "SingleQuoted" || A2.type === "Escaped") E2 += I$e(A2.value);
    else if (A2.type === "DoubleQuoted") {
      let w4 = await n3(e5, A2.parts);
      E2 += I$e(w4);
    } else if (A2.type === "ParameterExpansion") {
      let w4 = await s3(e5, A2);
      E2 += k$b(w4, true, e5.state.shoptOptions.extglob);
    } else {
      let w4 = await s3(e5, A2);
      E2 += I$e(w4);
    }
    let S3 = g2.replacement ? await n3(e5, g2.replacement.parts) : "", m3 = E2;
    g2.anchor === "start" ? m3 = `^${E2}` : g2.anchor === "end" && (m3 = `${E2}$`);
    try {
      let A2 = new RegExp(m3, g2.all ? "g" : "");
      d3 = d3.map((w4) => w4.replace(A2, S3));
    } catch {
    }
  }
  if (o2) {
    let g2 = N$b(e5.state.env);
    return { values: [u3 + d3.join(g2) + f3], quoted: true };
  }
  return d3.length === 1 ? { values: [u3 + d3[0] + f3], quoted: true } : { values: [u3 + d3[0], ...d3.slice(1, -1), d3[d3.length - 1] + f3], quoted: true };
}
async function qn$2(e5, t4, r2, s3) {
  if (!r2 || t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0], a3 = -1, i4 = "", l3 = false;
  for (let d3 = 0; d3 < n3.parts.length; d3++) {
    let y2 = n3.parts[d3];
    if (y2.type === "ParameterExpansion" && !y2.operation) {
      let g2 = y2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (g2) {
        a3 = d3, i4 = g2[1], l3 = g2[2] === "*";
        break;
      }
    }
  }
  if (a3 === -1) return null;
  let o2 = "";
  for (let d3 = 0; d3 < a3; d3++) o2 += await s3(e5, n3.parts[d3]);
  let c3 = "";
  for (let d3 = a3 + 1; d3 < n3.parts.length; d3++) c3 += await s3(e5, n3.parts[d3]);
  let u3 = P$g(e5, i4), f3 = u3.map(([, d3]) => d3);
  if (u3.length === 0) {
    let d3 = e5.state.env[i4];
    if (d3 !== void 0) return { values: [o2 + d3 + c3], quoted: true };
    if (l3) return { values: [o2 + c3], quoted: true };
    let y2 = o2 + c3;
    return { values: y2 ? [y2] : [], quoted: true };
  }
  if (l3) {
    let d3 = N$b(e5.state.env);
    return { values: [o2 + f3.join(d3) + c3], quoted: true };
  }
  return f3.length === 1 ? { values: [o2 + f3[0] + c3], quoted: true } : { values: [o2 + f3[0], ...f3.slice(1, -1), f3[f3.length - 1] + c3], quoted: true };
}
async function Bn$2(e5, t4, r2) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let s3 = t4[0];
  if (s3.parts.length !== 1 || s3.parts[0].type !== "ParameterExpansion" || s3.parts[0].operation?.type !== "Substring") return null;
  let n3 = s3.parts[0], a3 = n3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!a3) return null;
  let i4 = a3[1], l3 = a3[2] === "*", o2 = n3.operation;
  if (e5.state.associativeArrays?.has(i4)) throw new d$8(1, "", `bash: \${${i4}[@]: 0: 3}: bad substitution
`);
  let c3 = o2.offset ? await r2(e5, o2.offset.expression) : 0, u3 = o2.length ? await r2(e5, o2.length.expression) : void 0, f3 = P$g(e5, i4), h3 = 0;
  if (c3 < 0) {
    if (f3.length > 0) {
      let y2 = f3[f3.length - 1][0], E2 = (typeof y2 == "number" ? y2 : 0) + 1 + c3;
      if (E2 < 0) return { values: [], quoted: true };
      h3 = f3.findIndex(([S3]) => typeof S3 == "number" && S3 >= E2), h3 < 0 && (h3 = f3.length);
    }
  } else h3 = f3.findIndex(([y2]) => typeof y2 == "number" && y2 >= c3), h3 < 0 && (h3 = f3.length);
  let d3;
  if (u3 !== void 0) {
    if (u3 < 0) throw new p$f(`${i4}[@]: substring expression < 0`);
    d3 = f3.slice(h3, h3 + u3).map(([, y2]) => y2);
  } else d3 = f3.slice(h3).map(([, y2]) => y2);
  if (d3.length === 0) return { values: [], quoted: true };
  if (l3) {
    let y2 = N$b(e5.state.env);
    return { values: [d3.join(y2)], quoted: true };
  }
  return { values: d3, quoted: true };
}
function Fn$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let r2 = t4[0];
  if (r2.parts.length !== 1 || r2.parts[0].type !== "ParameterExpansion" || r2.parts[0].operation?.type !== "Transform") return null;
  let s3 = r2.parts[0], n3 = s3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!n3) return null;
  let a3 = n3[1], i4 = n3[2] === "*", l3 = s3.operation, o2 = P$g(e5, a3);
  if (o2.length === 0) {
    let f3 = e5.state.env[a3];
    if (f3 !== void 0) {
      let h3;
      switch (l3.operator) {
        case "a":
          h3 = "";
          break;
        case "P":
          h3 = Ee$6(e5, f3);
          break;
        case "Q":
          h3 = ie$8(f3);
          break;
        default:
          h3 = f3;
      }
      return { values: [h3], quoted: true };
    }
    return i4 ? { values: [""], quoted: true } : { values: [], quoted: true };
  }
  let c3 = ae$5(e5, a3), u3;
  switch (l3.operator) {
    case "a":
      u3 = o2.map(() => c3);
      break;
    case "P":
      u3 = o2.map(([, f3]) => Ee$6(e5, f3));
      break;
    case "Q":
      u3 = o2.map(([, f3]) => ie$8(f3));
      break;
    case "u":
      u3 = o2.map(([, f3]) => f3.charAt(0).toUpperCase() + f3.slice(1));
      break;
    case "U":
      u3 = o2.map(([, f3]) => f3.toUpperCase());
      break;
    case "L":
      u3 = o2.map(([, f3]) => f3.toLowerCase());
      break;
    default:
      u3 = o2.map(([, f3]) => f3);
  }
  if (i4) {
    let f3 = N$b(e5.state.env);
    return { values: [u3.join(f3)], quoted: true };
  }
  return { values: u3, quoted: true };
}
function Qn$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let r2 = t4[0];
  if (r2.parts.length !== 1 || r2.parts[0].type !== "ParameterExpansion") return null;
  let s3 = r2.parts[0];
  if (s3.operation) return null;
  let n3 = s3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!n3) return null;
  let a3 = n3[1];
  if (C$g(e5, a3)) {
    let o2 = ge$5(e5, a3);
    if (o2?.endsWith("[@]") || o2?.endsWith("[*]")) return { values: [], quoted: true };
  }
  let i4 = P$g(e5, a3);
  if (i4.length > 0) return { values: i4.map(([, o2]) => o2), quoted: true };
  let l3 = e5.state.env[a3];
  return l3 !== void 0 ? { values: [l3], quoted: true } : { values: [], quoted: true };
}
function zn$2(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let r2 = t4[0];
  if (r2.parts.length !== 1 || r2.parts[0].type !== "ParameterExpansion" || r2.parts[0].operation) return null;
  let n3 = r2.parts[0].parameter;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n3) || !C$g(e5, n3)) return null;
  let a3 = ge$5(e5, n3);
  if (!a3) return null;
  let i4 = a3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(@)\]$/);
  if (!i4) return null;
  let l3 = i4[1], o2 = P$g(e5, l3);
  if (o2.length > 0) return { values: o2.map(([, u3]) => u3), quoted: true };
  let c3 = e5.state.env[l3];
  return c3 !== void 0 ? { values: [c3], quoted: true } : { values: [], quoted: true };
}
async function Zn$1(e5, t4, r2, s3, n3) {
  if (!r2 || t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let a3 = t4[0];
  if (a3.parts.length !== 1 || a3.parts[0].type !== "ParameterExpansion" || a3.parts[0].operation?.type !== "Indirection") return null;
  let i4 = a3.parts[0], l3 = i4.operation, o2 = await v$b(e5, i4.parameter), c3 = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c3) {
    if (!l3.innerOp && (o2 === "@" || o2 === "*")) {
      let y2 = Number.parseInt(e5.state.env["#"] || "0", 10), g2 = [];
      for (let E2 = 1; E2 <= y2; E2++) g2.push(e5.state.env[String(E2)] || "");
      return o2 === "*" ? { values: [g2.join(N$b(e5.state.env))], quoted: true } : { values: g2, quoted: true };
    }
    return null;
  }
  let u3 = c3[1], f3 = c3[2] === "*", h3 = P$g(e5, u3);
  if (l3.innerOp) {
    if (l3.innerOp.type === "Substring") return Es$1(e5, h3, u3, f3, l3.innerOp);
    if (l3.innerOp.type === "DefaultValue" || l3.innerOp.type === "UseAlternative" || l3.innerOp.type === "AssignDefault" || l3.innerOp.type === "ErrorIfUnset") return As$1(e5, h3, u3, f3, l3.innerOp, n3);
    if (l3.innerOp.type === "Transform" && l3.innerOp.operator === "a") {
      let g2 = ae$5(e5, u3), E2 = h3.map(() => g2);
      return f3 ? { values: [E2.join(N$b(e5.state.env))], quoted: true } : { values: E2, quoted: true };
    }
    let y2 = [];
    for (let [, g2] of h3) {
      let E2 = { type: "ParameterExpansion", parameter: "_indirect_elem_", operation: l3.innerOp }, S3 = e5.state.env._indirect_elem_;
      e5.state.env._indirect_elem_ = g2;
      try {
        let m3 = await s3(e5, E2, true);
        y2.push(m3);
      } finally {
        S3 !== void 0 ? e5.state.env._indirect_elem_ = S3 : delete e5.state.env._indirect_elem_;
      }
    }
    return f3 ? { values: [y2.join(N$b(e5.state.env))], quoted: true } : { values: y2, quoted: true };
  }
  if (h3.length > 0) {
    let y2 = h3.map(([, g2]) => g2);
    return f3 ? { values: [y2.join(N$b(e5.state.env))], quoted: true } : { values: y2, quoted: true };
  }
  let d3 = e5.state.env[u3];
  return d3 !== void 0 ? { values: [d3], quoted: true } : { values: [], quoted: true };
}
async function Es$1(e5, t4, r2, s3, n3) {
  let a3 = n3.offset ? await R$a(e5, n3.offset.expression) : 0, i4 = n3.length ? await R$a(e5, n3.length.expression) : void 0, l3 = 0;
  if (a3 < 0) {
    if (t4.length > 0) {
      let u3 = t4[t4.length - 1][0], h3 = (typeof u3 == "number" ? u3 : 0) + 1 + a3;
      if (h3 < 0) return { values: [], quoted: true };
      if (l3 = t4.findIndex(([d3]) => typeof d3 == "number" && d3 >= h3), l3 < 0) return { values: [], quoted: true };
    }
  } else if (l3 = t4.findIndex(([u3]) => typeof u3 == "number" && u3 >= a3), l3 < 0) return { values: [], quoted: true };
  let o2;
  if (i4 !== void 0) {
    if (i4 < 0) throw new p$f(`${r2}[@]: substring expression < 0`);
    o2 = t4.slice(l3, l3 + i4);
  } else o2 = t4.slice(l3);
  let c3 = o2.map(([, u3]) => u3);
  return s3 ? { values: [c3.join(N$b(e5.state.env))], quoted: true } : { values: c3, quoted: true };
}
async function As$1(e5, t4, r2, s3, n3, a3) {
  let i4 = n3.checkEmpty ?? false, l3 = t4.map(([, u3]) => u3), o2 = t4.length === 0, c3 = t4.length === 0;
  if (n3.type === "UseAlternative") return !c3 && !(i4 && o2) && n3.word ? { values: [await a3(e5, n3.word.parts, true)], quoted: true } : { values: [], quoted: true };
  if (n3.type === "DefaultValue") return (c3 || i4 && o2) && n3.word ? { values: [await a3(e5, n3.word.parts, true)], quoted: true } : s3 ? { values: [l3.join(N$b(e5.state.env))], quoted: true } : { values: l3, quoted: true };
  if (n3.type === "AssignDefault") {
    if ((c3 || i4 && o2) && n3.word) {
      let f3 = await a3(e5, n3.word.parts, true);
      return e5.state.env[`${r2}_0`] = f3, e5.state.env[`${r2}__length`] = "1", { values: [f3], quoted: true };
    }
    return s3 ? { values: [l3.join(N$b(e5.state.env))], quoted: true } : { values: l3, quoted: true };
  }
  return s3 ? { values: [l3.join(N$b(e5.state.env))], quoted: true } : { values: l3, quoted: true };
}
async function Gn$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].operation?.type !== "UseAlternative" && t4[0].operation?.type !== "DefaultValue") return null;
  let r2 = t4[0], s3 = r2.operation, n3 = s3?.word;
  if (!n3 || n3.parts.length !== 1 || n3.parts[0].type !== "DoubleQuoted") return null;
  let a3 = n3.parts[0];
  if (a3.parts.length !== 1 || a3.parts[0].type !== "ParameterExpansion" || a3.parts[0].operation?.type !== "Indirection") return null;
  let i4 = a3.parts[0], o2 = (await v$b(e5, i4.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!o2) return null;
  let c3 = await Y$a(e5, r2.parameter), u3 = await v$b(e5, r2.parameter) === "", f3 = s3.checkEmpty ?? false, h3;
  if (s3.type === "UseAlternative" ? h3 = c3 && !(f3 && u3) : h3 = !c3 || f3 && u3, h3) {
    let d3 = o2[1], y2 = o2[2] === "*", g2 = P$g(e5, d3);
    if (g2.length > 0) {
      let S3 = g2.map(([, m3]) => m3);
      return y2 ? { values: [S3.join(N$b(e5.state.env))], quoted: true } : { values: S3, quoted: true };
    }
    let E2 = e5.state.env[d3];
    return E2 !== void 0 ? { values: [E2], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
async function Un$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].operation?.type !== "Indirection") return null;
  let r2 = t4[0], n3 = r2.operation.innerOp;
  if (!n3 || n3.type !== "UseAlternative" && n3.type !== "DefaultValue") return null;
  let a3 = n3.word;
  if (!a3 || a3.parts.length !== 1 || a3.parts[0].type !== "DoubleQuoted") return null;
  let i4 = a3.parts[0];
  if (i4.parts.length !== 1 || i4.parts[0].type !== "ParameterExpansion" || i4.parts[0].operation?.type !== "Indirection") return null;
  let l3 = i4.parts[0], c3 = (await v$b(e5, l3.parameter)).match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!c3) return null;
  let u3 = await v$b(e5, r2.parameter), f3 = await Y$a(e5, r2.parameter), h3 = u3 === "", d3 = n3.checkEmpty ?? false, y2;
  if (n3.type === "UseAlternative" ? y2 = f3 && !(d3 && h3) : y2 = !f3 || d3 && h3, y2) {
    let g2 = c3[1], E2 = c3[2] === "*", S3 = P$g(e5, g2);
    if (S3.length > 0) {
      let A2 = S3.map(([, w4]) => w4);
      return E2 ? { values: [A2.join(N$b(e5.state.env))], quoted: true } : { values: A2, quoted: true };
    }
    let m3 = e5.state.env[g2];
    return m3 !== void 0 ? { values: [m3], quoted: true } : { values: [], quoted: true };
  }
  return { values: [], quoted: false };
}
function jn$1(e5) {
  let t4 = Number.parseInt(e5.state.env["#"] || "0", 10), r2 = [];
  for (let s3 = 1; s3 <= t4; s3++) r2.push(e5.state.env[String(s3)] || "");
  return r2;
}
async function Hn$1(e5, t4, r2, s3) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0], a3 = -1, i4 = false;
  for (let m3 = 0; m3 < n3.parts.length; m3++) {
    let A2 = n3.parts[m3];
    if (A2.type === "ParameterExpansion" && (A2.parameter === "@" || A2.parameter === "*") && A2.operation?.type === "Substring") {
      a3 = m3, i4 = A2.parameter === "*";
      break;
    }
  }
  if (a3 === -1) return null;
  let o2 = n3.parts[a3].operation, c3 = o2.offset ? await r2(e5, o2.offset.expression) : 0, u3 = o2.length ? await r2(e5, o2.length.expression) : void 0, f3 = Number.parseInt(e5.state.env["#"] || "0", 10), h3 = [];
  for (let m3 = 1; m3 <= f3; m3++) h3.push(e5.state.env[String(m3)] || "");
  let d3 = e5.state.env[0] || "bash", y2;
  if (c3 <= 0) {
    let m3 = [d3, ...h3], A2 = m3.length + c3;
    if (A2 < 0) y2 = [];
    else {
      let w4 = c3 < 0 ? A2 : 0;
      if (u3 !== void 0) {
        let L4 = u3 < 0 ? m3.length + u3 : w4 + u3;
        y2 = m3.slice(w4, Math.max(w4, L4));
      } else y2 = m3.slice(w4);
    }
  } else {
    let m3 = c3 - 1;
    if (m3 >= h3.length) y2 = [];
    else if (u3 !== void 0) {
      let A2 = u3 < 0 ? h3.length + u3 : m3 + u3;
      y2 = h3.slice(m3, Math.max(m3, A2));
    } else y2 = h3.slice(m3);
  }
  let g2 = "";
  for (let m3 = 0; m3 < a3; m3++) g2 += await s3(e5, n3.parts[m3]);
  let E2 = "";
  for (let m3 = a3 + 1; m3 < n3.parts.length; m3++) E2 += await s3(e5, n3.parts[m3]);
  if (y2.length === 0) {
    let m3 = g2 + E2;
    return { values: m3 ? [m3] : [], quoted: true };
  }
  if (i4) {
    let m3 = N$b(e5.state.env);
    return { values: [g2 + y2.join(m3) + E2], quoted: true };
  }
  return y2.length === 1 ? { values: [g2 + y2[0] + E2], quoted: true } : { values: [g2 + y2[0], ...y2.slice(1, -1), y2[y2.length - 1] + E2], quoted: true };
}
async function Kn$1(e5, t4, r2, s3) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0], a3 = -1, i4 = false;
  for (let S3 = 0; S3 < n3.parts.length; S3++) {
    let m3 = n3.parts[S3];
    if (m3.type === "ParameterExpansion" && (m3.parameter === "@" || m3.parameter === "*") && m3.operation?.type === "PatternReplacement") {
      a3 = S3, i4 = m3.parameter === "*";
      break;
    }
  }
  if (a3 === -1) return null;
  let o2 = n3.parts[a3].operation, c3 = jn$1(e5), u3 = "";
  for (let S3 = 0; S3 < a3; S3++) u3 += await r2(e5, n3.parts[S3]);
  let f3 = "";
  for (let S3 = a3 + 1; S3 < n3.parts.length; S3++) f3 += await r2(e5, n3.parts[S3]);
  if (c3.length === 0) {
    let S3 = u3 + f3;
    return { values: S3 ? [S3] : [], quoted: true };
  }
  let h3 = "";
  if (o2.pattern) for (let S3 of o2.pattern.parts) if (S3.type === "Glob") h3 += k$b(S3.pattern, true, e5.state.shoptOptions.extglob);
  else if (S3.type === "Literal") h3 += k$b(S3.value, true, e5.state.shoptOptions.extglob);
  else if (S3.type === "SingleQuoted" || S3.type === "Escaped") h3 += I$e(S3.value);
  else if (S3.type === "DoubleQuoted") {
    let m3 = await s3(e5, S3.parts);
    h3 += I$e(m3);
  } else if (S3.type === "ParameterExpansion") {
    let m3 = await r2(e5, S3);
    h3 += k$b(m3, true, e5.state.shoptOptions.extglob);
  } else {
    let m3 = await r2(e5, S3);
    h3 += I$e(m3);
  }
  let d3 = o2.replacement ? await s3(e5, o2.replacement.parts) : "", y2 = h3;
  o2.anchor === "start" ? y2 = `^${h3}` : o2.anchor === "end" && (y2 = `${h3}$`);
  let g2 = [];
  try {
    let S3 = new RegExp(y2, o2.all ? "g" : "");
    for (let m3 of c3) g2.push(m3.replace(S3, d3));
  } catch {
    g2.push(...c3);
  }
  if (i4) {
    let S3 = N$b(e5.state.env);
    return { values: [u3 + g2.join(S3) + f3], quoted: true };
  }
  return g2.length === 1 ? { values: [u3 + g2[0] + f3], quoted: true } : { values: [u3 + g2[0], ...g2.slice(1, -1), g2[g2.length - 1] + f3], quoted: true };
}
async function Xn$1(e5, t4, r2, s3) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let n3 = t4[0], a3 = -1, i4 = false;
  for (let E2 = 0; E2 < n3.parts.length; E2++) {
    let S3 = n3.parts[E2];
    if (S3.type === "ParameterExpansion" && (S3.parameter === "@" || S3.parameter === "*") && S3.operation?.type === "PatternRemoval") {
      a3 = E2, i4 = S3.parameter === "*";
      break;
    }
  }
  if (a3 === -1) return null;
  let o2 = n3.parts[a3].operation, c3 = jn$1(e5), u3 = "";
  for (let E2 = 0; E2 < a3; E2++) u3 += await r2(e5, n3.parts[E2]);
  let f3 = "";
  for (let E2 = a3 + 1; E2 < n3.parts.length; E2++) f3 += await r2(e5, n3.parts[E2]);
  if (c3.length === 0) {
    let E2 = u3 + f3;
    return { values: E2 ? [E2] : [], quoted: true };
  }
  let h3 = "", d3 = e5.state.shoptOptions.extglob;
  if (o2.pattern) for (let E2 of o2.pattern.parts) if (E2.type === "Glob") h3 += k$b(E2.pattern, o2.greedy, d3);
  else if (E2.type === "Literal") h3 += k$b(E2.value, o2.greedy, d3);
  else if (E2.type === "SingleQuoted" || E2.type === "Escaped") h3 += I$e(E2.value);
  else if (E2.type === "DoubleQuoted") {
    let S3 = await s3(e5, E2.parts);
    h3 += I$e(S3);
  } else if (E2.type === "ParameterExpansion") {
    let S3 = await r2(e5, E2);
    h3 += k$b(S3, o2.greedy, d3);
  } else {
    let S3 = await r2(e5, E2);
    h3 += I$e(S3);
  }
  let y2 = [];
  for (let E2 of c3) y2.push(ne$7(E2, h3, o2.side, o2.greedy));
  if (i4) {
    let E2 = N$b(e5.state.env);
    return { values: [u3 + y2.join(E2) + f3], quoted: true };
  }
  return y2.length === 1 ? { values: [u3 + y2[0] + f3], quoted: true } : { values: [u3 + y2[0], ...y2.slice(1, -1), y2[y2.length - 1] + f3], quoted: true };
}
async function Jn$2(e5, t4, r2) {
  if (t4.length !== 1 || t4[0].type !== "DoubleQuoted") return null;
  let s3 = t4[0], n3 = -1, a3 = false;
  for (let h3 = 0; h3 < s3.parts.length; h3++) {
    let d3 = s3.parts[h3];
    if (d3.type === "ParameterExpansion" && (d3.parameter === "@" || d3.parameter === "*")) {
      n3 = h3, a3 = d3.parameter === "*";
      break;
    }
  }
  if (n3 === -1) return null;
  let i4 = s3.parts[n3];
  if (i4.type === "ParameterExpansion" && i4.operation) return null;
  let l3 = Number.parseInt(e5.state.env["#"] || "0", 10), o2 = "";
  for (let h3 = 0; h3 < n3; h3++) o2 += await r2(e5, s3.parts[h3]);
  let c3 = "";
  for (let h3 = n3 + 1; h3 < s3.parts.length; h3++) c3 += await r2(e5, s3.parts[h3]);
  if (l3 === 0) {
    if (a3) return { values: [o2 + c3], quoted: true };
    let h3 = o2 + c3;
    return { values: h3 ? [h3] : [], quoted: true };
  }
  let u3 = [];
  for (let h3 = 1; h3 <= l3; h3++) u3.push(e5.state.env[String(h3)] || "");
  if (a3) {
    let h3 = N$b(e5.state.env);
    return { values: [o2 + u3.join(h3) + c3], quoted: true };
  }
  return u3.length === 1 ? { values: [o2 + u3[0] + c3], quoted: true } : { values: [o2 + u3[0], ...u3.slice(1, -1), u3[u3.length - 1] + c3], quoted: true };
}
function Ss$1(e5) {
  return new se$7(e5.fs, e5.state.cwd, e5.state.env, { globstar: e5.state.shoptOptions.globstar, nullglob: e5.state.shoptOptions.nullglob, failglob: e5.state.shoptOptions.failglob, dotglob: e5.state.shoptOptions.dotglob, extglob: e5.state.shoptOptions.extglob, globskipdots: e5.state.shoptOptions.globskipdots });
}
async function Le$5(e5, t4) {
  if (e5.state.options.noglob) return t4;
  let r2 = Ss$1(e5), s3 = [];
  for (let n3 of t4) if (ee$4(n3, e5.state.shoptOptions.extglob)) {
    let a3 = await r2.expand(n3);
    if (a3.length > 0) s3.push(...a3);
    else {
      if (r2.hasFailglob()) throw new l$7(n3);
      r2.hasNullglob() || s3.push(n3);
    }
  } else s3.push(n3);
  return s3;
}
async function Yn$1(e5, t4, r2, s3) {
  let n3 = -1, a3 = "", i4 = false;
  for (let m3 = 0; m3 < t4.length; m3++) {
    let A2 = t4[m3];
    if (A2.type === "ParameterExpansion" && A2.operation?.type === "PatternReplacement") {
      let w4 = A2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (w4) {
        n3 = m3, a3 = w4[1], i4 = w4[2] === "*";
        break;
      }
    }
  }
  if (n3 === -1) return null;
  let o2 = t4[n3].operation, c3 = P$g(e5, a3), u3 = c3.map(([, m3]) => m3);
  if (c3.length === 0) {
    let m3 = e5.state.env[a3];
    m3 !== void 0 && (u3 = [m3]);
  }
  if (u3.length === 0) return { values: [], quoted: false };
  let f3 = "";
  if (o2.pattern) for (let m3 of o2.pattern.parts) if (m3.type === "Glob") f3 += k$b(m3.pattern, true, e5.state.shoptOptions.extglob);
  else if (m3.type === "Literal") f3 += k$b(m3.value, true, e5.state.shoptOptions.extglob);
  else if (m3.type === "SingleQuoted" || m3.type === "Escaped") f3 += I$e(m3.value);
  else if (m3.type === "DoubleQuoted") {
    let A2 = await r2(e5, m3.parts);
    f3 += I$e(A2);
  } else if (m3.type === "ParameterExpansion") {
    let A2 = await s3(e5, m3);
    f3 += k$b(A2, true, e5.state.shoptOptions.extglob);
  } else {
    let A2 = await s3(e5, m3);
    f3 += I$e(A2);
  }
  let h3 = o2.replacement ? await r2(e5, o2.replacement.parts) : "", d3 = f3;
  o2.anchor === "start" ? d3 = `^${f3}` : o2.anchor === "end" && (d3 = `${f3}$`);
  let y2 = [];
  try {
    let m3 = new RegExp(d3, o2.all ? "g" : "");
    for (let A2 of u3) y2.push(A2.replace(m3, h3));
  } catch {
    y2.push(...u3);
  }
  let g2 = O$e(e5.state.env), E2 = M$c(e5.state.env);
  if (i4) {
    let m3 = N$b(e5.state.env), A2 = y2.join(m3);
    return E2 ? { values: A2 ? [A2] : [], quoted: false } : { values: D$e(A2, g2), quoted: false };
  }
  if (E2) return { values: y2, quoted: false };
  let S3 = [];
  for (let m3 of y2) m3 === "" ? S3.push("") : S3.push(...D$e(m3, g2));
  return { values: S3, quoted: false };
}
async function er$1(e5, t4, r2, s3) {
  let n3 = -1, a3 = "", i4 = false;
  for (let S3 = 0; S3 < t4.length; S3++) {
    let m3 = t4[S3];
    if (m3.type === "ParameterExpansion" && m3.operation?.type === "PatternRemoval") {
      let A2 = m3.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
      if (A2) {
        n3 = S3, a3 = A2[1], i4 = A2[2] === "*";
        break;
      }
    }
  }
  if (n3 === -1) return null;
  let o2 = t4[n3].operation, c3 = P$g(e5, a3), u3 = c3.map(([, S3]) => S3);
  if (c3.length === 0) {
    let S3 = e5.state.env[a3];
    S3 !== void 0 && (u3 = [S3]);
  }
  if (u3.length === 0) return { values: [], quoted: false };
  let f3 = "", h3 = e5.state.shoptOptions.extglob;
  if (o2.pattern) for (let S3 of o2.pattern.parts) if (S3.type === "Glob") f3 += k$b(S3.pattern, o2.greedy, h3);
  else if (S3.type === "Literal") f3 += k$b(S3.value, o2.greedy, h3);
  else if (S3.type === "SingleQuoted" || S3.type === "Escaped") f3 += I$e(S3.value);
  else if (S3.type === "DoubleQuoted") {
    let m3 = await r2(e5, S3.parts);
    f3 += I$e(m3);
  } else if (S3.type === "ParameterExpansion") {
    let m3 = await s3(e5, S3);
    f3 += k$b(m3, o2.greedy, h3);
  } else {
    let m3 = await s3(e5, S3);
    f3 += I$e(m3);
  }
  let d3 = [];
  for (let S3 of u3) d3.push(ne$7(S3, f3, o2.side, o2.greedy));
  let y2 = O$e(e5.state.env), g2 = M$c(e5.state.env);
  if (i4) {
    let S3 = N$b(e5.state.env), m3 = d3.join(S3);
    return g2 ? { values: m3 ? [m3] : [], quoted: false } : { values: D$e(m3, y2), quoted: false };
  }
  if (g2) return { values: d3, quoted: false };
  let E2 = [];
  for (let S3 of d3) S3 === "" ? E2.push("") : E2.push(...D$e(S3, y2));
  return { values: E2, quoted: false };
}
async function tr$1(e5, t4, r2, s3) {
  let n3 = -1, a3 = false;
  for (let E2 = 0; E2 < t4.length; E2++) {
    let S3 = t4[E2];
    if (S3.type === "ParameterExpansion" && (S3.parameter === "@" || S3.parameter === "*") && S3.operation?.type === "PatternRemoval") {
      n3 = E2, a3 = S3.parameter === "*";
      break;
    }
  }
  if (n3 === -1) return null;
  let l3 = t4[n3].operation, o2 = Number.parseInt(e5.state.env["#"] || "0", 10), c3 = [];
  for (let E2 = 1; E2 <= o2; E2++) c3.push(e5.state.env[String(E2)] || "");
  if (c3.length === 0) return { values: [], quoted: false };
  let u3 = "", f3 = e5.state.shoptOptions.extglob;
  if (l3.pattern) for (let E2 of l3.pattern.parts) if (E2.type === "Glob") u3 += k$b(E2.pattern, l3.greedy, f3);
  else if (E2.type === "Literal") u3 += k$b(E2.value, l3.greedy, f3);
  else if (E2.type === "SingleQuoted" || E2.type === "Escaped") u3 += I$e(E2.value);
  else if (E2.type === "DoubleQuoted") {
    let S3 = await r2(e5, E2.parts);
    u3 += I$e(S3);
  } else if (E2.type === "ParameterExpansion") {
    let S3 = await s3(e5, E2);
    u3 += k$b(S3, l3.greedy, f3);
  } else {
    let S3 = await s3(e5, E2);
    u3 += I$e(S3);
  }
  let h3 = [];
  for (let E2 of c3) h3.push(ne$7(E2, u3, l3.side, l3.greedy));
  let d3 = O$e(e5.state.env), y2 = M$c(e5.state.env);
  if (a3) {
    let E2 = N$b(e5.state.env), S3 = h3.join(E2);
    return y2 ? { values: S3 ? [S3] : [], quoted: false } : { values: D$e(S3, d3), quoted: false };
  }
  if (y2) return { values: h3, quoted: false };
  let g2 = [];
  for (let E2 of h3) E2 === "" ? g2.push("") : g2.push(...D$e(E2, d3));
  return { values: g2, quoted: false };
}
async function nr$1(e5, t4, r2, s3) {
  let n3 = -1, a3 = false;
  for (let A2 = 0; A2 < t4.length; A2++) {
    let w4 = t4[A2];
    if (w4.type === "ParameterExpansion" && (w4.parameter === "@" || w4.parameter === "*") && w4.operation?.type === "Substring") {
      n3 = A2, a3 = w4.parameter === "*";
      break;
    }
  }
  if (n3 === -1) return null;
  let l3 = t4[n3].operation, o2 = l3.offset ? await r2(e5, l3.offset.expression) : 0, c3 = l3.length ? await r2(e5, l3.length.expression) : void 0, u3 = Number.parseInt(e5.state.env["#"] || "0", 10), f3 = [];
  for (let A2 = 1; A2 <= u3; A2++) f3.push(e5.state.env[String(A2)] || "");
  let h3 = e5.state.env[0] || "bash", d3;
  if (o2 <= 0) {
    let A2 = [h3, ...f3], w4 = A2.length + o2;
    if (w4 < 0) d3 = [];
    else {
      let L4 = o2 < 0 ? w4 : 0;
      if (c3 !== void 0) {
        let H2 = c3 < 0 ? A2.length + c3 : L4 + c3;
        d3 = A2.slice(L4, Math.max(L4, H2));
      } else d3 = A2.slice(L4);
    }
  } else {
    let A2 = o2 - 1;
    if (A2 >= f3.length) d3 = [];
    else if (c3 !== void 0) {
      let w4 = c3 < 0 ? f3.length + c3 : A2 + c3;
      d3 = f3.slice(A2, Math.max(A2, w4));
    } else d3 = f3.slice(A2);
  }
  let y2 = "";
  for (let A2 = 0; A2 < n3; A2++) y2 += await s3(e5, t4[A2]);
  let g2 = "";
  for (let A2 = n3 + 1; A2 < t4.length; A2++) g2 += await s3(e5, t4[A2]);
  let E2 = O$e(e5.state.env), S3 = M$c(e5.state.env);
  if (d3.length === 0) {
    let A2 = y2 + g2;
    return A2 ? S3 ? { values: [A2], quoted: false } : { values: D$e(A2, E2), quoted: false } : { values: [], quoted: false };
  }
  let m3;
  if (a3) {
    let A2 = N$b(e5.state.env), w4 = y2 + d3.join(A2) + g2;
    S3 ? m3 = w4 ? [w4] : [] : m3 = D$e(w4, E2);
  } else if (S3) d3.length === 1 ? m3 = [y2 + d3[0] + g2] : m3 = [y2 + d3[0], ...d3.slice(1, -1), d3[d3.length - 1] + g2];
  else {
    m3 = [];
    for (let A2 = 0; A2 < d3.length; A2++) {
      let w4 = d3[A2];
      if (A2 === 0 && (w4 = y2 + w4), A2 === d3.length - 1 && (w4 = w4 + g2), w4 === "") m3.push("");
      else {
        let L4 = D$e(w4, E2);
        m3.push(...L4);
      }
    }
  }
  return { values: await Le$5(e5, m3), quoted: false };
}
async function rr$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].parameter !== "@" && t4[0].parameter !== "*" || t4[0].operation) return null;
  let r2 = t4[0].parameter === "*", s3 = Number.parseInt(e5.state.env["#"] || "0", 10);
  if (s3 === 0) return { values: [], quoted: false };
  let n3 = [];
  for (let c3 = 1; c3 <= s3; c3++) n3.push(e5.state.env[String(c3)] || "");
  let a3 = O$e(e5.state.env), i4 = M$c(e5.state.env), l3 = $e$5(e5.state.env), o2;
  if (r2) if (i4) o2 = n3.filter((c3) => c3 !== "");
  else {
    let c3 = N$b(e5.state.env), u3 = n3.join(c3);
    o2 = D$e(u3, a3);
  }
  else if (i4) o2 = n3.filter((c3) => c3 !== "");
  else if (l3) {
    o2 = [];
    for (let c3 of n3) {
      if (c3 === "") continue;
      let u3 = D$e(c3, a3);
      o2.push(...u3);
    }
  } else {
    o2 = [];
    for (let c3 of n3) if (c3 === "") o2.push("");
    else {
      let u3 = D$e(c3, a3);
      o2.push(...u3);
    }
    for (; o2.length > 0 && o2[o2.length - 1] === ""; ) o2.pop();
  }
  return { values: await Le$5(e5, o2), quoted: false };
}
async function sr$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].operation) return null;
  let r2 = t4[0].parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
  if (!r2) return null;
  let s3 = r2[1], n3 = r2[2] === "*", a3 = P$g(e5, s3), i4;
  if (a3.length === 0) {
    let f3 = e5.state.env[s3];
    if (f3 !== void 0) i4 = [f3];
    else return { values: [], quoted: false };
  } else i4 = a3.map(([, f3]) => f3);
  let l3 = O$e(e5.state.env), o2 = M$c(e5.state.env), c3 = $e$5(e5.state.env), u3;
  if (n3) if (o2) u3 = i4.filter((f3) => f3 !== "");
  else {
    let f3 = N$b(e5.state.env), h3 = i4.join(f3);
    u3 = D$e(h3, l3);
  }
  else if (o2) u3 = i4.filter((f3) => f3 !== "");
  else if (c3) {
    u3 = [];
    for (let f3 of i4) {
      if (f3 === "") continue;
      let h3 = D$e(f3, l3);
      u3.push(...h3);
    }
  } else {
    u3 = [];
    for (let f3 of i4) if (f3 === "") u3.push("");
    else {
      let h3 = D$e(f3, l3);
      u3.push(...h3);
    }
    for (; u3.length > 0 && u3[u3.length - 1] === ""; ) u3.pop();
  }
  return { values: await Le$5(e5, u3), quoted: false };
}
function ir$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].operation?.type !== "VarNamePrefix") return null;
  let r2 = t4[0].operation, s3 = ce$9(e5, r2.prefix);
  if (s3.length === 0) return { values: [], quoted: false };
  let n3 = O$e(e5.state.env), a3 = M$c(e5.state.env), i4;
  if (r2.star) if (a3) i4 = s3;
  else {
    let l3 = N$b(e5.state.env), o2 = s3.join(l3);
    i4 = D$e(o2, n3);
  }
  else if (a3) i4 = s3;
  else {
    i4 = [];
    for (let l3 of s3) {
      let o2 = D$e(l3, n3);
      i4.push(...o2);
    }
  }
  return { values: i4, quoted: false };
}
function ar$1(e5, t4) {
  if (t4.length !== 1 || t4[0].type !== "ParameterExpansion" || t4[0].operation?.type !== "ArrayKeys") return null;
  let r2 = t4[0].operation, n3 = P$g(e5, r2.array).map(([o2]) => String(o2));
  if (n3.length === 0) return { values: [], quoted: false };
  let a3 = O$e(e5.state.env), i4 = M$c(e5.state.env), l3;
  if (r2.star) if (i4) l3 = n3;
  else {
    let o2 = N$b(e5.state.env), c3 = n3.join(o2);
    l3 = D$e(c3, a3);
  }
  else if (i4) l3 = n3;
  else {
    l3 = [];
    for (let o2 of n3) {
      let c3 = D$e(o2, a3);
      l3.push(...c3);
    }
  }
  return { values: l3, quoted: false };
}
async function or$1(e5, t4, r2) {
  let s3 = -1;
  for (let h3 = 0; h3 < t4.length; h3++) {
    let d3 = t4[h3];
    if (d3.type === "ParameterExpansion" && (d3.parameter === "@" || d3.parameter === "*") && !d3.operation) {
      s3 = h3;
      break;
    }
  }
  if (s3 === -1 || t4.length <= 1) return null;
  let n3 = Number.parseInt(e5.state.env["#"] || "0", 10), a3 = [];
  for (let h3 = 1; h3 <= n3; h3++) a3.push(e5.state.env[String(h3)] || "");
  let i4 = "";
  for (let h3 = 0; h3 < s3; h3++) i4 += await r2(e5, t4[h3]);
  let l3 = "";
  for (let h3 = s3 + 1; h3 < t4.length; h3++) l3 += await r2(e5, t4[h3]);
  let o2 = O$e(e5.state.env), c3 = M$c(e5.state.env), u3 = $e$5(e5.state.env);
  if (n3 === 0) {
    let h3 = i4 + l3;
    return { values: h3 ? [h3] : [], quoted: false };
  }
  let f3;
  {
    let h3 = [];
    for (let d3 = 0; d3 < a3.length; d3++) {
      let y2 = a3[d3];
      d3 === 0 && (y2 = i4 + y2), d3 === a3.length - 1 && (y2 = y2 + l3), h3.push(y2);
    }
    if (c3) f3 = h3.filter((d3) => d3 !== "");
    else if (u3) {
      f3 = [];
      for (let d3 of h3) {
        if (d3 === "") continue;
        let y2 = D$e(d3, o2);
        f3.push(...y2);
      }
    } else {
      f3 = [];
      for (let d3 of h3) if (d3 === "") f3.push("");
      else {
        let y2 = D$e(d3, o2);
        f3.push(...y2);
      }
      for (; f3.length > 0 && f3[f3.length - 1] === ""; ) f3.pop();
    }
  }
  return f3.length === 0 ? { values: [], quoted: false } : { values: await Le$5(e5, f3), quoted: false };
}
async function cr$1(e5, t4, r2) {
  let s3 = t4.parts, { hasQuoted: n3, hasCommandSub: a3, hasArrayVar: i4, hasArrayAtExpansion: l3, hasParamExpansion: o2, hasVarNamePrefixExpansion: c3, hasIndirection: u3 } = de$5(s3), h3 = r2.hasBraceExpansion(s3) ? await r2.expandWordWithBracesAsync(e5, t4) : null;
  if (h3 && h3.length > 1) return bs$1(e5, h3, n3);
  let d3 = await ws$2(e5, s3, l3, c3, u3, r2);
  if (d3 !== null) return d3;
  let y2 = await ks$2(e5, s3, r2);
  if (y2 !== null) return y2;
  let g2 = await Ps$1(e5, s3, r2);
  if (g2 !== null) return g2;
  let E2 = await Is$2(e5, s3, r2.expandPart);
  if (E2 !== null) return ur$1(e5, E2);
  if ((a3 || i4 || o2) && !M$c(e5.state.env)) {
    let m3 = O$e(e5.state.env), A2 = r2.buildIfsCharClassPattern(m3), w4 = await r2.smartWordSplit(e5, s3, m3, A2, r2.expandPart);
    return ur$1(e5, w4);
  }
  let S3 = await r2.expandWordAsync(e5, t4);
  return vs$2(e5, t4, s3, S3, n3, r2.expandWordForGlobbing);
}
async function bs$1(e5, t4, r2) {
  let s3 = [];
  for (let n3 of t4) if (!(!r2 && n3 === "")) if (!r2 && !e5.state.options.noglob && ee$4(n3, e5.state.shoptOptions.extglob)) {
    let a3 = await We$6(e5, n3);
    s3.push(...a3);
  } else s3.push(n3);
  return { values: s3, quoted: false };
}
async function ws$2(e5, t4, r2, s3, n3, a3) {
  if (r2) {
    let i4 = Qn$1(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = zn$2(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Mn$1(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Vn$1(e5, t4, r2, a3.expandPart, a3.expandWordPartsAsync);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await qn$2(e5, t4, r2, a3.expandPart);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Bn$2(e5, t4, a3.evaluateArithmetic);
    if (i4 !== null) return i4;
  }
  {
    let i4 = Fn$1(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Wn$2(e5, t4, a3.expandWordPartsAsync, a3.expandPart);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Tn$1(e5, t4, a3.expandWordPartsAsync, a3.expandPart);
    if (i4 !== null) return i4;
  }
  if (s3 && t4.length === 1 && t4[0].type === "DoubleQuoted") {
    let i4 = Ns$1(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Zn$1(e5, t4, n3, a3.expandParameterAsync, a3.expandWordPartsAsync);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Gn$1(e5, t4);
    if (i4 !== null) return i4;
  }
  {
    let i4 = await Un$1(e5, t4);
    if (i4 !== null) return i4;
  }
  return null;
}
function Ns$1(e5, t4) {
  let r2 = t4[0];
  if (r2.type !== "DoubleQuoted") return null;
  if (r2.parts.length === 1 && r2.parts[0].type === "ParameterExpansion" && r2.parts[0].operation?.type === "VarNamePrefix") {
    let s3 = r2.parts[0].operation, n3 = ce$9(e5, s3.prefix);
    return s3.star ? { values: [n3.join(N$b(e5.state.env))], quoted: true } : { values: n3, quoted: true };
  }
  if (r2.parts.length === 1 && r2.parts[0].type === "ParameterExpansion" && r2.parts[0].operation?.type === "ArrayKeys") {
    let s3 = r2.parts[0].operation, a3 = P$g(e5, s3.array).map(([i4]) => String(i4));
    return s3.star ? { values: [a3.join(N$b(e5.state.env))], quoted: true } : { values: a3, quoted: true };
  }
  return null;
}
async function ks$2(e5, t4, r2) {
  {
    let s3 = await Hn$1(e5, t4, r2.evaluateArithmetic, r2.expandPart);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await Kn$1(e5, t4, r2.expandPart, r2.expandWordPartsAsync);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await Xn$1(e5, t4, r2.expandPart, r2.expandWordPartsAsync);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await Jn$2(e5, t4, r2.expandPart);
    if (s3 !== null) return s3;
  }
  return null;
}
async function Ps$1(e5, t4, r2) {
  {
    let s3 = await Yn$1(e5, t4, r2.expandWordPartsAsync, r2.expandPart);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await er$1(e5, t4, r2.expandWordPartsAsync, r2.expandPart);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await tr$1(e5, t4, r2.expandWordPartsAsync, r2.expandPart);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await nr$1(e5, t4, r2.evaluateArithmetic, r2.expandPart);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await rr$1(e5, t4);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await sr$1(e5, t4);
    if (s3 !== null) return s3;
  }
  {
    let s3 = ir$1(e5, t4);
    if (s3 !== null) return s3;
  }
  {
    let s3 = ar$1(e5, t4);
    if (s3 !== null) return s3;
  }
  {
    let s3 = await or$1(e5, t4, r2.expandPart);
    if (s3 !== null) return s3;
  }
  return null;
}
function lr$1(e5) {
  if (e5.type !== "DoubleQuoted") return null;
  for (let t4 = 0; t4 < e5.parts.length; t4++) {
    let r2 = e5.parts[t4];
    if (r2.type !== "ParameterExpansion" || r2.operation) continue;
    let s3 = r2.parameter.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([@*])\]$/);
    if (s3) return { type: "array", name: s3[1], atIndex: t4, isStar: s3[2] === "*" };
    if (r2.parameter === "@" || r2.parameter === "*") return { type: "positional", atIndex: t4, isStar: r2.parameter === "*" };
  }
  return null;
}
async function Rs$2(e5, t4, r2, s3) {
  let n3 = "";
  for (let l3 = 0; l3 < r2.atIndex; l3++) n3 += await s3(e5, t4.parts[l3]);
  let a3 = "";
  for (let l3 = r2.atIndex + 1; l3 < t4.parts.length; l3++) a3 += await s3(e5, t4.parts[l3]);
  let i4;
  if (r2.type === "array") {
    if (i4 = P$g(e5, r2.name).map(([, o2]) => o2), i4.length === 0) {
      let o2 = e5.state.env[r2.name];
      o2 !== void 0 && (i4 = [o2]);
    }
  } else {
    let l3 = Number.parseInt(e5.state.env["#"] || "0", 10);
    i4 = [];
    for (let o2 = 1; o2 <= l3; o2++) i4.push(e5.state.env[String(o2)] || "");
  }
  if (r2.isStar) {
    let l3 = N$b(e5.state.env), o2 = i4.join(l3);
    return [n3 + o2 + a3];
  }
  if (i4.length === 0) {
    let l3 = n3 + a3;
    return l3 ? [l3] : [];
  }
  return i4.length === 1 ? [n3 + i4[0] + a3] : [n3 + i4[0], ...i4.slice(1, -1), i4[i4.length - 1] + a3];
}
async function Is$2(e5, t4, r2) {
  if (t4.length < 2) return null;
  let s3 = false;
  for (let o2 of t4) if (lr$1(o2)) {
    s3 = true;
    break;
  }
  if (!s3) return null;
  let n3 = O$e(e5.state.env), a3 = M$c(e5.state.env), i4 = [];
  for (let o2 of t4) {
    let c3 = lr$1(o2);
    if (c3 && o2.type === "DoubleQuoted") {
      let u3 = await Rs$2(e5, o2, c3, r2);
      i4.push(u3);
    } else if (o2.type === "DoubleQuoted" || o2.type === "SingleQuoted") {
      let u3 = await r2(e5, o2);
      i4.push([u3]);
    } else if (o2.type === "Literal") i4.push([o2.value]);
    else if (o2.type === "ParameterExpansion") {
      let u3 = await r2(e5, o2);
      if (a3) i4.push(u3 ? [u3] : []);
      else {
        let f3 = D$e(u3, n3);
        i4.push(f3);
      }
    } else {
      let u3 = await r2(e5, o2);
      if (a3) i4.push(u3 ? [u3] : []);
      else {
        let f3 = D$e(u3, n3);
        i4.push(f3);
      }
    }
  }
  let l3 = [];
  for (let o2 of i4) if (o2.length !== 0) if (l3.length === 0) l3.push(...o2);
  else {
    let c3 = l3.length - 1;
    l3[c3] = l3[c3] + o2[0];
    for (let u3 = 1; u3 < o2.length; u3++) l3.push(o2[u3]);
  }
  return l3;
}
async function ur$1(e5, t4) {
  if (e5.state.options.noglob) return { values: t4, quoted: false };
  let r2 = [];
  for (let s3 of t4) if (ee$4(s3, e5.state.shoptOptions.extglob)) {
    let n3 = await We$6(e5, s3);
    r2.push(...n3);
  } else r2.push(s3);
  return { values: r2, quoted: false };
}
async function We$6(e5, t4) {
  let r2 = new se$7(e5.fs, e5.state.cwd, e5.state.env, { globstar: e5.state.shoptOptions.globstar, nullglob: e5.state.shoptOptions.nullglob, failglob: e5.state.shoptOptions.failglob, dotglob: e5.state.shoptOptions.dotglob, extglob: e5.state.shoptOptions.extglob, globskipdots: e5.state.shoptOptions.globskipdots }), s3 = await r2.expand(t4);
  if (s3.length > 0) return s3;
  if (r2.hasFailglob()) throw new l$7(t4);
  return r2.hasNullglob() ? [] : [t4];
}
async function vs$2(e5, t4, r2, s3, n3, a3) {
  let i4 = r2.some((l3) => l3.type === "Glob");
  if (!e5.state.options.noglob && i4) {
    let l3 = await a3(e5, t4);
    if (ee$4(l3, e5.state.shoptOptions.extglob)) {
      let c3 = await We$6(e5, l3);
      if (c3.length > 0 && c3[0] !== l3) return { values: c3, quoted: false };
      if (c3.length === 0) return { values: [], quoted: false };
    }
    let o2 = yt$4(s3);
    if (!M$c(e5.state.env)) {
      let c3 = O$e(e5.state.env);
      return { values: D$e(o2, c3), quoted: false };
    }
    return { values: [o2], quoted: false };
  }
  if (!n3 && !e5.state.options.noglob && ee$4(s3, e5.state.shoptOptions.extglob)) {
    let l3 = await a3(e5, t4);
    if (ee$4(l3, e5.state.shoptOptions.extglob)) {
      let o2 = await We$6(e5, l3);
      if (o2.length > 0 && o2[0] !== l3) return { values: o2, quoted: false };
    }
  }
  if (s3 === "" && !n3) return { values: [], quoted: false };
  if (i4 && !n3) {
    let l3 = yt$4(s3);
    if (!M$c(e5.state.env)) {
      let o2 = O$e(e5.state.env);
      return { values: D$e(l3, o2), quoted: false };
    }
    return { values: [l3], quoted: false };
  }
  return { values: [s3], quoted: n3 };
}
async function pr$1(e5, t4) {
  let r2 = t4.operation;
  if (!r2 || r2.type !== "DefaultValue" && r2.type !== "AssignDefault" && r2.type !== "UseAlternative") return null;
  let s3 = r2.word;
  if (!s3 || s3.parts.length === 0) return null;
  let n3 = await Y$a(e5, t4.parameter), i4 = await v$b(e5, t4.parameter, false) === "", l3 = r2.checkEmpty ?? false, o2;
  return r2.type === "UseAlternative" ? o2 = n3 && !(l3 && i4) : o2 = !n3 || l3 && i4, o2 ? s3.parts : null;
}
function Ds$1(e5) {
  return e5.type === "SingleQuoted" ? true : e5.type === "DoubleQuoted" ? e5.parts.every((r2) => r2.type === "Literal") : false;
}
async function xs$2(e5, t4) {
  if (t4.type !== "ParameterExpansion") return null;
  let r2 = await pr$1(e5, t4);
  if (!r2 || r2.length <= 1) return null;
  let s3 = r2.some((a3) => Ds$1(a3)), n3 = r2.some((a3) => a3.type === "Literal" || a3.type === "ParameterExpansion" || a3.type === "CommandSubstitution" || a3.type === "ArithmeticExpansion");
  return s3 && n3 ? r2 : null;
}
function $s$2(e5) {
  return e5.type === "DoubleQuoted" || e5.type === "SingleQuoted" || e5.type === "Literal" ? false : e5.type === "Glob" ? ft$3(e5.pattern) : !(!(e5.type === "ParameterExpansion" || e5.type === "CommandSubstitution" || e5.type === "ArithmeticExpansion") || e5.type === "ParameterExpansion" && fn$3(e5));
}
async function hr$1(e5, t4, r2, s3, n3) {
  if (t4.length === 1 && t4[0].type === "ParameterExpansion") {
    let h3 = t4[0], d3 = await pr$1(e5, h3);
    if (d3 && d3.length > 0 && d3.length > 1 && d3.some((g2) => g2.type === "DoubleQuoted" || g2.type === "SingleQuoted") && d3.some((g2) => g2.type === "Literal" || g2.type === "ParameterExpansion" || g2.type === "CommandSubstitution" || g2.type === "ArithmeticExpansion")) return fr$1(e5, d3, r2, s3, n3);
  }
  let a3 = [], i4 = false;
  for (let h3 of t4) {
    let d3 = $s$2(h3), y2 = h3.type === "DoubleQuoted" || h3.type === "SingleQuoted", g2 = d3 ? await xs$2(e5, h3) : null, E2 = await n3(e5, h3);
    a3.push({ value: E2, isSplittable: d3, isQuoted: y2, mixedDefaultParts: g2 ?? void 0 }), d3 && (i4 = true);
  }
  if (!i4) {
    let h3 = a3.map((d3) => d3.value).join("");
    return h3 ? [h3] : [];
  }
  let l3 = [], o2 = "", c3 = false, u3 = false, f3 = false;
  for (let h3 of a3) if (!h3.isSplittable) u3 ? h3.isQuoted && h3.value === "" ? (o2 !== "" && l3.push(o2), l3.push(""), c3 = true, o2 = "", u3 = false, f3 = true) : h3.value !== "" ? (o2 !== "" && l3.push(o2), o2 = h3.value, u3 = false, f3 = false) : (o2 += h3.value, f3 = false) : (o2 += h3.value, f3 = h3.isQuoted && h3.value === "");
  else if (h3.mixedDefaultParts) {
    let d3 = await fr$1(e5, h3.mixedDefaultParts, r2, s3, n3);
    if (d3.length !== 0) if (d3.length === 1) o2 += d3[0], c3 = true;
    else {
      o2 += d3[0], l3.push(o2), c3 = true;
      for (let y2 = 1; y2 < d3.length - 1; y2++) l3.push(d3[y2]);
      o2 = d3[d3.length - 1];
    }
    u3 = false, f3 = false;
  } else {
    let { words: d3, hadLeadingDelimiter: y2, hadTrailingDelimiter: g2 } = _e$5(h3.value, r2);
    if (f3 && y2 && o2 === "" && (l3.push(""), c3 = true), d3.length === 0) g2 && (u3 = true);
    else if (d3.length === 1) o2 += d3[0], c3 = true, u3 = g2;
    else {
      o2 += d3[0], l3.push(o2), c3 = true;
      for (let E2 = 1; E2 < d3.length - 1; E2++) l3.push(d3[E2]);
      o2 = d3[d3.length - 1], u3 = g2;
    }
    f3 = false;
  }
  return o2 !== "" ? l3.push(o2) : l3.length === 0 && c3 && l3.push(""), l3;
}
function _s$2(e5, t4) {
  return e5.length > 0 && t4.includes(e5[0]);
}
async function fr$1(e5, t4, r2, s3, n3) {
  let a3 = [];
  for (let u3 of t4) {
    let h3 = !(u3.type === "DoubleQuoted" || u3.type === "SingleQuoted"), d3 = await n3(e5, u3);
    a3.push({ value: d3, isSplittable: h3 });
  }
  let i4 = [], l3 = "", o2 = false, c3 = false;
  for (let u3 of a3) if (!u3.isSplittable) c3 && u3.value !== "" ? (l3 !== "" && i4.push(l3), l3 = u3.value, c3 = false) : l3 += u3.value;
  else {
    _s$2(u3.value, r2) && l3 !== "" && (i4.push(l3), l3 = "", o2 = true);
    let { words: h3, hadTrailingDelimiter: d3 } = _e$5(u3.value, r2);
    if (h3.length === 0) d3 && (c3 = true);
    else if (h3.length === 1) l3 += h3[0], o2 = true, c3 = d3;
    else {
      l3 += h3[0], i4.push(l3), o2 = true;
      for (let y2 = 1; y2 < h3.length - 1; y2++) i4.push(h3[y2]);
      l3 = h3[h3.length - 1], c3 = d3;
    }
  }
  return l3 !== "" ? i4.push(l3) : i4.length === 0 && o2 && i4.push(""), i4;
}
function dr$1(e5) {
  switch (e5.type) {
    case "Literal":
      return e5.value;
    case "SingleQuoted":
      return e5.value;
    case "Escaped":
      return e5.value;
    default:
      return null;
  }
}
function mr$1(e5) {
  switch (e5.type) {
    case "SingleQuoted":
    case "Escaped":
    case "DoubleQuoted":
      return true;
    case "Literal":
      return e5.value === "";
    default:
      return false;
  }
}
async function j$c(e5, t4, r2 = false) {
  let s3 = [];
  for (let n3 of t4) s3.push(await z$5(e5, n3, r2));
  return s3.join("");
}
function Cs$2(e5) {
  return mr$1(e5);
}
function al$1(e5) {
  if (e5.parts.length === 0) return true;
  for (let t4 of e5.parts) if (!Cs$2(t4)) return false;
  return true;
}
function Os$2(e5, t4, r2 = false) {
  let s3 = dr$1(t4);
  if (s3 !== null) return s3;
  switch (t4.type) {
    case "TildeExpansion":
      return r2 ? t4.user === null ? "~" : `~${t4.user}` : t4.user === null ? e5.state.env.HOME !== void 0 ? e5.state.env.HOME : "/home/user" : t4.user === "root" ? "/root" : `~${t4.user}`;
    case "Glob":
      return St$3(e5, t4.pattern);
    default:
      return null;
  }
}
async function wt$5(e5, t4) {
  return Nt$2(e5, t4);
}
async function ol$1(e5, t4) {
  let r2 = [];
  for (let s3 of t4.parts) if (s3.type === "Escaped") r2.push(`\\${s3.value}`);
  else if (s3.type === "SingleQuoted") r2.push(s3.value);
  else if (s3.type === "DoubleQuoted") {
    let n3 = await j$c(e5, s3.parts);
    r2.push(n3);
  } else if (s3.type === "TildeExpansion") {
    let n3 = await z$5(e5, s3);
    r2.push(Et$3(n3));
  } else r2.push(await z$5(e5, s3));
  return r2.join("");
}
async function ll$1(e5, t4) {
  let r2 = [];
  for (let s3 of t4.parts) if (s3.type === "Escaped") {
    let n3 = s3.value;
    "()|*?[]".includes(n3) ? r2.push(`\\${n3}`) : r2.push(n3);
  } else if (s3.type === "SingleQuoted") r2.push(U$8(s3.value));
  else if (s3.type === "DoubleQuoted") {
    let n3 = await j$c(e5, s3.parts);
    r2.push(U$8(n3));
  } else r2.push(await z$5(e5, s3));
  return r2.join("");
}
async function gr$1(e5, t4) {
  let r2 = [];
  for (let s3 of t4.parts) if (s3.type === "SingleQuoted") r2.push(U$8(s3.value));
  else if (s3.type === "Escaped") {
    let n3 = s3.value;
    "*?[]\\()|".includes(n3) ? r2.push(`\\${n3}`) : r2.push(n3);
  } else if (s3.type === "DoubleQuoted") {
    let n3 = await j$c(e5, s3.parts);
    r2.push(U$8(n3));
  } else s3.type === "Glob" ? _n$1(s3.pattern) ? r2.push(await On$1(e5, s3.pattern)) : r2.push(St$3(e5, s3.pattern)) : s3.type === "Literal" ? r2.push(s3.value) : r2.push(await z$5(e5, s3));
  return r2.join("");
}
function Me$6(e5) {
  for (let t4 of e5) if (t4.type === "BraceExpansion" || t4.type === "DoubleQuoted" && Me$6(t4.parts)) return true;
  return false;
}
var Ls$2 = 1e4, bt$2 = 1e5;
async function yr$1(e5, t4, r2 = { count: 0 }) {
  if (r2.count > bt$2) return [[]];
  let s3 = [[]];
  for (let n3 of t4) if (n3.type === "BraceExpansion") {
    let a3 = [], i4 = false, l3 = "";
    for (let u3 of n3.items) if (u3.type === "Range") {
      let f3 = gt$4(u3.start, u3.end, u3.step, u3.startStr, u3.endStr);
      if (f3.expanded) for (let h3 of f3.expanded) r2.count++, a3.push(h3);
      else {
        i4 = true, l3 = f3.literal;
        break;
      }
    } else {
      let f3 = await yr$1(e5, u3.word.parts, r2);
      for (let h3 of f3) {
        r2.count++;
        let d3 = [];
        for (let y2 of h3) typeof y2 == "string" ? d3.push(y2) : d3.push(await z$5(e5, y2));
        a3.push(d3.join(""));
      }
    }
    if (i4) {
      for (let u3 of s3) r2.count++, u3.push(l3);
      continue;
    }
    if (s3.length * a3.length > Ls$2 || r2.count > bt$2) return s3;
    let c3 = [];
    for (let u3 of s3) for (let f3 of a3) {
      if (r2.count++, r2.count > bt$2) return c3.length > 0 ? c3 : s3;
      c3.push([...u3, f3]);
    }
    s3 = c3;
  } else for (let a3 of s3) r2.count++, a3.push(n3);
  return s3;
}
async function Er$1(e5, t4) {
  let r2 = t4.parts;
  if (!Me$6(r2)) return [await wt$5(e5, t4)];
  let s3 = await yr$1(e5, r2), n3 = [];
  for (let a3 of s3) {
    let i4 = [];
    for (let l3 of a3) typeof l3 == "string" ? i4.push(l3) : i4.push(await z$5(e5, l3));
    n3.push(Ln$1(e5, i4.join("")));
  }
  return n3;
}
function Ws$1() {
  return { expandWordAsync: Nt$2, expandWordForGlobbing: gr$1, expandWordWithBracesAsync: Er$1, expandWordPartsAsync: j$c, expandPart: z$5, expandParameterAsync: Te$5, hasBraceExpansion: Me$6, evaluateArithmetic: R$a, buildIfsCharClassPattern: dn$2, smartWordSplit: hr$1 };
}
async function ul$1(e5, t4) {
  return cr$1(e5, t4, Ws$1());
}
function Ts$1(e5) {
  for (let t4 of e5) {
    if (t4.type === "ParameterExpansion") return t4.parameter;
    if (t4.type === "Literal") return t4.value;
  }
  return "";
}
function Ms$1(e5, t4) {
  if (Number.parseInt(e5.state.env["#"] || "0", 10) < 2) return false;
  function s3(n3) {
    for (let a3 of n3) if (a3.type === "DoubleQuoted") {
      for (let i4 of a3.parts) if (i4.type === "ParameterExpansion" && i4.parameter === "@" && !i4.operation) return true;
    }
    return false;
  }
  return s3(t4.parts);
}
async function cl$1(e5, t4) {
  if (Ms$1(e5, t4)) return { error: `bash: $@: ambiguous redirect
` };
  let r2 = t4.parts, { hasQuoted: s3 } = de$5(r2);
  if (Me$6(r2) && (await Er$1(e5, t4)).length > 1) return { error: `bash: ${r2.map((d3) => d3.type === "Literal" ? d3.value : d3.type === "BraceExpansion" ? `{${d3.items.map((g2) => {
    if (g2.type === "Range") {
      let E2 = g2.step ? `..${g2.step}` : "";
      return `${g2.startStr ?? g2.start}..${g2.endStr ?? g2.end}${E2}`;
    }
    return g2.word.parts.map((E2) => E2.type === "Literal" ? E2.value : "").join("");
  }).join(",")}}` : "").join("")}: ambiguous redirect
` };
  let n3 = await Nt$2(e5, t4), { hasParamExpansion: a3, hasCommandSub: i4 } = de$5(r2);
  if ((a3 || i4) && !s3 && !M$c(e5.state.env)) {
    let f3 = O$e(e5.state.env);
    if (D$e(n3, f3).length > 1) return { error: `bash: $${Ts$1(r2)}: ambiguous redirect
` };
  }
  if (s3 || e5.state.options.noglob) return { target: n3 };
  let o2 = await gr$1(e5, t4);
  if (!ee$4(o2, e5.state.shoptOptions.extglob)) return { target: n3 };
  let c3 = new se$7(e5.fs, e5.state.cwd, e5.state.env, { globstar: e5.state.shoptOptions.globstar, nullglob: e5.state.shoptOptions.nullglob, failglob: e5.state.shoptOptions.failglob, dotglob: e5.state.shoptOptions.dotglob, extglob: e5.state.shoptOptions.extglob, globskipdots: e5.state.shoptOptions.globskipdots }), u3 = await c3.expand(o2);
  return u3.length === 0 ? c3.hasFailglob() ? { error: `bash: no match: ${n3}
` } : { target: n3 } : u3.length === 1 ? { target: u3[0] } : { error: `bash: ${n3}: ambiguous redirect
` };
}
async function Nt$2(e5, t4) {
  let r2 = t4.parts, s3 = r2.length;
  if (s3 === 1) return z$5(e5, r2[0]);
  let n3 = [];
  for (let a3 = 0; a3 < s3; a3++) n3.push(await z$5(e5, r2[a3]));
  return n3.join("");
}
async function z$5(e5, t4, r2 = false) {
  if (t4.type === "ParameterExpansion") return Te$5(e5, t4, r2);
  let s3 = Os$2(e5, t4, r2);
  if (s3 !== null) return s3;
  switch (t4.type) {
    case "DoubleQuoted": {
      let n3 = [];
      for (let a3 of t4.parts) n3.push(await z$5(e5, a3, true));
      return n3.join("");
    }
    case "CommandSubstitution": {
      let n3 = yn$1(t4.body);
      if (n3) try {
        let c3 = await wt$5(e5, n3.target), u3 = c3.startsWith("/") ? c3 : `${e5.state.cwd}/${c3}`, f3 = await e5.fs.readFile(u3);
        return e5.state.lastExitCode = 0, e5.state.env["?"] = "0", f3.replace(/\n+$/, "");
      } catch {
        return e5.state.lastExitCode = 1, e5.state.env["?"] = "1", "";
      }
      let a3 = e5.state.bashPid;
      e5.state.bashPid = e5.state.nextVirtualPid++;
      let i4 = { ...e5.state.env }, l3 = e5.state.cwd, o2 = e5.state.suppressVerbose;
      e5.state.suppressVerbose = true;
      try {
        let c3 = await e5.executeScript(t4.body), u3 = c3.exitCode;
        return e5.state.env = i4, e5.state.cwd = l3, e5.state.suppressVerbose = o2, e5.state.lastExitCode = u3, e5.state.env["?"] = String(u3), c3.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + c3.stderr), e5.state.bashPid = a3, c3.stdout.replace(/\n+$/, "");
      } catch (c3) {
        if (e5.state.env = i4, e5.state.cwd = l3, e5.state.bashPid = a3, e5.state.suppressVerbose = o2, c3 instanceof b$i) throw c3;
        if (c3 instanceof d$8) return e5.state.lastExitCode = c3.exitCode, e5.state.env["?"] = String(c3.exitCode), c3.stderr && (e5.state.expansionStderr = (e5.state.expansionStderr || "") + c3.stderr), c3.stdout.replace(/\n+$/, "");
        throw c3;
      }
    }
    case "ArithmeticExpansion": {
      let n3 = t4.expression.originalText;
      if (n3 && /\$[a-zA-Z_][a-zA-Z0-9_]*(?![{[(])/.test(n3)) {
        let i4 = await gn$1(e5, n3), l3 = new T$9(), o2 = W$d(l3, i4);
        return String(await R$a(e5, o2.expression, true));
      }
      return String(await R$a(e5, t4.expression.expression, true));
    }
    case "BraceExpansion": {
      let n3 = [];
      for (let a3 of t4.items) if (a3.type === "Range") {
        let i4 = gt$4(a3.start, a3.end, a3.step, a3.startStr, a3.endStr);
        if (i4.expanded) n3.push(...i4.expanded);
        else return i4.literal;
      } else n3.push(await wt$5(e5, a3.word));
      return n3.join(" ");
    }
    default:
      return "";
  }
}
async function Te$5(e5, t4, r2 = false) {
  let { parameter: s3 } = t4, { operation: n3 } = t4, a3 = s3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (a3) {
    let [, h3, d3] = a3;
    if (e5.state.associativeArrays?.has(h3) || d3.includes("$(") || d3.includes("`") || d3.includes("${")) {
      let g2 = await mt$3(e5, d3);
      s3 = `${h3}[${g2}]`;
    }
  } else if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(s3) && C$g(e5, s3)) {
    let h3 = le$8(e5, s3);
    if (h3 && h3 !== s3) {
      let d3 = h3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (d3) {
        let [, y2, g2] = d3;
        if (e5.state.associativeArrays?.has(y2) || g2.includes("$(") || g2.includes("`") || g2.includes("${")) {
          let S3 = await mt$3(e5, g2);
          s3 = `${y2}[${S3}]`;
        }
      }
    }
  }
  let i4 = n3 && (n3.type === "DefaultValue" || n3.type === "AssignDefault" || n3.type === "UseAlternative" || n3.type === "ErrorIfUnset"), l3 = await v$b(e5, s3, !i4);
  if (!n3) return l3;
  let o2 = !await Y$a(e5, s3), { isEmpty: c3, effectiveValue: u3 } = $n$1(e5, s3, l3, r2), f3 = { isUnset: o2, isEmpty: c3, effectiveValue: u3, inDoubleQuotes: r2 };
  switch (n3.type) {
    case "DefaultValue":
      return En$2(e5, n3, f3, j$c);
    case "AssignDefault":
      return An$1(e5, s3, n3, f3, j$c);
    case "ErrorIfUnset":
      return Sn$1(e5, s3, n3, f3, j$c);
    case "UseAlternative":
      return bn$2(e5, n3, f3, j$c);
    case "PatternRemoval":
      return wn$1(e5, l3, n3, j$c, z$5);
    case "PatternReplacement":
      return Nn$1(e5, l3, n3, j$c, z$5);
    case "Length":
      return kn$2(e5, s3, l3);
    case "LengthSliceError":
      throw new h$f(s3);
    case "BadSubstitution":
      throw new h$f(n3.text);
    case "Substring":
      return Pn$1(e5, s3, l3, n3);
    case "CaseModification":
      return Rn$1(e5, l3, n3, j$c, Te$5);
    case "Transform":
      return In$1(e5, s3, l3, o2, n3);
    case "Indirection":
      return vn$1(e5, s3, l3, o2, n3, Te$5, r2);
    case "ArrayKeys":
      return Dn$2(e5, n3);
    case "VarNamePrefix":
      return xn$1(e5, n3);
    default:
      return l3;
  }
}
function n$5(e5) {
  return e5 instanceof Error ? e5.message : String(e5);
}
var h$e = Object.create;
var e$4 = Object.defineProperty;
var i$5 = Object.getOwnPropertyDescriptor;
var j$b = Object.getOwnPropertyNames;
var k$a = Object.getPrototypeOf, l$6 = Object.prototype.hasOwnProperty;
var m$d = ((a3) => typeof require < "u" ? require : typeof Proxy < "u" ? new Proxy(a3, { get: (b4, c3) => (typeof require < "u" ? require : b4)[c3] }) : a3)(function(a3) {
  if (typeof require < "u") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + a3 + '" is not supported');
});
var n$4 = (a3, b4) => () => (a3 && (b4 = a3(a3 = 0)), b4);
var o$4 = (a3, b4) => () => (b4 || a3((b4 = { exports: {} }).exports, b4), b4.exports), p$d = (a3, b4) => {
  for (var c3 in b4) e$4(a3, c3, { get: b4[c3], enumerable: true });
}, g$g = (a3, b4, c3, f3) => {
  if (b4 && typeof b4 == "object" || typeof b4 == "function") for (let d3 of j$b(b4)) !l$6.call(a3, d3) && d3 !== c3 && e$4(a3, d3, { get: () => b4[d3], enumerable: !(f3 = i$5(b4, d3)) || f3.enumerable });
  return a3;
};
var q$d = (a3, b4, c3) => (c3 = a3 != null ? h$e(k$a(a3)) : {}, g$g(e$4(c3, "default", { value: a3, enumerable: true }), a3)), r$4 = (a3) => g$g(e$4({}, "__esModule", { value: true }), a3);
var Ge$3 = /* @__PURE__ */ Symbol.for("workflow-serialize"), Ke$3 = /* @__PURE__ */ Symbol.for("workflow-deserialize");
var Ee$5 = [{ name: "echo", load: async () => (await Promise.resolve().then(function() {
  return echo6S7WE7XB;
})).echoCommand }, { name: "cat", load: async () => (await Promise.resolve().then(function() {
  return catMV4K6AUA;
})).catCommand }, { name: "printf", load: async () => (await Promise.resolve().then(function() {
  return printf66XGXFCD;
})).printfCommand }, { name: "ls", load: async () => (await Promise.resolve().then(function() {
  return ls5W3NU5OJ;
})).lsCommand }, { name: "mkdir", load: async () => (await Promise.resolve().then(function() {
  return mkdir7UKY4B3B;
})).mkdirCommand }, { name: "rmdir", load: async () => (await Promise.resolve().then(function() {
  return rmdirXFQE4ZYV;
})).rmdirCommand }, { name: "touch", load: async () => (await Promise.resolve().then(function() {
  return touchTDTEBHHI;
})).touchCommand }, { name: "rm", load: async () => (await Promise.resolve().then(function() {
  return rmI2SRVF7H;
})).rmCommand }, { name: "cp", load: async () => (await Promise.resolve().then(function() {
  return cpPBJT3GBF;
})).cpCommand }, { name: "mv", load: async () => (await Promise.resolve().then(function() {
  return mvFXHEKRTB;
})).mvCommand }, { name: "ln", load: async () => (await Promise.resolve().then(function() {
  return lnY7YB677N;
})).lnCommand }, { name: "chmod", load: async () => (await Promise.resolve().then(function() {
  return chmodODWUR7E6;
})).chmodCommand }, { name: "pwd", load: async () => (await Promise.resolve().then(function() {
  return pwdS4NVAMC4;
})).pwdCommand }, { name: "readlink", load: async () => (await Promise.resolve().then(function() {
  return readlinkEM4O3U4P;
})).readlinkCommand }, { name: "head", load: async () => (await Promise.resolve().then(function() {
  return headSA7P5NJ7;
})).headCommand }, { name: "tail", load: async () => (await Promise.resolve().then(function() {
  return tail52LRAWXT;
})).tailCommand }, { name: "wc", load: async () => (await Promise.resolve().then(function() {
  return wcHE5XARI4;
})).wcCommand }, { name: "stat", load: async () => (await Promise.resolve().then(function() {
  return statIVQBBOKN;
})).statCommand }, { name: "grep", load: async () => (await Promise.resolve().then(function() {
  return grepNIC6JNLH;
})).grepCommand }, { name: "fgrep", load: async () => (await Promise.resolve().then(function() {
  return grepNIC6JNLH;
})).fgrepCommand }, { name: "egrep", load: async () => (await Promise.resolve().then(function() {
  return grepNIC6JNLH;
})).egrepCommand }, { name: "rg", load: async () => (await Promise.resolve().then(function() {
  return rgSRMB7L6G;
})).rgCommand }, { name: "sed", load: async () => (await Promise.resolve().then(function() {
  return sedIV6HLDXU;
})).sedCommand }, { name: "awk", load: async () => (await Promise.resolve().then(function() {
  return awk26FBZTP57;
})).awkCommand2 }, { name: "sort", load: async () => (await Promise.resolve().then(function() {
  return sortEJUT5LXD;
})).sortCommand }, { name: "uniq", load: async () => (await Promise.resolve().then(function() {
  return uniq47QVBRNC;
})).uniqCommand }, { name: "comm", load: async () => (await Promise.resolve().then(function() {
  return commAXQM7FFF;
})).commCommand }, { name: "cut", load: async () => (await Promise.resolve().then(function() {
  return cutNVKWEAZF;
})).cutCommand }, { name: "paste", load: async () => (await Promise.resolve().then(function() {
  return pasteQTGVEPH5;
})).pasteCommand }, { name: "tr", load: async () => (await Promise.resolve().then(function() {
  return trEDGW5FG6;
})).trCommand }, { name: "rev", load: async () => (await Promise.resolve().then(function() {
  return revFKUV5GH5;
})).rev }, { name: "nl", load: async () => (await Promise.resolve().then(function() {
  return nlKWQGFZH5;
})).nl }, { name: "fold", load: async () => (await Promise.resolve().then(function() {
  return fold6CFXIPYZ;
})).fold }, { name: "expand", load: async () => (await Promise.resolve().then(function() {
  return expandVSTNOVF5;
})).expand }, { name: "unexpand", load: async () => (await Promise.resolve().then(function() {
  return unexpandI7A2VXFD;
})).unexpand }, { name: "strings", load: async () => (await Promise.resolve().then(function() {
  return stringsLRU5XCFP;
})).strings }, { name: "split", load: async () => (await Promise.resolve().then(function() {
  return splitYBTFW7MT;
})).split }, { name: "column", load: async () => (await Promise.resolve().then(function() {
  return columnXPDNNO5Y;
})).column }, { name: "join", load: async () => (await Promise.resolve().then(function() {
  return joinX3QYPZUA;
})).join }, { name: "tee", load: async () => (await Promise.resolve().then(function() {
  return tee2QU4NRSJ;
})).teeCommand }, { name: "find", load: async () => (await Promise.resolve().then(function() {
  return findYGMSVGUV;
})).findCommand }, { name: "basename", load: async () => (await Promise.resolve().then(function() {
  return basenameCFA5ZIGT;
})).basenameCommand }, { name: "dirname", load: async () => (await Promise.resolve().then(function() {
  return dirnameYPJLCQYA;
})).dirnameCommand }, { name: "tree", load: async () => (await Promise.resolve().then(function() {
  return treeMEM64BW3;
})).treeCommand }, { name: "du", load: async () => (await Promise.resolve().then(function() {
  return duNQXEC3EF;
})).duCommand }, { name: "env", load: async () => (await Promise.resolve().then(function() {
  return env2UI6XINU;
})).envCommand }, { name: "printenv", load: async () => (await Promise.resolve().then(function() {
  return env2UI6XINU;
})).printenvCommand }, { name: "alias", load: async () => (await Promise.resolve().then(function() {
  return aliasATFBB6D2;
})).aliasCommand }, { name: "unalias", load: async () => (await Promise.resolve().then(function() {
  return aliasATFBB6D2;
})).unaliasCommand }, { name: "history", load: async () => (await Promise.resolve().then(function() {
  return historyMQDK2OPD;
})).historyCommand }, { name: "xargs", load: async () => (await Promise.resolve().then(function() {
  return xargs4FRA6OJ7;
})).xargsCommand }, { name: "true", load: async () => (await Promise.resolve().then(function() {
  return trueCNJ54NE6;
})).trueCommand }, { name: "false", load: async () => (await Promise.resolve().then(function() {
  return trueCNJ54NE6;
})).falseCommand }, { name: "clear", load: async () => (await Promise.resolve().then(function() {
  return clearVT2LJIDX;
})).clearCommand }, { name: "bash", load: async () => (await Promise.resolve().then(function() {
  return bashOLRNM52U;
})).bashCommand }, { name: "sh", load: async () => (await Promise.resolve().then(function() {
  return bashOLRNM52U;
})).shCommand }, { name: "jq", load: async () => (await Promise.resolve().then(function() {
  return jqRLRYRPOJ;
})).jqCommand }, { name: "base64", load: async () => (await Promise.resolve().then(function() {
  return base643BME25ON;
})).base64Command }, { name: "diff", load: async () => (await Promise.resolve().then(function() {
  return diffZLJYSBRK;
})).diffCommand }, { name: "date", load: async () => (await Promise.resolve().then(function() {
  return datePN3CMG7K;
})).dateCommand }, { name: "sleep", load: async () => (await Promise.resolve().then(function() {
  return sleepAK4QE4WR;
})).sleepCommand }, { name: "timeout", load: async () => (await Promise.resolve().then(function() {
  return timeoutX3X3N6IE;
})).timeoutCommand }, { name: "time", load: async () => (await Promise.resolve().then(function() {
  return timeUWXBG6CS;
})).timeCommand }, { name: "seq", load: async () => (await Promise.resolve().then(function() {
  return seq5VRIVQYP;
})).seqCommand }, { name: "expr", load: async () => (await Promise.resolve().then(function() {
  return exprDG4E7SIS;
})).exprCommand }, { name: "md5sum", load: async () => (await Promise.resolve().then(function() {
  return md5sumKLHZSRUA;
})).md5sumCommand }, { name: "sha1sum", load: async () => (await Promise.resolve().then(function() {
  return sha1sumWKWTIZGQ;
})).sha1sumCommand }, { name: "sha256sum", load: async () => (await Promise.resolve().then(function() {
  return sha256sumIUVNMBTA;
})).sha256sumCommand }, { name: "file", load: async () => (await Promise.resolve().then(function() {
  return fileNQP3CKRV;
})).fileCommand }, { name: "html-to-markdown", load: async () => (await Promise.resolve().then(function() {
  return htmlToMarkdownZK6GQVSL;
})).htmlToMarkdownCommand }, { name: "help", load: async () => (await Promise.resolve().then(function() {
  return help75YOGKM4;
})).helpCommand }, { name: "which", load: async () => (await Promise.resolve().then(function() {
  return whichUBLRBDHN;
})).whichCommand }, { name: "tac", load: async () => (await Promise.resolve().then(function() {
  return tac2X4JLF4W;
})).tac }, { name: "hostname", load: async () => (await Promise.resolve().then(function() {
  return hostnameNWR32CGF;
})).hostname }, { name: "whoami", load: async () => (await Promise.resolve().then(function() {
  return whoamiYUDAIS32;
})).whoami }, { name: "od", load: async () => (await Promise.resolve().then(function() {
  return od3FPDPLWJ;
})).od }, { name: "gzip", load: async () => (await Promise.resolve().then(function() {
  return gzipL3NDJG3F;
})).gzipCommand }, { name: "gunzip", load: async () => (await Promise.resolve().then(function() {
  return gzipL3NDJG3F;
})).gunzipCommand }, { name: "zcat", load: async () => (await Promise.resolve().then(function() {
  return gzipL3NDJG3F;
})).zcatCommand }];
(typeof __BROWSER__ > "u" || !__BROWSER__) && (Ee$5.push({ name: "tar", load: async () => (await Promise.resolve().then(function() {
  return tarLWIHPMT6;
})).tarCommand }), Ee$5.push({ name: "yq", load: async () => (await Promise.resolve().then(function() {
  return yqL665QPQU;
})).yqCommand }), Ee$5.push({ name: "xan", load: async () => (await Promise.resolve().then(function() {
  return xanA6VPI4HJ;
})).xanCommand }), Ee$5.push({ name: "sqlite3", load: async () => (await Promise.resolve().then(function() {
  return sqlite35QVZOGER;
})).sqlite3Command }), Ee$5.push({ name: "python3", load: async () => (await Promise.resolve().then(function() {
  return python33OP7EKER;
})).python3Command }), Ee$5.push({ name: "python", load: async () => (await Promise.resolve().then(function() {
  return python33OP7EKER;
})).pythonCommand }));
var on$1 = [{ name: "curl", load: async () => (await Promise.resolve().then(function() {
  return curlXLP4VABU;
})).curlCommand }], rn = /* @__PURE__ */ new Map();
function an(e5) {
  return { name: e5.name, async execute(t4, s3) {
    let n3 = rn.get(e5.name);
    return n3 || (n3 = await e5.load(), rn.set(e5.name, n3)), n3.execute(t4, s3);
  } };
}
function ln(e5) {
  return (e5 ? Ee$5.filter((s3) => e5.includes(s3.name)) : Ee$5).map(an);
}
function cn() {
  return on$1.map(an);
}
function fn$2(e5) {
  return "load" in e5 && typeof e5.load == "function";
}
function un(e5) {
  let t4 = null;
  return { name: e5.name, async execute(s3, n3) {
    return t4 || (t4 = await e5.load()), t4.execute(s3, n3);
  } };
}
var zr$1 = new TextEncoder(), Vr = new TextDecoder();
function $e$4(e5, t4) {
  if (e5 instanceof Uint8Array) return e5;
  if (t4 === "base64") return Uint8Array.from(atob(e5), (s3) => s3.charCodeAt(0));
  if (t4 === "hex") {
    let s3 = new Uint8Array(e5.length / 2);
    for (let n3 = 0; n3 < e5.length; n3 += 2) s3[n3 / 2] = parseInt(e5.slice(n3, n3 + 2), 16);
    return s3;
  }
  return t4 === "binary" || t4 === "latin1" ? Uint8Array.from(e5, (s3) => s3.charCodeAt(0)) : zr$1.encode(e5);
}
function xe$8(e5, t4) {
  return t4 === "base64" ? btoa(String.fromCharCode(...e5)) : t4 === "hex" ? Array.from(e5).map((s3) => s3.toString(16).padStart(2, "0")).join("") : t4 === "binary" || t4 === "latin1" ? String.fromCharCode(...e5) : Vr.decode(e5);
}
function ce$8(e5) {
  if (e5 != null) return typeof e5 == "string" ? e5 : e5.encoding ?? void 0;
}
var ut$3 = new TextEncoder();
function Br(e5) {
  return typeof e5 == "object" && e5 !== null && !(e5 instanceof Uint8Array) && "content" in e5;
}
var oe$7 = class e2 {
  static classId = "just-bash/InMemoryFs";
  data = /* @__PURE__ */ new Map();
  constructor(t4) {
    if (this.data.set("/", { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() }), t4) for (let [s3, n3] of Object.entries(t4)) Br(n3) ? this.writeFileSync(s3, n3.content, void 0, { mode: n3.mode, mtime: n3.mtime }) : this.writeFileSync(s3, n3);
  }
  normalizePath(t4) {
    if (!t4 || t4 === "/") return "/";
    let s3 = t4.endsWith("/") && t4 !== "/" ? t4.slice(0, -1) : t4;
    s3.startsWith("/") || (s3 = `/${s3}`);
    let n3 = s3.split("/").filter((i4) => i4 && i4 !== "."), r2 = [];
    for (let i4 of n3) i4 === ".." ? r2.pop() : r2.push(i4);
    return `/${r2.join("/")}` || "/";
  }
  dirname(t4) {
    let s3 = this.normalizePath(t4);
    if (s3 === "/") return "/";
    let n3 = s3.lastIndexOf("/");
    return n3 === 0 ? "/" : s3.slice(0, n3);
  }
  ensureParentDirs(t4) {
    let s3 = this.dirname(t4);
    s3 !== "/" && (this.data.has(s3) || (this.ensureParentDirs(s3), this.data.set(s3, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() })));
  }
  writeFileSync(t4, s3, n3, r2) {
    let i4 = this.normalizePath(t4);
    this.ensureParentDirs(i4);
    let o2 = ce$8(n3), a3 = $e$4(s3, o2);
    this.data.set(i4, { type: "file", content: a3, mode: r2?.mode ?? 420, mtime: r2?.mtime ?? /* @__PURE__ */ new Date() });
  }
  async readFile(t4, s3) {
    let n3 = await this.readFileBuffer(t4), r2 = ce$8(s3);
    return xe$8(n3, r2);
  }
  async readFileBuffer(t4) {
    let s3 = this.resolvePathWithSymlinks(t4), n3 = this.data.get(s3);
    if (!n3) throw new Error(`ENOENT: no such file or directory, open '${t4}'`);
    if (n3.type !== "file") throw new Error(`EISDIR: illegal operation on a directory, read '${t4}'`);
    return n3.content instanceof Uint8Array ? n3.content : ut$3.encode(n3.content);
  }
  async writeFile(t4, s3, n3) {
    this.writeFileSync(t4, s3, n3);
  }
  async appendFile(t4, s3, n3) {
    let r2 = this.normalizePath(t4), i4 = this.data.get(r2);
    if (i4 && i4.type === "directory") throw new Error(`EISDIR: illegal operation on a directory, write '${t4}'`);
    let o2 = ce$8(n3), a3 = $e$4(s3, o2);
    if (i4?.type === "file") {
      let l3 = i4.content instanceof Uint8Array ? i4.content : ut$3.encode(i4.content), c3 = new Uint8Array(l3.length + a3.length);
      c3.set(l3), c3.set(a3, l3.length), this.data.set(r2, { type: "file", content: c3, mode: i4.mode, mtime: /* @__PURE__ */ new Date() });
    } else this.writeFileSync(t4, s3, n3);
  }
  async exists(t4) {
    try {
      let s3 = this.resolvePathWithSymlinks(t4);
      return this.data.has(s3);
    } catch {
      return false;
    }
  }
  async stat(t4) {
    let s3 = this.resolvePathWithSymlinks(t4), n3 = this.data.get(s3);
    if (!n3) throw new Error(`ENOENT: no such file or directory, stat '${t4}'`);
    let r2 = 0;
    return n3.type === "file" && n3.content && (n3.content instanceof Uint8Array ? r2 = n3.content.length : r2 = ut$3.encode(n3.content).length), { isFile: n3.type === "file", isDirectory: n3.type === "directory", isSymbolicLink: false, mode: n3.mode, size: r2, mtime: n3.mtime || /* @__PURE__ */ new Date() };
  }
  async lstat(t4) {
    let s3 = this.resolveIntermediateSymlinks(t4), n3 = this.data.get(s3);
    if (!n3) throw new Error(`ENOENT: no such file or directory, lstat '${t4}'`);
    if (n3.type === "symlink") return { isFile: false, isDirectory: false, isSymbolicLink: true, mode: n3.mode, size: n3.target.length, mtime: n3.mtime || /* @__PURE__ */ new Date() };
    let r2 = 0;
    return n3.type === "file" && n3.content && (n3.content instanceof Uint8Array ? r2 = n3.content.length : r2 = ut$3.encode(n3.content).length), { isFile: n3.type === "file", isDirectory: n3.type === "directory", isSymbolicLink: false, mode: n3.mode, size: r2, mtime: n3.mtime || /* @__PURE__ */ new Date() };
  }
  resolveSymlink(t4, s3) {
    if (s3.startsWith("/")) return this.normalizePath(s3);
    let n3 = this.dirname(t4);
    return this.normalizePath(n3 === "/" ? `/${s3}` : `${n3}/${s3}`);
  }
  resolveIntermediateSymlinks(t4) {
    let s3 = this.normalizePath(t4);
    if (s3 === "/") return "/";
    let n3 = s3.slice(1).split("/");
    if (n3.length <= 1) return s3;
    let r2 = "", i4 = /* @__PURE__ */ new Set();
    for (let o2 = 0; o2 < n3.length - 1; o2++) {
      let a3 = n3[o2];
      r2 = `${r2}/${a3}`;
      let l3 = this.data.get(r2), c3 = 0, f3 = 40;
      for (; l3 && l3.type === "symlink" && c3 < f3; ) {
        if (i4.has(r2)) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t4}'`);
        i4.add(r2), r2 = this.resolveSymlink(r2, l3.target), l3 = this.data.get(r2), c3++;
      }
      if (c3 >= f3) throw new Error(`ELOOP: too many levels of symbolic links, lstat '${t4}'`);
    }
    return `${r2}/${n3[n3.length - 1]}`;
  }
  resolvePathWithSymlinks(t4) {
    let s3 = this.normalizePath(t4);
    if (s3 === "/") return "/";
    let n3 = s3.slice(1).split("/"), r2 = "", i4 = /* @__PURE__ */ new Set();
    for (let o2 of n3) {
      r2 = `${r2}/${o2}`;
      let a3 = this.data.get(r2), l3 = 0, c3 = 40;
      for (; a3 && a3.type === "symlink" && l3 < c3; ) {
        if (i4.has(r2)) throw new Error(`ELOOP: too many levels of symbolic links, open '${t4}'`);
        i4.add(r2), r2 = this.resolveSymlink(r2, a3.target), a3 = this.data.get(r2), l3++;
      }
      if (l3 >= c3) throw new Error(`ELOOP: too many levels of symbolic links, open '${t4}'`);
    }
    return r2;
  }
  async mkdir(t4, s3) {
    this.mkdirSync(t4, s3);
  }
  mkdirSync(t4, s3) {
    let n3 = this.normalizePath(t4);
    if (this.data.has(n3)) {
      if (this.data.get(n3)?.type === "file") throw new Error(`EEXIST: file already exists, mkdir '${t4}'`);
      if (!s3?.recursive) throw new Error(`EEXIST: directory already exists, mkdir '${t4}'`);
      return;
    }
    let r2 = this.dirname(n3);
    if (r2 !== "/" && !this.data.has(r2)) if (s3?.recursive) this.mkdirSync(r2, { recursive: true });
    else throw new Error(`ENOENT: no such file or directory, mkdir '${t4}'`);
    this.data.set(n3, { type: "directory", mode: 493, mtime: /* @__PURE__ */ new Date() });
  }
  async readdir(t4) {
    return (await this.readdirWithFileTypes(t4)).map((n3) => n3.name);
  }
  async readdirWithFileTypes(t4) {
    let s3 = this.normalizePath(t4), n3 = this.data.get(s3);
    if (!n3) throw new Error(`ENOENT: no such file or directory, scandir '${t4}'`);
    let r2 = /* @__PURE__ */ new Set();
    for (; n3 && n3.type === "symlink"; ) {
      if (r2.has(s3)) throw new Error(`ELOOP: too many levels of symbolic links, scandir '${t4}'`);
      r2.add(s3), s3 = this.resolveSymlink(s3, n3.target), n3 = this.data.get(s3);
    }
    if (!n3) throw new Error(`ENOENT: no such file or directory, scandir '${t4}'`);
    if (n3.type !== "directory") throw new Error(`ENOTDIR: not a directory, scandir '${t4}'`);
    let i4 = s3 === "/" ? "/" : `${s3}/`, o2 = /* @__PURE__ */ new Map();
    for (let [a3, l3] of this.data.entries()) if (a3 !== s3 && a3.startsWith(i4)) {
      let c3 = a3.slice(i4.length), f3 = c3.split("/")[0];
      f3 && !c3.includes("/", f3.length) && !o2.has(f3) && o2.set(f3, { name: f3, isFile: l3.type === "file", isDirectory: l3.type === "directory", isSymbolicLink: l3.type === "symlink" });
    }
    return Array.from(o2.values()).sort((a3, l3) => a3.name < l3.name ? -1 : a3.name > l3.name ? 1 : 0);
  }
  async rm(t4, s3) {
    let n3 = this.normalizePath(t4), r2 = this.data.get(n3);
    if (!r2) {
      if (s3?.force) return;
      throw new Error(`ENOENT: no such file or directory, rm '${t4}'`);
    }
    if (r2.type === "directory") {
      let i4 = await this.readdir(n3);
      if (i4.length > 0) {
        if (!s3?.recursive) throw new Error(`ENOTEMPTY: directory not empty, rm '${t4}'`);
        for (let o2 of i4) {
          let a3 = n3 === "/" ? `/${o2}` : `${n3}/${o2}`;
          await this.rm(a3, s3);
        }
      }
    }
    this.data.delete(n3);
  }
  async cp(t4, s3, n3) {
    let r2 = this.normalizePath(t4), i4 = this.normalizePath(s3), o2 = this.data.get(r2);
    if (!o2) throw new Error(`ENOENT: no such file or directory, cp '${t4}'`);
    if (o2.type === "file") this.ensureParentDirs(i4), this.data.set(i4, { ...o2 });
    else if (o2.type === "directory") {
      if (!n3?.recursive) throw new Error(`EISDIR: is a directory, cp '${t4}'`);
      await this.mkdir(i4, { recursive: true });
      let a3 = await this.readdir(r2);
      for (let l3 of a3) {
        let c3 = r2 === "/" ? `/${l3}` : `${r2}/${l3}`, f3 = i4 === "/" ? `/${l3}` : `${i4}/${l3}`;
        await this.cp(c3, f3, n3);
      }
    }
  }
  async mv(t4, s3) {
    await this.cp(t4, s3, { recursive: true }), await this.rm(t4, { recursive: true });
  }
  getAllPaths() {
    return Array.from(this.data.keys());
  }
  resolvePath(t4, s3) {
    if (s3.startsWith("/")) return this.normalizePath(s3);
    let n3 = t4 === "/" ? `/${s3}` : `${t4}/${s3}`;
    return this.normalizePath(n3);
  }
  async chmod(t4, s3) {
    let n3 = this.normalizePath(t4), r2 = this.data.get(n3);
    if (!r2) throw new Error(`ENOENT: no such file or directory, chmod '${t4}'`);
    r2.mode = s3;
  }
  async symlink(t4, s3) {
    let n3 = this.normalizePath(s3);
    if (this.data.has(n3)) throw new Error(`EEXIST: file already exists, symlink '${s3}'`);
    this.ensureParentDirs(n3), this.data.set(n3, { type: "symlink", target: t4, mode: 511, mtime: /* @__PURE__ */ new Date() });
  }
  async link(t4, s3) {
    let n3 = this.normalizePath(t4), r2 = this.normalizePath(s3), i4 = this.data.get(n3);
    if (!i4) throw new Error(`ENOENT: no such file or directory, link '${t4}'`);
    if (i4.type !== "file") throw new Error(`EPERM: operation not permitted, link '${t4}'`);
    if (this.data.has(r2)) throw new Error(`EEXIST: file already exists, link '${s3}'`);
    this.ensureParentDirs(r2), this.data.set(r2, { type: "file", content: i4.content, mode: i4.mode, mtime: i4.mtime });
  }
  async readlink(t4) {
    let s3 = this.normalizePath(t4), n3 = this.data.get(s3);
    if (!n3) throw new Error(`ENOENT: no such file or directory, readlink '${t4}'`);
    if (n3.type !== "symlink") throw new Error(`EINVAL: invalid argument, readlink '${t4}'`);
    return n3.target;
  }
  async realpath(t4) {
    let s3 = this.resolvePathWithSymlinks(t4);
    if (!this.data.has(s3)) throw new Error(`ENOENT: no such file or directory, realpath '${t4}'`);
    return s3;
  }
  static _serialize(t4) {
    return { data: t4.data };
  }
  static _deserialize(t4) {
    let s3 = new e2();
    return s3.data = t4.data, s3;
  }
  async utimes(t4, s3, n3) {
    let r2 = this.normalizePath(t4), i4 = this.resolvePathWithSymlinks(r2), o2 = this.data.get(i4);
    if (!o2) throw new Error(`ENOENT: no such file or directory, utimes '${t4}'`);
    o2.mtime = n3;
  }
};
oe$7[Ge$3] = oe$7._serialize;
oe$7[Ke$3] = oe$7._deserialize;
function jr(e5) {
  let t4 = e5;
  return typeof t4.mkdirSync == "function" && typeof t4.writeFileSync == "function";
}
function Hr$1(e5, t4) {
  e5.mkdirSync("/bin", { recursive: true }), e5.mkdirSync("/usr/bin", { recursive: true }), t4 && (e5.mkdirSync("/home/user", { recursive: true }), e5.mkdirSync("/tmp", { recursive: true }));
}
function Ur(e5) {
  e5.mkdirSync("/dev", { recursive: true }), e5.writeFileSync("/dev/null", ""), e5.writeFileSync("/dev/zero", new Uint8Array(0)), e5.writeFileSync("/dev/stdin", ""), e5.writeFileSync("/dev/stdout", ""), e5.writeFileSync("/dev/stderr", "");
}
function Zr(e5) {
  e5.mkdirSync("/proc/self/fd", { recursive: true }), e5.writeFileSync("/proc/version", `${Ni$2}
`), e5.writeFileSync("/proc/self/exe", "/bin/bash"), e5.writeFileSync("/proc/self/cmdline", "bash\0"), e5.writeFileSync("/proc/self/comm", `bash
`), e5.writeFileSync("/proc/self/status", ki$2()), e5.writeFileSync("/proc/self/fd/0", "/dev/stdin"), e5.writeFileSync("/proc/self/fd/1", "/dev/stdout"), e5.writeFileSync("/proc/self/fd/2", "/dev/stderr");
}
function dn$1(e5, t4) {
  jr(e5) && (Hr$1(e5, t4), Ur(e5), Zr(e5));
}
var qr = ["allexport", "errexit", "noglob", "noclobber", "noexec", "nounset", "pipefail", "posix", "verbose", "xtrace"], Gr = ["braceexpand", "hashall", "interactive-comments"];
function Ut$1(e5) {
  let t4 = [], s3 = [...Gr.map((n3) => ({ name: n3, enabled: true })), ...qr.map((n3) => ({ name: n3, enabled: e5[n3] }))].sort((n3, r2) => n3.name.localeCompare(r2.name));
  for (let n3 of s3) n3.enabled && t4.push(n3.name);
  return t4.join(":");
}
function Le$4(e5) {
  e5.state.env.SHELLOPTS = Ut$1(e5.state.options);
}
var Kr = ["dotglob", "expand_aliases", "extglob", "failglob", "globskipdots", "globstar", "lastpipe", "nocaseglob", "nocasematch", "nullglob", "xpg_echo"];
function Zt$2(e5) {
  let t4 = [];
  for (let s3 of Kr) e5[s3] && t4.push(s3);
  return t4.join(":");
}
function qt(e5) {
  e5.state.env.BASHOPTS = Zt$2(e5.state.shoptOptions);
}
var Xr = "BASH_ALIAS_";
function hn(e5) {
  return e5.parts.length !== 1 ? false : e5.parts[0].type === "Literal";
}
function pn$1(e5) {
  if (e5.parts.length !== 1) return null;
  let t4 = e5.parts[0];
  return t4.type === "Literal" ? t4.value : null;
}
function mn(e5, t4) {
  return e5.env[`${Xr}${t4}`];
}
function Gt$1(e5, t4, s3) {
  if (!t4.name || !hn(t4.name)) return t4;
  let n3 = pn$1(t4.name);
  if (!n3) return t4;
  let r2 = mn(e5, n3);
  if (!r2 || s3.has(n3)) return t4;
  try {
    s3.add(n3);
    let i4 = new T$9(), o2 = r2, a3 = r2.endsWith(" ");
    if (!a3) for (let u3 of t4.args) {
      let d3 = wn(u3);
      o2 += ` ${d3}`;
    }
    let l3;
    try {
      l3 = i4.parse(o2);
    } catch (u3) {
      if (u3 instanceof Q$9) throw u3;
      return t4;
    }
    if (l3.statements.length !== 1 || l3.statements[0].pipelines.length !== 1 || l3.statements[0].pipelines[0].commands.length !== 1) return yn(t4, r2);
    let c3 = l3.statements[0].pipelines[0].commands[0];
    if (c3.type !== "SimpleCommand") return yn(t4, r2);
    let f3 = { ...c3, assignments: [...t4.assignments, ...c3.assignments], redirections: [...c3.redirections, ...t4.redirections], line: t4.line };
    if (a3 && t4.args.length > 0 && (f3 = { ...f3, args: [...f3.args, ...t4.args] }, f3.args.length > 0)) {
      let u3 = f3.args[0];
      if (hn(u3)) {
        let d3 = pn$1(u3);
        if (d3 && mn(e5, d3)) {
          let h3 = { type: "SimpleCommand", name: u3, args: f3.args.slice(1), assignments: [], redirections: [] }, m3 = Gt$1(e5, h3, s3);
          m3 !== h3 && (f3 = { ...f3, name: m3.name, args: [...m3.args] });
        }
      }
    }
    return f3;
  } catch (i4) {
    throw s3.delete(n3), i4;
  }
}
function yn(e5, t4) {
  let s3 = t4;
  for (let o2 of e5.args) {
    let a3 = wn(o2);
    s3 += ` ${a3}`;
  }
  let n3 = new T$9(), r2 = n3.parseWordFromString("eval", false, false), i4 = n3.parseWordFromString(`'${s3.replace(/'/g, "'\\''")}'`, false, false);
  return { type: "SimpleCommand", name: r2, args: [i4], assignments: e5.assignments, redirections: e5.redirections, line: e5.line };
}
function wn(e5) {
  let t4 = "";
  for (let s3 of e5.parts) switch (s3.type) {
    case "Literal":
      t4 += s3.value.replace(/([\s"'$`\\*?[\]{}()<>|&;#!])/g, "\\$1");
      break;
    case "SingleQuoted":
      t4 += `'${s3.value}'`;
      break;
    case "DoubleQuoted":
      t4 += `"${s3.parts.map((n3) => n3.type === "Literal" ? n3.value : `$${n3.type}`).join("")}"`;
      break;
    case "ParameterExpansion":
      t4 += `\${${s3.parameter}}`;
      break;
    case "CommandSubstitution":
      t4 += "$(...)";
      break;
    case "ArithmeticExpansion":
      t4 += `$((${s3.expression}))`;
      break;
    case "Glob":
      t4 += s3.pattern;
      break;
  }
  return t4;
}
async function gn(e5, t4) {
  let s3 = t4.parts.map((f3) => f3.type === "Literal" ? f3.value : "\0").join(""), n3 = s3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
  if (!n3 || !s3.endsWith(")")) return null;
  let r2 = n3[1], i4 = [], o2 = false, a3 = "", l3 = false;
  for (let f3 of t4.parts) if (f3.type === "Literal") {
    let u3 = f3.value;
    if (!o2) {
      let d3 = u3.indexOf("=(");
      d3 !== -1 && (o2 = true, u3 = u3.slice(d3 + 2));
    }
    if (o2) {
      u3.endsWith(")") && (u3 = u3.slice(0, -1));
      let d3 = u3.split(/(\s+)/);
      for (let h3 of d3) /^\s+$/.test(h3) ? (a3 || l3) && (i4.push(a3), a3 = "", l3 = false) : h3 && (a3 += h3);
    }
  } else if (o2) if (f3.type === "BraceExpansion") if (/^\[.+\]=/.test(a3)) a3 += hn$1({ parts: [f3] });
  else {
    (a3 || l3) && (i4.push(a3), a3 = "", l3 = false);
    let d3 = await ul$1(e5, { type: "Word", parts: [f3] });
    i4.push(...d3.values);
  }
  else {
    (f3.type === "SingleQuoted" || f3.type === "DoubleQuoted" || f3.type === "Escaped") && (l3 = true);
    let u3 = await wt$5(e5, { parts: [f3] });
    a3 += u3;
  }
  (a3 || l3) && i4.push(a3);
  let c3 = i4.map((f3) => /^\[.+\]=/.test(f3) ? f3 : f3 === "" ? "''" : /[\s"'\\$`!*?[\]{}|&;<>()]/.test(f3) && !f3.startsWith("'") && !f3.startsWith('"') ? `'${f3.replace(/'/g, "'\\''")}'` : f3);
  return `${r2}=(${c3.join(" ")})`;
}
async function vn(e5, t4) {
  let s3 = -1, n3 = -1, r2 = false;
  for (let p3 = 0; p3 < t4.parts.length; p3++) {
    let w4 = t4.parts[p3];
    if (w4.type === "Literal") {
      let b4 = w4.value.indexOf("+=");
      if (b4 !== -1) {
        let C2 = w4.value.slice(0, b4);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(C2)) {
          s3 = p3, n3 = b4, r2 = true;
          break;
        }
        if (/^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(C2)) {
          s3 = p3, n3 = b4, r2 = true;
          break;
        }
      }
      let $5 = w4.value.indexOf("=");
      if ($5 !== -1 && ($5 === 0 || w4.value[$5 - 1] !== "+")) {
        let C2 = w4.value.slice(0, $5);
        if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(C2) || /^[a-zA-Z_][a-zA-Z0-9_]*\[[^\]]+\]$/.test(C2)) {
          s3 = p3, n3 = $5;
          break;
        }
      }
    }
  }
  if (s3 === -1) return null;
  let i4 = t4.parts.slice(0, s3), o2 = t4.parts[s3];
  if (o2.type !== "Literal") return null;
  let a3 = r2 ? 2 : 1, l3 = o2.value.slice(0, n3), c3 = o2.value.slice(n3 + a3), f3 = t4.parts.slice(s3 + 1), u3 = "";
  for (let p3 of i4) u3 += await wt$5(e5, { parts: [p3] });
  u3 += l3;
  let d3 = { parts: c3 !== "" ? [{ type: "Literal", value: c3 }, ...f3] : f3 }, h3 = d3.parts.length > 0 ? await wt$5(e5, d3) : "";
  return `${u3}${r2 ? "+=" : "="}${h3}`;
}
var Yr = ["tar", "yq", "xan", "sqlite3", "python3", "python"];
function bn$1(e5) {
  return Yr.includes(e5);
}
var L$d = Object.freeze({ stdout: "", stderr: "", exitCode: 0 });
function F$a(e5 = "") {
  return { stdout: e5, stderr: "", exitCode: 0 };
}
function S$d(e5, t4 = 1) {
  return { stdout: "", stderr: e5, exitCode: t4 };
}
function P$f(e5, t4, s3) {
  return { stdout: e5, stderr: t4, exitCode: s3 };
}
function Z$6(e5) {
  return { stdout: "", stderr: "", exitCode: e5 ? 0 : 1 };
}
function Se$5(e5, t4, s3 = "", n3 = "") {
  throw new b$i(e5, t4, s3, n3);
}
function Kt(e5, t4) {
  if (e5.state.loopDepth === 0) {
    if (e5.state.parentHasLoopContext) throw new $$a();
    return L$d;
  }
  if (t4.length > 1) throw new d$8(1, "", `bash: break: too many arguments
`);
  let s3 = 1;
  if (t4.length > 0) {
    let n3 = Number.parseInt(t4[0], 10);
    if (Number.isNaN(n3) || n3 < 1) throw new d$8(128, "", `bash: break: ${t4[0]}: numeric argument required
`);
    s3 = n3;
  }
  throw new c$7(s3);
}
async function Xt$1(e5, t4) {
  let s3, n3 = false, r2 = false, i4 = 0;
  for (; i4 < t4.length; ) if (t4[i4] === "--") {
    i4++;
    break;
  } else if (t4[i4] === "-L") r2 = false, i4++;
  else if (t4[i4] === "-P") r2 = true, i4++;
  else if (t4[i4].startsWith("-") && t4[i4] !== "-") i4++;
  else break;
  let o2 = t4.slice(i4);
  if (o2.length === 0 || o2[0] === "~" ? s3 = e5.state.env.HOME || "/" : o2[0] === "-" ? (s3 = e5.state.previousDir, n3 = true) : s3 = o2[0], !s3.startsWith("/") && !s3.startsWith("./") && !s3.startsWith("../") && s3 !== "." && s3 !== "..") {
    let u3 = e5.state.env.CDPATH;
    if (u3) {
      let d3 = u3.split(":").filter((h3) => h3);
      for (let h3 of d3) {
        let m3 = h3.startsWith("/") ? `${h3}/${s3}` : `${e5.state.cwd}/${h3}/${s3}`;
        try {
          if ((await e5.fs.stat(m3)).isDirectory) {
            s3 = m3, n3 = true;
            break;
          }
        } catch {
        }
      }
    }
  }
  let l3 = (s3.startsWith("/") ? s3 : `${e5.state.cwd}/${s3}`).split("/").filter((u3) => u3 && u3 !== "."), c3 = "";
  for (let u3 of l3) if (u3 === "..") c3 = c3.split("/").slice(0, -1).join("/") || "/";
  else {
    c3 = c3 ? `${c3}/${u3}` : `/${u3}`;
    try {
      if (!(await e5.fs.stat(c3)).isDirectory) return S$d(`bash: cd: ${s3}: Not a directory
`);
    } catch {
      return S$d(`bash: cd: ${s3}: No such file or directory
`);
    }
  }
  let f3 = c3 || "/";
  if (r2) try {
    f3 = await e5.fs.realpath(f3);
  } catch {
  }
  return e5.state.previousDir = e5.state.cwd, e5.state.cwd = f3, e5.state.env.PWD = e5.state.cwd, e5.state.env.OLDPWD = e5.state.previousDir, F$a(n3 ? `${f3}
` : "");
}
function Yt(e5, t4) {
  return e5.fs.resolvePath(e5.state.cwd, t4);
}
var Qr = ["-e", "-a", "-f", "-d", "-r", "-w", "-x", "-s", "-L", "-h", "-k", "-g", "-u", "-G", "-O", "-b", "-c", "-p", "-S", "-t", "-N"];
function dt$3(e5) {
  return Qr.includes(e5);
}
async function ht$3(e5, t4, s3) {
  let n3 = Yt(e5, s3);
  switch (t4) {
    case "-e":
    case "-a":
      return e5.fs.exists(n3);
    case "-f":
      return await e5.fs.exists(n3) ? (await e5.fs.stat(n3)).isFile : false;
    case "-d":
      return await e5.fs.exists(n3) ? (await e5.fs.stat(n3)).isDirectory : false;
    case "-r":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 256) !== 0 : false;
    case "-w":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 128) !== 0 : false;
    case "-x":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 64) !== 0 : false;
    case "-s":
      return await e5.fs.exists(n3) ? (await e5.fs.stat(n3)).size > 0 : false;
    case "-L":
    case "-h":
      try {
        return (await e5.fs.lstat(n3)).isSymbolicLink;
      } catch {
        return false;
      }
    case "-k":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 512) !== 0 : false;
    case "-g":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 1024) !== 0 : false;
    case "-u":
      return await e5.fs.exists(n3) ? ((await e5.fs.stat(n3)).mode & 2048) !== 0 : false;
    case "-G":
    case "-O":
      return e5.fs.exists(n3);
    case "-b":
      return false;
    case "-c":
      return ["/dev/null", "/dev/zero", "/dev/random", "/dev/urandom", "/dev/tty", "/dev/stdin", "/dev/stdout", "/dev/stderr"].some((i4) => n3 === i4 || n3.endsWith(i4));
    case "-p":
      return false;
    case "-S":
      return false;
    case "-t":
      return false;
    case "-N":
      return e5.fs.exists(n3);
    default:
      return false;
  }
}
var Jr = ["-nt", "-ot", "-ef"];
function pt$1(e5) {
  return Jr.includes(e5);
}
async function mt$2(e5, t4, s3, n3) {
  let r2 = Yt(e5, s3), i4 = Yt(e5, n3);
  switch (t4) {
    case "-nt":
      try {
        let o2 = await e5.fs.stat(r2), a3 = await e5.fs.stat(i4);
        return o2.mtime > a3.mtime;
      } catch {
        return false;
      }
    case "-ot":
      try {
        let o2 = await e5.fs.stat(r2), a3 = await e5.fs.stat(i4);
        return o2.mtime < a3.mtime;
      } catch {
        return false;
      }
    case "-ef":
      try {
        if (!await e5.fs.exists(r2) || !await e5.fs.exists(i4)) return false;
        let o2 = e5.fs.resolvePath(e5.state.cwd, r2), a3 = e5.fs.resolvePath(e5.state.cwd, i4);
        return o2 === a3;
      } catch {
        return false;
      }
    default:
      return false;
  }
}
var ei = /* @__PURE__ */ new Set(["-eq", "-ne", "-lt", "-le", "-gt", "-ge"]);
function yt$3(e5) {
  return ei.has(e5);
}
function wt$4(e5, t4, s3) {
  switch (e5) {
    case "-eq":
      return t4 === s3;
    case "-ne":
      return t4 !== s3;
    case "-lt":
      return t4 < s3;
    case "-le":
      return t4 <= s3;
    case "-gt":
      return t4 > s3;
    case "-ge":
      return t4 >= s3;
  }
}
function Xe$3(e5) {
  return e5 === "=" || e5 === "==" || e5 === "!=";
}
function gt$3(e5, t4, s3, n3 = false, r2 = false, i4 = false) {
  if (n3) {
    let a3 = Fe$5(t4, s3, r2, i4);
    return e5 === "!=" ? !a3 : a3;
  }
  if (r2) {
    let a3 = t4.toLowerCase() === s3.toLowerCase();
    return e5 === "!=" ? !a3 : a3;
  }
  let o2 = t4 === s3;
  return e5 === "!=" ? !o2 : o2;
}
var ti = /* @__PURE__ */ new Set(["-z", "-n"]);
function vt$2(e5) {
  return ti.has(e5);
}
function bt$1(e5, t4) {
  switch (e5) {
    case "-z":
      return t4 === "";
    case "-n":
      return t4 !== "";
  }
}
async function Et$2(e5, t4) {
  let s3 = t4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
  if (s3) {
    let n3 = s3[1], r2 = s3[2];
    if (e5.state.associativeArrays?.has(n3)) {
      let a3 = r2;
      return (a3.startsWith("'") && a3.endsWith("'") || a3.startsWith('"') && a3.endsWith('"')) && (a3 = a3.slice(1, -1)), a3 = a3.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (l3, c3) => e5.state.env[c3] || ""), `${n3}_${a3}` in e5.state.env;
    }
    let o2;
    try {
      let a3 = new T$9(), l3 = W$d(a3, r2);
      o2 = await R$a(e5, l3.expression);
    } catch {
      if (/^-?\d+$/.test(r2)) o2 = Number.parseInt(r2, 10);
      else {
        let a3 = e5.state.env[r2];
        o2 = a3 ? Number.parseInt(a3, 10) : 0;
      }
    }
    if (o2 < 0) {
      let a3 = pt$2(e5, n3), l3 = e5.state.currentLine;
      if (a3.length === 0) return e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${l3}: ${n3}: bad array subscript
`, false;
      if (o2 = Math.max(...a3) + 1 + o2, o2 < 0) return e5.state.expansionStderr = (e5.state.expansionStderr || "") + `bash: line ${l3}: ${n3}: bad array subscript
`, false;
    }
    return `${n3}_${o2}` in e5.state.env;
  }
  return t4 in e5.state.env ? true : e5.state.associativeArrays?.has(t4) ? ht$4(e5, t4).length > 0 : pt$2(e5, t4).length > 0;
}
async function ke$6(e5, t4) {
  switch (t4.type) {
    case "CondBinary": {
      let s3 = await wt$5(e5, t4.left), n3 = t4.right.parts.length > 0 && t4.right.parts.every((i4) => i4.type === "SingleQuoted" || i4.type === "DoubleQuoted" || i4.type === "Escaped" && t4.operator !== "=~"), r2;
      if (t4.operator === "=~") if (n3) {
        let i4 = await wt$5(e5, t4.right);
        r2 = Et$3(i4);
      } else r2 = await ol$1(e5, t4.right);
      else Xe$3(t4.operator) && !n3 ? r2 = await ll$1(e5, t4.right) : r2 = await wt$5(e5, t4.right);
      if (Xe$3(t4.operator)) {
        let i4 = e5.state.shoptOptions.nocasematch;
        return gt$3(t4.operator, s3, r2, !n3, i4, true);
      }
      if (yt$3(t4.operator)) return wt$4(t4.operator, await $n(e5, s3), await $n(e5, r2));
      if (pt$1(t4.operator)) return mt$2(e5, t4.operator, s3, r2);
      switch (t4.operator) {
        case "=~":
          try {
            let i4 = e5.state.shoptOptions.nocasematch, o2 = ii(r2), a3 = new RegExp(o2, i4 ? "i" : ""), l3 = s3.match(a3);
            if (Ri$1(e5, "BASH_REMATCH"), l3) for (let c3 = 0; c3 < l3.length; c3++) e5.state.env[`BASH_REMATCH_${c3}`] = l3[c3] || "";
            return l3 !== null;
          } catch {
            throw new Error("syntax error in regular expression");
          }
        case "<":
          return s3 < r2;
        case ">":
          return s3 > r2;
        default:
          return false;
      }
    }
    case "CondUnary": {
      let s3 = await wt$5(e5, t4.operand);
      return dt$3(t4.operator) ? ht$3(e5, t4.operator, s3) : vt$2(t4.operator) ? bt$1(t4.operator, s3) : t4.operator === "-v" ? await Et$2(e5, s3) : t4.operator === "-o" ? Jt$1(e5, s3) : false;
    }
    case "CondNot":
      return e5.state.shoptOptions.extglob && t4.operand.type === "CondGroup" && t4.operand.expression.type === "CondWord" ? `!(${await wt$5(e5, t4.operand.expression.word)})` !== "" : !await ke$6(e5, t4.operand);
    case "CondAnd":
      return await ke$6(e5, t4.left) ? await ke$6(e5, t4.right) : false;
    case "CondOr":
      return await ke$6(e5, t4.left) ? true : await ke$6(e5, t4.right);
    case "CondGroup":
      return await ke$6(e5, t4.expression);
    case "CondWord":
      return await wt$5(e5, t4.word) !== "";
    default:
      return false;
  }
}
async function Ye$4(e5, t4) {
  if (t4.length === 0) return P$f("", "", 1);
  if (t4.length === 1) return Z$6(!!t4[0]);
  if (t4.length === 2) {
    let n3 = t4[0], r2 = t4[1];
    return n3 === "(" ? S$d(`test: '(' without matching ')'
`, 2) : dt$3(n3) ? Z$6(await ht$3(e5, n3, r2)) : vt$2(n3) ? Z$6(bt$1(n3, r2)) : n3 === "!" ? Z$6(!r2) : n3 === "-v" ? Z$6(await Et$2(e5, r2)) : n3 === "-o" ? Z$6(Jt$1(e5, r2)) : n3 === "=" || n3 === "==" || n3 === "!=" || n3 === "<" || n3 === ">" || n3 === "-eq" || n3 === "-ne" || n3 === "-lt" || n3 === "-le" || n3 === "-gt" || n3 === "-ge" || n3 === "-nt" || n3 === "-ot" || n3 === "-ef" ? S$d(`test: ${n3}: unary operator expected
`, 2) : P$f("", "", 1);
  }
  if (t4.length === 3) {
    let n3 = t4[0], r2 = t4[1], i4 = t4[2];
    if (Xe$3(r2)) return Z$6(gt$3(r2, n3, i4));
    if (yt$3(r2)) {
      let o2 = $t$1(n3), a3 = $t$1(i4);
      return !o2.valid || !a3.valid ? P$f("", "", 2) : Z$6(wt$4(r2, o2.value, a3.value));
    }
    if (pt$1(r2)) return Z$6(await mt$2(e5, r2, n3, i4));
    switch (r2) {
      case "-a":
        return Z$6(n3 !== "" && i4 !== "");
      case "-o":
        return Z$6(n3 !== "" || i4 !== "");
      case ">":
        return Z$6(n3 > i4);
      case "<":
        return Z$6(n3 < i4);
    }
    if (n3 === "!") {
      let o2 = await Ye$4(e5, [r2, i4]);
      return P$f("", o2.stderr, o2.exitCode === 0 ? 1 : o2.exitCode === 1 ? 0 : o2.exitCode);
    }
    if (n3 === "(" && i4 === ")") return Z$6(r2 !== "");
  }
  if (t4.length === 4) {
    if (t4[0] === "!") {
      let n3 = await Ye$4(e5, t4.slice(1));
      return P$f("", n3.stderr, n3.exitCode === 0 ? 1 : n3.exitCode === 1 ? 0 : n3.exitCode);
    }
    if (t4[0] === "(" && t4[3] === ")") return Ye$4(e5, [t4[1], t4[2]]);
  }
  let s3 = await An(e5, t4, 0);
  return s3.pos < t4.length ? S$d(`test: too many arguments
`, 2) : Z$6(s3.value);
}
async function An(e5, t4, s3) {
  return si(e5, t4, s3);
}
async function si(e5, t4, s3) {
  let { value: n3, pos: r2 } = await En$1(e5, t4, s3);
  for (; t4[r2] === "-o"; ) {
    let i4 = await En$1(e5, t4, r2 + 1);
    n3 = n3 || i4.value, r2 = i4.pos;
  }
  return { value: n3, pos: r2 };
}
async function En$1(e5, t4, s3) {
  let { value: n3, pos: r2 } = await Qt$1(e5, t4, s3);
  for (; t4[r2] === "-a"; ) {
    let i4 = await Qt$1(e5, t4, r2 + 1);
    n3 = n3 && i4.value, r2 = i4.pos;
  }
  return { value: n3, pos: r2 };
}
async function Qt$1(e5, t4, s3) {
  if (t4[s3] === "!") {
    let { value: n3, pos: r2 } = await Qt$1(e5, t4, s3 + 1);
    return { value: !n3, pos: r2 };
  }
  return ni$1(e5, t4, s3);
}
async function ni$1(e5, t4, s3) {
  let n3 = t4[s3];
  if (n3 === "(") {
    let { value: i4, pos: o2 } = await An(e5, t4, s3 + 1);
    return { value: i4, pos: t4[o2] === ")" ? o2 + 1 : o2 };
  }
  let r2 = t4[s3 + 1];
  if (Xe$3(r2)) {
    let i4 = n3, o2 = t4[s3 + 2] ?? "";
    return { value: gt$3(r2, i4, o2), pos: s3 + 3 };
  }
  if (yt$3(r2)) {
    let i4 = $t$1(n3), o2 = $t$1(t4[s3 + 2] ?? "0");
    return !i4.valid || !o2.valid ? { value: false, pos: s3 + 3 } : { value: wt$4(r2, i4.value, o2.value), pos: s3 + 3 };
  }
  if (pt$1(r2)) {
    let i4 = n3, o2 = t4[s3 + 2] ?? "";
    return { value: await mt$2(e5, r2, i4, o2), pos: s3 + 3 };
  }
  if (dt$3(n3)) {
    let i4 = t4[s3 + 1] ?? "";
    return { value: await ht$3(e5, n3, i4), pos: s3 + 2 };
  }
  if (vt$2(n3)) {
    let i4 = t4[s3 + 1] ?? "";
    return { value: bt$1(n3, i4), pos: s3 + 2 };
  }
  if (n3 === "-v") {
    let i4 = t4[s3 + 1] ?? "";
    return { value: await Et$2(e5, i4), pos: s3 + 2 };
  }
  if (n3 === "-o") {
    let i4 = t4[s3 + 1] ?? "";
    return { value: Jt$1(e5, i4), pos: s3 + 2 };
  }
  return { value: n3 !== void 0 && n3 !== "", pos: s3 + 1 };
}
function Fe$5(e5, t4, s3 = false, n3 = false) {
  let r2 = `^${Pn(t4, n3)}$`, i4 = s3 ? "is" : "s";
  return new RegExp(r2, i4).test(e5);
}
function Pn(e5, t4) {
  let s3 = "";
  for (let n3 = 0; n3 < e5.length; n3++) {
    let r2 = e5[n3];
    if (t4 && (r2 === "@" || r2 === "*" || r2 === "+" || r2 === "?" || r2 === "!") && n3 + 1 < e5.length && e5[n3 + 1] === "(") {
      let i4 = _n(e5, n3 + 1);
      if (i4 !== -1) {
        let o2 = e5.slice(n3 + 2, i4), a3 = Nn(o2), l3 = a3.map((f3) => Pn(f3, t4)), c3 = l3.length > 0 ? l3.join("|") : "(?:)";
        if (r2 === "@") s3 += `(?:${c3})`;
        else if (r2 === "*") s3 += `(?:${c3})*`;
        else if (r2 === "+") s3 += `(?:${c3})+`;
        else if (r2 === "?") s3 += `(?:${c3})?`;
        else if (r2 === "!") if (i4 < e5.length - 1) {
          let u3 = a3.map((h3) => Cn(h3, t4));
          if (u3.every((h3) => h3 !== null) && u3.every((h3) => h3 === u3[0]) && u3[0] !== null) {
            let h3 = u3[0];
            if (h3 === 0) s3 += "(?:.+)";
            else {
              let m3 = [];
              h3 > 0 && m3.push(`.{0,${h3 - 1}}`), m3.push(`.{${h3 + 1},}`), m3.push(`(?!(?:${c3})).{${h3}}`), s3 += `(?:${m3.join("|")})`;
            }
          } else s3 += `(?:(?!(?:${c3})).)*?`;
        } else s3 += `(?!(?:${c3})$).*`;
        n3 = i4;
        continue;
      }
    }
    if (r2 === "\\") if (n3 + 1 < e5.length) {
      let i4 = e5[n3 + 1];
      /[\\^$.|+(){}[\]*?]/.test(i4) ? s3 += `\\${i4}` : s3 += i4, n3++;
    } else s3 += "\\\\";
    else if (r2 === "*") s3 += ".*";
    else if (r2 === "?") s3 += ".";
    else if (r2 === "[") {
      let i4 = e5.indexOf("]", n3 + 1);
      i4 !== -1 ? (s3 += e5.slice(n3, i4 + 1), n3 = i4) : s3 += "\\[";
    } else /[\\^$.|+(){}]/.test(r2) ? s3 += `\\${r2}` : s3 += r2;
  }
  return s3;
}
function _n(e5, t4) {
  let s3 = 1, n3 = t4 + 1;
  for (; n3 < e5.length && s3 > 0; ) {
    let r2 = e5[n3];
    if (r2 === "\\") {
      n3 += 2;
      continue;
    }
    if (r2 === "(") s3++;
    else if (r2 === ")" && (s3--, s3 === 0)) return n3;
    n3++;
  }
  return -1;
}
function Nn(e5) {
  let t4 = [], s3 = "", n3 = 0, r2 = 0;
  for (; r2 < e5.length; ) {
    let i4 = e5[r2];
    if (i4 === "\\") {
      s3 += i4, r2 + 1 < e5.length ? (s3 += e5[r2 + 1], r2 += 2) : r2++;
      continue;
    }
    i4 === "(" ? (n3++, s3 += i4) : i4 === ")" ? (n3--, s3 += i4) : i4 === "|" && n3 === 0 ? (t4.push(s3), s3 = "") : s3 += i4, r2++;
  }
  return t4.push(s3), t4;
}
function Cn(e5, t4) {
  let s3 = 0, n3 = 0;
  for (; n3 < e5.length; ) {
    let r2 = e5[n3];
    if (t4 && (r2 === "@" || r2 === "*" || r2 === "+" || r2 === "?" || r2 === "!") && n3 + 1 < e5.length && e5[n3 + 1] === "(") {
      let i4 = _n(e5, n3 + 1);
      if (i4 !== -1) {
        if (r2 === "@") {
          let o2 = e5.slice(n3 + 2, i4), l3 = Nn(o2).map((c3) => Cn(c3, t4));
          if (l3.every((c3) => c3 !== null) && l3.every((c3) => c3 === l3[0])) {
            s3 += l3[0], n3 = i4 + 1;
            continue;
          }
          return null;
        }
        return null;
      }
    }
    if (r2 === "*") return null;
    if (r2 === "?") {
      s3 += 1, n3++;
      continue;
    }
    if (r2 === "[") {
      let i4 = e5.indexOf("]", n3 + 1);
      if (i4 !== -1) {
        s3 += 1, n3 = i4 + 1;
        continue;
      }
      s3 += 1, n3++;
      continue;
    }
    if (r2 === "\\") {
      s3 += 1, n3 += 2;
      continue;
    }
    s3 += 1, n3++;
  }
  return s3;
}
function Jt$1(e5, t4) {
  let n3 = { errexit: () => e5.state.options.errexit === true, nounset: () => e5.state.options.nounset === true, pipefail: () => e5.state.options.pipefail === true, xtrace: () => e5.state.options.xtrace === true, e: () => e5.state.options.errexit === true, u: () => e5.state.options.nounset === true, x: () => e5.state.options.xtrace === true }[t4];
  return n3 ? n3() : false;
}
async function $n(e5, t4) {
  if (t4 = t4.trim(), t4 === "") return 0;
  if (/^[+-]?(\d+#[a-zA-Z0-9@_]+|0[xX][0-9a-fA-F]+|0[0-7]+|\d+)$/.test(t4)) return Sn(t4);
  try {
    let s3 = new T$9(), n3 = W$d(s3, t4);
    return await R$a(e5, n3.expression);
  } catch {
    return Sn(t4);
  }
}
function ri(e5, t4) {
  let s3 = 0;
  for (let n3 of e5) {
    let r2;
    if (n3 >= "0" && n3 <= "9") r2 = n3.charCodeAt(0) - 48;
    else if (n3 >= "a" && n3 <= "z") r2 = n3.charCodeAt(0) - 97 + 10;
    else if (n3 >= "A" && n3 <= "Z") r2 = n3.charCodeAt(0) - 65 + 36;
    else if (n3 === "@") r2 = 62;
    else if (n3 === "_") r2 = 63;
    else return Number.NaN;
    if (r2 >= t4) return Number.NaN;
    s3 = s3 * t4 + r2;
  }
  return s3;
}
function Sn(e5) {
  if (e5 = e5.trim(), e5 === "") return 0;
  let t4 = false;
  e5.startsWith("-") ? (t4 = true, e5 = e5.slice(1)) : e5.startsWith("+") && (e5 = e5.slice(1));
  let s3, n3 = e5.match(/^(\d+)#([a-zA-Z0-9@_]+)$/);
  if (n3) {
    let r2 = Number.parseInt(n3[1], 10);
    r2 >= 2 && r2 <= 64 ? s3 = ri(n3[2], r2) : s3 = 0;
  } else /^0[xX][0-9a-fA-F]+$/.test(e5) ? s3 = Number.parseInt(e5, 16) : /^0[0-7]+$/.test(e5) ? s3 = Number.parseInt(e5, 8) : s3 = Number.parseInt(e5, 10);
  return Number.isNaN(s3) && (s3 = 0), t4 ? -s3 : s3;
}
function $t$1(e5) {
  if (e5 = e5.trim(), e5 === "") return { value: 0, valid: true };
  let t4 = false;
  if (e5.startsWith("-") ? (t4 = true, e5 = e5.slice(1)) : e5.startsWith("+") && (e5 = e5.slice(1)), !/^\d+$/.test(e5)) return { value: 0, valid: false };
  let s3 = Number.parseInt(e5, 10);
  return Number.isNaN(s3) ? { value: 0, valid: false } : { value: t4 ? -s3 : s3, valid: true };
}
function ii(e5) {
  let t4 = "", s3 = 0;
  for (; s3 < e5.length; ) if (e5[s3] === "\\" && s3 + 1 < e5.length) t4 += e5[s3] + e5[s3 + 1], s3 += 2;
  else if (e5[s3] === "[") {
    let n3 = oi(e5, s3);
    t4 += n3.converted, s3 = n3.endIndex;
  } else t4 += e5[s3], s3++;
  return t4;
}
function oi(e5, t4) {
  let s3 = t4 + 1, n3 = "[";
  s3 < e5.length && (e5[s3] === "^" || e5[s3] === "!") && (n3 += "^", s3++);
  let r2 = false;
  s3 < e5.length && e5[s3] === "]" && (r2 = true, s3++);
  let i4 = false;
  s3 < e5.length && e5[s3] === "[" && s3 + 1 < e5.length && e5[s3 + 1] !== ":" && (i4 = true, s3++);
  let o2 = "", a3 = false;
  for (; s3 < e5.length; ) {
    let l3 = e5[s3];
    if (l3 === "]") {
      a3 = true, s3++;
      break;
    }
    if (l3 === "[" && s3 + 1 < e5.length && e5[s3 + 1] === ":") {
      let c3 = e5.indexOf(":]", s3 + 2);
      if (c3 !== -1) {
        let f3 = e5.slice(s3 + 2, c3);
        o2 += ai(f3), s3 = c3 + 2;
        continue;
      }
    }
    if (l3 === "[" && s3 + 1 < e5.length) {
      let c3 = e5[s3 + 1];
      if (c3 === "." || c3 === "=") {
        let f3 = `${c3}]`, u3 = e5.indexOf(f3, s3 + 2);
        if (u3 !== -1) {
          let d3 = e5.slice(s3 + 2, u3);
          o2 += d3, s3 = u3 + 2;
          continue;
        }
      }
    }
    if (l3 === "\\" && s3 + 1 < e5.length) {
      o2 += l3 + e5[s3 + 1], s3 += 2;
      continue;
    }
    o2 += l3, s3++;
  }
  return a3 ? (r2 && (n3 += "\\]"), i4 && (n3 += "\\["), n3 += o2, n3 += "]", { converted: n3, endIndex: s3 }) : { converted: "\\[", endIndex: t4 + 1 };
}
function ai(e5) {
  return { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" }[e5] ?? "";
}
function ye$4(e5) {
  let t4 = [], s3 = "", n3 = false, r2 = false, i4 = false, o2 = false;
  for (let a3 of e5) {
    if (i4) {
      s3 += a3, i4 = false, o2 = true;
      continue;
    }
    if (a3 === "\\") {
      i4 = true;
      continue;
    }
    if (a3 === "'" && !r2) {
      n3 || (o2 = true), n3 = !n3;
      continue;
    }
    if (a3 === '"' && !n3) {
      r2 || (o2 = true), r2 = !r2;
      continue;
    }
    if ((a3 === " " || a3 === "	" || a3 === `
`) && !n3 && !r2) {
      o2 && (t4.push(s3), s3 = "", o2 = false);
      continue;
    }
    s3 += a3, o2 = true;
  }
  return o2 && t4.push(s3), t4;
}
function St$2(e5) {
  let t4 = [], s3 = 0;
  for (; s3 < e5.length; ) {
    for (; s3 < e5.length && /\s/.test(e5[s3]); ) s3++;
    if (s3 >= e5.length) break;
    if (e5[s3] !== "[") {
      s3++;
      continue;
    }
    s3++;
    let n3 = "";
    if (e5[s3] === "'" || e5[s3] === '"') {
      let i4 = e5[s3];
      for (s3++; s3 < e5.length && e5[s3] !== i4; ) n3 += e5[s3], s3++;
      e5[s3] === i4 && s3++;
    } else for (; s3 < e5.length && e5[s3] !== "]" && e5[s3] !== "="; ) n3 += e5[s3], s3++;
    for (; s3 < e5.length && e5[s3] !== "]"; ) s3++;
    if (e5[s3] === "]" && s3++, e5[s3] !== "=") continue;
    s3++;
    let r2 = "";
    if (e5[s3] === "'" || e5[s3] === '"') {
      let i4 = e5[s3];
      for (s3++; s3 < e5.length && e5[s3] !== i4; ) e5[s3] === "\\" && s3 + 1 < e5.length && s3++, r2 += e5[s3], s3++;
      e5[s3] === i4 && s3++;
    } else for (; s3 < e5.length && !/\s/.test(e5[s3]); ) r2 += e5[s3], s3++;
    t4.push([n3, r2]);
  }
  return t4;
}
function kn$1(e5) {
  let t4 = e5.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
  if (t4) return { name: t4[1], isArray: true, arrayElements: ye$4(t4[2]) };
  let s3 = e5.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
  if (s3) return { name: s3[1], isArray: false, arrayIndex: s3[2], value: s3[3] };
  if (e5.includes("=")) {
    let n3 = e5.indexOf("=");
    return { name: e5.slice(0, n3), isArray: false, value: e5.slice(n3 + 1) };
  }
  return { name: e5, isArray: false };
}
async function li(e5, t4) {
  try {
    let s3 = new T$9(), n3 = W$d(s3, t4);
    return await R$a(e5, n3.expression);
  } catch {
    let s3 = parseInt(t4, 10);
    return Number.isNaN(s3) ? 0 : s3;
  }
}
async function On(e5, t4, s3 = {}) {
  let { name: n3, isArray: r2, arrayElements: i4, value: o2, arrayIndex: a3 } = t4, { makeReadonly: l3 = false, checkReadonly: c3 = true } = s3;
  if (c3) {
    aa(e5, n3);
  }
  if (r2 && i4) {
    for (let f3 = 0; f3 < i4.length; f3++) e5.state.env[`${n3}_${f3}`] = i4[f3];
    e5.state.env[`${n3}__length`] = String(i4.length);
  } else if (a3 !== void 0 && o2 !== void 0) {
    let f3 = await li(e5, a3);
    e5.state.env[`${n3}_${f3}`] = o2;
    let u3 = parseInt(e5.state.env[`${n3}__length`] ?? "0", 10);
    f3 >= u3 && (e5.state.env[`${n3}__length`] = String(f3 + 1));
  } else o2 !== void 0 && (e5.state.env[n3] = o2);
  return l3 && ia$1(e5, n3), null;
}
function Oe$5(e5, t4) {
  e5.state.localVarDepth = e5.state.localVarDepth || /* @__PURE__ */ new Map(), e5.state.localVarDepth.set(t4, e5.state.callDepth);
}
function We$5(e5, t4) {
  return e5.state.localVarDepth?.get(t4);
}
function At$3(e5, t4) {
  e5.state.localVarDepth?.delete(t4);
}
function Dn$1(e5, t4, s3) {
  e5.state.localVarStack = e5.state.localVarStack || /* @__PURE__ */ new Map();
  let n3 = e5.state.localVarStack.get(t4) || [];
  n3.push({ value: s3, scopeIndex: e5.state.localScopes.length - 1 }), e5.state.localVarStack.set(t4, n3);
}
function Pt$1(e5, t4) {
  let s3 = e5.state.localVarStack?.get(t4);
  if (!(!s3 || s3.length === 0)) return s3.pop();
}
function In(e5, t4) {
  if (e5.state.localVarStack) for (let [s3, n3] of e5.state.localVarStack.entries()) {
    for (; n3.length > 0 && n3[n3.length - 1].scopeIndex === t4; ) n3.pop();
    n3.length === 0 && e5.state.localVarStack.delete(s3);
  }
}
var es = /* @__PURE__ */ new Set([":", ".", "break", "continue", "eval", "exec", "exit", "export", "readonly", "return", "set", "shift", "trap", "unset"]);
function Tn(e5) {
  return es.has(e5);
}
var ts = /* @__PURE__ */ new Set(["if", "then", "else", "elif", "fi", "case", "esac", "for", "select", "while", "until", "do", "done", "in", "function", "{", "}", "time", "[[", "]]", "!"]), Qe$5 = /* @__PURE__ */ new Set([":", "true", "false", "cd", "export", "unset", "exit", "local", "set", "break", "continue", "return", "eval", "shift", "getopts", "compgen", "complete", "compopt", "pushd", "popd", "dirs", "source", ".", "read", "mapfile", "readarray", "declare", "typeset", "readonly", "let", "command", "shopt", "exec", "test", "[", "echo", "printf", "pwd", "alias", "unalias", "type", "hash", "ulimit", "umask", "trap", "times", "wait", "kill", "jobs", "fg", "bg", "disown", "suspend", "fc", "history", "help", "enable", "builtin", "caller"]);
async function Te$4(e5, t4, s3, n3) {
  try {
    if ((await e5.fs.stat(t4)).isDirectory) return `bash: ${s3}: Is a directory
`;
    if (n3.checkNoclobber && e5.state.options.noclobber && !n3.isClobber && s3 !== "/dev/null") return `bash: ${s3}: cannot overwrite existing file
`;
  } catch {
  }
  return null;
}
function Y$9(e5) {
  for (let t4 = 0; t4 < e5.length; t4++) if (e5.charCodeAt(t4) > 255) return "utf8";
  return "binary";
}
function ci(e5) {
  if (!e5.startsWith("__rw__:")) return null;
  let t4 = e5.slice(7), s3 = t4.indexOf(":");
  if (s3 === -1) return null;
  let n3 = Number.parseInt(t4.slice(0, s3), 10);
  if (Number.isNaN(n3) || n3 < 0) return null;
  let r2 = s3 + 1, i4 = t4.slice(r2, r2 + n3), o2 = r2 + n3 + 1, a3 = t4.slice(o2), l3 = a3.indexOf(":");
  if (l3 === -1) return null;
  let c3 = Number.parseInt(a3.slice(0, l3), 10);
  if (Number.isNaN(c3) || c3 < 0) return null;
  let f3 = a3.slice(l3 + 1);
  return { path: i4, position: c3, content: f3 };
}
async function Rn(e5, t4) {
  let s3 = /* @__PURE__ */ new Map();
  for (let n3 = 0; n3 < t4.length; n3++) {
    let r2 = t4[n3];
    if (r2.target.type === "HereDoc") continue;
    if (r2.operator === ">&" || r2.operator === "<&") {
      if (Ms$1(e5, r2.target)) return { targets: s3, error: `bash: $@: ambiguous redirect
` };
      s3.set(n3, await wt$5(e5, r2.target));
    } else {
      let o2 = await cl$1(e5, r2.target);
      if ("error" in o2) return { targets: s3, error: o2.error };
      s3.set(n3, o2.target);
    }
  }
  return { targets: s3 };
}
function fi(e5) {
  e5.state.nextFd === void 0 && (e5.state.nextFd = 10);
  let t4 = e5.state.nextFd;
  return e5.state.nextFd++, t4;
}
async function _t$1(e5, t4) {
  for (let s3 of t4) {
    if (!s3.fdVariable) continue;
    if (e5.state.fileDescriptors || (e5.state.fileDescriptors = /* @__PURE__ */ new Map()), (s3.operator === ">&" || s3.operator === "<&") && s3.target.type === "Word" && await wt$5(e5, s3.target) === "-") {
      let i4 = e5.state.env[s3.fdVariable];
      if (i4 !== void 0) {
        let o2 = Number.parseInt(i4, 10);
        Number.isNaN(o2) || e5.state.fileDescriptors.delete(o2);
      }
      continue;
    }
    let n3 = fi(e5);
    if (e5.state.env[s3.fdVariable] = String(n3), s3.target.type === "Word") {
      let r2 = await wt$5(e5, s3.target);
      if (s3.operator === ">&" || s3.operator === "<&") {
        let i4 = Number.parseInt(r2, 10);
        if (!Number.isNaN(i4)) {
          let o2 = e5.state.fileDescriptors.get(i4);
          o2 !== void 0 && e5.state.fileDescriptors.set(n3, o2);
          continue;
        }
      }
      if (s3.operator === ">" || s3.operator === ">>" || s3.operator === ">|" || s3.operator === "&>" || s3.operator === "&>>") {
        let i4 = e5.fs.resolvePath(e5.state.cwd, r2);
        (s3.operator === ">" || s3.operator === ">|" || s3.operator === "&>") && await e5.fs.writeFile(i4, "", "binary"), e5.state.fileDescriptors.set(n3, `__file__:${i4}`);
      } else if (s3.operator === "<<<") e5.state.fileDescriptors.set(n3, `${r2}
`);
      else if (s3.operator === "<" || s3.operator === "<>") try {
        let i4 = e5.fs.resolvePath(e5.state.cwd, r2), o2 = await e5.fs.readFile(i4);
        e5.state.fileDescriptors.set(n3, o2);
      } catch {
        return P$f("", `bash: ${r2}: No such file or directory
`, 1);
      }
    }
  }
  return null;
}
async function we$5(e5, t4) {
  for (let s3 of t4) {
    if (s3.target.type === "HereDoc") continue;
    let n3 = s3.operator === ">&";
    if (s3.operator !== ">" && s3.operator !== ">|" && s3.operator !== "&>" && !n3) continue;
    let r2;
    if (n3) {
      if (r2 = await wt$5(e5, s3.target), r2 === "-" || !Number.isNaN(Number.parseInt(r2, 10)) || s3.fd != null) continue;
    } else {
      let a3 = await cl$1(e5, s3.target);
      if ("error" in a3) return P$f("", a3.error, 1);
      r2 = a3.target;
    }
    let i4 = e5.fs.resolvePath(e5.state.cwd, r2), o2 = s3.operator === ">|";
    try {
      let a3 = await e5.fs.stat(i4);
      if (a3.isDirectory) return P$f("", `bash: ${r2}: Is a directory
`, 1);
      if (e5.state.options.noclobber && !o2 && !a3.isDirectory && r2 !== "/dev/null") return P$f("", `bash: ${r2}: cannot overwrite existing file
`, 1);
    } catch {
    }
    if (r2 !== "/dev/null" && r2 !== "/dev/stdout" && r2 !== "/dev/stderr" && r2 !== "/dev/full" && await e5.fs.writeFile(i4, "", "binary"), r2 === "/dev/full") return P$f("", `bash: /dev/full: No space left on device
`, 1);
  }
  return null;
}
async function j$a(e5, t4, s3, n3) {
  let { stdout: r2, stderr: i4, exitCode: o2 } = t4;
  for (let c3 = 0; c3 < s3.length; c3++) {
    let f3 = s3[c3];
    if (f3.target.type === "HereDoc") continue;
    let u3, d3 = n3?.get(c3);
    if (d3 !== void 0) u3 = d3;
    else if (f3.operator === ">&" || f3.operator === "<&") {
      if (Ms$1(e5, f3.target)) {
        i4 += `bash: $@: ambiguous redirect
`, o2 = 1, r2 = "";
        continue;
      }
      u3 = await wt$5(e5, f3.target);
    } else {
      let m3 = await cl$1(e5, f3.target);
      if ("error" in m3) {
        i4 += m3.error, o2 = 1, r2 = "";
        continue;
      }
      u3 = m3.target;
    }
    if (!f3.fdVariable) switch (f3.operator) {
      case ">":
      case ">|": {
        let h3 = f3.fd ?? 1, m3 = f3.operator === ">|";
        if (h3 === 1) {
          if (u3 === "/dev/stdout") break;
          if (u3 === "/dev/stderr") {
            i4 += r2, r2 = "";
            break;
          }
          if (u3 === "/dev/full") {
            i4 += `bash: echo: write error: No space left on device
`, o2 = 1, r2 = "";
            break;
          }
          let p3 = e5.fs.resolvePath(e5.state.cwd, u3), w4 = await Te$4(e5, p3, u3, { checkNoclobber: true, isClobber: m3 });
          if (w4) {
            i4 += w4, o2 = 1, r2 = "";
            break;
          }
          await e5.fs.writeFile(p3, r2, Y$9(r2)), r2 = "";
        } else if (h3 === 2) {
          if (u3 === "/dev/stderr") break;
          if (u3 === "/dev/stdout") {
            r2 += i4, i4 = "";
            break;
          }
          if (u3 === "/dev/full") {
            i4 += `bash: echo: write error: No space left on device
`, o2 = 1;
            break;
          }
          if (u3 === "/dev/null") i4 = "";
          else {
            let p3 = e5.fs.resolvePath(e5.state.cwd, u3), w4 = await Te$4(e5, p3, u3, { checkNoclobber: true, isClobber: m3 });
            if (w4) {
              i4 += w4, o2 = 1;
              break;
            }
            await e5.fs.writeFile(p3, i4, Y$9(i4)), i4 = "";
          }
        }
        break;
      }
      case ">>": {
        let h3 = f3.fd ?? 1;
        if (h3 === 1) {
          if (u3 === "/dev/stdout") break;
          if (u3 === "/dev/stderr") {
            i4 += r2, r2 = "";
            break;
          }
          if (u3 === "/dev/full") {
            i4 += `bash: echo: write error: No space left on device
`, o2 = 1, r2 = "";
            break;
          }
          let m3 = e5.fs.resolvePath(e5.state.cwd, u3), p3 = await Te$4(e5, m3, u3, {});
          if (p3) {
            i4 += p3, o2 = 1, r2 = "";
            break;
          }
          await e5.fs.appendFile(m3, r2, Y$9(r2)), r2 = "";
        } else if (h3 === 2) {
          if (u3 === "/dev/stderr") break;
          if (u3 === "/dev/stdout") {
            r2 += i4, i4 = "";
            break;
          }
          if (u3 === "/dev/full") {
            i4 += `bash: echo: write error: No space left on device
`, o2 = 1;
            break;
          }
          let m3 = e5.fs.resolvePath(e5.state.cwd, u3), p3 = await Te$4(e5, m3, u3, {});
          if (p3) {
            i4 += p3, o2 = 1;
            break;
          }
          await e5.fs.appendFile(m3, i4, Y$9(i4)), i4 = "";
        }
        break;
      }
      case ">&":
      case "<&": {
        let h3 = f3.fd ?? 1;
        if (u3 === "-") break;
        if (u3.endsWith("-")) {
          let m3 = u3.slice(0, -1), p3 = Number.parseInt(m3, 10);
          if (!Number.isNaN(p3)) {
            let w4 = e5.state.fileDescriptors?.get(p3);
            w4 !== void 0 ? (e5.state.fileDescriptors || (e5.state.fileDescriptors = /* @__PURE__ */ new Map()), e5.state.fileDescriptors.set(h3, w4), p3 >= 3 && e5.state.fileDescriptors?.delete(p3)) : p3 === 1 || p3 === 2 ? (e5.state.fileDescriptors || (e5.state.fileDescriptors = /* @__PURE__ */ new Map()), e5.state.fileDescriptors.set(h3, `__dupout__:${p3}`)) : p3 === 0 ? (e5.state.fileDescriptors || (e5.state.fileDescriptors = /* @__PURE__ */ new Map()), e5.state.fileDescriptors.set(h3, `__dupin__:${p3}`)) : p3 >= 3 && (i4 += `bash: ${p3}: Bad file descriptor
`, o2 = 1);
          }
          break;
        }
        if (u3 === "2" || u3 === "&2") h3 === 1 && (i4 += r2, r2 = "");
        else if (u3 === "1" || u3 === "&1") r2 += i4, i4 = "";
        else {
          let m3 = Number.parseInt(u3, 10);
          if (Number.isNaN(m3)) {
            if (f3.operator === ">&") {
              let p3 = e5.fs.resolvePath(e5.state.cwd, u3), w4 = await Te$4(e5, p3, u3, { checkNoclobber: true });
              if (w4) {
                i4 = w4, o2 = 1, r2 = "";
                break;
              }
              if (f3.fd == null) {
                let b4 = r2 + i4;
                await e5.fs.writeFile(p3, b4, Y$9(b4)), r2 = "", i4 = "";
              } else h3 === 1 ? (await e5.fs.writeFile(p3, r2, Y$9(r2)), r2 = "") : h3 === 2 && (await e5.fs.writeFile(p3, i4, Y$9(i4)), i4 = "");
            }
          } else {
            let p3 = e5.state.fileDescriptors?.get(m3);
            if (p3?.startsWith("__file__:")) {
              let w4 = p3.slice(9);
              h3 === 1 ? (await e5.fs.appendFile(w4, r2, Y$9(r2)), r2 = "") : h3 === 2 && (await e5.fs.appendFile(w4, i4, Y$9(i4)), i4 = "");
            } else if (p3?.startsWith("__rw__:")) {
              let w4 = ci(p3);
              w4 && (h3 === 1 ? (await e5.fs.appendFile(w4.path, r2, Y$9(r2)), r2 = "") : h3 === 2 && (await e5.fs.appendFile(w4.path, i4, Y$9(i4)), i4 = ""));
            } else if (p3?.startsWith("__dupout__:")) {
              let w4 = Number.parseInt(p3.slice(11), 10);
              if (w4 !== 1) if (w4 === 2) h3 === 1 && (i4 += r2, r2 = "");
              else {
                let b4 = e5.state.fileDescriptors?.get(w4);
                if (b4?.startsWith("__file__:")) {
                  let $5 = b4.slice(9);
                  h3 === 1 ? (await e5.fs.appendFile($5, r2, Y$9(r2)), r2 = "") : h3 === 2 && (await e5.fs.appendFile($5, i4, Y$9(i4)), i4 = "");
                }
              }
            } else p3?.startsWith("__dupin__:") ? (i4 += `bash: ${m3}: Bad file descriptor
`, o2 = 1, r2 = "") : m3 >= 3 && (i4 += `bash: ${m3}: Bad file descriptor
`, o2 = 1, r2 = "");
          }
        }
        break;
      }
      case "&>": {
        if (u3 === "/dev/full") {
          i4 = `bash: echo: write error: No space left on device
`, o2 = 1, r2 = "";
          break;
        }
        let h3 = e5.fs.resolvePath(e5.state.cwd, u3), m3 = await Te$4(e5, h3, u3, { checkNoclobber: true });
        if (m3) {
          i4 = m3, o2 = 1, r2 = "";
          break;
        }
        let p3 = r2 + i4;
        await e5.fs.writeFile(h3, p3, Y$9(p3)), r2 = "", i4 = "";
        break;
      }
      case "&>>": {
        if (u3 === "/dev/full") {
          i4 = `bash: echo: write error: No space left on device
`, o2 = 1, r2 = "";
          break;
        }
        let h3 = e5.fs.resolvePath(e5.state.cwd, u3), m3 = await Te$4(e5, h3, u3, {});
        if (m3) {
          i4 = m3, o2 = 1, r2 = "";
          break;
        }
        let p3 = r2 + i4;
        await e5.fs.appendFile(h3, p3, Y$9(p3)), r2 = "", i4 = "";
        break;
      }
    }
  }
  let a3 = e5.state.fileDescriptors?.get(1);
  if (a3) {
    if (a3 === "__dupout__:2") i4 += r2, r2 = "";
    else if (a3.startsWith("__file__:")) {
      let c3 = a3.slice(9);
      await e5.fs.appendFile(c3, r2, Y$9(r2)), r2 = "";
    } else if (a3.startsWith("__file_append__:")) {
      let c3 = a3.slice(16);
      await e5.fs.appendFile(c3, r2, Y$9(r2)), r2 = "";
    }
  }
  let l3 = e5.state.fileDescriptors?.get(2);
  if (l3) {
    if (l3 === "__dupout__:1") r2 += i4, i4 = "";
    else if (l3.startsWith("__file__:")) {
      let c3 = l3.slice(9);
      await e5.fs.appendFile(c3, i4, Y$9(i4)), i4 = "";
    } else if (l3.startsWith("__file_append__:")) {
      let c3 = l3.slice(16);
      await e5.fs.appendFile(c3, i4, Y$9(i4)), i4 = "";
    }
  }
  return P$f(r2, i4, o2);
}
function xn(e5, t4) {
  if (e5.state.options.posix && es.has(t4.name)) {
    let n3 = `bash: line ${e5.state.currentLine}: \`${t4.name}': is a special builtin
`;
    throw new d$8(2, "", n3);
  }
  let s3 = { ...t4, sourceFile: t4.sourceFile ?? e5.state.currentSource ?? "main" };
  return e5.state.functions.set(t4.name, s3), L$d;
}
async function ui(e5, t4) {
  let s3 = "";
  for (let n3 of t4) if ((n3.operator === "<<" || n3.operator === "<<-") && n3.target.type === "HereDoc") {
    let r2 = n3.target, i4 = await wt$5(e5, r2.content);
    r2.stripTabs && (i4 = i4.split(`
`).map((a3) => a3.replace(/^\t+/, "")).join(`
`)), (n3.fd ?? 0) === 0 && (s3 = i4);
  } else if (n3.operator === "<<<" && n3.target.type === "Word") s3 = `${await wt$5(e5, n3.target)}
`;
  else if (n3.operator === "<" && n3.target.type === "Word") {
    let r2 = await wt$5(e5, n3.target), i4 = e5.fs.resolvePath(e5.state.cwd, r2);
    try {
      s3 = await e5.fs.readFile(i4);
    } catch {
    }
  }
  return s3;
}
async function Nt$1(e5, t4, s3, n3 = "", r2) {
  e5.state.callDepth++, e5.state.callDepth > e5.limits.maxCallDepth && (e5.state.callDepth--, Se$5(`${t4.name}: maximum recursion depth (${e5.limits.maxCallDepth}) exceeded, increase executionLimits.maxCallDepth`, "recursion")), e5.state.funcNameStack || (e5.state.funcNameStack = []), e5.state.callLineStack || (e5.state.callLineStack = []), e5.state.sourceStack || (e5.state.sourceStack = []), e5.state.funcNameStack.unshift(t4.name), e5.state.callLineStack.unshift(e5.state.currentLine), e5.state.sourceStack.unshift(t4.sourceFile ?? "main"), e5.state.localScopes.push(/* @__PURE__ */ new Map()), e5.state.localExportedVars || (e5.state.localExportedVars = []), e5.state.localExportedVars.push(/* @__PURE__ */ new Set());
  let i4 = {};
  for (let c3 = 0; c3 < s3.length; c3++) i4[String(c3 + 1)] = e5.state.env[String(c3 + 1)], e5.state.env[String(c3 + 1)] = s3[c3];
  i4["@"] = e5.state.env["@"], i4["#"] = e5.state.env["#"], e5.state.env["@"] = s3.join(" "), e5.state.env["#"] = String(s3.length);
  let o2 = () => {
    let c3 = e5.state.localScopes.length - 1, f3 = e5.state.localScopes.pop();
    if (f3) for (let [u3, d3] of f3) d3 === void 0 ? delete e5.state.env[u3] : e5.state.env[u3] = d3;
    if (In(e5, c3), e5.state.fullyUnsetLocals) for (let [u3, d3] of e5.state.fullyUnsetLocals.entries()) d3 === c3 && e5.state.fullyUnsetLocals.delete(u3);
    if (e5.state.localExportedVars && e5.state.localExportedVars.length > 0) {
      let u3 = e5.state.localExportedVars.pop();
      if (u3) for (let d3 of u3) e5.state.exportedVars?.delete(d3);
    }
    for (let [u3, d3] of Object.entries(i4)) d3 === void 0 ? delete e5.state.env[u3] : e5.state.env[u3] = d3;
    e5.state.funcNameStack?.shift(), e5.state.callLineStack?.shift(), e5.state.sourceStack?.shift(), e5.state.callDepth--;
  }, { targets: a3, error: l3 } = await Rn(e5, t4.redirections);
  if (l3) return o2(), P$f("", l3, 1);
  try {
    let c3 = await ui(e5, t4.redirections), f3 = n3 || c3, u3 = await e5.executeCommand(t4.body, f3);
    return o2(), j$a(e5, u3, t4.redirections, a3);
  } catch (c3) {
    if (o2(), c3 instanceof i$6) {
      let f3 = P$f(c3.stdout, c3.stderr, c3.exitCode);
      return j$a(e5, f3, t4.redirections, a3);
    }
    throw c3;
  }
}
var Fn = ["!", "[[", "]]", "case", "do", "done", "elif", "else", "esac", "fi", "for", "function", "if", "in", "then", "time", "until", "while", "{", "}"], ns = [".", ":", "[", "alias", "bg", "bind", "break", "builtin", "caller", "cd", "command", "compgen", "complete", "compopt", "continue", "declare", "dirs", "disown", "echo", "enable", "eval", "exec", "exit", "export", "false", "fc", "fg", "getopts", "hash", "help", "history", "jobs", "kill", "let", "local", "logout", "mapfile", "popd", "printf", "pushd", "pwd", "read", "readarray", "readonly", "return", "set", "shift", "shopt", "source", "suspend", "test", "times", "trap", "true", "type", "typeset", "ulimit", "umask", "unalias", "unset", "wait"], di = ["autocd", "assoc_expand_once", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "dotglob", "execfail", "expand_aliases", "extdebug", "extglob", "extquote", "failglob", "force_fignore", "globasciiranges", "globstar", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lastpipe", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "nocaseglob", "nocasematch", "nullglob", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath", "xpg_echo"], hi$1 = ns;
async function rs$1(e5, t4) {
  let s3 = [], n3 = null, r2 = "", i4 = "", o2 = null, a3 = false, l3 = false, c3 = false, f3 = null, u3 = null, d3 = null, h3 = [], m3 = ["alias", "arrayvar", "binding", "builtin", "command", "directory", "disabled", "enabled", "export", "file", "function", "group", "helptopic", "hostname", "job", "keyword", "running", "service", "setopt", "shopt", "signal", "stopped", "user", "variable"];
  for (let y2 = 0; y2 < t4.length; y2++) {
    let g2 = t4[y2];
    if (g2 === "-v") s3.push("variable");
    else if (g2 === "-e") s3.push("export");
    else if (g2 === "-f") s3.push("file");
    else if (g2 === "-d") s3.push("directory");
    else if (g2 === "-k") s3.push("keyword");
    else if (g2 === "-A") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -A: option requires an argument
`, 2);
      let v2 = t4[y2];
      if (!m3.includes(v2)) return S$d(`compgen: ${v2}: invalid action name
`, 2);
      s3.push(v2);
    } else if (g2 === "-W") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -W: option requires an argument
`, 2);
      n3 = t4[y2];
    } else if (g2 === "-P") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -P: option requires an argument
`, 2);
      r2 = t4[y2];
    } else if (g2 === "-S") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -S: option requires an argument
`, 2);
      i4 = t4[y2];
    } else if (g2 === "-o") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -o: option requires an argument
`, 2);
      let v2 = t4[y2];
      if (v2 === "plusdirs") a3 = true;
      else if (v2 === "dirnames") l3 = true;
      else if (v2 === "default") c3 = true;
      else if (!(v2 === "filenames" || v2 === "nospace" || v2 === "bashdefault" || v2 === "noquote")) return S$d(`compgen: ${v2}: invalid option name
`, 2);
    } else if (g2 === "-F") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -F: option requires an argument
`, 2);
      u3 = t4[y2];
    } else if (g2 === "-C") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -C: option requires an argument
`, 2);
      d3 = t4[y2];
    } else if (g2 === "-X") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -X: option requires an argument
`, 2);
      f3 = t4[y2];
    } else if (g2 === "-G") {
      if (y2++, y2 >= t4.length) return S$d(`compgen: -G: option requires an argument
`, 2);
    } else if (g2 === "--") {
      h3.push(...t4.slice(y2 + 1));
      break;
    } else g2.startsWith("-") || h3.push(g2);
  }
  o2 = h3[0] ?? null;
  let p3 = [];
  if (l3) {
    let y2 = await ss(e5, o2);
    p3.push(...y2);
  }
  if (c3) {
    let y2 = await Ln(e5, o2);
    p3.push(...y2);
  }
  for (let y2 of s3) if (y2 === "variable") {
    let g2 = pi(e5, o2);
    p3.push(...g2);
  } else if (y2 === "export") {
    let g2 = mi$1(e5, o2);
    p3.push(...g2);
  } else if (y2 === "function") {
    let g2 = yi$1(e5, o2);
    p3.push(...g2);
  } else if (y2 === "builtin") {
    let g2 = wi$1(o2);
    p3.push(...g2);
  } else if (y2 === "keyword") {
    let g2 = gi(o2);
    p3.push(...g2);
  } else if (y2 === "alias") {
    let g2 = vi(e5, o2);
    p3.push(...g2);
  } else if (y2 === "shopt") {
    let g2 = bi(o2);
    p3.push(...g2);
  } else if (y2 === "helptopic") {
    let g2 = Ei$1(o2);
    p3.push(...g2);
  } else if (y2 === "directory") {
    let g2 = await ss(e5, o2);
    p3.push(...g2);
  } else if (y2 === "file") {
    let g2 = await Ln(e5, o2);
    p3.push(...g2);
  } else if (y2 === "user") {
    let g2 = $i$1();
    p3.push(...g2);
  } else if (y2 === "command") {
    let g2 = await Si$1(e5, o2);
    p3.push(...g2);
  }
  if (n3 !== null) try {
    let y2 = await Ai(e5, n3), g2 = Pi$1(e5, y2);
    for (let v2 of g2) (o2 === null || v2.startsWith(o2)) && p3.push(v2);
  } catch {
    return P$f("", "", 1);
  }
  if (a3) {
    let y2 = await ss(e5, o2);
    for (let g2 of y2) p3.includes(g2) || p3.push(g2);
  }
  let w4 = "";
  if (u3 !== null) {
    let y2 = e5.state.functions.get(u3);
    if (y2) {
      let g2 = {};
      g2.COMP_WORDS__length = e5.state.env.COMP_WORDS__length, e5.state.env.COMP_WORDS__length = "0", g2.COMP_CWORD = e5.state.env.COMP_CWORD, e5.state.env.COMP_CWORD = "-1", g2.COMP_LINE = e5.state.env.COMP_LINE, e5.state.env.COMP_LINE = "", g2.COMP_POINT = e5.state.env.COMP_POINT, e5.state.env.COMP_POINT = "0";
      let v2 = {};
      for (let k3 of Object.keys(e5.state.env)) (k3 === "COMPREPLY" || k3.startsWith("COMPREPLY_") || k3 === "COMPREPLY__length") && (v2[k3] = e5.state.env[k3], delete e5.state.env[k3]);
      let _4 = ["compgen", h3[0] ?? "", ""];
      try {
        let k3 = await Nt$1(e5, y2, _4, "");
        if (k3.exitCode !== 0) return Me$5(e5, g2), Me$5(e5, v2), P$f("", k3.stderr, 1);
        w4 = k3.stdout;
        let T3 = _i$1(e5);
        p3.push(...T3);
      } catch {
        return Me$5(e5, g2), Me$5(e5, v2), P$f("", "", 1);
      }
      Me$5(e5, g2), Me$5(e5, v2);
    }
  }
  if (d3 !== null) try {
    let y2 = ci$1(d3), g2 = await e5.executeScript(y2);
    if (g2.exitCode !== 0) return P$f("", g2.stderr, g2.exitCode);
    if (g2.stdout) {
      let v2 = g2.stdout.split(`
`);
      for (let _4 of v2) _4.length > 0 && p3.push(_4);
    }
  } catch (y2) {
    if (y2.name === "ParseException") return S$d(`compgen: -C: ${y2.message}
`, 2);
    throw y2;
  }
  let b4 = p3;
  if (f3 !== null) {
    let y2 = f3.startsWith("!"), g2 = y2 ? f3.slice(1) : f3;
    b4 = p3.filter((v2) => {
      let _4 = Fe$5(v2, g2, false, true);
      return y2 ? _4 : !_4;
    });
  }
  if (b4.length === 0 && o2 !== null) return P$f(w4, "", 1);
  let $5 = b4.map((y2) => `${r2}${y2}${i4}`).join(`
`), C2 = w4 + ($5 ? `${$5}
` : "");
  return F$a(C2);
}
function pi(e5, t4) {
  let s3 = /* @__PURE__ */ new Set();
  for (let r2 of Object.keys(e5.state.env)) {
    if (r2.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(r2) || r2.endsWith("__length")) continue;
    let i4 = r2.split("_")[0];
    /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(r2) ? s3.add(r2) : i4 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(i4) && e5.state.env[`${i4}__length`] !== void 0 && s3.add(i4);
  }
  let n3 = Array.from(s3);
  return t4 !== null && (n3 = n3.filter((r2) => r2.startsWith(t4))), n3.sort();
}
function mi$1(e5, t4) {
  let s3 = e5.state.exportedVars ?? /* @__PURE__ */ new Set(), n3 = Array.from(s3);
  return t4 !== null && (n3 = n3.filter((r2) => r2.startsWith(t4))), n3 = n3.filter((r2) => r2.includes("_") && /^[a-zA-Z_][a-zA-Z0-9_]*_\d+$/.test(r2) || r2.endsWith("__length") ? false : e5.state.env[r2] !== void 0), n3.sort();
}
function yi$1(e5, t4) {
  let s3 = Array.from(e5.state.functions.keys());
  return t4 !== null && (s3 = s3.filter((n3) => n3.startsWith(t4))), s3.sort();
}
function wi$1(e5) {
  let t4 = [...ns];
  return e5 !== null && (t4 = t4.filter((s3) => s3.startsWith(e5))), t4.sort();
}
function gi(e5) {
  let t4 = [...Fn];
  return e5 !== null && (t4 = t4.filter((s3) => s3.startsWith(e5))), t4.sort();
}
function vi(e5, t4) {
  let s3 = [];
  for (let r2 of Object.keys(e5.state.env)) if (r2.startsWith("BASH_ALIAS_")) {
    let i4 = r2.slice(11);
    s3.push(i4);
  }
  let n3 = s3;
  return t4 !== null && (n3 = n3.filter((r2) => r2.startsWith(t4))), n3.sort();
}
function bi(e5) {
  let t4 = [...di];
  return e5 !== null && (t4 = t4.filter((s3) => s3.startsWith(e5))), t4.sort();
}
function Ei$1(e5) {
  let t4 = [...hi$1];
  return e5 !== null && (t4 = t4.filter((s3) => s3.startsWith(e5))), t4.sort();
}
async function ss(e5, t4) {
  let s3 = [];
  try {
    let n3 = e5.state.cwd, r2 = t4 ?? "";
    if (t4) {
      let o2 = t4.lastIndexOf("/");
      if (o2 !== -1) {
        let a3 = t4.slice(0, o2) || "/";
        r2 = t4.slice(o2 + 1), a3.startsWith("/") ? n3 = a3 : n3 = `${e5.state.cwd}/${a3}`;
      }
    }
    let i4 = await e5.fs.readdir(n3);
    for (let o2 of i4) {
      let a3 = `${n3}/${o2}`;
      try {
        if ((await e5.fs.stat(a3)).isDirectory && (!r2 || o2.startsWith(r2))) if (t4?.includes("/")) {
          let c3 = t4.lastIndexOf("/"), f3 = t4.slice(0, c3 + 1);
          s3.push(f3 + o2);
        } else s3.push(o2);
      } catch {
      }
    }
  } catch {
  }
  return s3.sort();
}
async function Ln(e5, t4) {
  let s3 = [];
  try {
    let n3 = e5.state.cwd, r2 = t4 ?? "";
    if (t4) {
      let o2 = t4.lastIndexOf("/");
      if (o2 !== -1) {
        let a3 = t4.slice(0, o2) || "/";
        r2 = t4.slice(o2 + 1), a3.startsWith("/") ? n3 = a3 : n3 = `${e5.state.cwd}/${a3}`;
      }
    }
    let i4 = await e5.fs.readdir(n3);
    for (let o2 of i4) if (!r2 || o2.startsWith(r2)) if (t4?.includes("/")) {
      let a3 = t4.lastIndexOf("/"), l3 = t4.slice(0, a3 + 1);
      s3.push(l3 + o2);
    } else s3.push(o2);
  } catch {
  }
  return s3.sort();
}
function $i$1(e5) {
  return ["root", "nobody"];
}
async function Si$1(e5, t4) {
  let s3 = /* @__PURE__ */ new Set();
  for (let i4 of ns) s3.add(i4);
  for (let i4 of e5.state.functions.keys()) s3.add(i4);
  for (let i4 of Object.keys(e5.state.env)) i4.startsWith("BASH_ALIAS_") && s3.add(i4.slice(11));
  for (let i4 of Fn) s3.add(i4);
  let n3 = e5.state.env.PATH ?? "/usr/bin:/bin";
  for (let i4 of n3.split(":")) if (i4) try {
    let o2 = await e5.fs.readdir(i4);
    for (let a3 of o2) s3.add(a3);
  } catch {
  }
  let r2 = Array.from(s3);
  return t4 !== null && (r2 = r2.filter((i4) => i4.startsWith(t4))), r2.sort();
}
async function Ai(e5, t4) {
  let n3 = new T$9().parseWordFromString(t4, false, false);
  return await wt$5(e5, n3);
}
function Pi$1(e5, t4) {
  let s3 = e5.state.env.IFS ?? ` 	
`;
  if (s3.length === 0) return [t4];
  let n3 = new Set(s3.split("")), r2 = [], i4 = "", o2 = 0;
  for (; o2 < t4.length; ) {
    let a3 = t4[o2];
    if (a3 === "\\" && o2 + 1 < t4.length) {
      let l3 = t4[o2 + 1];
      i4 += l3, o2 += 2;
    } else n3.has(a3) ? (i4.length > 0 && (r2.push(i4), i4 = ""), o2++) : (i4 += a3, o2++);
  }
  return i4.length > 0 && r2.push(i4), r2;
}
function Me$5(e5, t4) {
  for (let [s3, n3] of Object.entries(t4)) n3 === void 0 ? delete e5.state.env[s3] : e5.state.env[s3] = n3;
}
function _i$1(e5) {
  let t4 = [];
  if (e5.state.env["COMPREPLY__length"] !== void 0) {
    let r2 = P$g(e5, "COMPREPLY");
    for (let [, i4] of r2) t4.push(i4);
  } else e5.state.env.COMPREPLY !== void 0 && t4.push(e5.state.env.COMPREPLY);
  return t4;
}
var Ni$1 = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function os(e5, t4) {
  e5.state.completionSpecs || (e5.state.completionSpecs = /* @__PURE__ */ new Map());
  let s3 = false, n3 = false, r2 = false, i4, o2, a3, l3 = [], c3 = [], f3 = [];
  for (let u3 = 0; u3 < t4.length; u3++) {
    let d3 = t4[u3];
    if (d3 === "-p") s3 = true;
    else if (d3 === "-r") n3 = true;
    else if (d3 === "-D") r2 = true;
    else if (d3 === "-W") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -W: option requires an argument
`, 2);
      i4 = t4[u3];
    } else if (d3 === "-F") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -F: option requires an argument
`, 2);
      o2 = t4[u3];
    } else if (d3 === "-o") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -o: option requires an argument
`, 2);
      let h3 = t4[u3];
      if (!Ni$1.includes(h3)) return S$d(`complete: ${h3}: invalid option name
`, 2);
      l3.push(h3);
    } else if (d3 === "-A") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -A: option requires an argument
`, 2);
      c3.push(t4[u3]);
    } else if (d3 === "-C") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -C: option requires an argument
`, 2);
      a3 = t4[u3];
    } else if (d3 === "-G") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -G: option requires an argument
`, 2);
    } else if (d3 === "-P") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -P: option requires an argument
`, 2);
    } else if (d3 === "-S") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -S: option requires an argument
`, 2);
    } else if (d3 === "-X") {
      if (u3++, u3 >= t4.length) return S$d(`complete: -X: option requires an argument
`, 2);
    } else if (d3 === "--") {
      f3.push(...t4.slice(u3 + 1));
      break;
    } else d3.startsWith("-") || f3.push(d3);
  }
  if (n3) {
    if (f3.length === 0) return e5.state.completionSpecs.clear(), F$a("");
    for (let u3 of f3) e5.state.completionSpecs.delete(u3);
    return F$a("");
  }
  if (s3) return f3.length === 0 ? is(e5) : is(e5, f3);
  if (t4.length === 0 || f3.length === 0 && !i4 && !o2 && !a3 && l3.length === 0 && c3.length === 0 && !r2) return is(e5);
  if (o2 && f3.length === 0 && !r2) return S$d(`complete: -F: option requires a command name
`, 2);
  if (r2) {
    let u3 = { isDefault: true };
    return i4 !== void 0 && (u3.wordlist = i4), o2 !== void 0 && (u3.function = o2), a3 !== void 0 && (u3.command = a3), l3.length > 0 && (u3.options = l3), c3.length > 0 && (u3.actions = c3), e5.state.completionSpecs.set("__default__", u3), F$a("");
  }
  for (let u3 of f3) {
    let d3 = {};
    i4 !== void 0 && (d3.wordlist = i4), o2 !== void 0 && (d3.function = o2), a3 !== void 0 && (d3.command = a3), l3.length > 0 && (d3.options = l3), c3.length > 0 && (d3.actions = c3), e5.state.completionSpecs.set(u3, d3);
  }
  return F$a("");
}
function is(e5, t4) {
  let s3 = e5.state.completionSpecs;
  if (!s3 || s3.size === 0) {
    if (t4 && t4.length > 0) {
      let i4 = "";
      for (let o2 of t4) i4 += `complete: ${o2}: no completion specification
`;
      return P$f("", i4, 1);
    }
    return F$a("");
  }
  let n3 = [], r2 = t4 || Array.from(s3.keys());
  for (let i4 of r2) {
    if (i4 === "__default__") continue;
    let o2 = s3.get(i4);
    if (!o2) {
      if (t4) return P$f(n3.join(`
`) + (n3.length > 0 ? `
` : ""), `complete: ${i4}: no completion specification
`, 1);
      continue;
    }
    let a3 = "complete";
    if (o2.options) for (let l3 of o2.options) a3 += ` -o ${l3}`;
    if (o2.actions) for (let l3 of o2.actions) a3 += ` -A ${l3}`;
    o2.wordlist !== void 0 && (o2.wordlist.includes(" ") || o2.wordlist.includes("'") ? a3 += ` -W '${o2.wordlist}'` : a3 += ` -W ${o2.wordlist}`), o2.function !== void 0 && (a3 += ` -F ${o2.function}`), o2.isDefault && (a3 += " -D"), a3 += ` ${i4}`, n3.push(a3);
  }
  return n3.length === 0 ? F$a("") : F$a(`${n3.join(`
`)}
`);
}
var Wn$1 = ["bashdefault", "default", "dirnames", "filenames", "noquote", "nosort", "nospace", "plusdirs"];
function as(e5, t4) {
  e5.state.completionSpecs || (e5.state.completionSpecs = /* @__PURE__ */ new Map());
  let s3 = false, n3 = false, r2 = [], i4 = [], o2 = [];
  for (let a3 = 0; a3 < t4.length; a3++) {
    let l3 = t4[a3];
    if (l3 === "-D") s3 = true;
    else if (l3 === "-E") n3 = true;
    else if (l3 === "-o") {
      if (a3++, a3 >= t4.length) return S$d(`compopt: -o: option requires an argument
`, 2);
      let c3 = t4[a3];
      if (!Wn$1.includes(c3)) return S$d(`compopt: ${c3}: invalid option name
`, 2);
      r2.push(c3);
    } else if (l3 === "+o") {
      if (a3++, a3 >= t4.length) return S$d(`compopt: +o: option requires an argument
`, 2);
      let c3 = t4[a3];
      if (!Wn$1.includes(c3)) return S$d(`compopt: ${c3}: invalid option name
`, 2);
      i4.push(c3);
    } else if (l3 === "--") {
      o2.push(...t4.slice(a3 + 1));
      break;
    } else !l3.startsWith("-") && !l3.startsWith("+") && o2.push(l3);
  }
  if (s3) {
    let a3 = e5.state.completionSpecs.get("__default__") ?? { isDefault: true }, l3 = new Set(a3.options ?? []);
    for (let c3 of r2) l3.add(c3);
    for (let c3 of i4) l3.delete(c3);
    return a3.options = l3.size > 0 ? Array.from(l3) : void 0, e5.state.completionSpecs.set("__default__", a3), F$a("");
  }
  if (n3) {
    let a3 = e5.state.completionSpecs.get("__empty__") ?? {}, l3 = new Set(a3.options ?? []);
    for (let c3 of r2) l3.add(c3);
    for (let c3 of i4) l3.delete(c3);
    return a3.options = l3.size > 0 ? Array.from(l3) : void 0, e5.state.completionSpecs.set("__empty__", a3), F$a("");
  }
  if (o2.length > 0) {
    for (let a3 of o2) {
      let l3 = e5.state.completionSpecs.get(a3) ?? {}, c3 = new Set(l3.options ?? []);
      for (let f3 of r2) c3.add(f3);
      for (let f3 of i4) c3.delete(f3);
      l3.options = c3.size > 0 ? Array.from(c3) : void 0, e5.state.completionSpecs.set(a3, l3);
    }
    return F$a("");
  }
  return S$d(`compopt: not currently executing completion function
`, 1);
}
function ls(e5, t4) {
  if (e5.state.loopDepth === 0) {
    if (e5.state.parentHasLoopContext) throw new $$a();
    return L$d;
  }
  if (t4.length > 1) throw new d$8(1, "", `bash: continue: too many arguments
`);
  let s3 = 1;
  if (t4.length > 0) {
    let n3 = Number.parseInt(t4[0], 10);
    if (Number.isNaN(n3) || n3 < 1) throw new d$8(1, "", `bash: continue: ${t4[0]}: numeric argument required
`);
    s3 = n3;
  }
  throw new a$1(s3);
}
function H$d(e5, t4) {
  let s3 = e5.state.env.HOME || "/home/user";
  return t4.split(":").map((i4) => i4 === "~" ? s3 : i4 === "~root" ? "/root" : i4.startsWith("~/") ? s3 + i4.slice(1) : i4.startsWith("~root/") ? `/root${i4.slice(5)}` : i4).join(":");
}
function cs(e5) {
  for (let t4 = 0; t4 < e5.length; t4++) {
    let s3 = e5.charCodeAt(t4);
    if (s3 < 32 || s3 === 127) return true;
  }
  return false;
}
function fs(e5) {
  let t4 = "$'";
  for (let s3 = 0; s3 < e5.length; s3++) {
    let n3 = e5[s3], r2 = e5.charCodeAt(s3);
    r2 === 7 ? t4 += "\\a" : r2 === 8 ? t4 += "\\b" : r2 === 9 ? t4 += "\\t" : r2 === 10 ? t4 += "\\n" : r2 === 11 ? t4 += "\\v" : r2 === 12 ? t4 += "\\f" : r2 === 13 ? t4 += "\\r" : r2 === 27 ? t4 += "\\e" : r2 === 39 ? t4 += "\\'" : r2 === 92 ? t4 += "\\\\" : r2 < 32 || r2 === 127 ? t4 += `\\${r2.toString(8).padStart(3, "0")}` : t4 += n3;
  }
  return t4 += "'", t4;
}
function Ct(e5) {
  return cs(e5) ? fs(e5) : /^[a-zA-Z0-9_/.:\-@%+,=]*$/.test(e5) ? e5 : `'${e5.replace(/'/g, "'\\''")}'`;
}
function Re$2(e5) {
  return cs(e5) ? fs(e5) : `"${e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function us(e5) {
  return cs(e5) ? fs(e5) : `"${e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function Mn(e5, t4) {
  let s3 = "";
  return e5.state.integerVars?.has(t4) && (s3 += "i"), e5.state.lowercaseVars?.has(t4) && (s3 += "l"), C$g(e5, t4) && (s3 += "n"), e5.state.readonlyVars?.has(t4) && (s3 += "r"), e5.state.uppercaseVars?.has(t4) && (s3 += "u"), e5.state.exportedVars?.has(t4) && (s3 += "x"), s3 === "" ? "--" : `-${s3}`;
}
function ds(e5) {
  return e5 === "" ? "''" : /[\s'\\]/.test(e5) ? `'${e5.replace(/'/g, "'\\''")}'` : e5;
}
function zn$1(e5, t4) {
  let s3 = "", n3 = "", r2 = false;
  for (let i4 of t4) {
    let o2 = Mn(e5, i4);
    if (e5.state.associativeArrays?.has(i4)) {
      let f3 = ht$4(e5, i4);
      if (f3.length === 0) s3 += `declare -A ${i4}=()
`;
      else {
        let u3 = f3.map((d3) => {
          let h3 = e5.state.env[`${i4}_${d3}`] ?? "", m3 = ds(h3);
          return `['${d3}']=${m3}`;
        });
        s3 += `declare -A ${i4}=(${u3.join(" ")})
`;
      }
      continue;
    }
    let l3 = pt$2(e5, i4);
    if (l3.length > 0) {
      let f3 = l3.map((u3) => {
        let d3 = e5.state.env[`${i4}_${u3}`] ?? "";
        return `[${u3}]=${Re$2(d3)}`;
      });
      s3 += `declare -a ${i4}=(${f3.join(" ")})
`;
      continue;
    }
    if (e5.state.env[`${i4}__length`] !== void 0) {
      s3 += `declare -a ${i4}=()
`;
      continue;
    }
    let c3 = e5.state.env[i4];
    if (c3 !== void 0) s3 += `declare ${o2} ${i4}=${us(c3)}
`;
    else {
      let f3 = e5.state.declaredVars?.has(i4), u3 = e5.state.localVarDepth?.has(i4);
      f3 || u3 ? s3 += `declare ${o2} ${i4}
` : (n3 += `bash: declare: ${i4}: not found
`, r2 = true);
    }
  }
  return P$f(s3, n3, r2 ? 1 : 0);
}
function Vn(e5, t4) {
  let { filterExport: s3, filterReadonly: n3, filterNameref: r2, filterIndexedArray: i4, filterAssocArray: o2 } = t4, a3 = s3 || n3 || r2 || i4 || o2, l3 = "", c3 = /* @__PURE__ */ new Set();
  for (let u3 of Object.keys(e5.state.env)) {
    if (u3.startsWith("BASH_")) continue;
    if (u3.endsWith("__length")) {
      let h3 = u3.slice(0, -8);
      c3.add(h3);
      continue;
    }
    let d3 = u3.lastIndexOf("_");
    if (d3 > 0) {
      let h3 = u3.slice(0, d3), m3 = u3.slice(d3 + 1);
      if (/^\d+$/.test(m3) || e5.state.associativeArrays?.has(h3)) {
        c3.add(h3);
        continue;
      }
    }
    c3.add(u3);
  }
  if (e5.state.localVarDepth) for (let u3 of e5.state.localVarDepth.keys()) c3.add(u3);
  if (e5.state.associativeArrays) for (let u3 of e5.state.associativeArrays) c3.add(u3);
  let f3 = Array.from(c3).sort();
  for (let u3 of f3) {
    let d3 = Mn(e5, u3), h3 = e5.state.associativeArrays?.has(u3), m3 = pt$2(e5, u3), p3 = !h3 && (m3.length > 0 || e5.state.env[`${u3}__length`] !== void 0);
    if (a3 && (o2 && !h3 || i4 && !p3 || s3 && !e5.state.exportedVars?.has(u3) || n3 && !e5.state.readonlyVars?.has(u3) || r2 && !C$g(e5, u3))) continue;
    if (h3) {
      let b4 = ht$4(e5, u3);
      if (b4.length === 0) l3 += `declare -A ${u3}=()
`;
      else {
        let $5 = b4.map((C2) => {
          let y2 = e5.state.env[`${u3}_${C2}`] ?? "", g2 = ds(y2);
          return `['${C2}']=${g2}`;
        });
        l3 += `declare -A ${u3}=(${$5.join(" ")})
`;
      }
      continue;
    }
    if (m3.length > 0) {
      let b4 = m3.map(($5) => {
        let C2 = e5.state.env[`${u3}_${$5}`] ?? "";
        return `[${$5}]=${Re$2(C2)}`;
      });
      l3 += `declare -a ${u3}=(${b4.join(" ")})
`;
      continue;
    }
    if (e5.state.env[`${u3}__length`] !== void 0) {
      l3 += `declare -a ${u3}=()
`;
      continue;
    }
    let w4 = e5.state.env[u3];
    w4 !== void 0 && (l3 += `declare ${d3} ${u3}=${us(w4)}
`);
  }
  return F$a(l3);
}
function Bn$1(e5) {
  let t4 = "", s3 = Array.from(e5.state.associativeArrays ?? []).sort();
  for (let n3 of s3) {
    let r2 = ht$4(e5, n3);
    if (r2.length === 0) t4 += `declare -A ${n3}=()
`;
    else {
      let i4 = r2.map((o2) => {
        let a3 = e5.state.env[`${n3}_${o2}`] ?? "", l3 = ds(a3);
        return `['${o2}']=${l3}`;
      });
      t4 += `declare -A ${n3}=(${i4.join(" ")})
`;
    }
  }
  return F$a(t4);
}
function jn(e5) {
  let t4 = "", s3 = /* @__PURE__ */ new Set();
  for (let r2 of Object.keys(e5.state.env)) {
    if (r2.startsWith("BASH_")) continue;
    if (r2.endsWith("__length")) {
      let o2 = r2.slice(0, -8);
      e5.state.associativeArrays?.has(o2) || s3.add(o2);
      continue;
    }
    let i4 = r2.lastIndexOf("_");
    if (i4 > 0) {
      let o2 = r2.slice(0, i4), a3 = r2.slice(i4 + 1);
      /^\d+$/.test(a3) && (e5.state.associativeArrays?.has(o2) || s3.add(o2));
    }
  }
  let n3 = Array.from(s3).sort();
  for (let r2 of n3) {
    let i4 = pt$2(e5, r2);
    if (i4.length === 0) t4 += `declare -a ${r2}=()
`;
    else {
      let o2 = i4.map((a3) => {
        let l3 = e5.state.env[`${r2}_${a3}`] ?? "";
        return `[${a3}]=${Re$2(l3)}`;
      });
      t4 += `declare -a ${r2}=(${o2.join(" ")})
`;
    }
  }
  return F$a(t4);
}
function Hn(e5) {
  let t4 = "", s3 = /* @__PURE__ */ new Set();
  for (let r2 of Object.keys(e5.state.env)) {
    if (r2.startsWith("BASH_")) continue;
    if (r2.endsWith("__length")) {
      let o2 = r2.slice(0, -8);
      s3.add(o2);
      continue;
    }
    let i4 = r2.lastIndexOf("_");
    if (i4 > 0) {
      let o2 = r2.slice(0, i4), a3 = r2.slice(i4 + 1);
      if (/^\d+$/.test(a3) || e5.state.associativeArrays?.has(o2)) {
        s3.add(o2);
        continue;
      }
    }
    s3.add(r2);
  }
  let n3 = Array.from(s3).sort();
  for (let r2 of n3) {
    if (e5.state.associativeArrays?.has(r2) || pt$2(e5, r2).length > 0 || e5.state.env[`${r2}__length`] !== void 0) continue;
    let a3 = e5.state.env[r2];
    a3 !== void 0 && (t4 += `${r2}=${Ct(a3)}
`);
  }
  return F$a(t4);
}
function hs(e5, t4) {
  e5.state.integerVars ??= /* @__PURE__ */ new Set(), e5.state.integerVars.add(t4);
}
function Je$5(e5, t4) {
  return e5.state.integerVars?.has(t4) ?? false;
}
function ps(e5, t4) {
  e5.state.lowercaseVars ??= /* @__PURE__ */ new Set(), e5.state.lowercaseVars.add(t4), e5.state.uppercaseVars?.delete(t4);
}
function Ci$1(e5, t4) {
  return e5.state.lowercaseVars?.has(t4) ?? false;
}
function ms$1(e5, t4) {
  e5.state.uppercaseVars ??= /* @__PURE__ */ new Set(), e5.state.uppercaseVars.add(t4), e5.state.lowercaseVars?.delete(t4);
}
function ki$1(e5, t4) {
  return e5.state.uppercaseVars?.has(t4) ?? false;
}
function ze$3(e5, t4, s3) {
  return Ci$1(e5, t4) ? s3.toLowerCase() : ki$1(e5, t4) ? s3.toUpperCase() : s3;
}
async function Un(e5, t4) {
  try {
    let s3 = new T$9(), n3 = W$d(s3, t4), r2 = await R$a(e5, n3.expression);
    return String(r2);
  } catch {
    return "0";
  }
}
function Oi(e5) {
  let t4 = e5.match(/^[a-zA-Z_][a-zA-Z0-9_]*/);
  if (!t4) return null;
  let s3 = t4[0], n3 = s3.length;
  if (e5[n3] !== "[") return null;
  let r2 = 0, i4 = n3 + 1;
  for (; n3 < e5.length; n3++) if (e5[n3] === "[") r2++;
  else if (e5[n3] === "]" && (r2--, r2 === 0)) break;
  if (r2 !== 0) return null;
  let o2 = e5.slice(i4, n3);
  if (n3++, e5[n3] !== "=") return null;
  n3++;
  let a3 = e5.slice(n3);
  return { name: s3, indexExpr: o2, value: a3 };
}
async function ys(e5, t4) {
  let s3 = false, n3 = false, r2 = false, i4 = false, o2 = false, a3 = false, l3 = false, c3 = false, f3 = false, u3 = false, d3 = false, h3 = false, m3 = false, p3 = false, w4 = false, b4 = [];
  for (let T3 = 0; T3 < t4.length; T3++) {
    let R2 = t4[T3];
    if (R2 === "-a") s3 = true;
    else if (R2 === "-A") n3 = true;
    else if (R2 === "-r") r2 = true;
    else if (R2 === "-x") i4 = true;
    else if (R2 === "-p") o2 = true;
    else if (R2 === "-n") a3 = true;
    else if (R2 === "+n") l3 = true;
    else if (R2 === "+a") c3 = true;
    else if (R2 === "+x") f3 = true;
    else if (R2 === "--") {
      b4.push(...t4.slice(T3 + 1));
      break;
    } else if (R2.startsWith("+")) {
      for (let A2 of R2.slice(1)) if (A2 === "n") l3 = true;
      else if (A2 === "a") c3 = true;
      else if (A2 === "x") f3 = true;
      else if (A2 !== "r") {
        if (A2 !== "i") {
          if (!(A2 === "f" || A2 === "F")) return P$f("", `bash: typeset: +${A2}: invalid option
`, 2);
        }
      }
    } else if (R2 === "-i") u3 = true;
    else if (R2 === "-l") d3 = true;
    else if (R2 === "-u") h3 = true;
    else if (R2 === "-f") m3 = true;
    else if (R2 === "-F") p3 = true;
    else if (R2 === "-g") w4 = true;
    else if (R2.startsWith("-")) for (let A2 of R2.slice(1)) if (A2 === "a") s3 = true;
    else if (A2 === "A") n3 = true;
    else if (A2 === "r") r2 = true;
    else if (A2 === "x") i4 = true;
    else if (A2 === "p") o2 = true;
    else if (A2 === "n") a3 = true;
    else if (A2 === "i") u3 = true;
    else if (A2 === "l") d3 = true;
    else if (A2 === "u") h3 = true;
    else if (A2 === "f") m3 = true;
    else if (A2 === "F") p3 = true;
    else if (A2 === "g") w4 = true;
    else return P$f("", `bash: typeset: -${A2}: invalid option
`, 2);
    else b4.push(R2);
  }
  let C2 = e5.state.localScopes.length > 0 && !w4, y2 = (T3) => {
    if (!C2) return;
    let R2 = e5.state.localScopes[e5.state.localScopes.length - 1];
    R2.has(T3) || R2.set(T3, e5.state.env[T3]);
  }, g2 = (T3) => {
    if (!C2) return;
    let R2 = e5.state.localScopes[e5.state.localScopes.length - 1];
    R2.has(T3) || R2.set(T3, e5.state.env[T3]);
    let A2 = `${T3}_`;
    for (let D3 of Object.keys(e5.state.env)) D3.startsWith(A2) && !D3.includes("__") && (R2.has(D3) || R2.set(D3, e5.state.env[D3]));
    let N2 = `${T3}__length`;
    e5.state.env[N2] !== void 0 && !R2.has(N2) && R2.set(N2, e5.state.env[N2]);
  }, v2 = (T3) => {
    C2 && Oe$5(e5, T3);
  };
  if (p3) {
    if (b4.length === 0) {
      let A2 = Array.from(e5.state.functions.keys()).sort(), N2 = "";
      for (let D3 of A2) N2 += `declare -f ${D3}
`;
      return F$a(N2);
    }
    let T3 = true, R2 = "";
    for (let A2 of b4) e5.state.functions.has(A2) ? R2 += `${A2}
` : T3 = false;
    return P$f(R2, "", T3 ? 0 : 1);
  }
  if (m3) {
    if (b4.length === 0) {
      let R2 = "", A2 = Array.from(e5.state.functions.keys()).sort();
      for (let N2 of A2) R2 += `${N2} ()
{
    # function body
}
`;
      return F$a(R2);
    }
    let T3 = true;
    for (let R2 of b4) e5.state.functions.has(R2) || (T3 = false);
    return P$f("", "", T3 ? 0 : 1);
  }
  if (o2 && b4.length > 0) return zn$1(e5, b4);
  if (o2 && b4.length === 0) return Vn(e5, { filterExport: i4, filterReadonly: r2, filterNameref: a3, filterIndexedArray: s3, filterAssocArray: n3 });
  if (b4.length === 0 && n3 && !o2) return Bn$1(e5);
  if (b4.length === 0 && s3 && !o2) return jn(e5);
  if (b4.length === 0 && !o2) return Hn(e5);
  let _4 = "", k3 = 0;
  for (let T3 of b4) {
    let R2 = T3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (R2 && !c3) {
      let E2 = R2[1], O2 = R2[2];
      if (n3 && pt$2(e5, E2).length > 0) {
        _4 += `bash: declare: ${E2}: cannot convert indexed to associative array
`, k3 = 1;
        continue;
      }
      if ((s3 || !n3 && !s3) && e5.state.associativeArrays?.has(E2)) {
        _4 += `bash: declare: ${E2}: cannot convert associative to indexed array
`, k3 = 1;
        continue;
      }
      if (g2(E2), n3 && (e5.state.associativeArrays ??= /* @__PURE__ */ new Set(), e5.state.associativeArrays.add(E2)), Ri$1(e5, E2), delete e5.state.env[E2], delete e5.state.env[`${E2}__length`], n3 && O2.includes("[")) {
        let x4 = St$2(O2);
        for (let [K2, W4] of x4) {
          let U2 = H$d(e5, W4);
          e5.state.env[`${E2}_${K2}`] = U2;
        }
      } else if (n3) {
        let x4 = ye$4(O2);
        for (let K2 = 0; K2 < x4.length; K2 += 2) {
          let W4 = x4[K2], U2 = K2 + 1 < x4.length ? H$d(e5, x4[K2 + 1]) : "";
          e5.state.env[`${E2}_${W4}`] = U2;
        }
      } else {
        let x4 = ye$4(O2);
        if (x4.some((W4) => /^\[[^\]]+\]=/.test(W4))) {
          let W4 = 0;
          for (let U2 of x4) {
            let ee2 = U2.match(/^\[([^\]]+)\]=(.*)$/);
            if (ee2) {
              let Q4 = ee2[1], Tr2 = ee2[2], Rr2 = H$d(e5, Tr2), qe2;
              if (/^-?\d+$/.test(Q4)) qe2 = Number.parseInt(Q4, 10);
              else try {
                let xr2 = new T$9(), Lr2 = W$d(xr2, Q4);
                qe2 = await R$a(e5, Lr2.expression);
              } catch {
                qe2 = 0;
              }
              e5.state.env[`${E2}_${qe2}`] = Rr2, W4 = qe2 + 1;
            } else {
              let Q4 = H$d(e5, U2);
              e5.state.env[`${E2}_${W4}`] = Q4, W4++;
            }
          }
        } else {
          for (let W4 = 0; W4 < x4.length; W4++) e5.state.env[`${E2}_${W4}`] = x4[W4];
          e5.state.env[`${E2}__length`] = String(x4.length);
        }
      }
      v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2);
      continue;
    }
    if (l3) {
      let E2 = T3.includes("=") ? T3.slice(0, T3.indexOf("=")) : T3;
      if (Ci$2(e5, E2), !T3.includes("=")) continue;
    }
    if (f3) {
      let E2 = T3.includes("=") ? T3.slice(0, T3.indexOf("=")) : T3;
      if (la(e5, E2), !T3.includes("=")) continue;
    }
    let A2 = Oi(T3);
    if (A2) {
      let { name: E2, indexExpr: O2, value: x4 } = A2;
      aa(e5, E2);
      g2(E2);
      let W4;
      try {
        let ee2 = new T$9(), Q4 = W$d(ee2, O2);
        W4 = await R$a(e5, Q4.expression);
      } catch {
        let ee2 = parseInt(O2, 10);
        W4 = Number.isNaN(ee2) ? 0 : ee2;
      }
      e5.state.env[`${E2}_${W4}`] = x4;
      let U2 = parseInt(e5.state.env[`${E2}__length`] ?? "0", 10);
      W4 >= U2 && (e5.state.env[`${E2}__length`] = String(W4 + 1)), v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2);
      continue;
    }
    let N2 = T3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (N2 && !c3) {
      let E2 = N2[1], O2 = N2[2];
      aa(e5, E2);
      g2(E2);
      let K2 = ye$4(O2);
      if (e5.state.associativeArrays?.has(E2)) {
        let W4 = St$2(O2);
        for (let [U2, ee2] of W4) {
          let Q4 = H$d(e5, ee2);
          e5.state.env[`${E2}_${U2}`] = Q4;
        }
      } else {
        let W4 = pt$2(e5, E2), U2 = 0;
        if (W4.length === 0 && e5.state.env[E2] !== void 0) {
          let Q4 = e5.state.env[E2];
          e5.state.env[`${E2}_0`] = Q4, delete e5.state.env[E2], U2 = 1;
        } else W4.length > 0 && (U2 = Math.max(...W4) + 1);
        for (let Q4 = 0; Q4 < K2.length; Q4++) e5.state.env[`${E2}_${U2 + Q4}`] = H$d(e5, K2[Q4]);
        let ee2 = U2 + K2.length;
        e5.state.env[`${E2}__length`] = String(ee2);
      }
      v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2);
      continue;
    }
    let D3 = T3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (D3) {
      let E2 = D3[1], O2 = H$d(e5, D3[2]);
      aa(e5, E2);
      y2(E2), u3 && hs(e5, E2), d3 && ps(e5, E2), h3 && ms$1(e5, E2);
      let W4 = pt$2(e5, E2).length > 0 || e5.state.associativeArrays?.has(E2);
      if (Je$5(e5, E2)) {
        let U2 = e5.state.env[E2] ?? "0", ee2 = parseInt(U2, 10) || 0, Q4 = parseInt(await Un(e5, O2), 10) || 0;
        O2 = String(ee2 + Q4), e5.state.env[E2] = O2;
      } else if (W4) {
        O2 = ze$3(e5, E2, O2);
        let U2 = `${E2}_0`, ee2 = e5.state.env[U2] ?? "";
        e5.state.env[U2] = ee2 + O2;
      } else {
        O2 = ze$3(e5, E2, O2);
        let U2 = e5.state.env[E2] ?? "";
        e5.state.env[E2] = U2 + O2;
      }
      v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2), e5.state.options.allexport && !f3 && (e5.state.exportedVars = e5.state.exportedVars || /* @__PURE__ */ new Set(), e5.state.exportedVars.add(E2));
      continue;
    }
    if (T3.includes("=")) {
      let E2 = T3.indexOf("="), O2 = T3.slice(0, E2), x4 = T3.slice(E2 + 1);
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(O2)) {
        _4 += `bash: typeset: \`${O2}': not a valid identifier
`, k3 = 1;
        continue;
      }
      aa(e5, O2);
      if (y2(O2), a3) {
        if (x4 !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(x4)) {
          _4 += `bash: declare: \`${x4}': invalid variable name for name reference
`, k3 = 1;
          continue;
        }
        e5.state.env[O2] = x4, _i$2(e5, O2), x4 !== "" && ss$1(e5, x4) && Li$2(e5, O2), v2(O2), r2 && ia$1(e5, O2), i4 && oa$1(e5, O2);
        continue;
      }
      if (u3 && hs(e5, O2), d3 && ps(e5, O2), h3 && ms$1(e5, O2), Je$5(e5, O2) && (x4 = await Un(e5, x4)), x4 = ze$3(e5, O2, x4), C$g(e5, O2)) {
        let W4 = le$8(e5, O2);
        W4 && W4 !== O2 ? e5.state.env[W4] = x4 : e5.state.env[O2] = x4;
      } else e5.state.env[O2] = x4;
      v2(O2), r2 && ia$1(e5, O2), i4 && oa$1(e5, O2), e5.state.options.allexport && !f3 && (e5.state.exportedVars = e5.state.exportedVars || /* @__PURE__ */ new Set(), e5.state.exportedVars.add(O2));
    } else {
      let E2 = T3;
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(E2)) {
        _4 += `bash: typeset: \`${E2}': not a valid identifier
`, k3 = 1;
        continue;
      }
      if (s3 || n3 ? g2(E2) : y2(E2), a3) {
        _i$2(e5, E2);
        let x4 = e5.state.env[E2];
        x4 !== void 0 && x4 !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(x4) ? Oi$1(e5, E2) : x4 && ss$1(e5, x4) && Li$2(e5, E2), v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2);
        continue;
      }
      if (u3 && hs(e5, E2), d3 && ps(e5, E2), h3 && ms$1(e5, E2), n3) {
        if (pt$2(e5, E2).length > 0) {
          _4 += `bash: declare: ${E2}: cannot convert indexed to associative array
`, k3 = 1;
          continue;
        }
        e5.state.associativeArrays ??= /* @__PURE__ */ new Set(), e5.state.associativeArrays.add(E2);
      }
      let O2 = Object.keys(e5.state.env).some((x4) => x4.startsWith(`${E2}_`) && !x4.startsWith(`${E2}__length`));
      !(E2 in e5.state.env) && !O2 && (s3 || n3 ? e5.state.env[`${E2}__length`] = "0" : (e5.state.declaredVars ??= /* @__PURE__ */ new Set(), e5.state.declaredVars.add(E2))), v2(E2), r2 && ia$1(e5, E2), i4 && oa$1(e5, E2);
    }
  }
  return P$f("", _4, k3);
}
async function ws$1(e5, t4) {
  let i4 = [];
  for (let o2 = 0; o2 < t4.length; o2++) {
    let a3 = t4[o2];
    if (a3 === "-a") ;
    else if (a3 === "-A") ;
    else if (a3 === "-p") ;
    else if (a3 === "--") {
      i4.push(...t4.slice(o2 + 1));
      break;
    } else a3.startsWith("-") || i4.push(a3);
  }
  if (i4.length === 0) {
    let o2 = "", a3 = Array.from(e5.state.readonlyVars || []).sort();
    for (let l3 of a3) {
      let c3 = e5.state.env[l3];
      if (c3 !== void 0) {
        let f3 = c3.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o2 += `declare -r ${l3}="${f3}"
`;
      }
    }
    return F$a(o2);
  }
  for (let o2 of i4) {
    let a3 = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (a3) {
      let u3 = a3[1], d3 = a3[2];
      aa(e5, u3);
      let m3 = ye$4(d3);
      if (e5.state.associativeArrays?.has(u3)) {
        let p3 = St$2(d3);
        for (let [w4, b4] of p3) {
          let $5 = H$d(e5, b4);
          e5.state.env[`${u3}_${w4}`] = $5;
        }
      } else {
        let p3 = pt$2(e5, u3), w4 = 0;
        if (p3.length === 0 && e5.state.env[u3] !== void 0) {
          let $5 = e5.state.env[u3];
          e5.state.env[`${u3}_0`] = $5, delete e5.state.env[u3], w4 = 1;
        } else p3.length > 0 && (w4 = Math.max(...p3) + 1);
        for (let $5 = 0; $5 < m3.length; $5++) e5.state.env[`${u3}_${w4 + $5}`] = H$d(e5, m3[$5]);
        let b4 = w4 + m3.length;
        e5.state.env[`${u3}__length`] = String(b4);
      }
      ia$1(e5, u3);
      continue;
    }
    let l3 = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (l3) {
      let u3 = l3[1], d3 = H$d(e5, l3[2]);
      aa(e5, u3);
      let m3 = e5.state.env[u3] ?? "";
      e5.state.env[u3] = m3 + d3, ia$1(e5, u3);
      continue;
    }
    let c3 = kn$1(o2);
    if (c3.value === void 0 && !c3.isArray) {
      ia$1(e5, c3.name);
      continue;
    }
    let f3 = await On(e5, c3, { makeReadonly: true });
    if (f3) return f3;
  }
  return L$d;
}
function gs(e5) {
  return e5.state.directoryStack ??= [], e5.state.directoryStack;
}
function et$6(e5, t4) {
  return t4 && e5 === t4 ? "~" : t4 && e5.startsWith(`${t4}/`) ? `~${e5.slice(t4.length)}` : e5;
}
function Di(e5) {
  let t4 = e5.split("/").filter((n3) => n3 && n3 !== "."), s3 = [];
  for (let n3 of t4) n3 === ".." ? s3.pop() : s3.push(n3);
  return `/${s3.join("/")}`;
}
async function vs$1(e5, t4) {
  let s3 = gs(e5), n3;
  for (let a3 = 0; a3 < t4.length; a3++) {
    let l3 = t4[a3];
    if (l3 === "--") {
      if (a3 + 1 < t4.length) {
        if (n3 !== void 0) return S$d(`bash: pushd: too many arguments
`, 2);
        n3 = t4[a3 + 1], a3++;
      }
    } else {
      if (l3.startsWith("-") && l3 !== "-") return S$d(`bash: pushd: ${l3}: invalid option
`, 2);
      if (n3 !== void 0) return S$d(`bash: pushd: too many arguments
`, 2);
      n3 = l3;
    }
  }
  if (n3 === void 0) {
    if (s3.length < 2) return S$d(`bash: pushd: no other directory
`, 1);
    let a3 = s3[0];
    s3[0] = s3[1], s3[1] = a3, n3 = s3[0];
  }
  let r2;
  if (n3.startsWith("/")) r2 = n3;
  else if (n3 === "..") {
    let a3 = e5.state.cwd.split("/").filter((l3) => l3);
    a3.pop(), r2 = `/${a3.join("/")}`;
  } else n3 === "." ? r2 = e5.state.cwd : n3.startsWith("~") ? r2 = (e5.state.env.HOME || "/") + n3.slice(1) : r2 = `${e5.state.cwd}/${n3}`;
  r2 = Di(r2);
  try {
    if (!(await e5.fs.stat(r2)).isDirectory) return S$d(`bash: pushd: ${n3}: Not a directory
`, 1);
  } catch {
    return S$d(`bash: pushd: ${n3}: No such file or directory
`, 1);
  }
  s3.unshift(e5.state.cwd), e5.state.previousDir = e5.state.cwd, e5.state.cwd = r2, e5.state.env.PWD = r2, e5.state.env.OLDPWD = e5.state.previousDir;
  let i4 = e5.state.env.HOME || "", o2 = `${[r2, ...s3].map((a3) => et$6(a3, i4)).join(" ")}
`;
  return F$a(o2);
}
function bs(e5, t4) {
  let s3 = gs(e5);
  for (let o2 of t4) if (o2 !== "--") return o2.startsWith("-") && o2 !== "-" ? S$d(`bash: popd: ${o2}: invalid option
`, 2) : S$d(`bash: popd: too many arguments
`, 2);
  if (s3.length === 0) return S$d(`bash: popd: directory stack empty
`, 1);
  let n3 = s3.shift();
  if (!n3) return S$d(`bash: popd: directory stack empty
`, 1);
  e5.state.previousDir = e5.state.cwd, e5.state.cwd = n3, e5.state.env.PWD = n3, e5.state.env.OLDPWD = e5.state.previousDir;
  let r2 = e5.state.env.HOME || "", i4 = `${[n3, ...s3].map((o2) => et$6(o2, r2)).join(" ")}
`;
  return F$a(i4);
}
function Es(e5, t4) {
  let s3 = gs(e5), n3 = false, r2 = false, i4 = false, o2 = false;
  for (let f3 of t4) if (f3 !== "--") if (f3.startsWith("-")) for (let u3 of f3.slice(1)) if (u3 === "c") n3 = true;
  else if (u3 === "l") r2 = true;
  else if (u3 === "p") i4 = true;
  else if (u3 === "v") i4 = true, o2 = true;
  else return S$d(`bash: dirs: -${u3}: invalid option
`, 2);
  else return S$d(`bash: dirs: too many arguments
`, 1);
  if (n3) return e5.state.directoryStack = [], L$d;
  let a3 = [e5.state.cwd, ...s3], l3 = e5.state.env.HOME || "", c3;
  return o2 ? (c3 = a3.map((f3, u3) => {
    let d3 = r2 ? f3 : et$6(f3, l3);
    return ` ${u3}  ${d3}`;
  }).join(`
`), c3 += `
`) : i4 ? c3 = a3.map((f3) => r2 ? f3 : et$6(f3, l3)).join(`
`) + `
` : c3 = a3.map((f3) => r2 ? f3 : et$6(f3, l3)).join(" ") + `
`, F$a(c3);
}
async function kt$1(e5, t4, s3) {
  let n3 = t4;
  if (n3.length > 0) {
    let a3 = n3[0];
    if (a3 === "--") n3 = n3.slice(1);
    else if (a3.startsWith("-") && a3 !== "-" && a3.length > 1) return S$d(`bash: eval: ${a3}: invalid option
eval: usage: eval [arg ...]
`, 2);
  }
  if (n3.length === 0) return L$d;
  let r2 = n3.join(" ");
  if (r2.trim() === "") return L$d;
  let i4 = e5.state.groupStdin, o2 = s3 ?? e5.state.groupStdin;
  o2 !== void 0 && (e5.state.groupStdin = o2);
  try {
    let a3 = ci$1(r2);
    return await e5.executeScript(a3);
  } catch (a3) {
    if (a3 instanceof c$7 || a3 instanceof a$1 || a3 instanceof i$6 || a3 instanceof d$8) throw a3;
    if (a3.name === "ParseException") return S$d(`bash: eval: ${a3.message}
`);
    throw a3;
  } finally {
    e5.state.groupStdin = i4;
  }
}
function $s$1(e5, t4) {
  let s3, n3 = "";
  if (t4.length === 0) s3 = e5.state.lastExitCode;
  else {
    let r2 = t4[0], i4 = Number.parseInt(r2, 10);
    r2 === "" || Number.isNaN(i4) || !/^-?\d+$/.test(r2) ? (n3 = `bash: exit: ${r2}: numeric argument required
`, s3 = 2) : s3 = (i4 % 256 + 256) % 256;
  }
  throw new d$8(s3, "", n3);
}
function Ss(e5, t4) {
  let s3 = false, n3 = [];
  for (let o2 of t4) o2 === "-n" ? s3 = true : o2 === "-p" || o2 === "--" || n3.push(o2);
  if (n3.length === 0 && !s3) {
    let o2 = "", a3 = e5.state.exportedVars ?? /* @__PURE__ */ new Set(), l3 = Array.from(a3).sort();
    for (let c3 of l3) {
      let f3 = e5.state.env[c3];
      if (f3 !== void 0) {
        let u3 = f3.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
        o2 += `declare -x ${c3}="${u3}"
`;
      }
    }
    return F$a(o2);
  }
  if (s3) {
    for (let o2 of n3) {
      let a3, l3;
      if (o2.includes("=")) {
        let c3 = o2.indexOf("=");
        a3 = o2.slice(0, c3), l3 = H$d(e5, o2.slice(c3 + 1)), e5.state.env[a3] = l3;
      } else a3 = o2;
      la(e5, a3);
    }
    return L$d;
  }
  let r2 = "", i4 = 0;
  for (let o2 of n3) {
    let a3, l3, c3 = false, f3 = o2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (f3) a3 = f3[1], l3 = H$d(e5, f3[2]), c3 = true;
    else if (o2.includes("=")) {
      let u3 = o2.indexOf("=");
      a3 = o2.slice(0, u3), l3 = H$d(e5, o2.slice(u3 + 1));
    } else a3 = o2;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(a3)) {
      r2 += `bash: export: \`${o2}': not a valid identifier
`, i4 = 1;
      continue;
    }
    if (l3 !== void 0) if (c3) {
      let u3 = e5.state.env[a3] ?? "";
      e5.state.env[a3] = u3 + l3;
    } else e5.state.env[a3] = l3;
    else a3 in e5.state.env || (e5.state.env[a3] = "");
    oa$1(e5, a3);
  }
  return P$f("", r2, i4);
}
function Ot$1(e5, t4) {
  if (t4.length < 2) return S$d(`bash: getopts: usage: getopts optstring name [arg ...]
`);
  let s3 = t4[0], n3 = t4[1], r2 = !/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(n3), i4 = s3.startsWith(":"), o2 = i4 ? s3.slice(1) : s3, a3;
  if (t4.length > 2) a3 = t4.slice(2);
  else {
    let p3 = Number.parseInt(e5.state.env["#"] || "0", 10);
    a3 = [];
    for (let w4 = 1; w4 <= p3; w4++) a3.push(e5.state.env[String(w4)] || "");
  }
  let l3 = Number.parseInt(e5.state.env.OPTIND || "1", 10);
  l3 < 1 && (l3 = 1);
  let c3 = Number.parseInt(e5.state.env.__GETOPTS_CHARINDEX || "0", 10);
  if (e5.state.env.OPTARG = "", l3 > a3.length) return r2 || (e5.state.env[n3] = "?"), e5.state.env.OPTIND = String(a3.length + 1), e5.state.env.__GETOPTS_CHARINDEX = "0", { exitCode: r2 ? 2 : 1, stdout: "", stderr: "" };
  let f3 = a3[l3 - 1];
  if (!f3 || f3 === "-" || !f3.startsWith("-")) return r2 || (e5.state.env[n3] = "?"), { exitCode: r2 ? 2 : 1, stdout: "", stderr: "" };
  if (f3 === "--") return e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0", r2 || (e5.state.env[n3] = "?"), { exitCode: r2 ? 2 : 1, stdout: "", stderr: "" };
  let u3 = c3 === 0 ? 1 : c3, d3 = f3[u3];
  if (!d3) return e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0", Ot$1(e5, t4);
  let h3 = o2.indexOf(d3);
  if (h3 === -1) {
    let p3 = "";
    return i4 ? e5.state.env.OPTARG = d3 : p3 = `bash: illegal option -- ${d3}
`, r2 || (e5.state.env[n3] = "?"), u3 + 1 < f3.length ? (e5.state.env.__GETOPTS_CHARINDEX = String(u3 + 1), e5.state.env.OPTIND = String(l3)) : (e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0"), { exitCode: r2 ? 2 : 0, stdout: "", stderr: p3 };
  }
  if (h3 + 1 < o2.length && o2[h3 + 1] === ":") if (u3 + 1 < f3.length) e5.state.env.OPTARG = f3.slice(u3 + 1), e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0";
  else {
    if (l3 >= a3.length) {
      let p3 = "";
      return i4 ? (e5.state.env.OPTARG = d3, r2 || (e5.state.env[n3] = ":")) : (p3 = `bash: option requires an argument -- ${d3}
`, r2 || (e5.state.env[n3] = "?")), e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0", { exitCode: r2 ? 2 : 0, stdout: "", stderr: p3 };
    }
    e5.state.env.OPTARG = a3[l3], e5.state.env.OPTIND = String(l3 + 2), e5.state.env.__GETOPTS_CHARINDEX = "0";
  }
  else u3 + 1 < f3.length ? (e5.state.env.__GETOPTS_CHARINDEX = String(u3 + 1), e5.state.env.OPTIND = String(l3)) : (e5.state.env.OPTIND = String(l3 + 1), e5.state.env.__GETOPTS_CHARINDEX = "0");
  return r2 || (e5.state.env[n3] = d3), { exitCode: r2 ? 2 : 0, stdout: "", stderr: "" };
}
async function As(e5, t4) {
  e5.state.hashTable || (e5.state.hashTable = /* @__PURE__ */ new Map());
  let s3 = false, n3 = false, r2 = false, i4 = false, o2 = false, a3 = "", l3 = [], c3 = 0;
  for (; c3 < t4.length; ) {
    let m3 = t4[c3];
    if (m3 === "--") {
      c3++, l3.push(...t4.slice(c3));
      break;
    }
    if (m3 === "-r") s3 = true, c3++;
    else if (m3 === "-d") n3 = true, c3++;
    else if (m3 === "-l") r2 = true, c3++;
    else if (m3 === "-t") o2 = true, c3++;
    else if (m3 === "-p") {
      if (i4 = true, c3++, c3 >= t4.length) return S$d(`bash: hash: -p: option requires an argument
`, 1);
      a3 = t4[c3], c3++;
    } else if (m3.startsWith("-") && m3.length > 1) {
      for (let p3 of m3.slice(1)) if (p3 === "r") s3 = true;
      else if (p3 === "d") n3 = true;
      else if (p3 === "l") r2 = true;
      else if (p3 === "t") o2 = true;
      else return p3 === "p" ? S$d(`bash: hash: -p: option requires an argument
`, 1) : S$d(`bash: hash: -${p3}: invalid option
`, 1);
      c3++;
    } else l3.push(m3), c3++;
  }
  if (s3) return e5.state.hashTable.clear(), L$d;
  if (n3) {
    if (l3.length === 0) return S$d(`bash: hash: -d: option requires an argument
`, 1);
    let m3 = false, p3 = "";
    for (let w4 of l3) e5.state.hashTable.has(w4) ? e5.state.hashTable.delete(w4) : (p3 += `bash: hash: ${w4}: not found
`, m3 = true);
    return m3 ? S$d(p3, 1) : L$d;
  }
  if (o2) {
    if (l3.length === 0) return S$d(`bash: hash: -t: option requires an argument
`, 1);
    let m3 = "", p3 = false, w4 = "";
    for (let b4 of l3) {
      let $5 = e5.state.hashTable.get(b4);
      $5 ? l3.length > 1 ? m3 += `${b4}	${$5}
` : m3 += `${$5}
` : (w4 += `bash: hash: ${b4}: not found
`, p3 = true);
    }
    return p3 ? { exitCode: 1, stdout: m3, stderr: w4 } : F$a(m3);
  }
  if (i4) {
    if (l3.length === 0) return S$d(`bash: hash: usage: hash [-lr] [-p pathname] [-dt] [name ...]
`, 1);
    let m3 = l3[0];
    return e5.state.hashTable.set(m3, a3), L$d;
  }
  if (l3.length === 0) {
    if (e5.state.hashTable.size === 0) return F$a(`hash: hash table empty
`);
    let m3 = "";
    if (r2) for (let [p3, w4] of e5.state.hashTable) m3 += `builtin hash -p ${w4} ${p3}
`;
    else {
      m3 = `hits	command
`;
      for (let [, p3] of e5.state.hashTable) m3 += `   1	${p3}
`;
    }
    return F$a(m3);
  }
  let f3 = false, u3 = "", h3 = (e5.state.env.PATH || "/usr/bin:/bin").split(":");
  for (let m3 of l3) {
    if (m3.includes("/")) {
      u3 += `bash: hash: ${m3}: cannot use / in name
`, f3 = true;
      continue;
    }
    let p3 = false;
    for (let w4 of h3) {
      if (!w4) continue;
      let b4 = `${w4}/${m3}`;
      if (await e5.fs.exists(b4)) {
        e5.state.hashTable.set(m3, b4), p3 = true;
        break;
      }
    }
    p3 || (u3 += `bash: hash: ${m3}: not found
`, f3 = true);
  }
  return f3 ? S$d(u3, 1) : L$d;
}
var Zn = { ":": [": [arguments]", `Null command.
    No effect; the command does nothing.
    Exit Status:
    Always succeeds.`], ".": [". filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`], "[": ["[ arg... ]", `Evaluate conditional expression.
    This is a synonym for the "test" builtin, but the last argument must
    be a literal \`]', to match the opening \`['.`], alias: ["alias [-p] [name[=value] ... ]", `Define or display aliases.
    Without arguments, \`alias' prints the list of aliases in the reusable
    form \`alias NAME=VALUE' on standard output.
    Exit Status:
    alias returns true unless a NAME is supplied for which no alias has been
    defined.`], bg: ["bg [job_spec ...]", `Move jobs to the background.
    Place the jobs identified by each JOB_SPEC in the background, as if they
    had been started with \`&'.`], break: ["break [n]", `Exit for, while, or until loops.
    Exit a FOR, WHILE or UNTIL loop.  If N is specified, break N enclosing
    loops.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`], builtin: ["builtin [shell-builtin [arg ...]]", `Execute shell builtins.
    Execute SHELL-BUILTIN with arguments ARGs without performing command
    lookup.  This is useful when you wish to reimplement a shell builtin
    as a shell function, but need to execute the builtin within the function.
    Exit Status:
    Returns the exit status of SHELL-BUILTIN, or false if SHELL-BUILTIN is
    not a shell builtin.`], caller: ["caller [expr]", `Return the context of the current subroutine call.
    Without EXPR, returns "$line $filename".  With EXPR, returns
    "$line $subroutine $filename"; this extra information can be used to
    provide a stack trace.
    Exit Status:
    Returns 0 unless the shell is not executing a subroutine call or
    EXPR is invalid.`], cd: ["cd [-L|-P] [dir]", `Change the shell working directory.
    Change the current directory to DIR.  The default DIR is the value of the
    HOME shell variable.

    The variable CDPATH defines the search path for the directory containing
    DIR.  Alternative directory names in CDPATH are separated by a colon (:).
    A null directory name is the same as the current directory.  If DIR begins
    with a slash (/), then CDPATH is not used.

    If the directory is not found, and the shell option \`cdable_vars' is set,
    the word is assumed to be a variable name.  If that variable has a value,
    its value is used for DIR.

    Options:
      -L	force symbolic links to be followed
      -P	use the physical directory structure without following symbolic
    	links

    The default is to follow symbolic links, as if \`-L' were specified.

    Exit Status:
    Returns 0 if the directory is changed; non-zero otherwise.`], command: ["command [-pVv] command [arg ...]", `Execute a simple command or display information about commands.
    Runs COMMAND with ARGS suppressing shell function lookup, or display
    information about the specified COMMANDs.

    Options:
      -p	use a default value for PATH that is guaranteed to find all of
    	the standard utilities
      -v	print a description of COMMAND similar to the \`type' builtin
      -V	print a more verbose description of each COMMAND

    Exit Status:
    Returns exit status of COMMAND, or failure if COMMAND is not found.`], compgen: ["compgen [-abcdefgjksuv] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [word]", `Display possible completions depending on the options.
    Intended to be used from within a shell function generating possible
    completions.  If the optional WORD argument is supplied, matches against
    WORD are generated.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], complete: ["complete [-abcdefgjksuv] [-pr] [-DEI] [-o option] [-A action] [-G globpat] [-W wordlist]  [-F function] [-C command] [-X filterpat] [-P prefix] [-S suffix] [name ...]", `Specify how arguments are to be completed.
    For each NAME, specify how arguments are to be completed.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], continue: ["continue [n]", `Resume for, while, or until loops.
    Resumes the next iteration of the enclosing FOR, WHILE or UNTIL loop.
    If N is specified, resumes the Nth enclosing loop.
    Exit Status:
    The exit status is 0 unless N is not greater than or equal to 1.`], declare: ["declare [-aAfFgilnrtux] [-p] [name[=value] ...]", `Set variable values and attributes.
    Declare variables and give them attributes.  If no NAMEs are given,
    display the attributes and values of all variables.

    Options:
      -a	to make NAMEs indexed arrays (if supported)
      -A	to make NAMEs associative arrays (if supported)
      -i	to make NAMEs have the \`integer' attribute
      -l	to convert the value of each NAME to lower case on assignment
      -n	make NAME a reference to the variable named by its value
      -r	to make NAMEs readonly
      -t	to make NAMEs have the \`trace' attribute
      -u	to convert the value of each NAME to upper case on assignment
      -x	to make NAMEs export

    Exit Status:
    Returns success unless an invalid option is supplied or a variable
    assignment error occurs.`], dirs: ["dirs [-clpv] [+N] [-N]", `Display directory stack.
    Display the list of currently remembered directories.  Directories
    find their way onto the list with the \`pushd' command; you can get
    back up through the list with the \`popd' command.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], disown: ["disown [-h] [-ar] [jobspec ...]", `Remove jobs from current shell.
    Without any JOBSPECs, remove the current job.`], echo: ["echo [-neE] [arg ...]", `Write arguments to the standard output.
    Display the ARGs, separated by a single space character and followed by a
    newline, on the standard output.

    Options:
      -n	do not append a newline
      -e	enable interpretation of the following backslash escapes
      -E	explicitly suppress interpretation of backslash escapes

    Exit Status:
    Returns success unless a write error occurs.`], enable: ["enable [-a] [-dnps] [-f filename] [name ...]", `Enable and disable shell builtins.
    Enables and disables builtin shell commands.
    Exit Status:
    Returns success unless NAME is not a shell builtin or an error occurs.`], eval: ["eval [arg ...]", `Execute arguments as a shell command.
    Combine ARGs into a single string, use the result as input to the shell,
    and execute the resulting commands.
    Exit Status:
    Returns exit status of command or success if command is null.`], exec: ["exec [-cl] [-a name] [command [arguments ...]] [redirection ...]", `Replace the shell with the given command.
    Execute COMMAND, replacing this shell with the specified program.
    ARGUMENTS become the arguments to COMMAND.  If COMMAND is not specified,
    any redirections take effect in the current shell.
    Exit Status:
    Returns success unless COMMAND is not found or a redirection error occurs.`], exit: ["exit [n]", `Exit the shell.
    Exits the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed.`], export: ["export [-fn] [name[=value] ...] or export -p", `Set export attribute for shell variables.
    Marks each NAME for automatic export to the environment of subsequently
    executed commands.  If VALUE is supplied, assign VALUE before exporting.

    Options:
      -f	refer to shell functions
      -n	remove the export property from each NAME
      -p	display a list of all exported variables and functions

    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`], false: ["false", `Return an unsuccessful result.
    Exit Status:
    Always fails.`], fc: ["fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]", `Display or execute commands from the history list.
    Exit Status:
    Returns success or status of executed command.`], fg: ["fg [job_spec]", `Move job to the foreground.
    Place the job identified by JOB_SPEC in the foreground, making it the
    current job.`], getopts: ["getopts optstring name [arg]", `Parse option arguments.
    Getopts is used by shell procedures to parse positional parameters
    as options.

    OPTSTRING contains the option letters to be recognized; if a letter
    is followed by a colon, the option is expected to have an argument,
    which should be separated from it by white space.
    Exit Status:
    Returns success if an option is found; fails if the end of options is
    encountered or an error occurs.`], hash: ["hash [-lr] [-p pathname] [-dt] [name ...]", `Remember or display program locations.
    Determine and remember the full pathname of each command NAME.
    Exit Status:
    Returns success unless NAME is not found or an invalid option is given.`], help: ["help [-s] [pattern ...]", `Display information about builtin commands.
    Displays brief summaries of builtin commands.  If PATTERN is
    specified, gives detailed help on all commands matching PATTERN,
    otherwise the list of help topics is printed.

    Options:
      -s	output only a short usage synopsis for each topic matching
    	PATTERN

    Exit Status:
    Returns success unless PATTERN is not found.`], history: ["history [-c] [-d offset] [n] or history -anrw [filename] or history -ps arg [arg...]", `Display or manipulate the history list.
    Display the history list with line numbers, prefixing each modified
    entry with a \`*'.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], jobs: ["jobs [-lnprs] [jobspec ...] or jobs -x command [args]", `Display status of jobs.
    Lists the active jobs.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], kill: ["kill [-s sigspec | -n signum | -sigspec] pid | jobspec ... or kill -l [sigspec]", `Send a signal to a job.
    Send the processes identified by PID or JOBSPEC the signal named by
    SIGSPEC or SIGNUM.
    Exit Status:
    Returns success unless an invalid option is given or an error occurs.`], let: ["let arg [arg ...]", `Evaluate arithmetic expressions.
    Evaluate each ARG as an arithmetic expression.  Evaluation is done in
    fixed-width integers with no check for overflow, though division by 0
    is trapped and flagged as an error.
    Exit Status:
    If the last ARG evaluates to 0, let returns 1; 0 is returned otherwise.`], local: ["local [option] name[=value] ...", `Define local variables.
    Create a local variable called NAME, and give it VALUE.  OPTION can
    be any option accepted by \`declare'.

    Local can only be used within a function; it makes the variable NAME
    have a visible scope restricted to that function and its children.
    Exit Status:
    Returns success unless an invalid option is supplied, a variable
    assignment error occurs, or the shell is not executing a function.`], logout: ["logout [n]", `Exit a login shell.
    Exits a login shell with exit status N.  Returns an error if not executed
    in a login shell.`], mapfile: ["mapfile [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", `Read lines from the standard input into an indexed array variable.
    Read lines from the standard input into the indexed array variable ARRAY,
    or from file descriptor FD if the -u option is supplied.

    Options:
      -d delim	Use DELIM to terminate lines, instead of newline
      -n count	Copy at most COUNT lines
      -O origin	Begin assigning to ARRAY at index ORIGIN
      -s count	Discard the first COUNT lines read
      -t	Remove a trailing DELIM from each line read (default newline)
      -u fd	Read lines from file descriptor FD instead of standard input

    Exit Status:
    Returns success unless an invalid option is given or ARRAY is readonly.`], popd: ["popd [-n] [+N | -N]", `Remove directories from stack.
    Removes entries from the directory stack.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`], printf: ["printf [-v var] format [arguments]", `Formats and prints ARGUMENTS under control of the FORMAT.

    Options:
      -v var	assign the output to shell variable VAR rather than
    		display it on the standard output

    FORMAT is a character string which contains three types of objects: plain
    characters, which are simply copied to standard output; character escape
    sequences, which are converted and copied to the standard output; and
    format specifications, each of which causes printing of the next successive
    argument.
    Exit Status:
    Returns success unless an invalid option is given or a write or assignment
    error occurs.`], pushd: ["pushd [-n] [+N | -N | dir]", `Add directories to stack.
    Adds a directory to the top of the directory stack, or rotates
    the stack, making the new top of the stack the current working
    directory.
    Exit Status:
    Returns success unless an invalid argument is supplied or the directory
    change fails.`], pwd: ["pwd [-LP]", `Print the name of the current working directory.

    Options:
      -L	print the value of $PWD if it names the current working
    	directory
      -P	print the physical directory, without any symbolic links

    By default, \`pwd' behaves as if \`-L' were specified.
    Exit Status:
    Returns 0 unless an invalid option is given or the current directory
    cannot be read.`], read: ["read [-ers] [-a array] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]", `Read a line from the standard input and split it into fields.
    Reads a single line from the standard input, or from file descriptor FD
    if the -u option is supplied.  The line is split into fields as with word
    splitting, and the first word is assigned to the first NAME, the second
    word to the second NAME, and so on, with any leftover words assigned to
    the last NAME.
    Exit Status:
    The return code is zero, unless end-of-file is encountered, read times out,
    or an invalid file descriptor is supplied as the argument to -u.`], readarray: ["readarray [-d delim] [-n count] [-O origin] [-s count] [-t] [-u fd] [-C callback] [-c quantum] [array]", "Read lines from a file into an array variable.\n    A synonym for `mapfile'."], readonly: ["readonly [-aAf] [name[=value] ...] or readonly -p", `Mark shell variables as unchangeable.
    Mark each NAME as read-only; the values of these NAMEs may not be
    changed by subsequent assignment.
    Exit Status:
    Returns success unless an invalid option is given or NAME is invalid.`], return: ["return [n]", `Return from a shell function.
    Causes a function or sourced script to exit with the return value
    specified by N.  If N is omitted, the return status is that of the
    last command executed within the function or script.
    Exit Status:
    Returns N, or failure if the shell is not executing a function or script.`], set: ["set [-abefhkmnptuvxBCHP] [-o option-name] [--] [arg ...]", `Set or unset values of shell options and positional parameters.
    Change the value of shell attributes and positional parameters, or
    display the names and values of shell variables.

    Options:
      -e  Exit immediately if a command exits with a non-zero status.
      -u  Treat unset variables as an error when substituting.
      -x  Print commands and their arguments as they are executed.
      -o option-name
          Set the variable corresponding to option-name

    Exit Status:
    Returns success unless an invalid option is given.`], shift: ["shift [n]", `Shift positional parameters.
    Rename the positional parameters $N+1,$N+2 ... to $1,$2 ...  If N is
    not given, it is assumed to be 1.
    Exit Status:
    Returns success unless N is negative or greater than $#.`], shopt: ["shopt [-pqsu] [-o] [optname ...]", `Set and unset shell options.
    Change the setting of each shell option OPTNAME.  Without any option
    arguments, list each supplied OPTNAME, or all shell options if no
    OPTNAMEs are given, with an indication of whether or not each is set.

    Options:
      -o	restrict OPTNAMEs to those defined for use with \`set -o'
      -p	print each shell option with an indication of its status
      -q	suppress output
      -s	enable (set) each OPTNAME
      -u	disable (unset) each OPTNAME

    Exit Status:
    Returns success if OPTNAME is enabled; fails if an invalid option is
    given or OPTNAME is disabled.`], source: ["source filename [arguments]", `Execute commands from a file in the current shell.
    Read and execute commands from FILENAME in the current shell.
    The entries in $PATH are used to find the directory containing FILENAME.
    Exit Status:
    Returns the status of the last command executed in FILENAME.`], suspend: ["suspend [-f]", `Suspend shell execution.
    Suspend the execution of this shell until it receives a SIGCONT signal.`], test: ["test [expr]", `Evaluate conditional expression.
    Exits with a status of 0 (true) or 1 (false) depending on
    the evaluation of EXPR.  Expressions may be unary or binary.
    Exit Status:
    Returns success if EXPR evaluates to true; fails if EXPR evaluates to
    false or an invalid argument is given.`], times: ["times", `Display process times.
    Prints the accumulated user and system times for the shell and all of its
    child processes.
    Exit Status:
    Always succeeds.`], trap: ["trap [-lp] [[arg] signal_spec ...]", `Trap signals and other events.
    Defines and activates handlers to be run when the shell receives signals
    or other conditions.
    Exit Status:
    Returns success unless a SIGSPEC is invalid or an invalid option is given.`], true: ["true", `Return a successful result.
    Exit Status:
    Always succeeds.`], type: ["type [-afptP] name [name ...]", `Display information about command type.
    For each NAME, indicate how it would be interpreted if used as a
    command name.

    Options:
      -a	display all locations containing an executable named NAME
      -f	suppress shell function lookup
      -P	force a PATH search for each NAME, even if it is an alias,
    	builtin, or function, and returns the name of the disk file
    	that would be executed
      -p	returns either the name of the disk file that would be executed,
    	or nothing if \`type -t NAME' would not return \`file'
      -t	output a single word which is one of \`alias', \`keyword',
    	\`function', \`builtin', \`file' or \`', if NAME is an alias,
    	shell reserved word, shell function, shell builtin, disk file,
    	or not found, respectively

    Exit Status:
    Returns success if all of the NAMEs are found; fails if any are not found.`], typeset: ["typeset [-aAfFgilnrtux] [-p] name[=value] ...", "Set variable values and attributes.\n    A synonym for `declare'."], ulimit: ["ulimit [-SHabcdefiklmnpqrstuvxPT] [limit]", `Modify shell resource limits.
    Provides control over the resources available to the shell and processes
    it creates, on systems that allow such control.
    Exit Status:
    Returns success unless an invalid option is supplied or an error occurs.`], umask: ["umask [-p] [-S] [mode]", `Display or set file mode mask.
    Sets the user file-creation mask to MODE.  If MODE is omitted, prints
    the current value of the mask.
    Exit Status:
    Returns success unless MODE is invalid or an invalid option is given.`], unalias: ["unalias [-a] name [name ...]", `Remove each NAME from the list of defined aliases.
    Exit Status:
    Returns success unless a NAME is not an existing alias.`], unset: ["unset [-f] [-v] [-n] [name ...]", `Unset values and attributes of shell variables and functions.
    For each NAME, remove the corresponding variable or function.

    Options:
      -f	treat each NAME as a shell function
      -v	treat each NAME as a shell variable
      -n	treat each NAME as a name reference and unset the variable itself
    	rather than the variable it references

    Without options, unset first tries to unset a variable, and if that fails,
    tries to unset a function.
    Exit Status:
    Returns success unless an invalid option is given or a NAME is read-only.`], wait: ["wait [-fn] [id ...]", `Wait for job completion and return exit status.
    Waits for each process identified by an ID, which may be a process ID or a
    job specification, and reports its termination status.
    Exit Status:
    Returns the status of the last ID; fails if ID is invalid or an invalid
    option is given.`] }, qn$1 = Object.keys(Zn).sort();
function Ps(e5, t4) {
  let s3 = false, n3 = [], r2 = 0;
  for (; r2 < t4.length; ) {
    let l3 = t4[r2];
    if (l3 === "--") {
      for (r2++; r2 < t4.length; ) n3.push(t4[r2]), r2++;
      break;
    }
    if (l3.startsWith("-") && l3.length > 1) {
      for (let c3 = 1; c3 < l3.length; c3++) {
        let f3 = l3[c3];
        if (f3 === "s") s3 = true;
        else return S$d(`bash: help: -${f3}: invalid option
`, 2);
      }
      r2++;
    } else n3.push(l3), r2++;
  }
  if (n3.length === 0) return Ti();
  let i4 = "", o2 = false, a3 = "";
  for (let l3 of n3) {
    let c3 = Ii$1(l3);
    if (c3.length === 0) {
      a3 += `bash: help: no help topics match \`${l3}'.  Try \`help help' or \`man -k ${l3}' or \`info ${l3}'.
`, o2 = true;
      continue;
    }
    for (let f3 of c3) {
      let [u3, d3] = Zn[f3];
      s3 ? i4 += `${f3}: ${u3}
` : i4 += `${f3}: ${u3}
${d3}
`;
    }
  }
  return { exitCode: o2 ? 1 : 0, stdout: i4, stderr: a3 };
}
function Ii$1(e5) {
  let t4 = e5.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*").replace(/\?/g, "."), s3 = new RegExp(`^${t4}$`);
  return qn$1.filter((n3) => s3.test(n3));
}
function Ti() {
  let e5 = [];
  e5.push("just-bash shell builtins"), e5.push("These shell commands are defined internally. Type `help' to see this list."), e5.push("Type `help name' to find out more about the function `name'."), e5.push("");
  let t4 = 36, s3 = qn$1.slice(), n3 = Math.ceil(s3.length / 2);
  for (let r2 = 0; r2 < n3; r2++) {
    let i4 = s3[r2] || "", o2 = s3[r2 + n3] || "", a3 = i4.padEnd(t4);
    e5.push(o2 ? `${a3}${o2}` : i4);
  }
  return F$a(`${e5.join(`
`)}
`);
}
function Ri(e5) {
  let t4 = [], s3 = "", n3 = 0;
  for (let r2 of e5) {
    for (let i4 of r2) i4 === "(" ? n3++ : i4 === ")" && n3--;
    s3 ? s3 += ` ${r2}` : s3 = r2, n3 === 0 && (t4.push(s3), s3 = "");
  }
  return s3 && t4.push(s3), t4;
}
async function _s$1(e5, t4) {
  if (t4.length === 0) return S$d(`bash: let: expression expected
`);
  let s3 = Ri(t4), n3 = 0;
  for (let r2 of s3) try {
    let o2 = ci$1(`(( ${r2} ))`).statements[0];
    if (o2 && o2.pipelines.length > 0 && o2.pipelines[0].commands.length > 0) {
      let a3 = o2.pipelines[0].commands[0];
      a3.type === "ArithmeticCommand" && (n3 = await R$a(e5, a3.expression.expression));
    }
  } catch (i4) {
    return S$d(`bash: let: ${r2}: ${i4.message}
`);
  }
  return P$f("", "", n3 === 0 ? 1 : 0);
}
async function Ns(e5, t4) {
  if (e5.state.localScopes.length === 0) return S$d(`bash: local: can only be used in a function
`);
  let s3 = e5.state.localScopes[e5.state.localScopes.length - 1], n3 = "", r2 = 0, i4 = false, o2 = false, l3 = [];
  for (let c3 of t4) if (c3 === "-n") i4 = true;
  else if (c3 === "-a") o2 = true;
  else if (c3 === "-p") ;
  else if (c3.startsWith("-") && !c3.includes("=")) for (let f3 of c3.slice(1)) f3 === "n" ? i4 = true : f3 === "a" ? o2 = true : f3 === "p" && true;
  else l3.push(c3);
  if (l3.length === 0) {
    let c3 = "", f3 = Array.from(s3.keys()).filter((u3) => !u3.includes("_") || !u3.match(/_\d+$/)).filter((u3) => !u3.includes("__length")).sort();
    for (let u3 of f3) {
      let d3 = e5.state.env[u3];
      d3 !== void 0 && (c3 += `${u3}=${d3}
`);
    }
    return P$f(c3, "", 0);
  }
  for (let c3 of l3) {
    let f3, u3, d3 = c3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\((.*)\)$/s);
    if (d3) {
      f3 = d3[1];
      let b4 = d3[2];
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(f3)) {
        n3 += `bash: local: \`${c3}': not a valid identifier
`, r2 = 1;
        continue;
      }
      if (aa(e5, f3, "bash"), !s3.has(f3)) {
        s3.set(f3, e5.state.env[f3]);
        let y2 = `${f3}_`;
        for (let g2 of Object.keys(e5.state.env)) g2.startsWith(y2) && !g2.includes("__") && (s3.has(g2) || s3.set(g2, e5.state.env[g2]));
      }
      let $5 = `${f3}_`;
      for (let y2 of Object.keys(e5.state.env)) y2.startsWith($5) && !y2.includes("__") && delete e5.state.env[y2];
      let C2 = ye$4(b4);
      for (let y2 = 0; y2 < C2.length; y2++) e5.state.env[`${f3}_${y2}`] = C2[y2];
      e5.state.env[`${f3}__length`] = String(C2.length), Oe$5(e5, f3), i4 && _i$2(e5, f3);
      continue;
    }
    let h3 = c3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=\((.*)\)$/s);
    if (h3) {
      f3 = h3[1];
      let b4 = h3[2];
      if (aa(e5, f3, "bash"), !s3.has(f3)) {
        s3.set(f3, e5.state.env[f3]);
        let v2 = `${f3}_`;
        for (let k3 of Object.keys(e5.state.env)) k3.startsWith(v2) && !k3.includes("__") && (s3.has(k3) || s3.set(k3, e5.state.env[k3]));
        let _4 = `${f3}__length`;
        e5.state.env[_4] !== void 0 && !s3.has(_4) && s3.set(_4, e5.state.env[_4]);
      }
      let $5 = ye$4(b4), C2 = pt$2(e5, f3), y2 = 0;
      if (C2.length === 0 && e5.state.env[f3] !== void 0) {
        let v2 = e5.state.env[f3];
        e5.state.env[`${f3}_0`] = v2, delete e5.state.env[f3], y2 = 1;
      } else C2.length > 0 && (y2 = Math.max(...C2) + 1);
      for (let v2 = 0; v2 < $5.length; v2++) e5.state.env[`${f3}_${y2 + v2}`] = H$d(e5, $5[v2]);
      let g2 = y2 + $5.length;
      e5.state.env[`${f3}__length`] = String(g2), Oe$5(e5, f3), i4 && _i$2(e5, f3);
      continue;
    }
    let m3 = c3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\+=(.*)$/);
    if (m3) {
      f3 = m3[1];
      let b4 = H$d(e5, m3[2]);
      aa(e5, f3, "bash"), s3.has(f3) || s3.set(f3, e5.state.env[f3]);
      let $5 = e5.state.env[f3] ?? "";
      e5.state.env[f3] = $5 + b4, Oe$5(e5, f3), i4 && _i$2(e5, f3);
      continue;
    }
    let p3 = c3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[([^\]]+)\]=(.*)$/s);
    if (p3) {
      f3 = p3[1];
      let b4 = p3[2], $5 = H$d(e5, p3[3]);
      if (aa(e5, f3, "bash"), !s3.has(f3)) {
        s3.set(f3, e5.state.env[f3]);
        let g2 = `${f3}_`;
        for (let _4 of Object.keys(e5.state.env)) _4.startsWith(g2) && !_4.includes("__") && (s3.has(_4) || s3.set(_4, e5.state.env[_4]));
        let v2 = `${f3}__length`;
        e5.state.env[v2] !== void 0 && !s3.has(v2) && s3.set(v2, e5.state.env[v2]);
      }
      let C2;
      try {
        let g2 = new T$9(), v2 = W$d(g2, b4);
        C2 = await R$a(e5, v2.expression);
      } catch {
        let g2 = parseInt(b4, 10);
        C2 = Number.isNaN(g2) ? 0 : g2;
      }
      e5.state.env[`${f3}_${C2}`] = $5;
      let y2 = parseInt(e5.state.env[`${f3}__length`] ?? "0", 10);
      C2 >= y2 && (e5.state.env[`${f3}__length`] = String(C2 + 1)), Oe$5(e5, f3), i4 && _i$2(e5, f3);
      continue;
    }
    if (c3.includes("=")) {
      let b4 = c3.indexOf("=");
      f3 = c3.slice(0, b4), u3 = H$d(e5, c3.slice(b4 + 1));
    } else f3 = c3;
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(f3)) {
      n3 += `bash: local: \`${c3}': not a valid identifier
`, r2 = 1;
      continue;
    }
    let w4 = s3.has(f3);
    if (u3 !== void 0) {
      let b4 = e5.state.env[f3];
      if (e5.state.tempEnvBindings) {
        let $5 = e5.state.accessedTempEnvVars?.has(f3), C2 = e5.state.mutatedTempEnvVars?.has(f3);
        if (!$5 && !C2) for (let y2 = e5.state.tempEnvBindings.length - 1; y2 >= 0; y2--) {
          let g2 = e5.state.tempEnvBindings[y2];
          if (g2.has(f3)) {
            b4 = g2.get(f3);
            break;
          }
        }
      }
      Dn$1(e5, f3, b4);
    }
    if (!w4) {
      let b4 = e5.state.env[f3];
      if (e5.state.tempEnvBindings) for (let $5 = e5.state.tempEnvBindings.length - 1; $5 >= 0; $5--) {
        let C2 = e5.state.tempEnvBindings[$5];
        if (C2.has(f3)) {
          b4 = C2.get(f3);
          break;
        }
      }
      if (s3.set(f3, b4), o2) {
        let $5 = `${f3}_`;
        for (let y2 of Object.keys(e5.state.env)) y2.startsWith($5) && !y2.includes("__") && (s3.has(y2) || s3.set(y2, e5.state.env[y2]));
        let C2 = `${f3}__length`;
        e5.state.env[C2] !== void 0 && !s3.has(C2) && s3.set(C2, e5.state.env[C2]);
      }
    }
    if (o2 && u3 === void 0) {
      let b4 = `${f3}_`;
      for (let $5 of Object.keys(e5.state.env)) $5.startsWith(b4) && !$5.includes("__") && delete e5.state.env[$5];
      e5.state.env[`${f3}__length`] = "0";
    } else if (u3 !== void 0) {
      if (aa(e5, f3, "bash"), i4 && u3 !== "" && !/^[a-zA-Z_][a-zA-Z0-9_]*(\[.+\])?$/.test(u3)) {
        n3 += `bash: local: \`${u3}': invalid variable name for name reference
`, r2 = 1;
        continue;
      }
      e5.state.env[f3] = u3, e5.state.options.allexport && (e5.state.exportedVars = e5.state.exportedVars || /* @__PURE__ */ new Set(), e5.state.exportedVars.add(f3));
    } else {
      let b4 = e5.state.tempEnvBindings?.some(($5) => $5.has(f3));
      !w4 && !b4 && delete e5.state.env[f3];
    }
    Oe$5(e5, f3), i4 && _i$2(e5, f3);
  }
  return P$f("", n3, r2);
}
function Cs$1(e5, t4, s3) {
  let n3 = `
`, r2 = 0, i4 = 0, o2 = 0, a3 = false, l3 = "MAPFILE", c3 = 0;
  for (; c3 < t4.length; ) {
    let b4 = t4[c3];
    b4 === "-d" && c3 + 1 < t4.length ? (n3 = t4[c3 + 1] === "" ? "\0" : t4[c3 + 1] || `
`, c3 += 2) : b4 === "-n" && c3 + 1 < t4.length ? (r2 = Number.parseInt(t4[c3 + 1], 10) || 0, c3 += 2) : b4 === "-O" && c3 + 1 < t4.length ? (i4 = Number.parseInt(t4[c3 + 1], 10) || 0, c3 += 2) : b4 === "-s" && c3 + 1 < t4.length ? (o2 = Number.parseInt(t4[c3 + 1], 10) || 0, c3 += 2) : b4 === "-t" ? (a3 = true, c3++) : b4 === "-u" || b4 === "-C" || b4 === "-c" ? c3 += 2 : (b4.startsWith("-") || (l3 = b4), c3++);
  }
  let f3 = s3;
  !f3 && e5.state.groupStdin !== void 0 && (f3 = e5.state.groupStdin);
  let u3 = [], d3 = f3, h3 = 0, m3 = 0;
  for (; d3.length > 0; ) {
    let b4 = d3.indexOf(n3);
    if (b4 === -1) {
      if (d3.length > 0) {
        if (m3 < o2) m3++;
        else if (r2 === 0 || h3 < r2) {
          let y2 = d3, g2 = y2.indexOf("\0");
          g2 !== -1 && (y2 = y2.substring(0, g2)), u3.push(y2), h3++;
        }
      }
      break;
    }
    let $5 = d3.substring(0, b4), C2 = $5.indexOf("\0");
    if (C2 !== -1 && ($5 = $5.substring(0, C2)), !a3 && n3 !== "\0" && ($5 += n3), d3 = d3.substring(b4 + n3.length), m3 < o2) {
      m3++;
      continue;
    }
    if (r2 > 0 && h3 >= r2) break;
    u3.push($5), h3++;
  }
  i4 === 0 && Ri$1(e5, l3);
  for (let b4 = 0; b4 < u3.length; b4++) e5.state.env[`${l3}_${i4 + b4}`] = u3[b4];
  let p3 = parseInt(e5.state.env[`${l3}__length`] || "0", 10), w4 = i4 + u3.length;
  return e5.state.env[`${l3}__length`] = String(Math.max(p3, w4)), e5.state.groupStdin !== void 0 && !s3 && (e5.state.groupStdin = ""), P$f("", "", 0);
}
function xi$1(e5) {
  if (!e5.startsWith("__rw__:")) return null;
  let t4 = e5.slice(7), s3 = t4.indexOf(":");
  if (s3 === -1) return null;
  let n3 = Number.parseInt(t4.slice(0, s3), 10);
  if (Number.isNaN(n3) || n3 < 0) return null;
  let r2 = s3 + 1, i4 = t4.slice(r2, r2 + n3), o2 = r2 + n3 + 1, a3 = t4.slice(o2), l3 = a3.indexOf(":");
  if (l3 === -1) return null;
  let c3 = Number.parseInt(a3.slice(0, l3), 10);
  if (Number.isNaN(c3) || c3 < 0) return null;
  let f3 = a3.slice(l3 + 1);
  return { path: i4, position: c3, content: f3 };
}
function Li$1(e5, t4, s3) {
  return `__rw__:${e5.length}:${e5}:${t4}:${s3}`;
}
function ks$1(e5, t4, s3, n3 = -1) {
  let r2 = false, i4 = `
`, a3 = -1, l3 = -1, c3 = null, f3 = -1, u3 = -1, d3 = [], h3 = 0, m3 = false, p3 = (A2, N2) => {
    let D3 = 1;
    for (; D3 < A2.length; ) {
      let E2 = A2[D3];
      if (E2 === "r") r2 = true, D3++;
      else if (E2 === "s") D3++;
      else {
        if (E2 === "d") return D3 + 1 < A2.length ? (i4 = A2.substring(D3 + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t4.length ? (i4 = t4[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
        if (E2 === "n") {
          if (D3 + 1 < A2.length) {
            let O2 = A2.substring(D3 + 1);
            return a3 = Number.parseInt(O2, 10), (Number.isNaN(a3) || a3 < 0) && (m3 = true, a3 = 0), { nextArgIndex: N2 + 1 };
          } else if (N2 + 1 < t4.length) return a3 = Number.parseInt(t4[N2 + 1], 10), (Number.isNaN(a3) || a3 < 0) && (m3 = true, a3 = 0), { nextArgIndex: N2 + 2 };
          return { nextArgIndex: N2 + 1 };
        } else if (E2 === "N") {
          if (D3 + 1 < A2.length) {
            let O2 = A2.substring(D3 + 1);
            return l3 = Number.parseInt(O2, 10), (Number.isNaN(l3) || l3 < 0) && (m3 = true, l3 = 0), { nextArgIndex: N2 + 1 };
          } else if (N2 + 1 < t4.length) return l3 = Number.parseInt(t4[N2 + 1], 10), (Number.isNaN(l3) || l3 < 0) && (m3 = true, l3 = 0), { nextArgIndex: N2 + 2 };
          return { nextArgIndex: N2 + 1 };
        } else {
          if (E2 === "a") return D3 + 1 < A2.length ? (c3 = A2.substring(D3 + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t4.length ? (c3 = t4[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
          if (E2 === "p") return D3 + 1 < A2.length ? (A2.substring(D3 + 1), { nextArgIndex: N2 + 1 }) : N2 + 1 < t4.length ? (t4[N2 + 1], { nextArgIndex: N2 + 2 }) : { nextArgIndex: N2 + 1 };
          if (E2 === "u") {
            if (D3 + 1 < A2.length) {
              let O2 = A2.substring(D3 + 1);
              return f3 = Number.parseInt(O2, 10), Number.isNaN(f3) || f3 < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N2 + 1 };
            } else if (N2 + 1 < t4.length) return f3 = Number.parseInt(t4[N2 + 1], 10), Number.isNaN(f3) || f3 < 0 ? { nextArgIndex: -2 } : { nextArgIndex: N2 + 2 };
            return { nextArgIndex: N2 + 1 };
          } else if (E2 === "t") {
            if (D3 + 1 < A2.length) {
              let O2 = A2.substring(D3 + 1);
              return u3 = Number.parseFloat(O2), Number.isNaN(u3) && (u3 = 0), { nextArgIndex: N2 + 1 };
            } else if (N2 + 1 < t4.length) return u3 = Number.parseFloat(t4[N2 + 1]), Number.isNaN(u3) && (u3 = 0), { nextArgIndex: N2 + 2 };
            return { nextArgIndex: N2 + 1 };
          } else if (E2 === "e" || E2 === "i" || E2 === "P") {
            if (E2 === "i" && N2 + 1 < t4.length) return { nextArgIndex: N2 + 2 };
            D3++;
          } else D3++;
        }
      }
    }
    return { nextArgIndex: N2 + 1 };
  };
  for (; h3 < t4.length; ) {
    let A2 = t4[h3];
    if (A2.startsWith("-") && A2.length > 1 && A2 !== "--") {
      let N2 = p3(A2, h3);
      if (N2.nextArgIndex === -1) return { stdout: "", stderr: "", exitCode: 2 };
      if (N2.nextArgIndex === -2) return { stdout: "", stderr: "", exitCode: 1 };
      h3 = N2.nextArgIndex;
    } else if (A2 === "--") for (h3++; h3 < t4.length; ) d3.push(t4[h3]), h3++;
    else d3.push(A2), h3++;
  }
  if (m3) return P$f("", "", 1);
  if (d3.length === 0 && c3 === null && d3.push("REPLY"), u3 === 0) {
    if (c3) Ri$1(e5, c3);
    else {
      for (let A2 of d3) e5.state.env[A2] = "";
      d3.length === 0 && (e5.state.env.REPLY = "");
    }
    return P$f("", "", 0);
  }
  if (u3 < 0 && u3 !== -1) return P$f("", "", 1);
  let w4 = s3;
  f3 >= 0 ? e5.state.fileDescriptors ? w4 = e5.state.fileDescriptors.get(f3) || "" : w4 = "" : !w4 && e5.state.groupStdin !== void 0 && (w4 = e5.state.groupStdin);
  let b4 = i4 === "" ? "\0" : i4, $5 = "", C2 = 0, y2 = true, g2 = (A2) => {
    if (f3 >= 0 && e5.state.fileDescriptors) e5.state.fileDescriptors.set(f3, w4.substring(A2));
    else if (n3 >= 0 && e5.state.fileDescriptors) {
      let N2 = e5.state.fileDescriptors.get(n3);
      if (N2?.startsWith("__rw__:")) {
        let D3 = xi$1(N2);
        if (D3) {
          let E2 = D3.position + A2;
          e5.state.fileDescriptors.set(n3, Li$1(D3.path, E2, D3.content));
        }
      }
    } else e5.state.groupStdin !== void 0 && !s3 && (e5.state.groupStdin = w4.substring(A2));
  };
  if (l3 >= 0) {
    let A2 = Math.min(l3, w4.length);
    $5 = w4.substring(0, A2), C2 = A2, y2 = A2 >= l3, g2(C2);
    let N2 = d3[0] || "REPLY";
    e5.state.env[N2] = $5;
    for (let D3 = 1; D3 < d3.length; D3++) e5.state.env[d3[D3]] = "";
    return P$f("", "", y2 ? 0 : 1);
  } else if (a3 >= 0) {
    let A2 = 0, N2 = 0, D3 = false;
    for (; N2 < w4.length && A2 < a3; ) {
      let E2 = w4[N2];
      if (E2 === b4) {
        C2 = N2 + 1, D3 = true;
        break;
      }
      if (!r2 && E2 === "\\" && N2 + 1 < w4.length) {
        let O2 = w4[N2 + 1];
        if (O2 === b4 && b4 === `
`) {
          N2 += 2, C2 = N2;
          continue;
        }
        if (O2 === b4) {
          N2 += 2, A2++, $5 += O2, C2 = N2;
          continue;
        }
        $5 += O2, N2 += 2, A2++, C2 = N2;
      } else $5 += E2, N2++, A2++, C2 = N2;
    }
    y2 = A2 >= a3 || D3, g2(C2);
  } else {
    C2 = 0;
    let A2 = 0;
    for (; A2 < w4.length; ) {
      let N2 = w4[A2];
      if (N2 === b4) {
        C2 = A2 + b4.length, y2 = true;
        break;
      }
      if (!r2 && N2 === "\\" && A2 + 1 < w4.length) {
        let D3 = w4[A2 + 1];
        if (D3 === `
`) {
          A2 += 2;
          continue;
        }
        if (D3 === b4) {
          $5 += D3, A2 += 2;
          continue;
        }
        $5 += N2, $5 += D3, A2 += 2;
        continue;
      }
      $5 += N2, A2++;
    }
    if (A2 >= w4.length && (y2 = false, C2 = A2, $5.length === 0 && w4.length === 0)) {
      for (let N2 of d3) e5.state.env[N2] = "";
      return c3 && Ri$1(e5, c3), P$f("", "", 1);
    }
    g2(C2);
  }
  b4 === `
` && $5.endsWith(`
`) && ($5 = $5.slice(0, -1));
  let v2 = (A2) => r2 ? A2 : A2.replace(/\\(.)/g, "$1");
  if (d3.length === 1 && d3[0] === "REPLY") return e5.state.env.REPLY = v2($5), P$f("", "", y2 ? 0 : 1);
  let _4 = O$e(e5.state.env);
  if (c3) {
    let { words: A2 } = Di$1($5, _4, void 0, r2);
    Ri$1(e5, c3);
    for (let N2 = 0; N2 < A2.length; N2++) e5.state.env[`${c3}_${N2}`] = v2(A2[N2]);
    return P$f("", "", y2 ? 0 : 1);
  }
  let k3 = d3.length, { words: T3, wordStarts: R2 } = Di$1($5, _4, k3, r2);
  for (let A2 = 0; A2 < d3.length; A2++) {
    let N2 = d3[A2];
    if (A2 < d3.length - 1) e5.state.env[N2] = v2(T3[A2] ?? "");
    else if (A2 < R2.length) {
      let D3 = $5.substring(R2[A2]);
      D3 = xi$2(D3, _4, r2), D3 = v2(D3), e5.state.env[N2] = D3;
    } else e5.state.env[N2] = "";
  }
  return P$f("", "", y2 ? 0 : 1);
}
function Os$1(e5, t4) {
  if (e5.state.callDepth === 0 && e5.state.sourceDepth === 0) return S$d("bash: return: can only `return' from a function or sourced script\n");
  let s3 = e5.state.lastExitCode;
  if (t4.length > 0) {
    let n3 = t4[0], r2 = Number.parseInt(n3, 10);
    if (n3 === "" || Number.isNaN(r2) || !/^-?\d+$/.test(n3)) return S$d(`bash: return: ${n3}: numeric argument required
`, 2);
    s3 = (r2 % 256 + 256) % 256;
  }
  throw new i$6(s3);
}
var Dt = `set: usage: set [-eux] [+eux] [-o option] [+o option]
Options:
  -e            Exit immediately if a command exits with non-zero status
  +e            Disable -e
  -u            Treat unset variables as an error when substituting
  +u            Disable -u
  -x            Print commands and their arguments as they are executed
  +x            Disable -x
  -o errexit    Same as -e
  +o errexit    Disable errexit
  -o nounset    Same as -u
  +o nounset    Disable nounset
  -o pipefail   Return status of last failing command in pipeline
  +o pipefail   Disable pipefail
  -o xtrace     Same as -x
  +o xtrace     Disable xtrace
`, Gn = { e: "errexit", u: "nounset", x: "xtrace", v: "verbose", f: "noglob", C: "noclobber", a: "allexport", n: "noexec", h: null, b: null, m: null, B: null, H: null, P: null, T: null, E: null, p: null }, Kn = { errexit: "errexit", pipefail: "pipefail", nounset: "nounset", xtrace: "xtrace", verbose: "verbose", noclobber: "noclobber", noglob: "noglob", allexport: "allexport", noexec: "noexec", posix: "posix", vi: "vi", emacs: "emacs", notify: null, monitor: null, braceexpand: null, histexpand: null, physical: null, functrace: null, errtrace: null, privileged: null, hashall: null, ignoreeof: null, "interactive-comments": null, keyword: null, onecmd: null }, Xn = ["errexit", "nounset", "pipefail", "verbose", "xtrace", "posix", "allexport", "noclobber", "noglob", "noexec", "vi", "emacs"], Yn = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"];
function Qn(e5, t4, s3) {
  t4 !== null && (s3 && (t4 === "vi" ? e5.state.options.emacs = false : t4 === "emacs" && (e5.state.options.vi = false)), e5.state.options[t4] = s3, Le$4(e5));
}
function Fi$1(e5, t4) {
  return t4 + 1 < e5.length && !e5[t4 + 1].startsWith("-") && !e5[t4 + 1].startsWith("+");
}
function Wi$1(e5, t4) {
  let s3 = pt$2(e5, t4);
  if (s3.length === 0) return `${t4}=()`;
  let n3 = s3.map((r2) => {
    let i4 = e5.state.env[`${t4}_${r2}`] ?? "";
    return `[${r2}]=${Re$2(i4)}`;
  });
  return `${t4}=(${n3.join(" ")})`;
}
function Mi$1(e5) {
  return /^[a-zA-Z0-9_]+$/.test(e5) ? e5 : `"${e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"')}"`;
}
function zi(e5, t4) {
  let s3 = ht$4(e5, t4);
  if (s3.length === 0) return `${t4}=()`;
  let n3 = s3.map((r2) => {
    let i4 = e5.state.env[`${t4}_${r2}`] ?? "";
    return `[${Mi$1(r2)}]=${Re$2(i4)}`;
  });
  return `${t4}=(${n3.join(" ")} )`;
}
function Vi(e5) {
  let t4 = /* @__PURE__ */ new Set(), s3 = e5.state.associativeArrays ?? /* @__PURE__ */ new Set();
  for (let n3 of Object.keys(e5.state.env)) {
    let r2 = n3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
    if (r2) {
      let i4 = r2[1];
      s3.has(i4) || t4.add(i4);
    }
  }
  return t4;
}
function Bi$1(e5) {
  return e5.state.associativeArrays ?? /* @__PURE__ */ new Set();
}
function Is$1(e5, t4) {
  if (t4.includes("--help")) return F$a(Dt);
  if (t4.length === 0) {
    let n3 = Vi(e5), r2 = Bi$1(e5), i4 = (l3) => {
      for (let c3 of r2) {
        let f3 = `${c3}_`, u3 = `${c3}__length`;
        if (l3 !== u3 && l3.startsWith(f3)) {
          if (l3.slice(f3.length).startsWith("_length")) continue;
          return true;
        }
      }
      return false;
    }, o2 = [];
    for (let [l3, c3] of Object.entries(e5.state.env)) {
      if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(l3) || n3.has(l3) || r2.has(l3)) continue;
      let f3 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)_(\d+)$/);
      if (f3 && n3.has(f3[1])) continue;
      let u3 = l3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)__length$/);
      u3 && n3.has(u3[1]) || i4(l3) || u3 && r2.has(u3[1]) || o2.push([l3, c3]);
    }
    let a3 = [];
    for (let [l3, c3] of o2.sort(([f3], [u3]) => f3 < u3 ? -1 : f3 > u3 ? 1 : 0)) a3.push(`${l3}=${Ct(c3)}`);
    for (let l3 of [...n3].sort((c3, f3) => c3 < f3 ? -1 : c3 > f3 ? 1 : 0)) a3.push(Wi$1(e5, l3));
    for (let l3 of [...r2].sort((c3, f3) => c3 < f3 ? -1 : c3 > f3 ? 1 : 0)) a3.push(zi(e5, l3));
    return a3.sort((l3, c3) => {
      let f3 = l3.split("=")[0], u3 = c3.split("=")[0];
      return f3 < u3 ? -1 : f3 > u3 ? 1 : 0;
    }), F$a(a3.length > 0 ? `${a3.join(`
`)}
` : "");
  }
  let s3 = 0;
  for (; s3 < t4.length; ) {
    let n3 = t4[s3];
    if ((n3 === "-o" || n3 === "+o") && Fi$1(t4, s3)) {
      let r2 = t4[s3 + 1];
      if (!(r2 in Kn)) {
        let i4 = `bash: set: ${r2}: invalid option name
${Dt}`;
        if (e5.state.options.posix) throw new f$7(1, "", i4);
        return S$d(i4);
      }
      Qn(e5, Kn[r2], n3 === "-o"), s3 += 2;
      continue;
    }
    if (n3 === "-o") {
      let r2 = Xn.map((a3) => `${a3.padEnd(16)}${e5.state.options[a3] ? "on" : "off"}`), i4 = Yn.map((a3) => `${a3.padEnd(16)}off`), o2 = [...r2, ...i4].sort();
      return F$a(`${o2.join(`
`)}
`);
    }
    if (n3 === "+o") {
      let r2 = Xn.map((a3) => `set ${e5.state.options[a3] ? "-o" : "+o"} ${a3}`), i4 = Yn.map((a3) => `set +o ${a3}`), o2 = [...r2, ...i4].sort();
      return F$a(`${o2.join(`
`)}
`);
    }
    if (n3.length > 1 && (n3[0] === "-" || n3[0] === "+") && n3[1] !== "-") {
      let r2 = n3[0] === "-";
      for (let i4 = 1; i4 < n3.length; i4++) {
        let o2 = n3[i4];
        if (!(o2 in Gn)) {
          let a3 = `bash: set: ${n3[0]}${o2}: invalid option
${Dt}`;
          if (e5.state.options.posix) throw new f$7(1, "", a3);
          return S$d(a3);
        }
        Qn(e5, Gn[o2], r2);
      }
      s3++;
      continue;
    }
    if (n3 === "--") return Ds(e5, t4.slice(s3 + 1)), L$d;
    if (n3 === "-") {
      if (e5.state.options.xtrace = false, e5.state.options.verbose = false, Le$4(e5), s3 + 1 < t4.length) return Ds(e5, t4.slice(s3 + 1)), L$d;
      s3++;
      continue;
    }
    if (n3 === "+") {
      s3++;
      continue;
    }
    if (n3.startsWith("-") || n3.startsWith("+")) {
      let r2 = `bash: set: ${n3}: invalid option
${Dt}`;
      if (e5.state.options.posix) throw new f$7(1, "", r2);
      return S$d(r2);
    }
    return Ds(e5, t4.slice(s3)), L$d;
  }
  return L$d;
}
function Ds(e5, t4) {
  let s3 = 1;
  for (; e5.state.env[String(s3)] !== void 0; ) delete e5.state.env[String(s3)], s3++;
  for (let n3 = 0; n3 < t4.length; n3++) e5.state.env[String(n3 + 1)] = t4[n3];
  e5.state.env["#"] = String(t4.length), e5.state.env["@"] = t4.join(" "), e5.state.env["*"] = t4.join(" ");
}
function Ts(e5, t4) {
  let s3 = 1;
  if (t4.length > 0) {
    let o2 = Number.parseInt(t4[0], 10);
    if (Number.isNaN(o2) || o2 < 0) {
      let a3 = `bash: shift: ${t4[0]}: numeric argument required
`;
      if (e5.state.options.posix) throw new f$7(1, "", a3);
      return S$d(a3);
    }
    s3 = o2;
  }
  let n3 = Number.parseInt(e5.state.env["#"] || "0", 10);
  if (s3 > n3) {
    let o2 = `bash: shift: shift count out of range
`;
    if (e5.state.options.posix) throw new f$7(1, "", o2);
    return S$d(o2);
  }
  if (s3 === 0) return L$d;
  let r2 = [];
  for (let o2 = 1; o2 <= n3; o2++) r2.push(e5.state.env[String(o2)] || "");
  let i4 = r2.slice(s3);
  for (let o2 = 1; o2 <= n3; o2++) delete e5.state.env[String(o2)];
  for (let o2 = 0; o2 < i4.length; o2++) e5.state.env[String(o2 + 1)] = i4[o2];
  return e5.state.env["#"] = String(i4.length), e5.state.env["@"] = i4.join(" "), L$d;
}
async function Rs$1(e5, t4) {
  let s3 = t4;
  if (s3.length > 0 && s3[0] === "--" && (s3 = s3.slice(1)), s3.length === 0) return P$f("", `bash: source: filename argument required
`, 2);
  let n3 = s3[0], r2 = null, i4 = null;
  if (n3.includes("/")) {
    let c3 = e5.fs.resolvePath(e5.state.cwd, n3);
    try {
      i4 = await e5.fs.readFile(c3), r2 = c3;
    } catch {
    }
  } else {
    let f3 = (e5.state.env.PATH || "").split(":").filter((u3) => u3);
    for (let u3 of f3) {
      let d3 = e5.fs.resolvePath(e5.state.cwd, `${u3}/${n3}`);
      try {
        if ((await e5.fs.stat(d3)).isDirectory) continue;
        i4 = await e5.fs.readFile(d3), r2 = d3;
        break;
      } catch {
      }
    }
    if (i4 === null) {
      let u3 = e5.fs.resolvePath(e5.state.cwd, n3);
      try {
        i4 = await e5.fs.readFile(u3), r2 = u3;
      } catch {
      }
    }
  }
  if (i4 === null) return S$d(`bash: ${n3}: No such file or directory
`);
  let o2 = {};
  if (s3.length > 1) {
    for (let f3 = 1; f3 <= 9; f3++) o2[String(f3)] = e5.state.env[String(f3)];
    o2["#"] = e5.state.env["#"], o2["@"] = e5.state.env["@"];
    let c3 = s3.slice(1);
    e5.state.env["#"] = String(c3.length), e5.state.env["@"] = c3.join(" ");
    for (let f3 = 0; f3 < c3.length && f3 < 9; f3++) e5.state.env[String(f3 + 1)] = c3[f3];
    for (let f3 = c3.length + 1; f3 <= 9; f3++) delete e5.state.env[String(f3)];
  }
  let a3 = e5.state.currentSource, l3 = () => {
    if (e5.state.sourceDepth--, e5.state.currentSource = a3, s3.length > 1) for (let [c3, f3] of Object.entries(o2)) f3 === void 0 ? delete e5.state.env[c3] : e5.state.env[c3] = f3;
  };
  e5.state.sourceDepth++, e5.state.currentSource = n3;
  try {
    let c3 = ci$1(i4), f3 = await e5.executeScript(c3);
    return l3(), f3;
  } catch (c3) {
    if (l3(), c3 instanceof d$8) throw c3;
    if (c3 instanceof i$6) return P$f(c3.stdout, c3.stderr, c3.exitCode);
    if (c3.name === "ParseException") return S$d(`bash: ${n3}: ${c3.message}
`);
    throw c3;
  }
}
function Jn$1(e5) {
  return /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(e5);
}
function ji(e5) {
  return e5.startsWith("'") && e5.endsWith("'") || e5.startsWith('"') && e5.endsWith('"');
}
async function er(e5, t4) {
  if (ji(t4)) return null;
  try {
    let s3 = new T$9(), n3 = W$d(s3, t4);
    return await R$a(e5, n3.expression);
  } catch {
    let s3 = parseInt(t4, 10);
    return Number.isNaN(s3) ? 0 : s3;
  }
}
function tr(e5, t4) {
  if (e5.state.localVarStack?.has(t4)) {
    let n3 = Pt$1(e5, t4);
    if (n3) {
      n3.value === void 0 ? delete e5.state.env[t4] : e5.state.env[t4] = n3.value;
      let r2 = e5.state.localVarStack?.get(t4);
      if (!r2 || r2.length === 0) At$3(e5, t4), e5.state.localVarStack?.delete(t4), e5.state.fullyUnsetLocals = e5.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e5.state.fullyUnsetLocals.set(t4, n3.scopeIndex), xs$1(e5, t4);
      else {
        let i4 = r2[r2.length - 1];
        e5.state.localVarDepth = e5.state.localVarDepth || /* @__PURE__ */ new Map(), e5.state.localVarDepth.set(t4, i4.scopeIndex + 1);
      }
      return true;
    }
    return delete e5.state.env[t4], At$3(e5, t4), e5.state.localVarStack?.delete(t4), e5.state.fullyUnsetLocals = e5.state.fullyUnsetLocals || /* @__PURE__ */ new Map(), e5.state.fullyUnsetLocals.set(t4, 0), true;
  }
  for (let n3 = e5.state.localScopes.length - 1; n3 >= 0; n3--) {
    let r2 = e5.state.localScopes[n3];
    if (r2.has(t4)) {
      let i4 = r2.get(t4);
      i4 === void 0 ? delete e5.state.env[t4] : e5.state.env[t4] = i4, r2.delete(t4);
      let o2 = false;
      for (let a3 = n3 - 1; a3 >= 0; a3--) if (e5.state.localScopes[a3].has(t4)) {
        e5.state.localVarDepth && e5.state.localVarDepth.set(t4, a3 + 1), o2 = true;
        break;
      }
      return o2 || At$3(e5, t4), true;
    }
  }
  return false;
}
function xs$1(e5, t4) {
  if (!e5.state.tempEnvBindings || e5.state.tempEnvBindings.length === 0) return false;
  for (let s3 = e5.state.tempEnvBindings.length - 1; s3 >= 0; s3--) {
    let n3 = e5.state.tempEnvBindings[s3];
    if (n3.has(t4)) {
      let r2 = n3.get(t4);
      return r2 === void 0 ? delete e5.state.env[t4] : e5.state.env[t4] = r2, n3.delete(t4), true;
    }
  }
  return false;
}
async function sr(e5, t4) {
  if (t4.startsWith("'") && t4.endsWith("'")) return t4.slice(1, -1);
  if (t4.startsWith('"') && t4.endsWith('"')) {
    let s3 = t4.slice(1, -1), r2 = new T$9().parseWordFromString(s3, true, false);
    return wt$5(e5, r2);
  }
  if (t4.includes("$")) {
    let n3 = new T$9().parseWordFromString(t4, false, false);
    return wt$5(e5, n3);
  }
  return t4;
}
async function Ls$1(e5, t4) {
  let s3 = "both", n3 = "", r2 = 0;
  for (let i4 of t4) {
    if (i4 === "-v") {
      s3 = "variable";
      continue;
    }
    if (i4 === "-f") {
      s3 = "function";
      continue;
    }
    if (s3 === "function") {
      e5.state.functions.delete(i4);
      continue;
    }
    if (s3 === "variable") {
      let c3 = i4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
      if (c3) {
        let d3 = c3[1], h3 = c3[2];
        if (h3 === "@" || h3 === "*") {
          let C2 = P$g(e5, d3);
          for (let [y2] of C2) delete e5.state.env[`${d3}_${y2}`];
          delete e5.state.env[d3];
          continue;
        }
        let m3 = e5.state.associativeArrays?.has(d3);
        if (m3) {
          let C2 = await sr(e5, h3);
          delete e5.state.env[`${d3}_${C2}`];
          continue;
        }
        let p3 = ye$5(e5, d3), w4 = e5.state.declaredVars?.has(d3);
        if ((d3 in e5.state.env || w4) && !p3 && !m3) {
          n3 += `bash: unset: ${d3}: not an array variable
`, r2 = 1;
          continue;
        }
        let $5 = await er(e5, h3);
        if ($5 === null && p3) {
          n3 += `bash: unset: ${h3}: not a valid identifier
`, r2 = 1;
          continue;
        }
        if ($5 === null) continue;
        if ($5 < 0) {
          let C2 = P$g(e5, d3), y2 = C2.length, g2 = e5.state.currentLine;
          if (y2 === 0) {
            n3 += `bash: line ${g2}: unset: [${$5}]: bad array subscript
`, r2 = 1;
            continue;
          }
          let v2 = y2 + $5;
          if (v2 < 0) {
            n3 += `bash: line ${g2}: unset: [${$5}]: bad array subscript
`, r2 = 1;
            continue;
          }
          let _4 = C2[v2][0];
          delete e5.state.env[`${d3}_${_4}`];
          continue;
        }
        delete e5.state.env[`${d3}_${$5}`];
        continue;
      }
      if (!Jn$1(i4)) {
        n3 += `bash: unset: \`${i4}': not a valid identifier
`, r2 = 1;
        continue;
      }
      let f3 = i4;
      if (C$g(e5, i4)) {
        let d3 = le$8(e5, i4);
        d3 && d3 !== i4 && (f3 = d3);
      }
      if (At$4(e5, f3)) {
        n3 += `bash: unset: ${f3}: cannot unset: readonly variable
`, r2 = 1;
        continue;
      }
      let u3 = We$5(e5, f3);
      if (u3 !== void 0 && u3 !== e5.state.callDepth) tr(e5, f3);
      else if (e5.state.fullyUnsetLocals?.has(f3)) delete e5.state.env[f3];
      else if (u3 !== void 0) {
        let d3 = e5.state.accessedTempEnvVars?.has(f3), h3 = e5.state.mutatedTempEnvVars?.has(f3);
        if ((d3 || h3) && e5.state.localVarStack?.has(f3)) {
          let m3 = Pt$1(e5, f3);
          m3 ? m3.value === void 0 ? delete e5.state.env[f3] : e5.state.env[f3] = m3.value : delete e5.state.env[f3];
        } else delete e5.state.env[f3];
      } else xs$1(e5, f3) || delete e5.state.env[f3];
      e5.state.exportedVars?.delete(f3);
      continue;
    }
    let o2 = i4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (o2) {
      let c3 = o2[1], f3 = o2[2];
      if (f3 === "@" || f3 === "*") {
        let p3 = P$g(e5, c3);
        for (let [w4] of p3) delete e5.state.env[`${c3}_${w4}`];
        delete e5.state.env[c3];
        continue;
      }
      let u3 = e5.state.associativeArrays?.has(c3);
      if (u3) {
        let p3 = await sr(e5, f3);
        delete e5.state.env[`${c3}_${p3}`];
        continue;
      }
      let d3 = ye$5(e5, c3);
      if (c3 in e5.state.env && !d3 && !u3) {
        n3 += `bash: unset: ${c3}: not an array variable
`, r2 = 1;
        continue;
      }
      let m3 = await er(e5, f3);
      if (m3 === null && d3) {
        n3 += `bash: unset: ${f3}: not a valid identifier
`, r2 = 1;
        continue;
      }
      if (m3 === null) continue;
      if (m3 < 0) {
        let p3 = P$g(e5, c3), w4 = p3.length, b4 = e5.state.currentLine;
        if (w4 === 0) {
          n3 += `bash: line ${b4}: unset: [${m3}]: bad array subscript
`, r2 = 1;
          continue;
        }
        let $5 = w4 + m3;
        if ($5 < 0) {
          n3 += `bash: line ${b4}: unset: [${m3}]: bad array subscript
`, r2 = 1;
          continue;
        }
        let C2 = p3[$5][0];
        delete e5.state.env[`${c3}_${C2}`];
        continue;
      }
      delete e5.state.env[`${c3}_${m3}`];
      continue;
    }
    if (!Jn$1(i4)) {
      n3 += `bash: unset: \`${i4}': not a valid identifier
`, r2 = 1;
      continue;
    }
    let a3 = i4;
    if (C$g(e5, i4)) {
      let c3 = le$8(e5, i4);
      c3 && c3 !== i4 && (a3 = c3);
    }
    if (At$4(e5, a3)) {
      n3 += `bash: unset: ${a3}: cannot unset: readonly variable
`, r2 = 1;
      continue;
    }
    let l3 = We$5(e5, a3);
    if (l3 !== void 0 && l3 !== e5.state.callDepth) tr(e5, a3);
    else if (e5.state.fullyUnsetLocals?.has(a3)) delete e5.state.env[a3];
    else if (l3 !== void 0) {
      let c3 = e5.state.accessedTempEnvVars?.has(a3), f3 = e5.state.mutatedTempEnvVars?.has(a3);
      if ((c3 || f3) && e5.state.localVarStack?.has(a3)) {
        let u3 = Pt$1(e5, a3);
        u3 ? u3.value === void 0 ? delete e5.state.env[a3] : e5.state.env[a3] = u3.value : delete e5.state.env[a3];
      } else delete e5.state.env[a3];
    } else xs$1(e5, a3) || delete e5.state.env[a3];
    e5.state.exportedVars?.delete(a3), e5.state.functions.delete(i4);
  }
  return P$f("", n3, r2);
}
var Fs = ["extglob", "dotglob", "nullglob", "failglob", "globstar", "globskipdots", "nocaseglob", "nocasematch", "expand_aliases", "lastpipe", "xpg_echo"], Hi$1 = ["autocd", "cdable_vars", "cdspell", "checkhash", "checkjobs", "checkwinsize", "cmdhist", "compat31", "compat32", "compat40", "compat41", "compat42", "compat43", "compat44", "complete_fullquote", "direxpand", "dirspell", "execfail", "extdebug", "extquote", "force_fignore", "globasciiranges", "gnu_errfmt", "histappend", "histreedit", "histverify", "hostcomplete", "huponexit", "inherit_errexit", "interactive_comments", "lithist", "localvar_inherit", "localvar_unset", "login_shell", "mailwarn", "no_empty_cmd_completion", "progcomp", "progcomp_alias", "promptvars", "restricted_shell", "shift_verbose", "sourcepath"];
function It$1(e5) {
  return Fs.includes(e5);
}
function Ui$1(e5) {
  return Hi$1.includes(e5);
}
function nr(e5, t4) {
  let s3 = false, n3 = false, r2 = false, i4 = false, o2 = false, a3 = [], l3 = 0;
  for (; l3 < t4.length; ) {
    let d3 = t4[l3];
    if (d3 === "--") {
      l3++;
      break;
    }
    if (d3.startsWith("-") && d3.length > 1) {
      for (let h3 = 1; h3 < d3.length; h3++) {
        let m3 = d3[h3];
        switch (m3) {
          case "s":
            s3 = true;
            break;
          case "u":
            n3 = true;
            break;
          case "p":
            r2 = true;
            break;
          case "q":
            i4 = true;
            break;
          case "o":
            o2 = true;
            break;
          default:
            return { exitCode: 2, stdout: "", stderr: `shopt: -${m3}: invalid option
` };
        }
      }
      l3++;
    } else break;
  }
  for (; l3 < t4.length; ) a3.push(t4[l3]), l3++;
  if (o2) return Zi(e5, a3, s3, n3, r2, i4);
  if (s3 && n3) return { exitCode: 1, stdout: "", stderr: `shopt: cannot set and unset shell options simultaneously
` };
  if (a3.length === 0) {
    if (s3 || n3) {
      let h3 = [];
      for (let m3 of Fs) {
        let p3 = e5.state.shoptOptions[m3];
        s3 && p3 ? h3.push(r2 ? `shopt -s ${m3}` : `${m3}		on`) : n3 && !p3 && h3.push(r2 ? `shopt -u ${m3}` : `${m3}		off`);
      }
      return { exitCode: 0, stdout: h3.length > 0 ? `${h3.join(`
`)}
` : "", stderr: "" };
    }
    let d3 = [];
    for (let h3 of Fs) {
      let m3 = e5.state.shoptOptions[h3];
      d3.push(r2 ? `shopt ${m3 ? "-s" : "-u"} ${h3}` : `${h3}		${m3 ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: `${d3.join(`
`)}
`, stderr: "" };
  }
  let c3 = false, f3 = "", u3 = [];
  for (let d3 of a3) {
    if (!It$1(d3) && !Ui$1(d3)) {
      f3 += `shopt: ${d3}: invalid shell option name
`, c3 = true;
      continue;
    }
    if (s3) It$1(d3) && (e5.state.shoptOptions[d3] = true, qt(e5));
    else if (n3) It$1(d3) && (e5.state.shoptOptions[d3] = false, qt(e5));
    else if (It$1(d3)) {
      let h3 = e5.state.shoptOptions[d3];
      i4 ? h3 || (c3 = true) : r2 ? (u3.push(`shopt ${h3 ? "-s" : "-u"} ${d3}`), h3 || (c3 = true)) : (u3.push(`${d3}		${h3 ? "on" : "off"}`), h3 || (c3 = true));
    } else i4 ? c3 = true : r2 ? (u3.push(`shopt -u ${d3}`), c3 = true) : (u3.push(`${d3}		off`), c3 = true);
  }
  return { exitCode: c3 ? 1 : 0, stdout: u3.length > 0 ? `${u3.join(`
`)}
` : "", stderr: f3 };
}
function Zi(e5, t4, s3, n3, r2, i4) {
  let o2 = { errexit: "errexit", pipefail: "pipefail", nounset: "nounset", xtrace: "xtrace", verbose: "verbose", posix: "posix", allexport: "allexport", noclobber: "noclobber", noglob: "noglob", noexec: "noexec", vi: "vi", emacs: "emacs" }, a3 = ["braceexpand", "errtrace", "functrace", "hashall", "histexpand", "history", "ignoreeof", "interactive-comments", "keyword", "monitor", "nolog", "notify", "onecmd", "physical", "privileged"], l3 = [...Object.keys(o2), ...a3].sort();
  if (t4.length === 0) {
    let d3 = [];
    for (let h3 of l3) {
      let p3 = a3.includes(h3) ? false : e5.state.options[o2[h3]];
      s3 && !p3 || n3 && p3 || d3.push(r2 ? `set ${p3 ? "-o" : "+o"} ${h3}` : `${h3}		${p3 ? "on" : "off"}`);
    }
    return { exitCode: 0, stdout: d3.length > 0 ? `${d3.join(`
`)}
` : "", stderr: "" };
  }
  let c3 = false, f3 = "", u3 = [];
  for (let d3 of t4) {
    let h3 = d3 in o2, m3 = a3.includes(d3);
    if (!h3 && !m3) {
      f3 += `shopt: ${d3}: invalid option name
`, c3 = true;
      continue;
    }
    if (m3) {
      s3 || n3 || (i4 ? c3 = true : r2 ? (u3.push(`set +o ${d3}`), c3 = true) : (u3.push(`${d3}		off`), c3 = true));
      continue;
    }
    let p3 = o2[d3];
    if (s3) p3 === "vi" ? e5.state.options.emacs = false : p3 === "emacs" && (e5.state.options.vi = false), e5.state.options[p3] = true, Le$4(e5);
    else if (n3) e5.state.options[p3] = false, Le$4(e5);
    else {
      let w4 = e5.state.options[p3];
      i4 ? w4 || (c3 = true) : r2 ? (u3.push(`set ${w4 ? "-o" : "+o"} ${d3}`), w4 || (c3 = true)) : (u3.push(`${d3}		${w4 ? "on" : "off"}`), w4 || (c3 = true));
    }
  }
  return { exitCode: c3 ? 1 : 0, stdout: u3.length > 0 ? `${u3.join(`
`)}
` : "", stderr: f3 };
}
async function rr(e5, t4, s3) {
  if (t4.includes("/")) {
    let o2 = e5.fs.resolvePath(e5.state.cwd, t4);
    if (!await e5.fs.exists(o2)) return { error: "not_found", path: o2 };
    let a3 = o2.split("/").pop() || t4, l3 = e5.commands.get(a3);
    try {
      let c3 = await e5.fs.stat(o2);
      return c3.isDirectory ? { error: "permission_denied", path: o2 } : l3 ? { cmd: l3, path: o2 } : (c3.mode & 73) !== 0 ? { script: true, path: o2 } : { error: "permission_denied", path: o2 };
    } catch {
      return { error: "not_found", path: o2 };
    }
  }
  if (!s3 && e5.state.hashTable) {
    let o2 = e5.state.hashTable.get(t4);
    if (o2) if (await e5.fs.exists(o2)) {
      let a3 = e5.commands.get(t4);
      if (a3) return { cmd: a3, path: o2 };
      try {
        let l3 = await e5.fs.stat(o2);
        if (!l3.isDirectory && (l3.mode & 73) !== 0) return { script: true, path: o2 };
      } catch {
      }
    } else e5.state.hashTable.delete(t4);
  }
  let r2 = (s3 ?? e5.state.env.PATH ?? "/usr/bin:/bin").split(":");
  for (let o2 of r2) {
    if (!o2) continue;
    let l3 = `${o2.startsWith("/") ? o2 : e5.fs.resolvePath(e5.state.cwd, o2)}/${t4}`;
    if (await e5.fs.exists(l3)) try {
      let c3 = await e5.fs.stat(l3);
      if (c3.isDirectory) continue;
      let f3 = (c3.mode & 73) !== 0, u3 = e5.commands.get(t4), d3 = o2 === "/bin" || o2 === "/usr/bin";
      if (u3 && d3) return { cmd: u3, path: l3 };
      if (f3) {
        if (u3 && !d3) return { script: true, path: l3 };
        if (!u3) return { script: true, path: l3 };
      }
    } catch {
    }
  }
  if (!await e5.fs.exists("/usr/bin")) {
    let o2 = e5.commands.get(t4);
    if (o2) return { cmd: o2, path: `/usr/bin/${t4}` };
  }
  return null;
}
async function Tt$1(e5, t4) {
  let s3 = [];
  if (t4.includes("/")) {
    let i4 = e5.fs.resolvePath(e5.state.cwd, t4);
    if (await e5.fs.exists(i4)) try {
      let o2 = await e5.fs.stat(i4);
      o2.isDirectory || (o2.mode & 73) !== 0 && s3.push(t4);
    } catch {
    }
    return s3;
  }
  let r2 = (e5.state.env.PATH || "/usr/bin:/bin").split(":");
  for (let i4 of r2) {
    if (!i4) continue;
    let a3 = `${i4.startsWith("/") ? i4 : e5.fs.resolvePath(e5.state.cwd, i4)}/${t4}`;
    if (await e5.fs.exists(a3)) {
      try {
        if ((await e5.fs.stat(a3)).isDirectory) continue;
      } catch {
        continue;
      }
      s3.push(i4.startsWith("/") ? a3 : `${i4}/${t4}`);
    }
  }
  return s3;
}
async function lr(e5, t4, s3, n3) {
  let r2 = false, i4 = false, o2 = false, a3 = false, l3 = false, c3 = [];
  for (let p3 of t4) if (p3.startsWith("-") && p3.length > 1) for (let w4 of p3.slice(1)) w4 === "t" ? r2 = true : w4 === "p" ? i4 = true : w4 === "P" ? o2 = true : w4 === "a" ? a3 = true : w4 === "f" && (l3 = true);
  else c3.push(p3);
  let f3 = "", u3 = "", d3 = 0, h3 = false, m3 = false;
  for (let p3 of c3) {
    let w4 = false;
    if (o2) {
      if (a3) {
        let v2 = await n3(p3);
        if (v2.length > 0) {
          for (let _4 of v2) f3 += `${_4}
`;
          h3 = true, w4 = true;
        }
      } else {
        let v2 = await s3(p3);
        v2 && (f3 += `${v2}
`, h3 = true, w4 = true);
      }
      w4 || (m3 = true);
      continue;
    }
    let b4 = !l3 && e5.state.functions.has(p3);
    if (a3 && b4) {
      if (!i4) if (r2) f3 += `function
`;
      else {
        let v2 = e5.state.functions.get(p3), _4 = v2 ? ir(p3, v2) : `${p3} is a function
`;
        f3 += _4;
      }
      w4 = true;
    }
    let $5 = e5.state.env[`BASH_ALIAS_${p3}`];
    if ($5 !== void 0 && (a3 || !w4) && (i4 || (r2 ? f3 += `alias
` : f3 += `${p3} is aliased to \`${$5}'
`), w4 = true, !a3) || ts.has(p3) && (a3 || !w4) && (i4 || (r2 ? f3 += `keyword
` : f3 += `${p3} is a shell keyword
`), w4 = true, !a3)) continue;
    if (!a3 && b4 && !w4) {
      if (!i4) if (r2) f3 += `function
`;
      else {
        let v2 = e5.state.functions.get(p3), _4 = v2 ? ir(p3, v2) : `${p3} is a function
`;
        f3 += _4;
      }
      w4 = true;
      continue;
    }
    if (!(Qe$5.has(p3) && (a3 || !w4) && (i4 || (r2 ? f3 += `builtin
` : f3 += `${p3} is a shell builtin
`), w4 = true, !a3))) {
      if (a3) {
        let v2 = await n3(p3);
        for (let _4 of v2) i4 ? f3 += `${_4}
` : r2 ? f3 += `file
` : f3 += `${p3} is ${_4}
`, h3 = true, w4 = true;
      } else if (!w4) {
        let v2 = await s3(p3);
        v2 && (i4 ? f3 += `${v2}
` : r2 ? f3 += `file
` : f3 += `${p3} is ${v2}
`, h3 = true, w4 = true);
      }
      if (!w4 && (m3 = true, !r2 && !i4)) {
        let v2 = true;
        if (p3.includes("/")) {
          let _4 = e5.fs.resolvePath(e5.state.cwd, p3);
          await e5.fs.exists(_4) && (v2 = false);
        }
        v2 && (u3 += `bash: type: ${p3}: not found
`);
      }
    }
  }
  return i4 ? d3 = m3 && !h3 ? 1 : 0 : d3 = m3 ? 1 : 0, P$f(f3, u3, d3);
}
function ir(e5, t4) {
  let s3;
  return t4.body.type === "Group" ? s3 = t4.body.body.map((r2) => tt$5(r2)).join("; ") : s3 = tt$5(t4.body), `${e5} is a function
${e5} () 
{ 
    ${s3}
}
`;
}
function tt$5(e5) {
  if (Array.isArray(e5)) return e5.map((t4) => tt$5(t4)).join("; ");
  if (e5.type === "Statement") {
    let t4 = [];
    for (let s3 = 0; s3 < e5.pipelines.length; s3++) {
      let n3 = e5.pipelines[s3];
      t4.push(qi$1(n3)), e5.operators[s3] && t4.push(e5.operators[s3]);
    }
    return t4.join(" ");
  }
  if (e5.type === "SimpleCommand") {
    let t4 = e5, s3 = [];
    t4.name && s3.push(or(t4.name));
    for (let n3 of t4.args) s3.push(or(n3));
    return s3.join(" ");
  }
  return e5.type === "Group" ? `{ ${e5.body.map((n3) => tt$5(n3)).join("; ")}; }` : "...";
}
function qi$1(e5) {
  let t4 = e5.commands.map((s3) => tt$5(s3));
  return (e5.negated ? "! " : "") + t4.join(" | ");
}
function or(e5) {
  let t4 = "";
  for (let s3 of e5.parts) s3.type === "Literal" ? t4 += s3.value : s3.type === "DoubleQuoted" ? t4 += `"${s3.parts.map((n3) => ar(n3)).join("")}"` : s3.type === "SingleQuoted" ? t4 += `'${s3.value}'` : t4 += ar(s3);
  return t4;
}
function ar(e5) {
  let t4 = e5;
  return t4.type === "Literal" ? t4.value ?? "" : t4.type === "Variable" ? `$${t4.name}` : "";
}
async function cr(e5, t4, s3, n3) {
  let r2 = "", i4 = "", o2 = 0;
  for (let a3 of t4) {
    if (!a3) {
      o2 = 1;
      continue;
    }
    let l3 = e5.state.env[`BASH_ALIAS_${a3}`];
    if (l3 !== void 0) n3 ? r2 += `${a3} is an alias for "${l3}"
` : r2 += `alias ${a3}='${l3}'
`;
    else if (ts.has(a3)) n3 ? r2 += `${a3} is a shell keyword
` : r2 += `${a3}
`;
    else if (Qe$5.has(a3)) n3 ? r2 += `${a3} is a shell builtin
` : r2 += `${a3}
`;
    else if (e5.state.functions.has(a3)) n3 ? r2 += `${a3} is a function
` : r2 += `${a3}
`;
    else if (a3.includes("/")) {
      let c3 = e5.fs.resolvePath(e5.state.cwd, a3), f3 = false;
      if (await e5.fs.exists(c3)) try {
        let u3 = await e5.fs.stat(c3);
        u3.isDirectory || (u3.mode & 73) !== 0 && (n3 ? r2 += `${a3} is ${a3}
` : r2 += `${a3}
`, f3 = true);
      } catch {
      }
      f3 || (n3 && (i4 += `${a3}: not found
`), o2 = 1);
    } else if (e5.commands.has(a3)) {
      let f3 = (e5.state.env.PATH ?? "/usr/bin:/bin").split(":"), u3 = null;
      for (let d3 of f3) {
        if (!d3) continue;
        let h3 = `${d3}/${a3}`;
        try {
          let m3 = await e5.fs.stat(h3);
          if (!m3.isDirectory && (m3.mode & 73) !== 0) {
            u3 = h3;
            break;
          }
        } catch {
        }
      }
      u3 || (u3 = `/usr/bin/${a3}`), n3 ? r2 += `${a3} is ${u3}
` : r2 += `${u3}
`;
    } else n3 && (i4 += `${a3}: not found
`), o2 = 1;
  }
  return P$f(r2, i4, o2);
}
async function fr(e5, t4) {
  if (t4.includes("/")) {
    let r2 = e5.fs.resolvePath(e5.state.cwd, t4);
    if (await e5.fs.exists(r2)) {
      try {
        let i4 = await e5.fs.stat(r2);
        if (i4.isDirectory || !((i4.mode & 73) !== 0)) return null;
      } catch {
        return null;
      }
      return t4;
    }
    return null;
  }
  let n3 = (e5.state.env.PATH ?? "/usr/bin:/bin").split(":");
  for (let r2 of n3) {
    if (!r2) continue;
    let o2 = `${r2.startsWith("/") ? r2 : e5.fs.resolvePath(e5.state.cwd, r2)}/${t4}`;
    if (await e5.fs.exists(o2)) {
      try {
        if ((await e5.fs.stat(o2)).isDirectory) continue;
      } catch {
        continue;
      }
      return `${r2}/${t4}`;
    }
  }
  if (e5.commands.has(t4)) {
    for (let r2 of n3) if (r2 === "/usr/bin" || r2 === "/bin") return `${r2}/${t4}`;
    return `/usr/bin/${t4}`;
  }
  return null;
}
async function ur(e5, t4, s3, n3, r2, i4, o2, a3) {
  let { ctx: l3, runCommand: c3 } = e5;
  if (t4 === "export") return Ss(l3, s3);
  if (t4 === "unset") return Ls$1(l3, s3);
  if (t4 === "exit") return $s$1(l3, s3);
  if (t4 === "local") return Ns(l3, s3);
  if (t4 === "set") return Is$1(l3, s3);
  if (t4 === "break") return Kt(l3, s3);
  if (t4 === "continue") return ls(l3, s3);
  if (t4 === "return") return Os$1(l3, s3);
  if (t4 === "eval" && l3.state.options.posix) return kt$1(l3, s3, r2);
  if (t4 === "shift") return Ts(l3, s3);
  if (t4 === "getopts") return Ot$1(l3, s3);
  if (t4 === "compgen") return rs$1(l3, s3);
  if (t4 === "complete") return os(l3, s3);
  if (t4 === "compopt") return as(l3, s3);
  if (t4 === "pushd") return await vs$1(l3, s3);
  if (t4 === "popd") return bs(l3, s3);
  if (t4 === "dirs") return Es(l3, s3);
  if (t4 === "source" || t4 === ".") return Rs$1(l3, s3);
  if (t4 === "read") return ks$1(l3, s3, r2, a3);
  if (t4 === "mapfile" || t4 === "readarray") return Cs$1(l3, s3, r2);
  if (t4 === "declare" || t4 === "typeset") return ys(l3, s3);
  if (t4 === "readonly") return ws$1(l3, s3);
  if (!i4) {
    let f3 = l3.state.functions.get(t4);
    if (f3) return Nt$1(l3, f3, s3, r2);
  }
  if (t4 === "eval") return kt$1(l3, s3, r2);
  if (t4 === "cd") return await Xt$1(l3, s3);
  if (t4 === ":" || t4 === "true") return L$d;
  if (t4 === "false") return Z$6(false);
  if (t4 === "let") return _s$1(l3, s3);
  if (t4 === "command") return Gi$1(e5, s3, r2);
  if (t4 === "builtin") return Ki(e5, s3, r2);
  if (t4 === "shopt") return nr(l3, s3);
  if (t4 === "exec") {
    if (s3.length === 0) return L$d;
    let [f3, ...u3] = s3;
    return c3(f3, u3, [], r2, false, false, -1);
  }
  if (t4 === "wait") return L$d;
  if (t4 === "type") return await lr(l3, s3, (f3) => fr(l3, f3), (f3) => Tt$1(l3, f3));
  if (t4 === "hash") return As(l3, s3);
  if (t4 === "help") return Ps(l3, s3);
  if (t4 === "[" || t4 === "test") {
    let f3 = s3;
    if (t4 === "[") {
      if (s3[s3.length - 1] !== "]") return S$d("[: missing `]'\n", 2);
      f3 = s3.slice(0, -1);
    }
    return Ye$4(l3, f3);
  }
  return null;
}
async function Gi$1(e5, t4, s3) {
  let { ctx: n3, runCommand: r2 } = e5;
  if (t4.length === 0) return L$d;
  let i4 = false, o2 = false, a3 = false, l3 = t4;
  for (; l3.length > 0 && l3[0].startsWith("-"); ) {
    let u3 = l3[0];
    if (u3 === "--") {
      l3 = l3.slice(1);
      break;
    }
    for (let d3 of u3.slice(1)) d3 === "p" ? i4 = true : d3 === "V" ? o2 = true : d3 === "v" && (a3 = true);
    l3 = l3.slice(1);
  }
  if (l3.length === 0) return L$d;
  if (a3 || o2) return await cr(n3, l3, a3, o2);
  let [c3, ...f3] = l3;
  return r2(c3, f3, [], s3, true, i4, -1);
}
async function Ki(e5, t4, s3) {
  let { runCommand: n3 } = e5;
  if (t4.length === 0) return L$d;
  let r2 = t4;
  if (r2[0] === "--" && (r2 = r2.slice(1), r2.length === 0)) return L$d;
  let i4 = r2[0];
  if (!Qe$5.has(i4)) return S$d(`bash: builtin: ${i4}: not a shell builtin
`);
  let [, ...o2] = r2;
  return n3(i4, o2, [], s3, true, false, -1);
}
async function dr(e5, t4, s3, n3, r2) {
  let { ctx: i4, buildExportedEnv: o2, executeUserScript: a3 } = e5, c3 = await rr(i4, t4, r2 ? "/usr/bin:/bin" : void 0);
  if (!c3) return bn$1(t4) ? S$d(`bash: ${t4}: command not available in browser environments. Exclude '${t4}' from your commands or use the Node.js bundle.
`, 127) : S$d(`bash: ${t4}: command not found
`, 127);
  if ("error" in c3) return c3.error === "permission_denied" ? S$d(`bash: ${t4}: Permission denied
`, 126) : S$d(`bash: ${t4}: No such file or directory
`, 127);
  if ("script" in c3) return t4.includes("/") || (i4.state.hashTable || (i4.state.hashTable = /* @__PURE__ */ new Map()), i4.state.hashTable.set(t4, c3.path)), await a3(c3.path, s3, n3);
  let { cmd: f3, path: u3 } = c3;
  t4.includes("/") || (i4.state.hashTable || (i4.state.hashTable = /* @__PURE__ */ new Map()), i4.state.hashTable.set(t4, u3));
  let d3 = n3 || i4.state.groupStdin || "", h3 = o2(), m3 = { fs: i4.fs, cwd: i4.state.cwd, env: i4.state.env, exportedEnv: h3, stdin: d3, limits: i4.limits, exec: i4.execFn, fetch: i4.fetch, getRegisteredCommands: () => Array.from(i4.commands.keys()), sleep: i4.sleep, trace: i4.trace, fileDescriptors: i4.state.fileDescriptors, xpgEcho: i4.state.shoptOptions.xpg_echo };
  try {
    return await f3.execute(s3, m3);
  } catch (p3) {
    return S$d(`${t4}: ${n$5(p3)}
`);
  }
}
async function Ws(e5, t4) {
  let s3 = e5.state.inCondition;
  e5.state.inCondition = true;
  let n3 = "", r2 = "", i4 = 0;
  try {
    for (let o2 of t4) {
      let a3 = await e5.executeStatement(o2);
      n3 += a3.stdout, r2 += a3.stderr, i4 = a3.exitCode;
    }
  } finally {
    e5.state.inCondition = s3;
  }
  return { stdout: n3, stderr: r2, exitCode: i4 };
}
function st$5(e5, t4, s3, n3) {
  if (e5 instanceof c$7) return t4 += e5.stdout, s3 += e5.stderr, e5.levels > 1 && n3 > 1 ? (e5.levels--, e5.stdout = t4, e5.stderr = s3, { action: "rethrow", stdout: t4, stderr: s3, error: e5 }) : { action: "break", stdout: t4, stderr: s3 };
  if (e5 instanceof a$1) return t4 += e5.stdout, s3 += e5.stderr, e5.levels > 1 && n3 > 1 ? (e5.levels--, e5.stdout = t4, e5.stderr = s3, { action: "rethrow", stdout: t4, stderr: s3, error: e5 }) : { action: "continue", stdout: t4, stderr: s3 };
  if (e5 instanceof i$6 || e5 instanceof u$8 || e5 instanceof d$8 || e5 instanceof b$i) return e5.prependOutput(t4, s3), { action: "rethrow", stdout: t4, stderr: s3, error: e5 };
  let r2 = n$5(e5);
  return { action: "error", stdout: t4, stderr: `${s3}${r2}
`, exitCode: 1 };
}
async function Rt$1(e5, t4, s3 = "", n3 = "") {
  let r2 = s3, i4 = n3, o2 = 0;
  try {
    for (let a3 of t4) {
      let l3 = await e5.executeStatement(a3);
      r2 += l3.stdout, i4 += l3.stderr, o2 = l3.exitCode;
    }
  } catch (a3) {
    if (C$h(a3) || a3 instanceof u$8 || a3 instanceof d$8 || a3 instanceof b$i || a3 instanceof $$a) throw a3.prependOutput(r2, i4), a3;
    return { stdout: r2, stderr: `${i4}${n$5(a3)}
`, exitCode: 1 };
  }
  return { stdout: r2, stderr: i4, exitCode: o2 };
}
async function hr(e5, t4) {
  let s3 = "", n3 = "";
  for (let r2 of t4.clauses) {
    let i4 = await Ws(e5, r2.condition);
    if (s3 += i4.stdout, n3 += i4.stderr, i4.exitCode === 0) return Rt$1(e5, r2.body, s3, n3);
  }
  return t4.elseBody ? Rt$1(e5, t4.elseBody, s3, n3) : P$f(s3, n3, 0);
}
async function pr(e5, t4) {
  let s3 = await we$5(e5, t4.redirections);
  if (s3) return s3;
  let n3 = "", r2 = "", i4 = 0, o2 = 0;
  if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(t4.variable)) return S$d(`bash: \`${t4.variable}': not a valid identifier
`);
  let a3 = [];
  if (t4.words === null) a3 = (e5.state.env["@"] || "").split(" ").filter(Boolean);
  else if (t4.words.length === 0) a3 = [];
  else try {
    for (let c3 of t4.words) {
      let f3 = await ul$1(e5, c3);
      a3.push(...f3.values);
    }
  } catch (c3) {
    if (c3 instanceof l$7) return { stdout: "", stderr: c3.stderr, exitCode: 1 };
    throw c3;
  }
  e5.state.loopDepth++;
  try {
    for (let c3 of a3) {
      o2++, o2 > e5.limits.maxLoopIterations && Se$5(`for loop: too many iterations (${e5.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", n3, r2), e5.state.env[t4.variable] = c3;
      try {
        for (let f3 of t4.body) {
          let u3 = await e5.executeStatement(f3);
          n3 += u3.stdout, r2 += u3.stderr, i4 = u3.exitCode;
        }
      } catch (f3) {
        let u3 = st$5(f3, n3, r2, e5.state.loopDepth);
        if (n3 = u3.stdout, r2 = u3.stderr, u3.action === "break") break;
        if (u3.action === "continue") continue;
        if (u3.action === "error") {
          let d3 = P$f(n3, r2, u3.exitCode ?? 1);
          return j$a(e5, d3, t4.redirections);
        }
        throw u3.error;
      }
    }
  } finally {
    e5.state.loopDepth--;
  }
  let l3 = P$f(n3, r2, i4);
  return j$a(e5, l3, t4.redirections);
}
async function mr(e5, t4) {
  let s3 = await we$5(e5, t4.redirections);
  if (s3) return s3;
  let n3 = t4.line;
  n3 !== void 0 && (e5.state.currentLine = n3);
  let r2 = "", i4 = "", o2 = 0, a3 = 0;
  t4.init && await R$a(e5, t4.init.expression), e5.state.loopDepth++;
  try {
    for (; a3++, a3 > e5.limits.maxLoopIterations && Se$5(`for loop: too many iterations (${e5.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", r2, i4), !(t4.condition && (n3 !== void 0 && (e5.state.currentLine = n3), await R$a(e5, t4.condition.expression) === 0)); ) {
      try {
        for (let c3 of t4.body) {
          let f3 = await e5.executeStatement(c3);
          r2 += f3.stdout, i4 += f3.stderr, o2 = f3.exitCode;
        }
      } catch (c3) {
        let f3 = st$5(c3, r2, i4, e5.state.loopDepth);
        if (r2 = f3.stdout, i4 = f3.stderr, f3.action === "break") break;
        if (f3.action === "continue") {
          t4.update && await R$a(e5, t4.update.expression);
          continue;
        }
        if (f3.action === "error") {
          let u3 = P$f(r2, i4, f3.exitCode ?? 1);
          return j$a(e5, u3, t4.redirections);
        }
        throw f3.error;
      }
      t4.update && await R$a(e5, t4.update.expression);
    }
  } finally {
    e5.state.loopDepth--;
  }
  let l3 = P$f(r2, i4, o2);
  return j$a(e5, l3, t4.redirections);
}
async function yr(e5, t4, s3 = "") {
  let n3 = "", r2 = "", i4 = 0, o2 = 0, a3 = s3;
  for (let c3 of t4.redirections) if ((c3.operator === "<<" || c3.operator === "<<-") && c3.target.type === "HereDoc") {
    let f3 = c3.target, u3 = await wt$5(e5, f3.content);
    f3.stripTabs && (u3 = u3.split(`
`).map((d3) => d3.replace(/^\t+/, "")).join(`
`)), a3 = u3;
  } else if (c3.operator === "<<<" && c3.target.type === "Word") a3 = `${await wt$5(e5, c3.target)}
`;
  else if (c3.operator === "<" && c3.target.type === "Word") try {
    let f3 = await wt$5(e5, c3.target), u3 = e5.fs.resolvePath(e5.state.cwd, f3);
    a3 = await e5.fs.readFile(u3);
  } catch {
    let f3 = await wt$5(e5, c3.target);
    return S$d(`bash: ${f3}: No such file or directory
`);
  }
  let l3 = e5.state.groupStdin;
  a3 && (e5.state.groupStdin = a3), e5.state.loopDepth++;
  try {
    for (; ; ) {
      o2++, o2 > e5.limits.maxLoopIterations && Se$5(`while loop: too many iterations (${e5.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", n3, r2);
      let c3 = 0, f3 = false, u3 = false, d3 = e5.state.inCondition;
      e5.state.inCondition = true;
      try {
        for (let h3 of t4.condition) {
          let m3 = await e5.executeStatement(h3);
          n3 += m3.stdout, r2 += m3.stderr, c3 = m3.exitCode;
        }
      } catch (h3) {
        if (h3 instanceof c$7) {
          if (n3 += h3.stdout, r2 += h3.stderr, h3.levels > 1 && e5.state.loopDepth > 1) throw h3.levels--, h3.stdout = n3, h3.stderr = r2, e5.state.inCondition = d3, h3;
          f3 = true;
        } else if (h3 instanceof a$1) {
          if (n3 += h3.stdout, r2 += h3.stderr, h3.levels > 1 && e5.state.loopDepth > 1) throw h3.levels--, h3.stdout = n3, h3.stderr = r2, e5.state.inCondition = d3, h3;
          u3 = true;
        } else throw e5.state.inCondition = d3, h3;
      } finally {
        e5.state.inCondition = d3;
      }
      if (f3) break;
      if (!u3) {
        if (c3 !== 0) break;
        try {
          for (let h3 of t4.body) {
            let m3 = await e5.executeStatement(h3);
            n3 += m3.stdout, r2 += m3.stderr, i4 = m3.exitCode;
          }
        } catch (h3) {
          let m3 = st$5(h3, n3, r2, e5.state.loopDepth);
          if (n3 = m3.stdout, r2 = m3.stderr, m3.action === "break") break;
          if (m3.action === "continue") continue;
          if (m3.action === "error") return P$f(n3, r2, m3.exitCode ?? 1);
          throw m3.error;
        }
      }
    }
  } finally {
    e5.state.loopDepth--, e5.state.groupStdin = l3;
  }
  return P$f(n3, r2, i4);
}
async function wr(e5, t4) {
  let s3 = "", n3 = "", r2 = 0, i4 = 0;
  e5.state.loopDepth++;
  try {
    for (; ; ) {
      i4++, i4 > e5.limits.maxLoopIterations && Se$5(`until loop: too many iterations (${e5.limits.maxLoopIterations}), increase executionLimits.maxLoopIterations`, "iterations", s3, n3);
      let o2 = await Ws(e5, t4.condition);
      if (s3 += o2.stdout, n3 += o2.stderr, o2.exitCode === 0) break;
      try {
        for (let a3 of t4.body) {
          let l3 = await e5.executeStatement(a3);
          s3 += l3.stdout, n3 += l3.stderr, r2 = l3.exitCode;
        }
      } catch (a3) {
        let l3 = st$5(a3, s3, n3, e5.state.loopDepth);
        if (s3 = l3.stdout, n3 = l3.stderr, l3.action === "break") break;
        if (l3.action === "continue") continue;
        if (l3.action === "error") return P$f(s3, n3, l3.exitCode ?? 1);
        throw l3.error;
      }
    }
  } finally {
    e5.state.loopDepth--;
  }
  return P$f(s3, n3, r2);
}
async function gr(e5, t4) {
  let s3 = await we$5(e5, t4.redirections);
  if (s3) return s3;
  let n3 = "", r2 = "", i4 = 0, o2 = await wt$5(e5, t4.word), a3 = false;
  for (let c3 = 0; c3 < t4.items.length; c3++) {
    let f3 = t4.items[c3], u3 = a3;
    if (!a3) for (let d3 of f3.patterns) {
      let h3 = await wt$5(e5, d3);
      al$1(d3) && (h3 = U$8(h3));
      let m3 = e5.state.shoptOptions.nocasematch, p3 = e5.state.shoptOptions.extglob;
      if (Fe$5(o2, h3, m3, p3)) {
        u3 = true;
        break;
      }
    }
    if (u3) {
      let d3 = await Rt$1(e5, f3.body, n3, r2);
      if (n3 = d3.stdout, r2 = d3.stderr, i4 = d3.exitCode, f3.terminator === ";;") break;
      f3.terminator === ";&" ? a3 = true : a3 = false;
    } else a3 = false;
  }
  let l3 = P$f(n3, r2, i4);
  return j$a(e5, l3, t4.redirections);
}
function Ms(e5, t4) {
  if (e5.parts.length !== 1) return false;
  let s3 = e5.parts[0];
  return s3.type !== "Literal" ? false : t4.includes(s3.value);
}
function vr(e5) {
  if (!e5.startsWith("__rw__:")) return null;
  let t4 = e5.slice(7), s3 = t4.indexOf(":");
  if (s3 === -1) return null;
  let n3 = Number.parseInt(t4.slice(0, s3), 10);
  if (Number.isNaN(n3) || n3 < 0) return null;
  let r2 = s3 + 1, i4 = t4.slice(r2, r2 + n3), o2 = r2 + n3 + 1, a3 = t4.slice(o2), l3 = a3.indexOf(":");
  if (l3 === -1) return null;
  let c3 = Number.parseInt(a3.slice(0, l3), 10);
  if (Number.isNaN(c3) || c3 < 0) return null;
  let f3 = a3.slice(l3 + 1);
  return { path: i4, position: c3, content: f3 };
}
var br = "+ ";
async function Er(e5) {
  let t4 = e5.state.env.PS4;
  if (t4 === void 0) return br;
  if (t4 === "") return "";
  try {
    let n3 = new T$9().parseWordFromString(t4, false, false);
    return await wt$5(e5, n3);
  } catch {
    return e5.state.expansionStderr = `${e5.state.expansionStderr || ""}bash: ${t4}: bad substitution
`, t4 || br;
  }
}
function Xi$1(e5) {
  return e5.map((t4) => Yi$1(t4)).join(" ");
}
function Yi$1(e5) {
  if (e5 === "") return "''";
  if (!/[\s'"\\$`!*?[\]{}|&;<>()~#\n\t]/.test(e5)) return e5;
  let s3 = /[\x00-\x1f\x7f]/.test(e5), n3 = e5.includes(`
`), r2 = e5.includes("	"), i4 = e5.includes("\\"), o2 = e5.includes("'");
  if (s3 || n3 || r2 || i4) {
    let l3 = "";
    for (let c3 of e5) {
      let f3 = c3.charCodeAt(0);
      c3 === `
` ? l3 += "\\n" : c3 === "	" ? l3 += "\\t" : c3 === "\\" ? l3 += "\\\\" : c3 === "'" ? l3 += "'" : c3 === '"' ? l3 += '"' : f3 < 32 || f3 === 127 ? f3 < 256 ? l3 += `\\x${f3.toString(16).padStart(2, "0")}` : l3 += `\\u${f3.toString(16).padStart(4, "0")}` : l3 += c3;
    }
    return `$'${l3}'`;
  }
  return o2 ? `"${e5.replace(/([\\$`"])/g, "\\$1")}"` : `'${e5}'`;
}
async function $r(e5, t4, s3) {
  if (!e5.state.options.xtrace) return "";
  let n3 = await Er(e5), r2 = [t4, ...s3], i4 = Xi$1(r2);
  return `${n3}${i4}
`;
}
async function Sr$1(e5, t4, s3) {
  return e5.state.options.xtrace ? `${await Er(e5)}${t4}=${s3}
` : "";
}
async function Ar(e5, t4, s3) {
  let n3 = t4.timed ? performance.now() : 0, r2 = "", i4 = L$d, o2 = 0, a3 = [], l3 = t4.commands.length > 1, c3 = e5.state.lastArg;
  for (let u3 = 0; u3 < t4.commands.length; u3++) {
    let d3 = t4.commands[u3], h3 = u3 === t4.commands.length - 1;
    l3 && (e5.state.lastArg = "");
    let p3 = l3 && (!h3 || !e5.state.shoptOptions.lastpipe) ? { ...e5.state.env } : null, w4;
    try {
      w4 = await s3(d3, r2);
    } catch (b4) {
      if (b4 instanceof h$f) w4 = { stdout: b4.stdout, stderr: b4.stderr, exitCode: 1 };
      else if (b4 instanceof d$8 && t4.commands.length > 1) w4 = { stdout: b4.stdout, stderr: b4.stderr, exitCode: b4.exitCode };
      else if (b4 instanceof u$8 && t4.commands.length > 1) w4 = { stdout: b4.stdout, stderr: b4.stderr, exitCode: b4.exitCode };
      else throw p3 && (e5.state.env = p3), b4;
    }
    p3 && (e5.state.env = p3), a3.push(w4.exitCode), w4.exitCode !== 0 && (o2 = w4.exitCode), h3 ? i4 = w4 : t4.pipeStderr?.[u3] ?? false ? (r2 = w4.stderr + w4.stdout, i4 = { stdout: "", stderr: "", exitCode: w4.exitCode }) : (r2 = w4.stdout, i4 = { stdout: "", stderr: w4.stderr, exitCode: w4.exitCode });
  }
  if (t4.commands.length > 1 || t4.commands.length === 1 && t4.commands[0].type === "SimpleCommand") {
    for (let u3 of Object.keys(e5.state.env)) u3.startsWith("PIPESTATUS_") && delete e5.state.env[u3];
    for (let u3 = 0; u3 < a3.length; u3++) e5.state.env[`PIPESTATUS_${u3}`] = String(a3[u3]);
    e5.state.env.PIPESTATUS__length = String(a3.length);
  }
  if (e5.state.options.pipefail && o2 !== 0 && (i4 = { ...i4, exitCode: o2 }), t4.negated && (i4 = { ...i4, exitCode: i4.exitCode === 0 ? 1 : 0 }), t4.timed) {
    let d3 = (performance.now() - n3) / 1e3, h3 = Math.floor(d3 / 60), m3 = d3 % 60, p3;
    t4.timePosix ? p3 = `real ${d3.toFixed(2)}
user 0.00
sys 0.00
` : p3 = `
real	${`${h3}m${m3.toFixed(3)}s`}
user	0m0.000s
sys	0m0.000s
`, i4 = { ...i4, stderr: i4.stderr + p3 };
  }
  return l3 && !e5.state.shoptOptions.lastpipe && (e5.state.lastArg = c3), i4;
}
async function Pr(e5, t4) {
  let s3 = {}, n3 = "";
  for (let r2 of t4.assignments) {
    let i4 = r2.name;
    if (r2.array) {
      let f3 = await Qi$1(e5, t4, i4, r2.array, r2.append, s3);
      if (f3.error) return { continueToNext: false, xtraceOutput: n3, tempAssignments: s3, error: f3.error };
      if (n3 += f3.xtraceOutput, f3.continueToNext) continue;
    }
    let o2 = r2.value ? await wt$5(e5, r2.value) : "";
    if (i4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[\]$/)) return { continueToNext: false, xtraceOutput: n3, tempAssignments: s3, error: P$f("", `bash: ${i4}: bad array subscript
`, 1) };
    let l3 = i4.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    if (l3) {
      let f3 = await no(e5, t4, l3[1], l3[2], o2, r2.append, s3);
      if (f3.error) return { continueToNext: false, xtraceOutput: n3, tempAssignments: s3, error: f3.error };
      if (f3.continueToNext) continue;
    }
    let c3 = await io(e5, t4, i4, o2, r2.append, s3);
    if (c3.error) return { continueToNext: false, xtraceOutput: n3, tempAssignments: s3, error: c3.error };
    n3 += c3.xtraceOutput, c3.continueToNext;
  }
  return { continueToNext: false, xtraceOutput: n3, tempAssignments: s3 };
}
async function Qi$1(e5, t4, s3, n3, r2, i4) {
  let o2 = "";
  if (/\[.+\]$/.test(s3)) return { continueToNext: false, xtraceOutput: "", error: P$f("", `bash: ${s3}: cannot assign list to array member
`, 1) };
  if (C$g(e5, s3)) {
    let f3 = ge$5(e5, s3);
    if (f3 === void 0 || f3 === "") throw new d$8(1, "", "");
    let u3 = le$8(e5, s3);
    if (u3 && /^[a-zA-Z_][a-zA-Z0-9_]*\[@\]$/.test(u3)) return { continueToNext: false, xtraceOutput: "", error: P$f("", `bash: ${s3}: cannot assign list to array member
`, 1) };
  }
  if (At$4(e5, s3)) {
    if (t4.name) return o2 += `bash: ${s3}: readonly variable
`, { continueToNext: true, xtraceOutput: o2 };
    aa(e5, s3);
  }
  let a3 = e5.state.associativeArrays?.has(s3), l3 = Ji$1(n3), c3 = () => {
    let f3 = `${s3}_`;
    for (let u3 of Object.keys(e5.state.env)) u3.startsWith(f3) && !u3.includes("__") && delete e5.state.env[u3];
    delete e5.state.env[s3];
  };
  if (a3 && l3 ? await eo(e5, t4, s3, n3, r2, c3, (f3) => {
    o2 += f3;
  }) : l3 ? await to(e5, s3, n3, r2, c3) : await so(e5, s3, n3, r2, c3), t4.name) {
    i4[s3] = e5.state.env[s3];
    let u3 = `(${n3.map((d3) => hn$1(d3)).join(" ")})`;
    e5.state.env[s3] = u3;
  }
  return { continueToNext: true, xtraceOutput: o2 };
}
function Ji$1(e5) {
  return e5.some((t4) => {
    if (t4.parts.length >= 2) {
      let s3 = t4.parts[0], n3 = t4.parts[1];
      if (s3.type !== "Glob" || !s3.pattern.startsWith("[")) return false;
      if (s3.pattern === "[" && (n3.type === "DoubleQuoted" || n3.type === "SingleQuoted")) {
        if (t4.parts.length < 3) return false;
        let r2 = t4.parts[2];
        return r2.type !== "Literal" ? false : r2.value.startsWith("]=") || r2.value.startsWith("]+=");
      }
      return n3.type !== "Literal" ? false : n3.value.startsWith("]") ? n3.value.startsWith("]=") || n3.value.startsWith("]+=") : s3.pattern.endsWith("]") ? n3.value.startsWith("=") || n3.value.startsWith("+=") : false;
    }
    return false;
  });
}
async function eo(e5, t4, s3, n3, r2, i4, o2) {
  let a3 = [];
  for (let l3 of n3) {
    let c3 = Ii$2(l3);
    if (c3) {
      let { key: f3, valueParts: u3, append: d3 } = c3, h3;
      u3.length > 0 ? h3 = await wt$5(e5, { parts: u3 }) : h3 = "", h3 = H$d(e5, h3), a3.push({ type: "keyed", key: f3, value: h3, append: d3 });
    } else {
      let f3 = await wt$5(e5, l3);
      a3.push({ type: "invalid", expandedValue: f3 });
    }
  }
  r2 || i4();
  for (let l3 of a3) if (l3.type === "keyed") if (l3.append) {
    let c3 = e5.state.env[`${s3}_${l3.key}`] ?? "";
    e5.state.env[`${s3}_${l3.key}`] = c3 + l3.value;
  } else e5.state.env[`${s3}_${l3.key}`] = l3.value;
  else {
    let c3 = t4.line ?? e5.state.currentLine ?? 1;
    o2(`bash: line ${c3}: ${s3}: ${l3.expandedValue}: must use subscript when assigning associative array
`);
  }
}
async function to(e5, t4, s3, n3, r2) {
  let i4 = [];
  for (let a3 of s3) {
    let l3 = Ii$2(a3);
    if (l3) {
      let { key: c3, valueParts: f3, append: u3 } = l3, d3;
      f3.length > 0 ? d3 = await wt$5(e5, { parts: f3 }) : d3 = "", d3 = H$d(e5, d3), i4.push({ type: "keyed", indexExpr: c3, value: d3, append: u3 });
    } else {
      let c3 = await ul$1(e5, a3);
      i4.push({ type: "non-keyed", values: c3.values });
    }
  }
  n3 || r2();
  let o2 = 0;
  for (let a3 of i4) if (a3.type === "keyed") {
    let l3;
    try {
      let c3 = new T$9(), f3 = W$d(c3, a3.indexExpr);
      l3 = await R$a(e5, f3.expression, false);
    } catch {
      if (/^-?\d+$/.test(a3.indexExpr)) l3 = Number.parseInt(a3.indexExpr, 10);
      else {
        let c3 = e5.state.env[a3.indexExpr];
        l3 = c3 ? Number.parseInt(c3, 10) : 0, Number.isNaN(l3) && (l3 = 0);
      }
    }
    if (a3.append) {
      let c3 = e5.state.env[`${t4}_${l3}`] ?? "";
      e5.state.env[`${t4}_${l3}`] = c3 + a3.value;
    } else e5.state.env[`${t4}_${l3}`] = a3.value;
    o2 = l3 + 1;
  } else for (let l3 of a3.values) e5.state.env[`${t4}_${o2++}`] = l3;
}
async function so(e5, t4, s3, n3, r2) {
  let i4 = [];
  for (let a3 of s3) {
    let l3 = await ul$1(e5, a3);
    i4.push(...l3.values);
  }
  let o2 = 0;
  if (n3) {
    let a3 = P$g(e5, t4);
    if (a3.length > 0) o2 = Math.max(...a3.map(([c3]) => typeof c3 == "number" ? c3 : 0)) + 1;
    else if (e5.state.env[t4] !== void 0) {
      let l3 = e5.state.env[t4];
      e5.state.env[`${t4}_0`] = l3, delete e5.state.env[t4], o2 = 1;
    }
  } else r2();
  for (let a3 = 0; a3 < i4.length; a3++) e5.state.env[`${t4}_${o2 + a3}`] = i4[a3];
  n3 || (e5.state.env[`${t4}__length`] = String(i4.length));
}
async function no(e5, t4, s3, n3, r2, i4, o2) {
  let a3 = s3;
  if (C$g(e5, s3)) {
    let u3 = le$8(e5, s3);
    if (u3 && u3 !== s3) {
      if (u3.includes("[")) return { continueToNext: false, xtraceOutput: "", error: P$f("", `bash: \`${u3}': not a valid identifier
`, 1) };
      a3 = u3;
    }
  }
  if (At$4(e5, a3)) {
    if (t4.name) return { continueToNext: true, xtraceOutput: "" };
    aa(e5, a3);
  }
  let l3 = e5.state.associativeArrays?.has(a3), c3;
  if (l3) c3 = await _r(e5, a3, n3);
  else {
    let u3 = await ro(e5, a3, n3);
    if (u3.error) return { continueToNext: false, xtraceOutput: "", error: u3.error };
    c3 = `${a3}_${u3.index}`;
  }
  let f3 = i4 ? (e5.state.env[c3] || "") + r2 : r2;
  if (t4.name) o2[c3] = e5.state.env[c3], e5.state.env[c3] = f3;
  else {
    let u3 = We$5(e5, a3);
    if (u3 !== void 0 && u3 === e5.state.callDepth && e5.state.localScopes.length > 0) {
      let d3 = e5.state.localScopes[e5.state.localScopes.length - 1];
      d3.has(c3) || d3.set(c3, e5.state.env[c3]);
    }
    e5.state.env[c3] = f3;
  }
  return { continueToNext: true, xtraceOutput: "" };
}
async function _r(e5, t4, s3) {
  let n3;
  if (s3.startsWith("'") && s3.endsWith("'")) n3 = s3.slice(1, -1);
  else if (s3.startsWith('"') && s3.endsWith('"')) {
    let r2 = s3.slice(1, -1), o2 = new T$9().parseWordFromString(r2, true, false);
    n3 = await wt$5(e5, o2);
  } else if (s3.includes("$")) {
    let i4 = new T$9().parseWordFromString(s3, false, false);
    n3 = await wt$5(e5, i4);
  } else n3 = s3;
  return `${t4}_${n3}`;
}
async function ro(e5, t4, s3) {
  let n3 = s3;
  s3.startsWith('"') && s3.endsWith('"') && s3.length >= 2 && (n3 = s3.slice(1, -1));
  let r2;
  if (/^-?\d+$/.test(n3)) r2 = Number.parseInt(n3, 10);
  else {
    try {
      let i4 = new T$9(), o2 = W$d(i4, n3);
      r2 = await R$a(e5, o2.expression, false);
    } catch (i4) {
      if (i4 instanceof p$f) {
        let l3 = `bash: line ${e5.state.currentLine}: ${s3}: ${i4.message}
`;
        if (i4.fatal) throw new d$8(1, "", l3);
        return { index: 0, error: P$f("", l3, 1) };
      }
      let o2 = e5.state.env[s3];
      r2 = o2 ? Number.parseInt(o2, 10) : 0;
    }
    Number.isNaN(r2) && (r2 = 0);
  }
  if (r2 < 0) {
    let i4 = P$g(e5, t4);
    if (i4.length === 0) {
      let a3 = e5.state.currentLine;
      return { index: 0, error: P$f("", `bash: line ${a3}: ${t4}[${s3}]: bad array subscript
`, 1) };
    }
    if (r2 = Math.max(...i4.map(([a3]) => typeof a3 == "number" ? a3 : 0)) + 1 + r2, r2 < 0) {
      let a3 = e5.state.currentLine;
      return { index: 0, error: P$f("", `bash: line ${a3}: ${t4}[${s3}]: bad array subscript
`, 1) };
    }
  }
  return { index: r2 };
}
async function io(e5, t4, s3, n3, r2, i4) {
  let o2 = "", a3 = s3, l3 = null;
  if (C$g(e5, s3)) {
    let u3 = Wi$2(e5, s3, n3);
    if (u3 === void 0) return { continueToNext: false, xtraceOutput: "", error: P$f("", `bash: ${s3}: circular name reference
`, 1) };
    if (u3 === null) return { continueToNext: true, xtraceOutput: "" };
    a3 = u3;
    let d3 = a3.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(.+)\]$/);
    d3 && (l3 = { arrayName: d3[1], subscriptExpr: d3[2] }, a3 = d3[1]);
  }
  if (At$4(e5, a3)) {
    if (t4.name) return o2 += `bash: ${a3}: readonly variable
`, { continueToNext: true, xtraceOutput: o2 };
    aa(e5, a3);
  }
  let c3;
  if (Je$5(e5, a3)) try {
    let u3 = new T$9();
    if (r2) {
      let h3 = `(${e5.state.env[a3] || "0"}) + (${n3})`, m3 = W$d(u3, h3);
      c3 = String(await R$a(e5, m3.expression));
    } else {
      let d3 = W$d(u3, n3);
      c3 = String(await R$a(e5, d3.expression));
    }
  } catch {
    c3 = "0";
  }
  else {
    let { isArray: u3 } = await Promise.resolve().then(function() {
      return expansionRIGCFEMA;
    }), d3 = u3(e5, a3) ? `${a3}_0` : a3;
    c3 = r2 ? (e5.state.env[d3] || "") + n3 : n3;
  }
  c3 = ze$3(e5, a3, c3), o2 += await Sr$1(e5, a3, c3);
  let f3 = a3;
  if (l3) f3 = await oo(e5, l3);
  else {
    let { isArray: u3 } = await Promise.resolve().then(function() {
      return expansionRIGCFEMA;
    });
    u3(e5, a3) && (f3 = `${a3}_0`);
  }
  return t4.name ? (i4[f3] = e5.state.env[f3], e5.state.env[f3] = c3) : (e5.state.env[f3] = c3, e5.state.options.allexport && (e5.state.exportedVars = e5.state.exportedVars || /* @__PURE__ */ new Set(), e5.state.exportedVars.add(a3)), e5.state.tempEnvBindings?.some((u3) => u3.has(a3)) && (e5.state.mutatedTempEnvVars = e5.state.mutatedTempEnvVars || /* @__PURE__ */ new Set(), e5.state.mutatedTempEnvVars.add(a3))), { continueToNext: false, xtraceOutput: o2 };
}
async function oo(e5, t4) {
  let { arrayName: s3, subscriptExpr: n3 } = t4;
  if (e5.state.associativeArrays?.has(s3)) return _r(e5, s3, n3);
  let i4;
  if (/^-?\d+$/.test(n3)) i4 = Number.parseInt(n3, 10);
  else {
    try {
      let o2 = new T$9(), a3 = W$d(o2, n3);
      i4 = await R$a(e5, a3.expression, false);
    } catch {
      let o2 = e5.state.env[n3];
      i4 = o2 ? Number.parseInt(o2, 10) : 0;
    }
    Number.isNaN(i4) && (i4 = 0);
  }
  if (i4 < 0) {
    let o2 = P$g(e5, s3);
    o2.length > 0 && (i4 = Math.max(...o2.map((l3) => l3[0])) + 1 + i4);
  }
  return `${s3}_${i4}`;
}
async function Nr(e5, t4, s3, n3) {
  let r2 = await we$5(e5, t4.redirections);
  if (r2) return r2;
  let i4 = { ...e5.state.env }, o2 = e5.state.cwd, a3 = { ...e5.state.options }, l3 = e5.state.localScopes, c3 = e5.state.localVarStack, f3 = e5.state.localVarDepth, u3 = e5.state.fullyUnsetLocals;
  if (e5.state.localScopes = l3.map((v2) => new Map(v2)), c3) {
    e5.state.localVarStack = /* @__PURE__ */ new Map();
    for (let [v2, _4] of c3.entries()) e5.state.localVarStack.set(v2, _4.map((k3) => ({ ...k3 })));
  }
  f3 && (e5.state.localVarDepth = new Map(f3)), u3 && (e5.state.fullyUnsetLocals = new Map(u3));
  let d3 = e5.state.loopDepth, h3 = e5.state.parentHasLoopContext;
  e5.state.parentHasLoopContext = d3 > 0, e5.state.loopDepth = 0;
  let m3 = e5.state.lastArg, p3 = e5.state.bashPid;
  e5.state.bashPid = e5.state.nextVirtualPid++;
  let w4 = e5.state.groupStdin;
  s3 && (e5.state.groupStdin = s3);
  let b4 = "", $5 = "", C2 = 0, y2 = () => {
    e5.state.env = i4, e5.state.cwd = o2, e5.state.options = a3, e5.state.localScopes = l3, e5.state.localVarStack = c3, e5.state.localVarDepth = f3, e5.state.fullyUnsetLocals = u3, e5.state.loopDepth = d3, e5.state.parentHasLoopContext = h3, e5.state.groupStdin = w4, e5.state.bashPid = p3, e5.state.lastArg = m3;
  };
  try {
    for (let v2 of t4.body) {
      let _4 = await n3(v2);
      b4 += _4.stdout, $5 += _4.stderr, C2 = _4.exitCode;
    }
  } catch (v2) {
    if (y2(), v2 instanceof b$i) throw v2;
    if (v2 instanceof $$a) {
      b4 += v2.stdout, $5 += v2.stderr;
      let k3 = P$f(b4, $5, 0);
      return j$a(e5, k3, t4.redirections);
    }
    if (v2 instanceof c$7 || v2 instanceof a$1) {
      b4 += v2.stdout, $5 += v2.stderr;
      let k3 = P$f(b4, $5, 0);
      return j$a(e5, k3, t4.redirections);
    }
    if (v2 instanceof d$8) {
      b4 += v2.stdout, $5 += v2.stderr;
      let k3 = P$f(b4, $5, v2.exitCode);
      return j$a(e5, k3, t4.redirections);
    }
    if (v2 instanceof i$6) {
      b4 += v2.stdout, $5 += v2.stderr;
      let k3 = P$f(b4, $5, v2.exitCode);
      return j$a(e5, k3, t4.redirections);
    }
    if (v2 instanceof u$8) {
      let k3 = P$f(b4 + v2.stdout, $5 + v2.stderr, v2.exitCode);
      return j$a(e5, k3, t4.redirections);
    }
    let _4 = P$f(b4, `${$5}${n$5(v2)}
`, 1);
    return j$a(e5, _4, t4.redirections);
  }
  y2();
  let g2 = P$f(b4, $5, C2);
  return j$a(e5, g2, t4.redirections);
}
async function Cr(e5, t4, s3, n3) {
  let r2 = "", i4 = "", o2 = 0, a3 = await _t$1(e5, t4.redirections);
  if (a3) return a3;
  let l3 = s3;
  for (let u3 of t4.redirections) if ((u3.operator === "<<" || u3.operator === "<<-") && u3.target.type === "HereDoc") {
    let d3 = u3.target, h3 = await wt$5(e5, d3.content);
    d3.stripTabs && (h3 = h3.split(`
`).map((p3) => p3.replace(/^\t+/, "")).join(`
`));
    let m3 = u3.fd ?? 0;
    m3 !== 0 ? (e5.state.fileDescriptors || (e5.state.fileDescriptors = /* @__PURE__ */ new Map()), e5.state.fileDescriptors.set(m3, h3)) : l3 = h3;
  } else if (u3.operator === "<<<" && u3.target.type === "Word") l3 = `${await wt$5(e5, u3.target)}
`;
  else if (u3.operator === "<" && u3.target.type === "Word") try {
    let d3 = await wt$5(e5, u3.target), h3 = e5.fs.resolvePath(e5.state.cwd, d3);
    l3 = await e5.fs.readFile(h3);
  } catch {
    let d3 = await wt$5(e5, u3.target);
    return P$f("", `bash: ${d3}: No such file or directory
`, 1);
  }
  let c3 = e5.state.groupStdin;
  l3 && (e5.state.groupStdin = l3);
  try {
    for (let u3 of t4.body) {
      let d3 = await n3(u3);
      r2 += d3.stdout, i4 += d3.stderr, o2 = d3.exitCode;
    }
  } catch (u3) {
    if (e5.state.groupStdin = c3, u3 instanceof b$i) throw u3;
    if (C$h(u3) || u3 instanceof u$8 || u3 instanceof d$8) throw u3.prependOutput(r2, i4), u3;
    return P$f(r2, `${i4}${n$5(u3)}
`, 1);
  }
  e5.state.groupStdin = c3;
  let f3 = P$f(r2, i4, o2);
  return j$a(e5, f3, t4.redirections);
}
async function kr(e5, t4, s3, n3, r2) {
  let i4;
  try {
    i4 = await e5.fs.readFile(t4);
  } catch {
    return S$d(`bash: ${t4}: No such file or directory
`, 127);
  }
  if (i4.startsWith("#!")) {
    let w4 = i4.indexOf(`
`);
    w4 !== -1 && (i4 = i4.slice(w4 + 1));
  }
  let o2 = { ...e5.state.env }, a3 = e5.state.cwd, l3 = { ...e5.state.options }, c3 = e5.state.loopDepth, f3 = e5.state.parentHasLoopContext, u3 = e5.state.lastArg, d3 = e5.state.bashPid, h3 = e5.state.groupStdin, m3 = e5.state.currentSource;
  e5.state.parentHasLoopContext = c3 > 0, e5.state.loopDepth = 0, e5.state.bashPid = e5.state.nextVirtualPid++, n3 && (e5.state.groupStdin = n3), e5.state.currentSource = t4, e5.state.env[0] = t4, e5.state.env["#"] = String(s3.length), e5.state.env["@"] = s3.join(" "), e5.state.env["*"] = s3.join(" ");
  for (let w4 = 0; w4 < s3.length && w4 < 9; w4++) e5.state.env[String(w4 + 1)] = s3[w4];
  for (let w4 = s3.length + 1; w4 <= 9; w4++) delete e5.state.env[String(w4)];
  let p3 = () => {
    e5.state.env = o2, e5.state.cwd = a3, e5.state.options = l3, e5.state.loopDepth = c3, e5.state.parentHasLoopContext = f3, e5.state.lastArg = u3, e5.state.bashPid = d3, e5.state.groupStdin = h3, e5.state.currentSource = m3;
  };
  try {
    let b4 = new T$9().parse(i4), $5 = await r2(b4);
    return p3(), $5;
  } catch (w4) {
    if (p3(), w4 instanceof d$8 || w4 instanceof b$i) throw w4;
    if (w4.name === "ParseException") return S$d(`bash: ${t4}: ${w4.message}
`);
    throw w4;
  }
}
var nt$4 = class nt {
  ctx;
  constructor(t4, s3) {
    this.ctx = { state: s3, fs: t4.fs, commands: t4.commands, limits: t4.limits, execFn: t4.exec, executeScript: this.executeScript.bind(this), executeStatement: this.executeStatement.bind(this), executeCommand: this.executeCommand.bind(this), fetch: t4.fetch, sleep: t4.sleep, trace: t4.trace };
  }
  buildExportedEnv() {
    let t4 = this.ctx.state.exportedVars, s3 = this.ctx.state.tempExportedVars, n3 = /* @__PURE__ */ new Set();
    if (t4) for (let i4 of t4) n3.add(i4);
    if (s3) for (let i4 of s3) n3.add(i4);
    if (n3.size === 0) return {};
    let r2 = {};
    for (let i4 of n3) {
      let o2 = this.ctx.state.env[i4];
      o2 !== void 0 && (r2[i4] = o2);
    }
    return r2;
  }
  async executeScript(t4) {
    let s3 = "", n3 = "", r2 = 0;
    for (let i4 of t4.statements) try {
      let o2 = await this.executeStatement(i4);
      s3 += o2.stdout, n3 += o2.stderr, r2 = o2.exitCode, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2);
    } catch (o2) {
      if (o2 instanceof d$8) throw o2.prependOutput(s3, n3), o2;
      if (o2 instanceof f$7) return s3 += o2.stdout, n3 += o2.stderr, r2 = o2.exitCode, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2), { stdout: s3, stderr: n3, exitCode: r2, env: { ...this.ctx.state.env } };
      if (o2 instanceof b$i) throw o2;
      if (o2 instanceof u$8) return s3 += o2.stdout, n3 += o2.stderr, r2 = o2.exitCode, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2), { stdout: s3, stderr: n3, exitCode: r2, env: { ...this.ctx.state.env } };
      if (o2 instanceof x$h) return s3 += o2.stdout, n3 += o2.stderr, r2 = 1, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2), { stdout: s3, stderr: n3, exitCode: r2, env: { ...this.ctx.state.env } };
      if (o2 instanceof h$f) return s3 += o2.stdout, n3 += o2.stderr, r2 = 1, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2), { stdout: s3, stderr: n3, exitCode: r2, env: { ...this.ctx.state.env } };
      if (o2 instanceof p$f) {
        s3 += o2.stdout, n3 += o2.stderr, r2 = 1, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2);
        continue;
      }
      if (o2 instanceof m$e) {
        s3 += o2.stdout, n3 += o2.stderr, r2 = 1, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2);
        continue;
      }
      if (o2 instanceof c$7 || o2 instanceof a$1) {
        if (this.ctx.state.loopDepth > 0) throw o2.prependOutput(s3, n3), o2;
        s3 += o2.stdout, n3 += o2.stderr;
        continue;
      }
      throw o2 instanceof i$6 && o2.prependOutput(s3, n3), o2;
    }
    return { stdout: s3, stderr: n3, exitCode: r2, env: { ...this.ctx.state.env } };
  }
  async executeUserScript(t4, s3, n3 = "") {
    return kr(this.ctx, t4, s3, n3, (r2) => this.executeScript(r2));
  }
  async executeStatement(t4) {
    if (this.ctx.state.commandCount++, this.ctx.state.commandCount > this.ctx.limits.maxCommandCount && Se$5(`too many commands executed (>${this.ctx.limits.maxCommandCount}), increase executionLimits.maxCommandCount`, "commands"), t4.deferredError) throw new Q$9(t4.deferredError.message, t4.line ?? 1, 1);
    if (this.ctx.state.options.noexec) return L$d;
    this.ctx.state.errexitSafe = false;
    let s3 = "", n3 = "";
    this.ctx.state.options.verbose && !this.ctx.state.suppressVerbose && t4.sourceText && (n3 += `${t4.sourceText}
`);
    let r2 = 0, i4 = -1, o2 = false;
    for (let c3 = 0; c3 < t4.pipelines.length; c3++) {
      let f3 = t4.pipelines[c3], u3 = c3 > 0 ? t4.operators[c3 - 1] : null;
      if (u3 === "&&" && r2 !== 0 || u3 === "||" && r2 === 0) continue;
      let d3 = await this.executePipeline(f3);
      s3 += d3.stdout, n3 += d3.stderr, r2 = d3.exitCode, i4 = c3, o2 = f3.negated, this.ctx.state.lastExitCode = r2, this.ctx.state.env["?"] = String(r2);
    }
    let a3 = i4 < t4.pipelines.length - 1, l3 = this.ctx.state.errexitSafe;
    if (this.ctx.state.errexitSafe = a3 || o2 || l3, this.ctx.state.options.errexit && r2 !== 0 && i4 === t4.pipelines.length - 1 && !o2 && !this.ctx.state.inCondition && !l3) throw new u$8(r2, s3, n3);
    return P$f(s3, n3, r2);
  }
  async executePipeline(t4) {
    return Ar(this.ctx, t4, (s3, n3) => this.executeCommand(s3, n3));
  }
  async executeCommand(t4, s3) {
    switch (t4.type) {
      case "SimpleCommand":
        return this.executeSimpleCommand(t4, s3);
      case "If":
        return hr(this.ctx, t4);
      case "For":
        return pr(this.ctx, t4);
      case "CStyleFor":
        return mr(this.ctx, t4);
      case "While":
        return yr(this.ctx, t4, s3);
      case "Until":
        return wr(this.ctx, t4);
      case "Case":
        return gr(this.ctx, t4);
      case "Subshell":
        return this.executeSubshell(t4, s3);
      case "Group":
        return this.executeGroup(t4, s3);
      case "FunctionDef":
        return xn(this.ctx, t4);
      case "ArithmeticCommand":
        return this.executeArithmeticCommand(t4);
      case "ConditionalCommand":
        return this.executeConditionalCommand(t4);
      default:
        return L$d;
    }
  }
  async executeSimpleCommand(t4, s3) {
    try {
      return await this.executeSimpleCommandInner(t4, s3);
    } catch (n3) {
      if (n3 instanceof l$7) return S$d(n3.stderr);
      throw n3;
    }
  }
  async executeSimpleCommandInner(t4, s3) {
    if (t4.line !== void 0 && (this.ctx.state.currentLine = t4.line), this.ctx.state.shoptOptions.expand_aliases && t4.name) {
      let y2 = t4, g2 = 100;
      for (; g2 > 0; ) {
        let v2 = this.expandAlias(y2);
        if (v2 === y2) break;
        y2 = v2, g2--;
      }
      this.aliasExpansionStack.clear(), y2 !== t4 && (t4 = y2);
    }
    this.ctx.state.expansionStderr = "";
    let n3 = await Pr(this.ctx, t4);
    if (n3.error) return n3.error;
    let r2 = n3.tempAssignments, i4 = n3.xtraceOutput;
    if (!t4.name) {
      if (t4.redirections.length > 0) {
        let g2 = await we$5(this.ctx, t4.redirections);
        if (g2) return g2;
        let v2 = P$f("", i4, 0);
        return j$a(this.ctx, v2, t4.redirections);
      }
      this.ctx.state.lastArg = "";
      let y2 = (this.ctx.state.expansionStderr || "") + i4;
      return this.ctx.state.expansionStderr = "", P$f("", y2, this.ctx.state.lastExitCode);
    }
    let o2 = t4.name && Ms(t4.name, ["local", "declare", "typeset", "export", "readonly"]), a3 = Object.keys(r2);
    if (a3.length > 0 && !o2) {
      this.ctx.state.tempExportedVars = this.ctx.state.tempExportedVars || /* @__PURE__ */ new Set();
      for (let y2 of a3) this.ctx.state.tempExportedVars.add(y2);
    }
    let l3 = await _t$1(this.ctx, t4.redirections);
    if (l3) {
      for (let [y2, g2] of Object.entries(r2)) g2 === void 0 ? delete this.ctx.state.env[y2] : this.ctx.state.env[y2] = g2;
      return l3;
    }
    let c3 = -1;
    for (let y2 of t4.redirections) {
      if ((y2.operator === "<<" || y2.operator === "<<-") && y2.target.type === "HereDoc") {
        let g2 = y2.target, v2 = await wt$5(this.ctx, g2.content);
        g2.stripTabs && (v2 = v2.split(`
`).map((k3) => k3.replace(/^\t+/, "")).join(`
`));
        let _4 = y2.fd ?? 0;
        _4 !== 0 ? (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), this.ctx.state.fileDescriptors.set(_4, v2)) : s3 = v2;
        continue;
      }
      if (y2.operator === "<<<" && y2.target.type === "Word") {
        s3 = `${await wt$5(this.ctx, y2.target)}
`;
        continue;
      }
      if (y2.operator === "<" && y2.target.type === "Word") try {
        let g2 = await wt$5(this.ctx, y2.target), v2 = this.ctx.fs.resolvePath(this.ctx.state.cwd, g2);
        s3 = await this.ctx.fs.readFile(v2);
      } catch {
        let g2 = await wt$5(this.ctx, y2.target);
        for (let [v2, _4] of Object.entries(r2)) _4 === void 0 ? delete this.ctx.state.env[v2] : this.ctx.state.env[v2] = _4;
        return S$d(`bash: ${g2}: No such file or directory
`);
      }
      if (y2.operator === "<&" && y2.target.type === "Word") {
        let g2 = await wt$5(this.ctx, y2.target), v2 = Number.parseInt(g2, 10);
        if (!Number.isNaN(v2) && this.ctx.state.fileDescriptors) {
          let _4 = this.ctx.state.fileDescriptors.get(v2);
          if (_4 !== void 0) if (_4.startsWith("__rw__:")) {
            let k3 = vr(_4);
            k3 && (s3 = k3.content.slice(k3.position), c3 = v2);
          } else _4.startsWith("__file__:") || _4.startsWith("__file_append__:") || (s3 = _4);
        }
      }
    }
    let f3 = await wt$5(this.ctx, t4.name), u3 = [], d3 = [];
    if (Ms(t4.name, ["local", "declare", "typeset", "export", "readonly"]) && (f3 === "local" || f3 === "declare" || f3 === "typeset" || f3 === "export" || f3 === "readonly")) for (let y2 of t4.args) {
      let g2 = await gn(this.ctx, y2);
      if (g2) u3.push(g2), d3.push(true);
      else {
        let v2 = await vn(this.ctx, y2);
        if (v2 !== null) u3.push(v2), d3.push(true);
        else {
          let _4 = await ul$1(this.ctx, y2);
          for (let k3 of _4.values) u3.push(k3), d3.push(_4.quoted);
        }
      }
    }
    else for (let y2 of t4.args) {
      let g2 = await ul$1(this.ctx, y2);
      for (let v2 of g2.values) u3.push(v2), d3.push(g2.quoted);
    }
    if (!f3) {
      if (t4.name.parts.every((g2) => g2.type === "CommandSubstitution" || g2.type === "ParameterExpansion" || g2.type === "ArithmeticExpansion")) {
        if (u3.length > 0) {
          let g2 = u3.shift();
          return d3.shift(), await this.runCommand(g2, u3, d3, s3, false, false, c3);
        }
        return P$f("", "", this.ctx.state.lastExitCode);
      }
      return S$d(`bash: : command not found
`, 127);
    }
    if (f3 === "exec" && (u3.length === 0 || u3[0] === "--")) {
      for (let y2 of t4.redirections) {
        if (y2.target.type === "HereDoc" || y2.fdVariable) continue;
        let g2 = await wt$5(this.ctx, y2.target), v2 = y2.fd ?? (y2.operator === "<" || y2.operator === "<>" ? 0 : 1);
        switch (this.ctx.state.fileDescriptors || (this.ctx.state.fileDescriptors = /* @__PURE__ */ new Map()), y2.operator) {
          case ">":
          case ">|": {
            let _4 = this.ctx.fs.resolvePath(this.ctx.state.cwd, g2);
            await this.ctx.fs.writeFile(_4, "", "utf8"), this.ctx.state.fileDescriptors.set(v2, `__file__:${_4}`);
            break;
          }
          case ">>": {
            let _4 = this.ctx.fs.resolvePath(this.ctx.state.cwd, g2);
            this.ctx.state.fileDescriptors.set(v2, `__file_append__:${_4}`);
            break;
          }
          case "<": {
            let _4 = this.ctx.fs.resolvePath(this.ctx.state.cwd, g2);
            try {
              let k3 = await this.ctx.fs.readFile(_4);
              this.ctx.state.fileDescriptors.set(v2, k3);
            } catch {
              return S$d(`bash: ${g2}: No such file or directory
`);
            }
            break;
          }
          case "<>": {
            let _4 = this.ctx.fs.resolvePath(this.ctx.state.cwd, g2);
            try {
              let k3 = await this.ctx.fs.readFile(_4);
              this.ctx.state.fileDescriptors.set(v2, `__rw__:${_4.length}:${_4}:0:${k3}`);
            } catch {
              await this.ctx.fs.writeFile(_4, "", "utf8"), this.ctx.state.fileDescriptors.set(v2, `__rw__:${_4.length}:${_4}:0:`);
            }
            break;
          }
          case ">&": {
            if (g2 === "-") this.ctx.state.fileDescriptors.delete(v2);
            else if (g2.endsWith("-")) {
              let _4 = g2.slice(0, -1), k3 = Number.parseInt(_4, 10);
              if (!Number.isNaN(k3)) {
                let T3 = this.ctx.state.fileDescriptors.get(k3);
                T3 !== void 0 ? this.ctx.state.fileDescriptors.set(v2, T3) : this.ctx.state.fileDescriptors.set(v2, `__dupout__:${k3}`), this.ctx.state.fileDescriptors.delete(k3);
              }
            } else {
              let _4 = Number.parseInt(g2, 10);
              Number.isNaN(_4) || this.ctx.state.fileDescriptors.set(v2, `__dupout__:${_4}`);
            }
            break;
          }
          case "<&": {
            if (g2 === "-") this.ctx.state.fileDescriptors.delete(v2);
            else if (g2.endsWith("-")) {
              let _4 = g2.slice(0, -1), k3 = Number.parseInt(_4, 10);
              if (!Number.isNaN(k3)) {
                let T3 = this.ctx.state.fileDescriptors.get(k3);
                T3 !== void 0 ? this.ctx.state.fileDescriptors.set(v2, T3) : this.ctx.state.fileDescriptors.set(v2, `__dupin__:${k3}`), this.ctx.state.fileDescriptors.delete(k3);
              }
            } else {
              let _4 = Number.parseInt(g2, 10);
              Number.isNaN(_4) || this.ctx.state.fileDescriptors.set(v2, `__dupin__:${_4}`);
            }
            break;
          }
        }
      }
      for (let [y2, g2] of Object.entries(r2)) g2 === void 0 ? delete this.ctx.state.env[y2] : this.ctx.state.env[y2] = g2;
      if (this.ctx.state.tempExportedVars) for (let y2 of Object.keys(r2)) this.ctx.state.tempExportedVars.delete(y2);
      return L$d;
    }
    let m3 = await $r(this.ctx, f3, u3);
    Object.keys(r2).length > 0 && (this.ctx.state.tempEnvBindings = this.ctx.state.tempEnvBindings || [], this.ctx.state.tempEnvBindings.push(new Map(Object.entries(r2))));
    let p3, w4 = null;
    try {
      p3 = await this.runCommand(f3, u3, d3, s3, false, false, c3);
    } catch (y2) {
      if (y2 instanceof c$7 || y2 instanceof a$1) w4 = y2, p3 = L$d;
      else throw y2;
    }
    let b4 = i4 + m3;
    if (b4 && (p3 = { ...p3, stderr: b4 + p3.stderr }), p3 = await j$a(this.ctx, p3, t4.redirections), w4) throw w4;
    if (u3.length > 0) {
      let y2 = u3[u3.length - 1];
      if ((f3 === "declare" || f3 === "local" || f3 === "typeset") && /^[a-zA-Z_][a-zA-Z0-9_]*=\(/.test(y2)) {
        let g2 = y2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)=\(/);
        g2 && (y2 = g2[1]);
      }
      this.ctx.state.lastArg = y2;
    } else this.ctx.state.lastArg = f3;
    let $5 = Tn(f3) && f3 !== "unset" && f3 !== "eval";
    if (!this.ctx.state.options.posix || !$5) for (let [y2, g2] of Object.entries(r2)) this.ctx.state.fullyUnsetLocals?.has(y2) || (g2 === void 0 ? delete this.ctx.state.env[y2] : this.ctx.state.env[y2] = g2);
    if (this.ctx.state.tempExportedVars) for (let y2 of Object.keys(r2)) this.ctx.state.tempExportedVars.delete(y2);
    return Object.keys(r2).length > 0 && this.ctx.state.tempEnvBindings && this.ctx.state.tempEnvBindings.pop(), this.ctx.state.expansionStderr && (p3 = { ...p3, stderr: this.ctx.state.expansionStderr + p3.stderr }, this.ctx.state.expansionStderr = ""), p3;
  }
  async runCommand(t4, s3, n3, r2, i4 = false, o2 = false, a3 = -1) {
    let l3 = { ctx: this.ctx, runCommand: (f3, u3, d3, h3, m3, p3, w4) => this.runCommand(f3, u3, d3, h3, m3, p3, w4), buildExportedEnv: () => this.buildExportedEnv(), executeUserScript: (f3, u3, d3) => this.executeUserScript(f3, u3, d3) }, c3 = await ur(l3, t4, s3, n3, r2, i4, o2, a3);
    return c3 !== null ? c3 : dr(l3, t4, s3, r2, o2);
  }
  aliasExpansionStack = /* @__PURE__ */ new Set();
  expandAlias(t4) {
    return Gt$1(this.ctx.state, t4, this.aliasExpansionStack);
  }
  async findCommandInPath(t4) {
    return Tt$1(this.ctx, t4);
  }
  async executeSubshell(t4, s3 = "") {
    return Nr(this.ctx, t4, s3, (n3) => this.executeStatement(n3));
  }
  async executeGroup(t4, s3 = "") {
    return Cr(this.ctx, t4, s3, (n3) => this.executeStatement(n3));
  }
  async executeArithmeticCommand(t4) {
    t4.line !== void 0 && (this.ctx.state.currentLine = t4.line);
    let s3 = await we$5(this.ctx, t4.redirections);
    if (s3) return s3;
    try {
      let n3 = await R$a(this.ctx, t4.expression.expression), r2 = Z$6(n3 !== 0);
      return this.ctx.state.expansionStderr && (r2 = { ...r2, stderr: this.ctx.state.expansionStderr + r2.stderr }, this.ctx.state.expansionStderr = ""), j$a(this.ctx, r2, t4.redirections);
    } catch (n3) {
      let r2 = S$d(`bash: arithmetic expression: ${n3.message}
`);
      return j$a(this.ctx, r2, t4.redirections);
    }
  }
  async executeConditionalCommand(t4) {
    t4.line !== void 0 && (this.ctx.state.currentLine = t4.line);
    let s3 = await we$5(this.ctx, t4.redirections);
    if (s3) return s3;
    try {
      let n3 = await ke$6(this.ctx, t4.expression), r2 = Z$6(n3);
      return this.ctx.state.expansionStderr && (r2 = { ...r2, stderr: this.ctx.state.expansionStderr + r2.stderr }, this.ctx.state.expansionStderr = ""), j$a(this.ctx, r2, t4.redirections);
    } catch (n3) {
      let r2 = n3 instanceof p$f ? 1 : 2, i4 = S$d(`bash: conditional expression: ${n3.message}
`, r2);
      return j$a(this.ctx, i4, t4.redirections);
    }
  }
};
var Ae$3 = { maxCallDepth: 100, maxCommandCount: 1e4, maxLoopIterations: 1e4, maxAwkIterations: 1e4, maxSedIterations: 1e4, maxJqIterations: 1e4, maxSqliteTimeoutMs: 5e3, maxPythonTimeoutMs: 3e4 };
function Or(e5) {
  return e5 ? { maxCallDepth: e5.maxCallDepth ?? Ae$3.maxCallDepth, maxCommandCount: e5.maxCommandCount ?? Ae$3.maxCommandCount, maxLoopIterations: e5.maxLoopIterations ?? Ae$3.maxLoopIterations, maxAwkIterations: e5.maxAwkIterations ?? Ae$3.maxAwkIterations, maxSedIterations: e5.maxSedIterations ?? Ae$3.maxSedIterations, maxJqIterations: e5.maxJqIterations ?? Ae$3.maxJqIterations, maxSqliteTimeoutMs: e5.maxSqliteTimeoutMs ?? Ae$3.maxSqliteTimeoutMs, maxPythonTimeoutMs: e5.maxPythonTimeoutMs ?? Ae$3.maxPythonTimeoutMs } : { ...Ae$3 };
}
function Dr$1(e5) {
  try {
    let t4 = new URL(e5);
    return { origin: t4.origin, pathname: t4.pathname, href: t4.href };
  } catch {
    return null;
  }
}
function ao(e5) {
  let t4 = Dr$1(e5);
  return t4 ? { origin: t4.origin, pathPrefix: t4.pathname } : null;
}
function lo(e5, t4) {
  let s3 = Dr$1(e5);
  if (!s3) return false;
  let n3 = ao(t4);
  return !n3 || s3.origin !== n3.origin ? false : n3.pathPrefix === "/" || n3.pathPrefix === "" ? true : s3.pathname.startsWith(n3.pathPrefix);
}
function zs(e5, t4) {
  return !t4 || t4.length === 0 ? false : t4.some((s3) => lo(e5, s3));
}
var Ve$5 = class Ve extends Error {
  constructor(t4) {
    super(`Network access denied: URL not in allow-list: ${t4}`), this.name = "NetworkAccessDeniedError";
  }
}, Be$5 = class Be extends Error {
  constructor(t4) {
    super(`Too many redirects (max: ${t4})`), this.name = "TooManyRedirectsError";
  }
}, je$5 = class je extends Error {
  constructor(t4) {
    super(`Redirect target not in allow-list: ${t4}`), this.name = "RedirectNotAllowedError";
  }
}, xt$1 = class xt extends Error {
  constructor(t4, s3) {
    super(`HTTP method '${t4}' not allowed. Allowed methods: ${s3.join(", ")}`), this.name = "MethodNotAllowedError";
  }
};
var co$1 = 20, fo$1 = 3e4, uo = ["GET", "HEAD"], ho$1 = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]), po = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
function Vs(e5) {
  let t4 = e5.maxRedirects ?? co$1, s3 = e5.timeoutMs ?? fo$1, n3 = e5.dangerouslyAllowFullInternetAccess ? ["GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"] : e5.allowedMethods ?? uo;
  function r2(a3) {
    if (!e5.dangerouslyAllowFullInternetAccess && !zs(a3, e5.allowedUrlPrefixes ?? [])) throw new Ve$5(a3);
  }
  function i4(a3) {
    if (e5.dangerouslyAllowFullInternetAccess) return;
    let l3 = a3.toUpperCase();
    if (!n3.includes(l3)) throw new xt$1(l3, n3);
  }
  async function o2(a3, l3 = {}) {
    let c3 = l3.method?.toUpperCase() ?? "GET";
    r2(a3), i4(c3);
    let f3 = a3, u3 = 0, d3 = l3.followRedirects ?? true, h3 = l3.timeoutMs !== void 0 ? Math.min(l3.timeoutMs, s3) : s3;
    for (; ; ) {
      let m3 = new AbortController(), p3 = setTimeout(() => m3.abort(), h3);
      try {
        let w4 = { method: c3, headers: l3.headers, signal: m3.signal, redirect: "manual" };
        l3.body && !ho$1.has(c3) && (w4.body = l3.body);
        let b4 = await fetch(f3, w4);
        if (po.has(b4.status) && d3) {
          let $5 = b4.headers.get("location");
          if (!$5) return await Ir(b4, f3);
          let C2 = new URL($5, f3).href;
          if (!e5.dangerouslyAllowFullInternetAccess && !zs(C2, e5.allowedUrlPrefixes ?? [])) throw new je$5(C2);
          if (u3++, u3 > t4) throw new Be$5(t4);
          f3 = C2;
          continue;
        }
        return await Ir(b4, f3);
      } finally {
        clearTimeout(p3);
      }
    }
  }
  return o2;
}
async function Ir(e5, t4) {
  let s3 = {};
  return e5.headers.forEach((n3, r2) => {
    s3[r2.toLowerCase()] = n3;
  }), { status: e5.status, statusText: e5.statusText, headers: s3, body: await e5.text(), url: t4 };
}
var Pe$4 = class e3 {
  static classId = "just-bash/Bash";
  fs;
  commands = /* @__PURE__ */ new Map();
  useDefaultLayout = false;
  limits;
  secureFetch;
  sleepFn;
  traceFn;
  logger;
  state;
  constructor(t4 = {}) {
    let s3 = t4.fs ?? new oe$7(t4.files);
    this.fs = s3, this.useDefaultLayout = !t4.cwd && !t4.files;
    let n3 = t4.cwd || (this.useDefaultLayout ? "/home/user" : "/"), r2 = { HOME: this.useDefaultLayout ? "/home/user" : "/", PATH: "/usr/bin:/bin", IFS: ` 	
`, OSTYPE: "linux-gnu", MACHTYPE: "x86_64-pc-linux-gnu", HOSTTYPE: "x86_64", HOSTNAME: "localhost", PWD: n3, OLDPWD: n3, OPTIND: "1", ...t4.env };
    if (this.limits = Or({ ...t4.executionLimits, ...t4.maxCallDepth !== void 0 && { maxCallDepth: t4.maxCallDepth }, ...t4.maxCommandCount !== void 0 && { maxCommandCount: t4.maxCommandCount }, ...t4.maxLoopIterations !== void 0 && { maxLoopIterations: t4.maxLoopIterations } }), t4.network && (this.secureFetch = Vs(t4.network)), this.sleepFn = t4.sleep, this.traceFn = t4.trace, this.logger = t4.logger, this.state = { env: r2, cwd: n3, previousDir: "/home/user", functions: /* @__PURE__ */ new Map(), localScopes: [], callDepth: 0, sourceDepth: 0, commandCount: 0, lastExitCode: 0, lastArg: "", startTime: Date.now(), lastBackgroundPid: 0, bashPid: process.pid, nextVirtualPid: process.pid + 1, currentLine: 1, options: { errexit: false, pipefail: false, nounset: false, xtrace: false, verbose: false, posix: false, allexport: false, noclobber: false, noglob: false, noexec: false, vi: false, emacs: false }, shoptOptions: { extglob: false, dotglob: false, nullglob: false, failglob: false, globstar: false, globskipdots: true, nocaseglob: false, nocasematch: false, expand_aliases: false, lastpipe: false, xpg_echo: false }, inCondition: false, loopDepth: 0, exportedVars: /* @__PURE__ */ new Set(["HOME", "PATH", "PWD", "OLDPWD", ...Object.keys(t4.env || {})]), readonlyVars: /* @__PURE__ */ new Set(["SHELLOPTS", "BASHOPTS"]), hashTable: /* @__PURE__ */ new Map() }, this.state.env.SHELLOPTS = Ut$1(this.state.options), this.state.env.BASHOPTS = Zt$2(this.state.shoptOptions), dn$1(s3, this.useDefaultLayout), n3 !== "/" && s3 instanceof oe$7) try {
      s3.mkdirSync(n3, { recursive: true });
    } catch {
    }
    for (let i4 of ln(t4.commands)) this.registerCommand(i4);
    if (t4.network) for (let i4 of cn()) this.registerCommand(i4);
    if (t4.customCommands) for (let i4 of t4.customCommands) fn$2(i4) ? this.registerCommand(un(i4)) : this.registerCommand(i4);
  }
  static _serialize(t4) {
    return { fs: t4.fs, state: t4.state, limits: t4.limits };
  }
  static _deserialize(t4) {
    let s3 = new e3({ fs: t4.fs });
    return s3.state = t4.state, s3.limits = t4.limits, s3;
  }
  registerCommand(t4) {
    this.commands.set(t4.name, t4);
    let s3 = this.fs;
    if (typeof s3.writeFileSync == "function") {
      let n3 = `#!/bin/bash
# Built-in command: ${t4.name}
`;
      try {
        s3.writeFileSync(`/bin/${t4.name}`, n3);
      } catch {
      }
      try {
        s3.writeFileSync(`/usr/bin/${t4.name}`, n3);
      } catch {
      }
    }
  }
  logResult(t4) {
    return this.logger && (t4.stdout && this.logger.debug("stdout", { output: t4.stdout }), t4.stderr && this.logger.info("stderr", { output: t4.stderr }), this.logger.info("exit", { exitCode: t4.exitCode })), t4;
  }
  async exec(t4, s3) {
    if (this.state.callDepth === 0 && (this.state.commandCount = 0), this.state.commandCount++, this.state.commandCount > this.limits.maxCommandCount) return { stdout: "", stderr: `bash: maximum command count (${this.limits.maxCommandCount}) exceeded (possible infinite loop). Increase with executionLimits.maxCommandCount option.
`, exitCode: 1, env: { ...this.state.env, ...s3?.env } };
    if (!t4.trim()) return { stdout: "", stderr: "", exitCode: 0, env: { ...this.state.env, ...s3?.env } };
    this.logger?.info("exec", { command: t4 });
    let n3 = s3?.cwd ?? this.state.cwd, r2, i4 = n3;
    if (s3?.cwd) if (s3.env && "PWD" in s3.env) r2 = s3.env.PWD;
    else if (s3?.env && !("PWD" in s3.env)) try {
      r2 = await this.fs.realpath(n3), i4 = r2;
    } catch {
      r2 = n3;
    }
    else r2 = n3;
    let o2 = { ...this.state, env: { ...this.state.env, ...s3?.env, ...r2 !== void 0 ? { PWD: r2 } : {} }, cwd: i4, functions: new Map(this.state.functions), localScopes: [...this.state.localScopes], options: { ...this.state.options }, hashTable: this.state.hashTable }, a3 = t4;
    s3?.rawScript || (a3 = mo(t4));
    try {
      let l3 = ci$1(a3), c3 = { fs: this.fs, commands: this.commands, limits: this.limits, exec: this.exec.bind(this), fetch: this.secureFetch, sleep: this.sleepFn, trace: this.traceFn }, u3 = await new nt$4(c3, o2).executeScript(l3);
      return this.logResult(u3);
    } catch (l3) {
      if (l3 instanceof d$8) return this.logResult({ stdout: l3.stdout, stderr: l3.stderr, exitCode: l3.exitCode, env: { ...this.state.env, ...s3?.env } });
      if (l3 instanceof f$7) return this.logResult({ stdout: l3.stdout, stderr: l3.stderr, exitCode: l3.exitCode, env: { ...this.state.env, ...s3?.env } });
      if (l3 instanceof p$f) return this.logResult({ stdout: l3.stdout, stderr: l3.stderr, exitCode: 1, env: { ...this.state.env, ...s3?.env } });
      if (l3 instanceof b$i) return this.logResult({ stdout: l3.stdout, stderr: l3.stderr, exitCode: b$i.EXIT_CODE, env: { ...this.state.env, ...s3?.env } });
      if (l3.name === "ParseException") return this.logResult({ stdout: "", stderr: `bash: syntax error: ${l3.message}
`, exitCode: 2, env: { ...this.state.env, ...s3?.env } });
      if (l3 instanceof he$6) return this.logResult({ stdout: "", stderr: `bash: ${l3.message}
`, exitCode: 2, env: { ...this.state.env, ...s3?.env } });
      if (l3 instanceof RangeError) return this.logResult({ stdout: "", stderr: `bash: ${l3.message}
`, exitCode: 1, env: { ...this.state.env, ...s3?.env } });
      throw l3;
    }
  }
  async readFile(t4) {
    return this.fs.readFile(this.fs.resolvePath(this.state.cwd, t4));
  }
  async writeFile(t4, s3) {
    return this.fs.writeFile(this.fs.resolvePath(this.state.cwd, t4), s3);
  }
  getCwd() {
    return this.state.cwd;
  }
  getEnv() {
    return { ...this.state.env };
  }
};
Pe$4[Ge$3] = Pe$4._serialize;
Pe$4[Ke$3] = Pe$4._deserialize;
function mo(e5) {
  let t4 = e5.split(`
`), s3 = [], n3 = [];
  for (let r2 = 0; r2 < t4.length; r2++) {
    let i4 = t4[r2];
    if (n3.length > 0) {
      let l3 = n3[n3.length - 1];
      if ((l3.stripTabs ? i4.replace(/^\t+/, "") : i4) === l3.delimiter) {
        s3.push(i4.trimStart()), n3.pop();
        continue;
      }
      s3.push(i4);
      continue;
    }
    let o2 = i4.trimStart();
    s3.push(o2);
    let a3 = /<<(-?)\s*(['"]?)([\w-]+)\2/g;
    for (let l3 of o2.matchAll(a3)) {
      let c3 = l3[1] === "-", f3 = l3[3];
      n3.push({ delimiter: f3, stripTabs: c3 });
    }
  }
  return s3.join(`
`);
}
function c$6(a3) {
  let s3 = "", e5 = 0;
  for (; e5 < a3.length; ) if (a3[e5] === "\\") {
    if (e5 + 1 >= a3.length) {
      s3 += "\\";
      break;
    }
    let o2 = a3[e5 + 1];
    switch (o2) {
      case "\\":
        s3 += "\\", e5 += 2;
        break;
      case "n":
        s3 += `
`, e5 += 2;
        break;
      case "t":
        s3 += "	", e5 += 2;
        break;
      case "r":
        s3 += "\r", e5 += 2;
        break;
      case "a":
        s3 += "\x07", e5 += 2;
        break;
      case "b":
        s3 += "\b", e5 += 2;
        break;
      case "f":
        s3 += "\f", e5 += 2;
        break;
      case "v":
        s3 += "\v", e5 += 2;
        break;
      case "e":
      case "E":
        s3 += "\x1B", e5 += 2;
        break;
      case "c":
        return { output: s3, stop: true };
      case "0": {
        let r2 = "", t4 = e5 + 2;
        for (; t4 < a3.length && t4 < e5 + 5 && /[0-7]/.test(a3[t4]); ) r2 += a3[t4], t4++;
        if (r2.length === 0) s3 += "\0";
        else {
          let l3 = parseInt(r2, 8) % 256;
          s3 += String.fromCharCode(l3);
        }
        e5 = t4;
        break;
      }
      case "x": {
        let r2 = "", t4 = e5 + 2;
        for (; t4 < a3.length && t4 < e5 + 4 && /[0-9a-fA-F]/.test(a3[t4]); ) r2 += a3[t4], t4++;
        if (r2.length === 0) s3 += "\\x", e5 += 2;
        else {
          let l3 = parseInt(r2, 16);
          s3 += String.fromCharCode(l3), e5 = t4;
        }
        break;
      }
      case "u": {
        let r2 = "", t4 = e5 + 2;
        for (; t4 < a3.length && t4 < e5 + 6 && /[0-9a-fA-F]/.test(a3[t4]); ) r2 += a3[t4], t4++;
        if (r2.length === 0) s3 += "\\u", e5 += 2;
        else {
          let l3 = parseInt(r2, 16);
          s3 += String.fromCodePoint(l3), e5 = t4;
        }
        break;
      }
      case "U": {
        let r2 = "", t4 = e5 + 2;
        for (; t4 < a3.length && t4 < e5 + 10 && /[0-9a-fA-F]/.test(a3[t4]); ) r2 += a3[t4], t4++;
        if (r2.length === 0) s3 += "\\U", e5 += 2;
        else {
          let l3 = parseInt(r2, 16);
          try {
            s3 += String.fromCodePoint(l3);
          } catch {
            s3 += `\\U${r2}`;
          }
          e5 = t4;
        }
        break;
      }
      default:
        s3 += `\\${o2}`, e5 += 2;
    }
  } else s3 += a3[e5], e5++;
  return { output: s3, stop: false };
}
var n$3 = { name: "echo", async execute(a3, s3) {
  let e5 = false, o2 = s3.xpgEcho ?? false, r2 = 0;
  for (; r2 < a3.length; ) {
    let l3 = a3[r2];
    if (l3 === "-n") e5 = true, r2++;
    else if (l3 === "-e") o2 = true, r2++;
    else if (l3 === "-E") o2 = false, r2++;
    else if (l3 === "-ne" || l3 === "-en") e5 = true, o2 = true, r2++;
    else break;
  }
  let t4 = a3.slice(r2).join(" ");
  if (o2) {
    let l3 = c$6(t4);
    if (t4 = l3.output, l3.stop) return { stdout: t4, stderr: "", exitCode: 0 };
  }
  return e5 || (t4 += `
`), { stdout: t4, stderr: "", exitCode: 0 };
} };
const echo6S7WE7XB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  echoCommand: n$3
});
async function y$e(t4, n3, s3) {
  let { cmdName: r2, allowStdinMarker: f3 = true, stopOnError: a3 = false, batchSize: u3 = 100 } = s3;
  if (n3.length === 0) return { files: [{ filename: "", content: t4.stdin }], stderr: "", exitCode: 0 };
  let i4 = [], c3 = "", l3 = 0;
  for (let o2 = 0; o2 < n3.length; o2 += u3) {
    let d3 = n3.slice(o2, o2 + u3), m3 = await Promise.all(d3.map(async (e5) => {
      if (f3 && e5 === "-") return { filename: "-", content: t4.stdin, error: null };
      try {
        let h3 = t4.fs.resolvePath(t4.cwd, e5), p3 = await t4.fs.readFile(h3, "binary");
        return { filename: e5, content: p3, error: null };
      } catch {
        return { filename: e5, content: "", error: `${r2}: ${e5}: No such file or directory
` };
      }
    }));
    for (let e5 of m3) if (e5.error) {
      if (c3 += e5.error, l3 = 1, a3) return { files: i4, stderr: c3, exitCode: l3 };
    } else i4.push({ filename: e5.filename, content: e5.content });
  }
  return { files: i4, stderr: c3, exitCode: l3 };
}
async function b$g(t4, n3, s3) {
  let r2 = await y$e(t4, n3, { ...s3, stopOnError: true });
  return r2.exitCode !== 0 ? { ok: false, error: { stdout: "", stderr: r2.stderr, exitCode: r2.exitCode } } : { ok: true, content: r2.files.map((a3) => a3.content).join("") };
}
function s$1(t4) {
  let e5 = `${t4.name} - ${t4.summary}

`;
  if (e5 += `Usage: ${t4.usage}
`, t4.description) {
    if (e5 += `
Description:
`, typeof t4.description == "string") for (let n3 of t4.description.split(`
`)) e5 += n3 ? `  ${n3}
` : `
`;
    else if (t4.description.length > 0) for (let n3 of t4.description) e5 += n3 ? `  ${n3}
` : `
`;
  }
  if (t4.options && t4.options.length > 0) {
    e5 += `
Options:
`;
    for (let n3 of t4.options) e5 += `  ${n3}
`;
  }
  if (t4.examples && t4.examples.length > 0) {
    e5 += `
Examples:
`;
    for (let n3 of t4.examples) e5 += `  ${n3}
`;
  }
  if (t4.notes && t4.notes.length > 0) {
    e5 += `
Notes:
`;
    for (let n3 of t4.notes) e5 += `  ${n3}
`;
  }
  return { stdout: e5, stderr: "", exitCode: 0 };
}
function o$3(t4) {
  return t4.includes("--help");
}
function r$3(t4, e5) {
  return { stdout: "", stderr: e5.startsWith("--") ? `${t4}: unrecognized option '${e5}'
` : `${t4}: invalid option -- '${e5.replace(/^-/, "")}'
`, exitCode: 1 };
}
function x$g(a3, i4, d3) {
  let g2 = /* @__PURE__ */ new Map(), h3 = /* @__PURE__ */ new Map();
  for (let [t4, e5] of Object.entries(d3)) {
    let n3 = { name: t4, type: e5.type };
    e5.short && g2.set(e5.short, n3), e5.long && h3.set(e5.long, n3);
  }
  let s3 = {};
  for (let [t4, e5] of Object.entries(d3)) e5.default !== void 0 ? s3[t4] = e5.default : e5.type === "boolean" && (s3[t4] = false);
  let b4 = [], k3 = false;
  for (let t4 = 0; t4 < i4.length; t4++) {
    let e5 = i4[t4];
    if (k3 || !e5.startsWith("-") || e5 === "-") {
      b4.push(e5);
      continue;
    }
    if (e5 === "--") {
      k3 = true;
      continue;
    }
    if (e5.startsWith("--")) {
      let n3 = e5.indexOf("="), o2, r2;
      n3 !== -1 ? (o2 = e5.slice(2, n3), r2 = e5.slice(n3 + 1)) : o2 = e5.slice(2);
      let f3 = h3.get(o2);
      if (!f3) return { ok: false, error: r$3(a3, e5) };
      let { name: l3, type: u3 } = f3;
      if (u3 === "boolean") s3[l3] = true;
      else {
        if (r2 === void 0) {
          if (t4 + 1 >= i4.length) return { ok: false, error: { stdout: "", stderr: `${a3}: option '--${o2}' requires an argument
`, exitCode: 1 } };
          r2 = i4[++t4];
        }
        s3[l3] = u3 === "number" ? parseInt(r2, 10) : r2;
      }
    } else {
      let n3 = e5.slice(1);
      for (let o2 = 0; o2 < n3.length; o2++) {
        let r2 = n3[o2], f3 = g2.get(r2);
        if (!f3) return { ok: false, error: r$3(a3, `-${r2}`) };
        let { name: l3, type: u3 } = f3;
        if (u3 === "boolean") s3[l3] = true;
        else {
          let c3;
          if (o2 + 1 < n3.length) c3 = n3.slice(o2 + 1);
          else if (t4 + 1 < i4.length) c3 = i4[++t4];
          else return { ok: false, error: { stdout: "", stderr: `${a3}: option requires an argument -- '${r2}'
`, exitCode: 1 } };
          s3[l3] = u3 === "number" ? parseInt(c3, 10) : c3;
          break;
        }
      }
    }
  }
  return { ok: true, result: { flags: s3, positional: b4 } };
}
var f$6 = { name: "cat", summary: "concatenate files and print on the standard output", usage: "cat [OPTION]... [FILE]...", options: ["-n, --number           number all output lines", "    --help             display this help and exit"] }, b$f = { number: { short: "n", long: "number", type: "boolean" } }, w$e = { name: "cat", async execute(t4, r2) {
  if (o$3(t4)) return s$1(f$6);
  let e5 = x$g("cat", t4, b$f);
  if (!e5.ok) return e5.error;
  let s3 = e5.result.flags.number, o2 = e5.result.positional, a3 = await y$e(r2, o2, { cmdName: "cat", allowStdinMarker: true, stopOnError: false }), n3 = "", i4 = 1;
  for (let { content: l3 } of a3.files) if (s3) {
    let u3 = h$d(l3, i4);
    n3 += u3.content, i4 = u3.nextLineNumber;
  } else n3 += l3;
  return { stdout: n3, stderr: a3.stderr, exitCode: a3.exitCode };
} };
function h$d(t4, r2) {
  let e5 = t4.split(`
`), s3 = t4.endsWith(`
`), o2 = s3 ? e5.slice(0, -1) : e5;
  return { content: o2.map((n3, i4) => `${String(r2 + i4).padStart(6, " ")}	${n3}`).join(`
`) + (s3 ? `
` : ""), nextLineNumber: r2 + o2.length };
}
const catMV4K6AUA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  catCommand: w$e
});
function i$4(t4, l3, e5) {
  let c3 = t4;
  e5 >= 0 && c3.length > e5 && (c3 = c3.slice(0, e5));
  let n3 = Math.abs(l3);
  return n3 > c3.length && (l3 < 0 ? c3 = c3.padEnd(n3, " ") : c3 = c3.padStart(n3, " ")), c3;
}
function h$c(t4, l3) {
  let e5 = l3, c3 = 0, n3 = -1, a3 = false;
  for (e5 < t4.length && t4[e5] === "-" && (a3 = true, e5++); e5 < t4.length && /\d/.test(t4[e5]); ) c3 = c3 * 10 + parseInt(t4[e5], 10), e5++;
  if (e5 < t4.length && t4[e5] === ".") for (e5++, n3 = 0; e5 < t4.length && /\d/.test(t4[e5]); ) n3 = n3 * 10 + parseInt(t4[e5], 10), e5++;
  return a3 && c3 > 0 && (c3 = -c3), [c3, n3, e5 - l3];
}
function r$2(t4) {
  let l3 = "", e5 = 0;
  for (; e5 < t4.length; ) if (t4[e5] === "\\" && e5 + 1 < t4.length) switch (t4[e5 + 1]) {
    case "n":
      l3 += `
`, e5 += 2;
      break;
    case "t":
      l3 += "	", e5 += 2;
      break;
    case "r":
      l3 += "\r", e5 += 2;
      break;
    case "\\":
      l3 += "\\", e5 += 2;
      break;
    case "a":
      l3 += "\x07", e5 += 2;
      break;
    case "b":
      l3 += "\b", e5 += 2;
      break;
    case "f":
      l3 += "\f", e5 += 2;
      break;
    case "v":
      l3 += "\v", e5 += 2;
      break;
    case "e":
    case "E":
      l3 += "\x1B", e5 += 2;
      break;
    case "0":
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7": {
      let n3 = "", a3 = e5 + 1;
      for (; a3 < t4.length && a3 < e5 + 4 && /[0-7]/.test(t4[a3]); ) n3 += t4[a3], a3++;
      l3 += String.fromCharCode(parseInt(n3, 8)), e5 = a3;
      break;
    }
    case "x": {
      let n3 = [], a3 = e5;
      for (; a3 + 3 < t4.length && t4[a3] === "\\" && t4[a3 + 1] === "x" && /[0-9a-fA-F]{2}/.test(t4.slice(a3 + 2, a3 + 4)); ) n3.push(parseInt(t4.slice(a3 + 2, a3 + 4), 16)), a3 += 4;
      if (n3.length > 0) {
        try {
          let s3 = new TextDecoder("utf-8", { fatal: true });
          l3 += s3.decode(new Uint8Array(n3));
        } catch {
          for (let s3 of n3) l3 += String.fromCharCode(s3);
        }
        e5 = a3;
      } else l3 += t4[e5], e5++;
      break;
    }
    case "u": {
      let n3 = "", a3 = e5 + 2;
      for (; a3 < t4.length && a3 < e5 + 6 && /[0-9a-fA-F]/.test(t4[a3]); ) n3 += t4[a3], a3++;
      n3 ? (l3 += String.fromCodePoint(parseInt(n3, 16)), e5 = a3) : (l3 += "\\u", e5 += 2);
      break;
    }
    case "U": {
      let n3 = "", a3 = e5 + 2;
      for (; a3 < t4.length && a3 < e5 + 10 && /[0-9a-fA-F]/.test(t4[a3]); ) n3 += t4[a3], a3++;
      n3 ? (l3 += String.fromCodePoint(parseInt(n3, 16)), e5 = a3) : (l3 += "\\U", e5 += 2);
      break;
    }
    default:
      l3 += t4[e5], e5++;
  }
  else l3 += t4[e5], e5++;
  return l3;
}
function W$c(t4, s3, r2) {
  let e5 = new Date(s3 * 1e3), a3 = "", n3 = 0;
  for (; n3 < t4.length; ) if (t4[n3] === "%" && n3 + 1 < t4.length) {
    let o2 = t4[n3 + 1], i4 = _$a(e5, o2, r2);
    i4 !== null ? (a3 += i4, n3 += 2) : (a3 += t4[n3], n3++);
  } else a3 += t4[n3], n3++;
  return a3;
}
function Y$8(t4, s3) {
  let r2 = { year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", weekday: "short", hour12: false, timeZone: s3 };
  try {
    let a3 = new Intl.DateTimeFormat("en-US", r2).formatToParts(t4), n3 = (u3) => a3.find((c3) => c3.type === u3)?.value ?? "", o2 = { Sun: 0, Mon: 1, Tue: 2, Wed: 3, Thu: 4, Fri: 5, Sat: 6 }, i4 = n3("weekday");
    return { year: Number.parseInt(n3("year"), 10) || t4.getFullYear(), month: Number.parseInt(n3("month"), 10) || t4.getMonth() + 1, day: Number.parseInt(n3("day"), 10) || t4.getDate(), hour: Number.parseInt(n3("hour"), 10) || t4.getHours(), minute: Number.parseInt(n3("minute"), 10) || t4.getMinutes(), second: Number.parseInt(n3("second"), 10) || t4.getSeconds(), weekday: o2[i4] ?? t4.getDay() };
  } catch {
    return { year: t4.getFullYear(), month: t4.getMonth() + 1, day: t4.getDate(), hour: t4.getHours(), minute: t4.getMinutes(), second: t4.getSeconds(), weekday: t4.getDay() };
  }
}
function _$a(t4, s3, r2) {
  let e5 = Y$8(t4, r2), a3 = (u3, c3 = 2) => String(u3).padStart(c3, "0"), n3 = P$e(e5.year, e5.month, e5.day), o2 = A$8(e5.year, e5.month, e5.day, e5.weekday, 0), i4 = A$8(e5.year, e5.month, e5.day, e5.weekday, 1);
  switch (s3) {
    case "a":
      return ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][e5.weekday];
    case "A":
      return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][e5.weekday];
    case "b":
    case "h":
      return ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e5.month - 1];
    case "B":
      return ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"][e5.month - 1];
    case "c":
      return `${["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"][e5.weekday]} ${["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e5.month - 1]} ${String(e5.day).padStart(2, " ")} ${a3(e5.hour)}:${a3(e5.minute)}:${a3(e5.second)} ${e5.year}`;
    case "C":
      return a3(Math.floor(e5.year / 100));
    case "d":
      return a3(e5.day);
    case "D":
      return `${a3(e5.month)}/${a3(e5.day)}/${a3(e5.year % 100)}`;
    case "e":
      return String(e5.day).padStart(2, " ");
    case "F":
      return `${e5.year}-${a3(e5.month)}-${a3(e5.day)}`;
    case "g":
      return a3(N$a(e5.year, e5.month, e5.day) % 100);
    case "G":
      return String(N$a(e5.year, e5.month, e5.day));
    case "H":
      return a3(e5.hour);
    case "I":
      return a3(e5.hour % 12 || 12);
    case "j":
      return String(n3).padStart(3, "0");
    case "k":
      return String(e5.hour).padStart(2, " ");
    case "l":
      return String(e5.hour % 12 || 12).padStart(2, " ");
    case "m":
      return a3(e5.month);
    case "M":
      return a3(e5.minute);
    case "n":
      return `
`;
    case "N":
      return "000000000";
    case "p":
      return e5.hour < 12 ? "AM" : "PM";
    case "P":
      return e5.hour < 12 ? "am" : "pm";
    case "r":
      return `${a3(e5.hour % 12 || 12)}:${a3(e5.minute)}:${a3(e5.second)} ${e5.hour < 12 ? "AM" : "PM"}`;
    case "R":
      return `${a3(e5.hour)}:${a3(e5.minute)}`;
    case "s":
      return String(Math.floor(t4.getTime() / 1e3));
    case "S":
      return a3(e5.second);
    case "t":
      return "	";
    case "T":
      return `${a3(e5.hour)}:${a3(e5.minute)}:${a3(e5.second)}`;
    case "u":
      return String(e5.weekday === 0 ? 7 : e5.weekday);
    case "U":
      return a3(o2);
    case "V":
      return a3(R$9(e5.year, e5.month, e5.day));
    case "w":
      return String(e5.weekday);
    case "W":
      return a3(i4);
    case "x":
      return `${a3(e5.month)}/${a3(e5.day)}/${a3(e5.year % 100)}`;
    case "X":
      return `${a3(e5.hour)}:${a3(e5.minute)}:${a3(e5.second)}`;
    case "y":
      return a3(e5.year % 100);
    case "Y":
      return String(e5.year);
    case "z":
      return G$7(t4, r2);
    case "Z":
      return H$c(t4, r2);
    case "%":
      return "%";
    default:
      return null;
  }
}
function G$7(t4, s3) {
  if (!s3) {
    let o2 = -t4.getTimezoneOffset(), i4 = o2 >= 0 ? "+" : "-", u3 = Math.floor(Math.abs(o2) / 60), c3 = Math.abs(o2) % 60;
    return `${i4}${String(u3).padStart(2, "0")}${String(c3).padStart(2, "0")}`;
  }
  try {
    let u3 = new Intl.DateTimeFormat("en-US", { timeZone: s3, timeZoneName: "longOffset" }).formatToParts(t4).find((c3) => c3.type === "timeZoneName");
    if (u3) {
      let c3 = u3.value.match(/GMT([+-])(\d{2}):(\d{2})/);
      if (c3) return `${c3[1]}${c3[2]}${c3[3]}`;
      if (u3.value === "GMT" || u3.value === "UTC") return "+0000";
    }
  } catch {
  }
  let r2 = -t4.getTimezoneOffset(), e5 = r2 >= 0 ? "+" : "-", a3 = Math.floor(Math.abs(r2) / 60), n3 = Math.abs(r2) % 60;
  return `${e5}${String(a3).padStart(2, "0")}${String(n3).padStart(2, "0")}`;
}
function H$c(t4, s3) {
  try {
    return new Intl.DateTimeFormat("en-US", { timeZone: s3, timeZoneName: "short" }).formatToParts(t4).find((n3) => n3.type === "timeZoneName")?.value ?? "UTC";
  } catch {
    return "UTC";
  }
}
function P$e(t4, s3, r2) {
  let e5 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  (t4 % 4 === 0 && t4 % 100 !== 0 || t4 % 400 === 0) && (e5[1] = 29);
  let n3 = r2;
  for (let o2 = 0; o2 < s3 - 1; o2++) n3 += e5[o2];
  return n3;
}
function A$8(t4, s3, r2, e5, a3) {
  let n3 = P$e(t4, s3, r2), u3 = (new Date(t4, 0, 1).getDay() - a3 + 7) % 7, c3 = (e5 - a3 + 7) % 7, l3 = n3 - 1 + u3;
  return Math.floor((l3 - c3 + 7) / 7);
}
function R$9(t4, s3, r2) {
  let e5 = new Date(t4, s3 - 1, r2, 12, 0, 0);
  e5.setDate(e5.getDate() + 3 - (e5.getDay() + 6) % 7);
  let a3 = new Date(e5.getFullYear(), 0, 4);
  a3.setDate(a3.getDate() + 3 - (a3.getDay() + 6) % 7);
  let n3 = e5.getTime() - a3.getTime();
  return 1 + Math.round(n3 / (10080 * 60 * 1e3));
}
function N$a(t4, s3, r2) {
  let e5 = new Date(t4, s3 - 1, r2, 12, 0, 0);
  return e5.setDate(e5.getDate() + 3 - (e5.getDay() + 6) % 7), e5.getFullYear();
}
function V$b(t4) {
  let s3 = "", r2 = 0;
  for (; r2 < t4.length; ) {
    let e5 = t4[r2];
    if (e5 < 128) {
      s3 += String.fromCharCode(e5), r2++;
      continue;
    }
    if ((e5 & 224) === 192) {
      if (r2 + 1 < t4.length && (t4[r2 + 1] & 192) === 128 && e5 >= 194) {
        let a3 = (e5 & 31) << 6 | t4[r2 + 1] & 63;
        s3 += String.fromCharCode(a3), r2 += 2;
        continue;
      }
      s3 += String.fromCharCode(e5), r2++;
      continue;
    }
    if ((e5 & 240) === 224) {
      if (r2 + 2 < t4.length && (t4[r2 + 1] & 192) === 128 && (t4[r2 + 2] & 192) === 128) {
        if (e5 === 224 && t4[r2 + 1] < 160) {
          s3 += String.fromCharCode(e5), r2++;
          continue;
        }
        let a3 = (e5 & 15) << 12 | (t4[r2 + 1] & 63) << 6 | t4[r2 + 2] & 63;
        if (a3 >= 55296 && a3 <= 57343) {
          s3 += String.fromCharCode(e5), r2++;
          continue;
        }
        s3 += String.fromCharCode(a3), r2 += 3;
        continue;
      }
      s3 += String.fromCharCode(e5), r2++;
      continue;
    }
    if ((e5 & 248) === 240 && e5 <= 244) {
      if (r2 + 3 < t4.length && (t4[r2 + 1] & 192) === 128 && (t4[r2 + 2] & 192) === 128 && (t4[r2 + 3] & 192) === 128) {
        if (e5 === 240 && t4[r2 + 1] < 144) {
          s3 += String.fromCharCode(e5), r2++;
          continue;
        }
        let a3 = (e5 & 7) << 18 | (t4[r2 + 1] & 63) << 12 | (t4[r2 + 2] & 63) << 6 | t4[r2 + 3] & 63;
        if (a3 > 1114111) {
          s3 += String.fromCharCode(e5), r2++;
          continue;
        }
        s3 += String.fromCodePoint(a3), r2 += 4;
        continue;
      }
      s3 += String.fromCharCode(e5), r2++;
      continue;
    }
    s3 += String.fromCharCode(e5), r2++;
  }
  return s3;
}
var X$8 = { name: "printf", summary: "format and print data", usage: "printf [-v var] FORMAT [ARGUMENT...]", options: ["    -v var     assign the output to shell variable VAR rather than display it", "    --help     display this help and exit"], notes: ["FORMAT controls the output like in C printf.", "Escape sequences: \\n (newline), \\t (tab), \\\\ (backslash)", "Format specifiers: %s (string), %d (integer), %f (float), %x (hex), %o (octal), %% (literal %)", "Width and precision: %10s (width 10), %.2f (2 decimal places), %010d (zero-padded)", "Flags: %- (left-justify), %+ (show sign), %0 (zero-pad)"] }, le$7 = { name: "printf", async execute(t4, s3) {
  if (o$3(t4)) return s$1(X$8);
  if (t4.length === 0) return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 2 };
  let r2 = null, e5 = 0;
  for (; e5 < t4.length; ) {
    let o2 = t4[e5];
    if (o2 === "--") {
      e5++;
      break;
    }
    if (o2 === "-v") {
      if (e5 + 1 >= t4.length) return { stdout: "", stderr: `printf: -v: option requires an argument
`, exitCode: 1 };
      if (r2 = t4[e5 + 1], !/^[a-zA-Z_][a-zA-Z0-9_]*(\[[^\]]+\])?$/.test(r2)) return { stdout: "", stderr: `printf: \`${r2}': not a valid identifier
`, exitCode: 2 };
      e5 += 2;
    } else {
      if (o2.startsWith("-") && o2 !== "-") break;
      break;
    }
  }
  if (e5 >= t4.length) return { stdout: "", stderr: `printf: usage: printf format [arguments]
`, exitCode: 1 };
  let a3 = t4[e5], n3 = t4.slice(e5 + 1);
  try {
    let o2 = r$2(a3), i4 = "", u3 = 0, c3 = false, l3 = "", y2 = s3.env.TZ;
    do {
      let { result: p3, argsConsumed: x4, error: g2, errMsg: d3, stopped: $5 } = q$c(o2, n3, u3, y2);
      if (i4 += p3, u3 += x4, g2 && (c3 = true, d3 && (l3 = d3)), $5) break;
    } while (u3 < n3.length && u3 > 0);
    if (u3 === 0 && n3.length > 0, r2) {
      let p3 = r2.match(/^([a-zA-Z_][a-zA-Z0-9_]*)\[(['"]?)(.+?)\2\]$/);
      if (p3) {
        let x4 = p3[1], g2 = p3[3];
        g2 = g2.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (d3, $5) => s3.env[$5] ?? ""), s3.env[`${x4}_${g2}`] = i4;
      } else s3.env[r2] = i4;
      return { stdout: "", stderr: l3, exitCode: c3 ? 1 : 0 };
    }
    return { stdout: i4, stderr: l3, exitCode: c3 ? 1 : 0 };
  } catch (o2) {
    return { stdout: "", stderr: `printf: ${n$5(o2)}
`, exitCode: 1 };
  }
} };
function q$c(t4, s3, r2, e5) {
  let a3 = "", n3 = 0, o2 = 0, i4 = false, u3 = "";
  for (; n3 < t4.length; ) if (t4[n3] === "%" && n3 + 1 < t4.length) {
    let c3 = n3;
    if (n3++, t4[n3] === "%") {
      a3 += "%", n3++;
      continue;
    }
    let l3 = t4.slice(c3).match(/^%(-?\d*)(?:\.(\d+))?\(([^)]*)\)T/);
    if (l3) {
      let m3 = l3[1] ? parseInt(l3[1], 10) : 0, v2 = l3[2] ? parseInt(l3[2], 10) : -1, U2 = l3[3], J3 = l3[0], w4 = s3[r2 + o2] || "";
      o2++;
      let M4;
      w4 === "" || w4 === "-1" || w4 === "-2" ? M4 = Math.floor(Date.now() / 1e3) : M4 = parseInt(w4, 10) || 0;
      let h3 = W$c(U2, M4, e5);
      if (v2 >= 0 && h3.length > v2 && (h3 = h3.slice(0, v2)), m3 !== 0) {
        let b4 = Math.abs(m3);
        h3.length < b4 && (m3 < 0 ? h3 = h3.padEnd(b4, " ") : h3 = h3.padStart(b4, " "));
      }
      a3 += h3, n3 = c3 + J3.length;
      continue;
    }
    for (; n3 < t4.length && "+-0 #'".includes(t4[n3]); ) n3++;
    let y2 = false;
    if (t4[n3] === "*") y2 = true, n3++;
    else for (; n3 < t4.length && /\d/.test(t4[n3]); ) n3++;
    let p3 = false;
    if (t4[n3] === ".") if (n3++, t4[n3] === "*") p3 = true, n3++;
    else for (; n3 < t4.length && /\d/.test(t4[n3]); ) n3++;
    n3 < t4.length && "hlL".includes(t4[n3]) && n3++;
    let x4 = t4[n3] || "";
    n3++;
    let d3 = t4.slice(c3, n3);
    if (y2) {
      let m3 = parseInt(s3[r2 + o2] || "0", 10);
      o2++, d3 = d3.replace("*", String(m3));
    }
    if (p3) {
      let m3 = parseInt(s3[r2 + o2] || "0", 10);
      o2++, d3 = d3.replace(".*", `.${m3}`);
    }
    let $5 = s3[r2 + o2] || "";
    o2++;
    let { value: z2, parseError: Z3, parseErrMsg: k3, stopped: j2 } = L$c(d3, x4, $5);
    if (a3 += z2, Z3 && (i4 = true, k3 && (u3 = k3)), j2) return { result: a3, argsConsumed: o2, error: i4, errMsg: u3, stopped: true };
  } else a3 += t4[n3], n3++;
  return { result: a3, argsConsumed: o2, error: i4, errMsg: u3, stopped: false };
}
function L$c(t4, s3, r2) {
  let e5 = false, a3 = "";
  switch (s3) {
    case "d":
    case "i": {
      let n3 = C$f(r2);
      return e5 = f$5, e5 && (a3 = `printf: ${r2}: invalid number
`), { value: O$d(t4, n3), parseError: e5, parseErrMsg: a3 };
    }
    case "o": {
      let n3 = C$f(r2);
      return e5 = f$5, e5 && (a3 = `printf: ${r2}: invalid number
`), { value: Q$8(t4, n3), parseError: e5, parseErrMsg: a3 };
    }
    case "u": {
      let n3 = C$f(r2);
      e5 = f$5, e5 && (a3 = `printf: ${r2}: invalid number
`);
      let o2 = n3 < 0 ? n3 >>> 0 : n3;
      return { value: O$d(t4.replace("u", "d"), o2), parseError: e5, parseErrMsg: a3 };
    }
    case "x":
    case "X": {
      let n3 = C$f(r2);
      return e5 = f$5, e5 && (a3 = `printf: ${r2}: invalid number
`), { value: B$b(t4, n3), parseError: e5, parseErrMsg: a3 };
    }
    case "e":
    case "E":
    case "f":
    case "F":
    case "g":
    case "G": {
      let n3 = parseFloat(r2) || 0;
      return { value: re$4(t4, s3, n3), parseError: false, parseErrMsg: "" };
    }
    case "c": {
      if (r2 === "") return { value: "", parseError: false, parseErrMsg: "" };
      let i4 = new TextEncoder().encode(r2)[0];
      return { value: String.fromCharCode(i4), parseError: false, parseErrMsg: "" };
    }
    case "s":
      return { value: ee$3(t4, r2), parseError: false, parseErrMsg: "" };
    case "q":
      return { value: te$8(t4, r2), parseError: false, parseErrMsg: "" };
    case "b": {
      let n3 = ne$6(r2);
      return { value: n3.value, parseError: false, parseErrMsg: "", stopped: n3.stopped };
    }
    default:
      try {
        return { value: sprintfExports.sprintf(t4, r2), parseError: false, parseErrMsg: "" };
      } catch {
        return { value: "", parseError: true, parseErrMsg: `printf: [sprintf] unexpected placeholder
` };
      }
  }
}
var f$5 = false;
function C$f(t4) {
  f$5 = false;
  let s3 = t4.trimStart(), r2 = s3 !== s3.trimEnd();
  if (t4 = s3.trimEnd(), t4.startsWith("'") && t4.length >= 2 || t4.startsWith('"') && t4.length >= 2) return t4.charCodeAt(1);
  if (t4.startsWith("\\'") && t4.length >= 3 || t4.startsWith('\\"') && t4.length >= 3) return t4.charCodeAt(2);
  if (t4.startsWith("+") && (t4 = t4.slice(1)), t4.startsWith("0x") || t4.startsWith("0X")) {
    let e5 = parseInt(t4, 16);
    return Number.isNaN(e5) ? (f$5 = true, 0) : (r2 && (f$5 = true), e5);
  }
  if (t4.startsWith("0") && t4.length > 1 && /^-?0[0-7]+$/.test(t4)) return r2 && (f$5 = true), parseInt(t4, 8) || 0;
  if (/^\d+#/.test(t4)) {
    f$5 = true;
    let e5 = t4.match(/^(\d+)#/);
    return e5 ? parseInt(e5[1], 10) : 0;
  }
  if (t4 !== "" && !/^-?\d+$/.test(t4)) {
    f$5 = true;
    let e5 = parseInt(t4, 10);
    return Number.isNaN(e5) ? 0 : e5;
  }
  return r2 && (f$5 = true), parseInt(t4, 10) || 0;
}
function O$d(t4, s3) {
  let r2 = t4.match(/^%([- +#0']*)(\d*)(\.(\d*))?[diu]$/);
  if (!r2) return sprintfExports.sprintf(t4.replace(/\.\d*/, ""), s3);
  let e5 = r2[1] || "", a3 = r2[2] ? parseInt(r2[2], 10) : 0, n3 = r2[3] !== void 0 ? r2[4] ? parseInt(r2[4], 10) : 0 : -1, o2 = s3 < 0, i4 = Math.abs(s3), u3 = String(i4);
  n3 >= 0 && (u3 = u3.padStart(n3, "0"));
  let c3 = "";
  o2 ? c3 = "-" : e5.includes("+") ? c3 = "+" : e5.includes(" ") && (c3 = " ");
  let l3 = c3 + u3;
  return a3 > l3.length && (e5.includes("-") ? l3 = l3.padEnd(a3, " ") : e5.includes("0") && n3 < 0 ? l3 = c3 + u3.padStart(a3 - c3.length, "0") : l3 = l3.padStart(a3, " ")), l3;
}
function Q$8(t4, s3) {
  let r2 = t4.match(/^%([- +#0']*)(\d*)(\.(\d*))?o$/);
  if (!r2) return sprintfExports.sprintf(t4, s3);
  let e5 = r2[1] || "", a3 = r2[2] ? parseInt(r2[2], 10) : 0, n3 = r2[3] !== void 0 ? r2[4] ? parseInt(r2[4], 10) : 0 : -1, o2 = Math.abs(s3).toString(8);
  n3 >= 0 && (o2 = o2.padStart(n3, "0")), e5.includes("#") && !o2.startsWith("0") && (o2 = `0${o2}`);
  let i4 = o2;
  return a3 > i4.length && (e5.includes("-") ? i4 = i4.padEnd(a3, " ") : e5.includes("0") && n3 < 0 ? i4 = i4.padStart(a3, "0") : i4 = i4.padStart(a3, " ")), i4;
}
function B$b(t4, s3) {
  let r2 = t4.includes("X"), e5 = t4.match(/^%([- +#0']*)(\d*)(\.(\d*))?[xX]$/);
  if (!e5) return sprintfExports.sprintf(t4, s3);
  let a3 = e5[1] || "", n3 = e5[2] ? parseInt(e5[2], 10) : 0, o2 = e5[3] !== void 0 ? e5[4] ? parseInt(e5[4], 10) : 0 : -1, i4 = Math.abs(s3).toString(16);
  r2 && (i4 = i4.toUpperCase()), o2 >= 0 && (i4 = i4.padStart(o2, "0"));
  let u3 = "";
  a3.includes("#") && s3 !== 0 && (u3 = r2 ? "0X" : "0x");
  let c3 = u3 + i4;
  return n3 > c3.length && (a3.includes("-") ? c3 = c3.padEnd(n3, " ") : a3.includes("0") && o2 < 0 ? c3 = u3 + i4.padStart(n3 - u3.length, "0") : c3 = c3.padStart(n3, " ")), c3;
}
function K$8(t4) {
  if (t4 === "") return "''";
  if (/^[a-zA-Z0-9_./-]+$/.test(t4)) return t4;
  if (/[\x00-\x1f\x7f-\xff]/.test(t4)) {
    let e5 = "$'";
    for (let a3 of t4) {
      let n3 = a3.charCodeAt(0);
      a3 === "'" ? e5 += "\\'" : a3 === "\\" ? e5 += "\\\\" : a3 === `
` ? e5 += "\\n" : a3 === "	" ? e5 += "\\t" : a3 === "\r" ? e5 += "\\r" : a3 === "\x07" ? e5 += "\\a" : a3 === "\b" ? e5 += "\\b" : a3 === "\f" ? e5 += "\\f" : a3 === "\v" ? e5 += "\\v" : a3 === "\x1B" ? e5 += "\\E" : n3 < 32 || n3 >= 127 && n3 <= 255 ? e5 += `\\${n3.toString(8).padStart(3, "0")}` : a3 === '"' ? e5 += '\\"' : e5 += a3;
    }
    return e5 += "'", e5;
  }
  let r2 = "";
  for (let e5 of t4) " 	|&;<>()$`\\\"'*?[#~=%!{}".includes(e5) ? r2 += `\\${e5}` : r2 += e5;
  return r2;
}
function ee$3(t4, s3) {
  let r2 = t4.match(/^%(-?)(\d*)(\.(\d*))?s$/);
  if (!r2) return sprintfExports.sprintf(t4.replace(/0+(?=\d)/, ""), s3);
  let e5 = r2[1] === "-", a3 = r2[2] ? parseInt(r2[2], 10) : 0, n3 = r2[3] !== void 0 ? r2[4] ? parseInt(r2[4], 10) : 0 : -1, o2 = e5 ? -a3 : a3;
  return i$4(s3, o2, n3);
}
function te$8(t4, s3) {
  let r2 = K$8(s3), e5 = t4.match(/^%(-?)(\d*)q$/);
  if (!e5) return r2;
  let a3 = e5[1] === "-", n3 = e5[2] ? parseInt(e5[2], 10) : 0, o2 = r2;
  return n3 > o2.length && (a3 ? o2 = o2.padEnd(n3, " ") : o2 = o2.padStart(n3, " ")), o2;
}
function re$4(t4, s3, r2) {
  let e5 = t4.match(/^%([- +#0']*)(\d*)(\.(\d*))?[eEfFgG]$/);
  if (!e5) return sprintfExports.sprintf(t4, r2);
  let a3 = e5[1] || "", n3 = e5[2] ? parseInt(e5[2], 10) : 0, o2 = e5[3] !== void 0 ? e5[4] ? parseInt(e5[4], 10) : 0 : 6, i4, u3 = s3.toLowerCase();
  if (u3 === "e" ? (i4 = r2.toExponential(o2), i4 = i4.replace(/e([+-])(\d)$/, "e$10$2"), s3 === "E" && (i4 = i4.toUpperCase())) : u3 === "f" ? (i4 = r2.toFixed(o2), a3.includes("#") && o2 === 0 && !i4.includes(".") && (i4 += ".")) : u3 === "g" ? (i4 = r2.toPrecision(o2 || 1), a3.includes("#") || (i4 = i4.replace(/\.?0+$/, ""), i4 = i4.replace(/\.?0+e/, "e")), i4 = i4.replace(/e([+-])(\d)$/, "e$10$2"), s3 === "G" && (i4 = i4.toUpperCase())) : i4 = r2.toString(), r2 >= 0 && (a3.includes("+") ? i4 = `+${i4}` : a3.includes(" ") && (i4 = ` ${i4}`)), n3 > i4.length) if (a3.includes("-")) i4 = i4.padEnd(n3, " ");
  else if (a3.includes("0")) {
    let c3 = i4.match(/^[+ -]/)?.[0] || "", l3 = c3 ? i4.slice(1) : i4;
    i4 = c3 + l3.padStart(n3 - c3.length, "0");
  } else i4 = i4.padStart(n3, " ");
  return i4;
}
function ne$6(t4) {
  let s3 = "", r2 = 0;
  for (; r2 < t4.length; ) if (t4[r2] === "\\" && r2 + 1 < t4.length) switch (t4[r2 + 1]) {
    case "n":
      s3 += `
`, r2 += 2;
      break;
    case "t":
      s3 += "	", r2 += 2;
      break;
    case "r":
      s3 += "\r", r2 += 2;
      break;
    case "\\":
      s3 += "\\", r2 += 2;
      break;
    case "a":
      s3 += "\x07", r2 += 2;
      break;
    case "b":
      s3 += "\b", r2 += 2;
      break;
    case "f":
      s3 += "\f", r2 += 2;
      break;
    case "v":
      s3 += "\v", r2 += 2;
      break;
    case "c":
      return { value: s3, stopped: true };
    case "x": {
      let a3 = [], n3 = r2;
      for (; n3 + 1 < t4.length && t4[n3] === "\\" && t4[n3 + 1] === "x"; ) {
        let o2 = "", i4 = n3 + 2;
        for (; i4 < t4.length && i4 < n3 + 4 && /[0-9a-fA-F]/.test(t4[i4]); ) o2 += t4[i4], i4++;
        if (o2) a3.push(parseInt(o2, 16)), n3 = i4;
        else break;
      }
      a3.length > 0 ? (s3 += V$b(a3), r2 = n3) : (s3 += "\\x", r2 += 2);
      break;
    }
    case "u": {
      let a3 = "", n3 = r2 + 2;
      for (; n3 < t4.length && n3 < r2 + 6 && /[0-9a-fA-F]/.test(t4[n3]); ) a3 += t4[n3], n3++;
      a3 ? (s3 += String.fromCodePoint(parseInt(a3, 16)), r2 = n3) : (s3 += "\\u", r2 += 2);
      break;
    }
    case "0": {
      let a3 = "", n3 = r2 + 2;
      for (; n3 < t4.length && n3 < r2 + 5 && /[0-7]/.test(t4[n3]); ) a3 += t4[n3], n3++;
      a3 ? s3 += String.fromCharCode(parseInt(a3, 8)) : s3 += "\0", r2 = n3;
      break;
    }
    case "1":
    case "2":
    case "3":
    case "4":
    case "5":
    case "6":
    case "7": {
      let a3 = "", n3 = r2 + 1;
      for (; n3 < t4.length && n3 < r2 + 4 && /[0-7]/.test(t4[n3]); ) a3 += t4[n3], n3++;
      s3 += String.fromCharCode(parseInt(a3, 8)), r2 = n3;
      break;
    }
    default:
      s3 += t4[r2], r2++;
  }
  else s3 += t4[r2], r2++;
  return { value: s3, stopped: false };
}
const printf66XGXFCD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  printfCommand: le$7
});
function A$7(i4) {
  if (i4 < 1024) return String(i4);
  if (i4 < 1024 * 1024) {
    let n3 = i4 / 1024;
    return n3 < 10 ? `${n3.toFixed(1)}K` : `${Math.round(n3)}K`;
  }
  if (i4 < 1024 * 1024 * 1024) {
    let n3 = i4 / 1048576;
    return n3 < 10 ? `${n3.toFixed(1)}M` : `${Math.round(n3)}M`;
  }
  let r2 = i4 / (1024 * 1024 * 1024);
  return r2 < 10 ? `${r2.toFixed(1)}G` : `${Math.round(r2)}G`;
}
function M$b(i4) {
  let n3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][i4.getMonth()], g2 = String(i4.getDate()).padStart(2, " "), $5 = /* @__PURE__ */ new Date(), y2 = new Date($5.getTime() - 4320 * 60 * 60 * 1e3);
  if (i4 > y2) {
    let w4 = String(i4.getHours()).padStart(2, "0"), S3 = String(i4.getMinutes()).padStart(2, "0");
    return `${n3} ${g2} ${w4}:${S3}`;
  }
  let z2 = i4.getFullYear();
  return `${n3} ${g2}  ${z2}`;
}
var G$6 = { name: "ls", summary: "list directory contents", usage: "ls [OPTION]... [FILE]...", options: ["-a, --all            do not ignore entries starting with .", "-A, --almost-all     do not list . and ..", "-d, --directory      list directories themselves, not their contents", "-h, --human-readable with -l, print sizes like 1K 234M 2G etc.", "-l                   use a long listing format", "-r, --reverse        reverse order while sorting", "-R, --recursive      list subdirectories recursively", "-S                   sort by file size, largest first", "-t                   sort by time, newest first", "-1                   list one file per line", "    --help           display this help and exit"] }, L$b = { showAll: { short: "a", long: "all", type: "boolean" }, showAlmostAll: { short: "A", long: "almost-all", type: "boolean" }, longFormat: { short: "l", type: "boolean" }, humanReadable: { short: "h", long: "human-readable", type: "boolean" }, recursive: { short: "R", long: "recursive", type: "boolean" }, reverse: { short: "r", long: "reverse", type: "boolean" }, sortBySize: { short: "S", type: "boolean" }, directoryOnly: { short: "d", long: "directory", type: "boolean" }, sortByTime: { short: "t", type: "boolean" }, onePerLine: { short: "1", type: "boolean" } }, U$7 = { name: "ls", async execute(i4, r2) {
  if (o$3(i4)) return s$1(G$6);
  let n3 = x$g("ls", i4, L$b);
  if (!n3.ok) return n3.error;
  let g2 = n3.result.flags.showAll, $5 = n3.result.flags.showAlmostAll, y2 = n3.result.flags.longFormat, z2 = n3.result.flags.humanReadable, w4 = n3.result.flags.recursive, S3 = n3.result.flags.reverse, D3 = n3.result.flags.sortBySize, C2 = n3.result.flags.directoryOnly;
  n3.result.flags.sortByTime;
  n3.result.flags.onePerLine;
  let o2 = n3.result.positional;
  o2.length === 0 && o2.push(".");
  let a3 = "", c3 = "", f3 = 0;
  for (let u3 = 0; u3 < o2.length; u3++) {
    let e5 = o2[u3];
    if (u3 > 0 && a3 && !a3.endsWith(`

`) && (a3 += `
`), C2) {
      let l3 = r2.fs.resolvePath(r2.cwd, e5);
      try {
        let s3 = await r2.fs.stat(l3);
        if (y2) {
          let t4 = s3.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", d3 = s3.isDirectory ? "/" : "", h3 = s3.size ?? 0, p3 = z2 ? A$7(h3).padStart(5) : String(h3).padStart(5), P2 = s3.mtime ?? /* @__PURE__ */ new Date(0), b4 = M$b(P2);
          a3 += `${t4} 1 user user ${p3} ${b4} ${e5}${d3}
`;
        } else a3 += `${e5}
`;
      } catch {
        c3 += `ls: cannot access '${e5}': No such file or directory
`, f3 = 2;
      }
      continue;
    }
    if (e5.includes("*") || e5.includes("?") || e5.includes("[")) {
      let l3 = await _$9(e5, r2, g2, $5, y2, S3, z2, D3);
      a3 += l3.stdout, c3 += l3.stderr, l3.exitCode !== 0 && (f3 = l3.exitCode);
    } else {
      let l3 = await E$c(e5, r2, g2, $5, y2, w4, o2.length > 1, S3, z2, D3);
      a3 += l3.stdout, c3 += l3.stderr, l3.exitCode !== 0 && (f3 = l3.exitCode);
    }
  }
  return { stdout: a3, stderr: c3, exitCode: f3 };
} };
async function _$9(i4, r2, n3, g2, $5, y2 = false, z2 = false, w4 = false) {
  let S3 = n3 || g2, D3 = r2.fs.getAllPaths(), C2 = r2.fs.resolvePath(r2.cwd, "."), m3 = [];
  for (let o2 of D3) {
    let a3 = o2.startsWith(C2) && o2.slice(C2.length + 1) || o2;
    if (minimatch(a3, i4) || minimatch(o2, i4)) {
      let c3 = a3.split("/").pop() || a3;
      if (!S3 && c3.startsWith(".")) continue;
      m3.push(a3 || o2);
    }
  }
  if (m3.length === 0) return { stdout: "", stderr: `ls: ${i4}: No such file or directory
`, exitCode: 2 };
  if (w4) {
    let o2 = [];
    for (let a3 of m3) {
      let c3 = r2.fs.resolvePath(r2.cwd, a3);
      try {
        let f3 = await r2.fs.stat(c3);
        o2.push({ path: a3, size: f3.size ?? 0 });
      } catch {
        o2.push({ path: a3, size: 0 });
      }
    }
    o2.sort((a3, c3) => c3.size - a3.size), m3.length = 0, m3.push(...o2.map((a3) => a3.path));
  } else m3.sort();
  if (y2 && m3.reverse(), $5) {
    let o2 = [];
    for (let a3 of m3) {
      let c3 = r2.fs.resolvePath(r2.cwd, a3);
      try {
        let f3 = await r2.fs.stat(c3), u3 = f3.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", e5 = f3.isDirectory ? "/" : "", l3 = f3.size ?? 0, s3 = z2 ? A$7(l3).padStart(5) : String(l3).padStart(5), t4 = f3.mtime ?? /* @__PURE__ */ new Date(0), d3 = M$b(t4);
        o2.push(`${u3} 1 user user ${s3} ${d3} ${a3}${e5}`);
      } catch {
        o2.push(`-rw-r--r-- 1 user user     0 Jan  1 00:00 ${a3}`);
      }
    }
    return { stdout: `${o2.join(`
`)}
`, stderr: "", exitCode: 0 };
  }
  return { stdout: `${m3.join(`
`)}
`, stderr: "", exitCode: 0 };
}
async function E$c(i4, r2, n3, g2, $5, y2, z2, w4 = false, S3 = false, D3 = false, C2 = false) {
  let m3 = n3 || g2, o2 = r2.fs.resolvePath(r2.cwd, i4);
  try {
    let a3 = await r2.fs.stat(o2);
    if (!a3.isDirectory) {
      if ($5) {
        let u3 = a3.size ?? 0, e5 = S3 ? A$7(u3).padStart(5) : String(u3).padStart(5), l3 = a3.mtime ?? /* @__PURE__ */ new Date(0), s3 = M$b(l3);
        return { stdout: `-rw-r--r-- 1 user user ${e5} ${s3} ${i4}
`, stderr: "", exitCode: 0 };
      }
      return { stdout: `${i4}
`, stderr: "", exitCode: 0 };
    }
    let c3 = await r2.fs.readdir(o2);
    if (m3 || (c3 = c3.filter((u3) => !u3.startsWith("."))), D3) {
      let u3 = [];
      for (let e5 of c3) {
        let l3 = o2 === "/" ? `/${e5}` : `${o2}/${e5}`;
        try {
          let s3 = await r2.fs.stat(l3);
          u3.push({ name: e5, size: s3.size ?? 0 });
        } catch {
          u3.push({ name: e5, size: 0 });
        }
      }
      u3.sort((e5, l3) => l3.size - e5.size), c3 = u3.map((e5) => e5.name);
    } else c3.sort();
    n3 && (c3 = [".", "..", ...c3]), w4 && c3.reverse();
    let f3 = "";
    if ((y2 || z2) && (f3 += `${i4}:
`), $5) {
      f3 += `total ${c3.length}
`;
      let u3 = c3.filter((t4) => t4 === "." || t4 === ".."), e5 = c3.filter((t4) => t4 !== "." && t4 !== "..");
      for (let t4 of u3) f3 += `drwxr-xr-x 1 user user     0 Jan  1 00:00 ${t4}
`;
      let l3 = [];
      for (let t4 = 0; t4 < e5.length; t4 += 100) {
        let d3 = e5.slice(t4, t4 + 100), h3 = await Promise.all(d3.map(async (p3) => {
          let P2 = o2 === "/" ? `/${p3}` : `${o2}/${p3}`;
          try {
            let b4 = await r2.fs.stat(P2), O2 = b4.isDirectory ? "drwxr-xr-x" : "-rw-r--r--", B2 = b4.isDirectory ? "/" : "", x4 = b4.size ?? 0, J3 = S3 ? A$7(x4).padStart(5) : String(x4).padStart(5), R2 = b4.mtime ?? /* @__PURE__ */ new Date(0), N2 = M$b(R2);
            return { name: p3, line: `${O2} 1 user user ${J3} ${N2} ${p3}${B2}
` };
          } catch {
            return { name: p3, line: `-rw-r--r-- 1 user user     0 Jan  1 00:00 ${p3}
` };
          }
        }));
        l3.push(...h3);
      }
      let s3 = new Map(e5.map((t4, d3) => [t4, d3]));
      l3.sort((t4, d3) => (s3.get(t4.name) ?? 0) - (s3.get(d3.name) ?? 0));
      for (let { line: t4 } of l3) f3 += t4;
    } else f3 += c3.join(`
`) + (c3.length ? `
` : "");
    if (y2) {
      let u3 = c3.filter((s3) => s3 !== "." && s3 !== ".."), e5 = [];
      if (r2.fs.readdirWithFileTypes) e5 = (await r2.fs.readdirWithFileTypes(o2)).filter((t4) => t4.isDirectory && u3.includes(t4.name)).map((t4) => ({ name: t4.name, isDirectory: true }));
      else for (let s3 = 0; s3 < u3.length; s3 += 100) {
        let t4 = u3.slice(s3, s3 + 100), d3 = await Promise.all(t4.map(async (h3) => {
          let p3 = o2 === "/" ? `/${h3}` : `${o2}/${h3}`;
          try {
            let P2 = await r2.fs.stat(p3);
            return { name: h3, isDirectory: P2.isDirectory };
          } catch {
            return { name: h3, isDirectory: false };
          }
        }));
        e5.push(...d3.filter((h3) => h3.isDirectory));
      }
      e5.sort((s3, t4) => s3.name.localeCompare(t4.name)), w4 && e5.reverse();
      let l3 = [];
      for (let s3 = 0; s3 < e5.length; s3 += 100) {
        let t4 = e5.slice(s3, s3 + 100), d3 = await Promise.all(t4.map(async (h3) => {
          let p3 = i4 === "." ? `./${h3.name}` : `${i4}/${h3.name}`, P2 = await E$c(p3, r2, n3, g2, $5, y2, false, w4, S3, D3, true);
          return { name: h3.name, result: P2 };
        }));
        l3.push(...d3);
      }
      l3.sort((s3, t4) => s3.name.localeCompare(t4.name)), w4 && l3.reverse();
      for (let { result: s3 } of l3) f3 += `
`, f3 += s3.stdout;
    }
    return { stdout: f3, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: "", stderr: `ls: ${i4}: No such file or directory
`, exitCode: 2 };
  }
}
const ls5W3NU5OJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  lsCommand: U$7
});
var g$f = { recursive: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, y$d = { name: "mkdir", async execute(u3, o2) {
  let e5 = x$g("mkdir", u3, g$f);
  if (!e5.ok) return e5.error;
  let m3 = e5.result.flags.recursive, f3 = e5.result.flags.verbose, n3 = e5.result.positional;
  if (n3.length === 0) return { stdout: "", stderr: `mkdir: missing operand
`, exitCode: 1 };
  let c3 = "", t4 = "", d3 = 0;
  for (let r2 of n3) try {
    let i4 = o2.fs.resolvePath(o2.cwd, r2);
    await o2.fs.mkdir(i4, { recursive: m3 }), f3 && (c3 += `mkdir: created directory '${r2}'
`);
  } catch (i4) {
    let s3 = n$5(i4);
    s3.includes("ENOENT") || s3.includes("no such file") ? t4 += `mkdir: cannot create directory '${r2}': No such file or directory
` : s3.includes("EEXIST") || s3.includes("already exists") ? t4 += `mkdir: cannot create directory '${r2}': File exists
` : t4 += `mkdir: cannot create directory '${r2}': ${s3}
`, d3 = 1;
  }
  return { stdout: c3, stderr: t4, exitCode: d3 };
} };
const mkdir7UKY4B3B = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mkdirCommand: y$d
});
var x$f = `Usage: rmdir [-pv] DIRECTORY...
Remove empty directories.

Options:
  -p, --parents   Remove DIRECTORY and its ancestors
  -v, --verbose   Output a diagnostic for every directory processed`, y$c = { parents: { short: "p", long: "parents", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, help: { long: "help", type: "boolean" } }, D$d = { name: "rmdir", async execute(t4, r2) {
  let e5 = x$g("rmdir", t4, y$c);
  if (!e5.ok) return e5.error;
  if (e5.result.flags.help) return { stdout: `${x$f}
`, stderr: "", exitCode: 0 };
  let a3 = e5.result.flags.parents, o2 = e5.result.flags.verbose, s3 = e5.result.positional;
  if (s3.length === 0) return { stdout: "", stderr: `rmdir: missing operand
`, exitCode: 1 };
  let f3 = "", n3 = "", i4 = 0;
  for (let u3 of s3) {
    let d3 = await b$e(r2, u3, a3, o2);
    f3 += d3.stdout, n3 += d3.stderr, d3.exitCode !== 0 && (i4 = d3.exitCode);
  }
  return { stdout: f3, stderr: n3, exitCode: i4 };
} };
async function b$e(t4, r2, e5, a3) {
  let o2 = "", s3 = "", n3 = t4.fs.resolvePath(t4.cwd, r2), i4 = await v$a(t4, n3, r2, a3);
  if (o2 += i4.stdout, s3 += i4.stderr, i4.exitCode !== 0) return { stdout: o2, stderr: s3, exitCode: i4.exitCode };
  if (e5) {
    let u3 = n3, d3 = r2;
    for (; ; ) {
      let c3 = C$e(u3), l3 = C$e(d3);
      if (c3 === u3 || c3 === "/" || c3 === "." || l3 === "." || l3 === "") break;
      let m3 = await v$a(t4, c3, l3, a3);
      if (o2 += m3.stdout, m3.exitCode !== 0) break;
      u3 = c3, d3 = l3;
    }
  }
  return { stdout: o2, stderr: s3, exitCode: 0 };
}
async function v$a(t4, r2, e5, a3) {
  try {
    if (!await t4.fs.exists(r2)) return { stdout: "", stderr: `rmdir: failed to remove '${e5}': No such file or directory
`, exitCode: 1 };
    if (!(await t4.fs.stat(r2)).isDirectory) return { stdout: "", stderr: `rmdir: failed to remove '${e5}': Not a directory
`, exitCode: 1 };
    if ((await t4.fs.readdir(r2)).length > 0) return { stdout: "", stderr: `rmdir: failed to remove '${e5}': Directory not empty
`, exitCode: 1 };
    await t4.fs.rm(r2, { recursive: false, force: false });
    let n3 = "";
    return a3 && (n3 = `rmdir: removing directory, '${e5}'
`), { stdout: n3, stderr: "", exitCode: 0 };
  } catch (o2) {
    let s3 = n$5(o2);
    return { stdout: "", stderr: `rmdir: failed to remove '${e5}': ${s3}
`, exitCode: 1 };
  }
}
function C$e(t4) {
  let r2 = t4.replace(/\/+$/, ""), e5 = r2.lastIndexOf("/");
  return e5 === -1 ? "." : e5 === 0 ? "/" : r2.substring(0, e5);
}
const rmdirXFQE4ZYV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  rmdirCommand: D$d
});
function h$b(s3) {
  let i4 = s3.replace(/\//g, "-"), r2 = new Date(i4);
  if (!Number.isNaN(r2.getTime())) return r2;
  let a3 = i4.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if (a3) {
    let [, o2, l3, d3] = a3;
    if (r2 = new Date(Number.parseInt(o2, 10), Number.parseInt(l3, 10) - 1, Number.parseInt(d3, 10)), !Number.isNaN(r2.getTime())) return r2;
  }
  let u3 = i4.match(/^(\d{4})-(\d{2})-(\d{2})\s+(\d{2}):(\d{2}):(\d{2})$/);
  if (u3) {
    let [, o2, l3, d3, t4, e5, f3] = u3;
    if (r2 = new Date(Number.parseInt(o2, 10), Number.parseInt(l3, 10) - 1, Number.parseInt(d3, 10), Number.parseInt(t4, 10), Number.parseInt(e5, 10), Number.parseInt(f3, 10)), !Number.isNaN(r2.getTime())) return r2;
  }
  return null;
}
var b$d = { name: "touch", async execute(s3, i4) {
  let r2 = [], a3 = null, u3 = false;
  for (let t4 = 0; t4 < s3.length; t4++) {
    let e5 = s3[t4];
    if (e5 === "--") {
      r2.push(...s3.slice(t4 + 1));
      break;
    } else if (e5 === "-d" || e5 === "--date") {
      if (t4 + 1 >= s3.length) return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
      a3 = s3[++t4];
    } else if (e5.startsWith("--date=")) a3 = e5.slice(7);
    else if (e5 === "-c" || e5 === "--no-create") u3 = true;
    else if (e5 === "-a" || e5 === "-m" || e5 === "-r" || e5 === "-t") (e5 === "-r" || e5 === "-t") && t4++;
    else {
      if (e5.startsWith("--")) return r$3("touch", e5);
      if (e5.startsWith("-") && e5.length > 1) {
        let f3 = false;
        for (let n3 of e5.slice(1)) if (n3 === "c") u3 = true;
        else if (!(n3 === "a" || n3 === "m")) if (n3 === "d") {
          if (t4 + 1 >= s3.length) return { stdout: "", stderr: `touch: option requires an argument -- 'd'
`, exitCode: 1 };
          a3 = s3[++t4], f3 = true;
          break;
        } else if (n3 === "r" || n3 === "t") {
          t4++, f3 = true;
          break;
        } else return r$3("touch", `-${n3}`);
        if (f3) continue;
      } else r2.push(e5);
    }
  }
  if (r2.length === 0) return { stdout: "", stderr: `touch: missing file operand
`, exitCode: 1 };
  let o2 = null;
  if (a3 !== null && (o2 = h$b(a3), o2 === null)) return { stdout: "", stderr: `touch: invalid date format '${a3}'
`, exitCode: 1 };
  let l3 = "", d3 = 0;
  for (let t4 of r2) try {
    let e5 = i4.fs.resolvePath(i4.cwd, t4);
    if (!await i4.fs.exists(e5)) {
      if (u3) continue;
      await i4.fs.writeFile(e5, "");
    }
    let n3 = o2 ?? /* @__PURE__ */ new Date();
    await i4.fs.utimes(e5, n3, n3);
  } catch (e5) {
    l3 += `touch: cannot touch '${t4}': ${n$5(e5)}
`, d3 = 1;
  }
  return { stdout: "", stderr: l3, exitCode: d3 };
} };
const touchTDTEBHHI = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  touchCommand: b$d
});
var v$9 = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, y$b = { name: "rm", async execute(d3, s3) {
  let e5 = x$g("rm", d3, v$9);
  if (!e5.ok) return e5.error;
  let a3 = e5.result.flags.recursive || e5.result.flags.recursiveUpper, c3 = e5.result.flags.force, p3 = e5.result.flags.verbose, l3 = e5.result.positional;
  if (l3.length === 0) return c3 ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: `rm: missing operand
`, exitCode: 1 };
  let f3 = "", t4 = "", i4 = 0;
  for (let r2 of l3) try {
    let n3 = s3.fs.resolvePath(s3.cwd, r2);
    if ((await s3.fs.stat(n3)).isDirectory && !a3) {
      t4 += `rm: cannot remove '${r2}': Is a directory
`, i4 = 1;
      continue;
    }
    await s3.fs.rm(n3, { recursive: a3, force: c3 }), p3 && (f3 += `removed '${r2}'
`);
  } catch (n3) {
    if (!c3) {
      let o2 = n$5(n3);
      o2.includes("ENOENT") || o2.includes("no such file") ? t4 += `rm: cannot remove '${r2}': No such file or directory
` : o2.includes("ENOTEMPTY") || o2.includes("not empty") ? t4 += `rm: cannot remove '${r2}': Directory not empty
` : t4 += `rm: cannot remove '${r2}': ${o2}
`, i4 = 1;
    }
  }
  return { stdout: f3, stderr: t4, exitCode: i4 };
} };
const rmI2SRVF7H = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  rmCommand: y$b
});
var D$c = { name: "cp", summary: "copy files and directories", usage: "cp [OPTION]... SOURCE... DEST", options: ["-r, -R, --recursive  copy directories recursively", "-n, --no-clobber     do not overwrite an existing file", "-p, --preserve       preserve file attributes", "-v, --verbose        explain what is being done", "    --help           display this help and exit"] }, E$b = { recursive: { short: "r", long: "recursive", type: "boolean" }, recursiveUpper: { short: "R", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, preserve: { short: "p", long: "preserve", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, R$8 = { name: "cp", async execute(f3, e5) {
  if (o$3(f3)) return s$1(D$c);
  let t4 = x$g("cp", f3, E$b);
  if (!t4.ok) return t4.error;
  let u3 = t4.result.flags.recursive || t4.result.flags.recursiveUpper, w4 = t4.result.flags.noClobber;
  t4.result.flags.preserve;
  let P2 = t4.result.flags.verbose, a3 = t4.result.positional;
  if (a3.length < 2) return { stdout: "", stderr: `cp: missing destination file operand
`, exitCode: 1 };
  let d3 = a3.pop() ?? "", h3 = a3, o2 = e5.fs.resolvePath(e5.cwd, d3), v2 = "", n3 = "", l3 = 0, p3 = false;
  try {
    p3 = (await e5.fs.stat(o2)).isDirectory;
  } catch {
  }
  if (h3.length > 1 && !p3) return { stdout: "", stderr: `cp: target '${d3}' is not a directory
`, exitCode: 1 };
  for (let r2 of h3) try {
    let i4 = e5.fs.resolvePath(e5.cwd, r2), s3 = await e5.fs.stat(i4), c3 = o2;
    if (p3) {
      let b4 = r2.split("/").pop() || r2;
      c3 = o2 === "/" ? `/${b4}` : `${o2}/${b4}`;
    }
    if (s3.isDirectory && !u3) {
      n3 += `cp: -r not specified; omitting directory '${r2}'
`, l3 = 1;
      continue;
    }
    if (w4) try {
      await e5.fs.stat(c3);
      continue;
    } catch {
    }
    await e5.fs.cp(i4, c3, { recursive: u3 }), P2 && (v2 += `'${r2}' -> '${c3}'
`);
  } catch (i4) {
    let s3 = n$5(i4);
    s3.includes("ENOENT") || s3.includes("no such file") ? n3 += `cp: cannot stat '${r2}': No such file or directory
` : n3 += `cp: cannot copy '${r2}': ${s3}
`, l3 = 1;
  }
  return { stdout: v2, stderr: n3, exitCode: l3 };
} };
const cpPBJT3GBF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  cpCommand: R$8
});
var C$d = { name: "mv", summary: "move (rename) files", usage: "mv [OPTION]... SOURCE... DEST", options: ["-f, --force       do not prompt before overwriting", "-n, --no-clobber  do not overwrite an existing file", "-v, --verbose     explain what is being done", "    --help        display this help and exit"] }, P$d = { force: { short: "f", long: "force", type: "boolean" }, noClobber: { short: "n", long: "no-clobber", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" } }, O$c = { name: "mv", async execute(m3, t4) {
  if (o$3(m3)) return s$1(C$d);
  let s3 = x$g("mv", m3, P$d);
  if (!s3.ok) return s3.error;
  s3.result.flags.force;
  let d3 = s3.result.flags.noClobber, w4 = s3.result.flags.verbose, l3 = s3.result.positional;
  if (l3.length < 2) return { stdout: "", stderr: `mv: missing destination file operand
`, exitCode: 1 };
  let r2 = l3.pop() ?? "", v2 = l3, n3 = t4.fs.resolvePath(t4.cwd, r2), h3 = "", c3 = "", b4 = 0, a3 = false;
  try {
    a3 = (await t4.fs.stat(n3)).isDirectory;
  } catch {
  }
  if (v2.length > 1 && !a3) return { stdout: "", stderr: `mv: target '${r2}' is not a directory
`, exitCode: 1 };
  for (let e5 of v2) try {
    let f3 = t4.fs.resolvePath(t4.cwd, e5), o2 = n3;
    if (a3) {
      let i4 = e5.split("/").pop() || e5;
      o2 = n3 === "/" ? `/${i4}` : `${n3}/${i4}`;
    }
    if (d3) try {
      await t4.fs.stat(o2);
      continue;
    } catch {
    }
    if (await t4.fs.mv(f3, o2), w4) {
      let i4 = a3 ? `${r2}/${e5.split("/").pop() || e5}` : r2;
      h3 += `renamed '${e5}' -> '${i4}'
`;
    }
  } catch (f3) {
    let o2 = n$5(f3);
    o2.includes("ENOENT") || o2.includes("no such file") ? c3 += `mv: cannot stat '${e5}': No such file or directory
` : c3 += `mv: cannot move '${e5}': ${o2}
`, b4 = 1;
  }
  return { stdout: h3, stderr: c3, exitCode: b4 };
} };
const mvFXHEKRTB = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  mvCommand: O$c
});
var y$a = { name: "ln", summary: "make links between files", usage: "ln [OPTIONS] TARGET LINK_NAME", options: ["-s      create a symbolic link instead of a hard link", "-f      remove existing destination files", "-n      treat LINK_NAME as a normal file if it is a symbolic link to a directory", "-v      print name of each linked file", "    --help display this help and exit"] }, p$c = { name: "ln", async execute(i4, s3) {
  if (o$3(i4)) return s$1(y$a);
  let r2 = false, a3 = false, d3 = false, t4 = 0;
  for (; t4 < i4.length && i4[t4].startsWith("-"); ) {
    let e5 = i4[t4];
    if (e5 === "-s" || e5 === "--symbolic") r2 = true, t4++;
    else if (e5 === "-f" || e5 === "--force") a3 = true, t4++;
    else if (e5 === "-v" || e5 === "--verbose") d3 = true, t4++;
    else if (e5 === "-n" || e5 === "--no-dereference") t4++;
    else if (/^-[sfvn]+$/.test(e5)) e5.includes("s") && (r2 = true), e5.includes("f") && (a3 = true), e5.includes("v") && (d3 = true), t4++;
    else if (e5 === "--") {
      t4++;
      break;
    } else return { stdout: "", stderr: `ln: invalid option -- '${e5.slice(1)}'
`, exitCode: 1 };
  }
  let f3 = i4.slice(t4);
  if (f3.length < 2) return { stdout: "", stderr: `ln: missing file operand
`, exitCode: 1 };
  let n3 = f3[0], l3 = f3[1], o2 = s3.fs.resolvePath(s3.cwd, l3);
  if (await s3.fs.exists(o2)) if (a3) try {
    await s3.fs.rm(o2, { force: true });
  } catch {
    return { stdout: "", stderr: `ln: cannot remove '${l3}': Permission denied
`, exitCode: 1 };
  }
  else return { stdout: "", stderr: `ln: failed to create ${r2 ? "symbolic " : ""}link '${l3}': File exists
`, exitCode: 1 };
  try {
    if (r2) await s3.fs.symlink(n3, o2);
    else {
      let e5 = s3.fs.resolvePath(s3.cwd, n3);
      if (!await s3.fs.exists(e5)) return { stdout: "", stderr: `ln: failed to access '${n3}': No such file or directory
`, exitCode: 1 };
      await s3.fs.link(e5, o2);
    }
  } catch (e5) {
    let u3 = e5;
    return u3.message.includes("EPERM") ? { stdout: "", stderr: `ln: '${n3}': hard link not allowed for directory
`, exitCode: 1 } : { stdout: "", stderr: `ln: ${u3.message}
`, exitCode: 1 };
  }
  let c3 = "";
  return d3 && (c3 = `'${l3}' -> '${n3}'
`), { stdout: c3, stderr: "", exitCode: 0 };
} };
const lnY7YB677N = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  lnCommand: p$c
});
var C$c = { name: "chmod", summary: "change file mode bits", usage: "chmod [OPTIONS] MODE FILE...", options: ["-R      change files recursively", "-v      output a diagnostic for every file processed", "    --help display this help and exit"] }, R$7 = { name: "chmod", async execute(s3, a3) {
  if (o$3(s3)) return s$1(C$c);
  if (s3.length < 2) return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
  let e5 = false, c3 = false, o2 = 0;
  for (; o2 < s3.length && s3[o2].startsWith("-"); ) {
    let t4 = s3[o2];
    if (t4 === "-R" || t4 === "--recursive") e5 = true, o2++;
    else if (t4 === "-v" || t4 === "--verbose") c3 = true, o2++;
    else if (t4 === "--") {
      o2++;
      break;
    } else {
      if (/^[+-]?[rwxugo]+/.test(t4) || /^\d+$/.test(t4)) break;
      if (/^-[Rv]+$/.test(t4)) {
        t4.includes("R") && (e5 = true), t4.includes("v") && (c3 = true), o2++;
        continue;
      }
      return { stdout: "", stderr: `chmod: invalid option -- '${t4.slice(1)}'
`, exitCode: 1 };
    }
  }
  if (s3.length - o2 < 2) return { stdout: "", stderr: `chmod: missing operand
`, exitCode: 1 };
  let n3 = s3[o2], d3 = s3.slice(o2 + 1), r2 = /^[0-7]+$/.test(n3), i4;
  if (r2) i4 = parseInt(n3, 8);
  else try {
    p$b(n3, 420);
  } catch {
    return { stdout: "", stderr: `chmod: invalid mode: '${n3}'
`, exitCode: 1 };
  }
  let f3 = "", l3 = "", u3 = false;
  for (let t4 of d3) {
    let h3 = a3.fs.resolvePath(a3.cwd, t4);
    try {
      let m3;
      if (r2 && i4 !== void 0) m3 = i4;
      else {
        let w4 = await a3.fs.stat(h3);
        m3 = p$b(n3, w4.mode);
      }
      if (await a3.fs.chmod(h3, m3), c3 && (f3 += `mode of '${t4}' changed to ${m3.toString(8).padStart(4, "0")}
`), e5 && (await a3.fs.stat(h3)).isDirectory) {
        let y2 = await v$8(a3, h3, r2 ? i4 : void 0, r2 ? void 0 : n3, c3);
        f3 += y2;
      }
    } catch {
      l3 += `chmod: cannot access '${t4}': No such file or directory
`, u3 = true;
    }
  }
  return { stdout: f3, stderr: l3, exitCode: u3 ? 1 : 0 };
} };
async function v$8(s3, a3, e5, c3, o2) {
  let n3 = "", d3 = await s3.fs.readdir(a3);
  for (let r2 of d3) {
    let i4 = a3 === "/" ? `/${r2}` : `${a3}/${r2}`, f3;
    if (e5 !== void 0) f3 = e5;
    else if (c3 !== void 0) {
      let u3 = await s3.fs.stat(i4);
      f3 = p$b(c3, u3.mode);
    } else f3 = 420;
    await s3.fs.chmod(i4, f3), o2 && (n3 += `mode of '${i4}' changed to ${f3.toString(8).padStart(4, "0")}
`), (await s3.fs.stat(i4)).isDirectory && (n3 += await v$8(s3, i4, e5, c3, o2));
  }
  return n3;
}
function p$b(s3, a3 = 420) {
  if (/^[0-7]+$/.test(s3)) return parseInt(s3, 8);
  let e5 = a3 & 4095, c3 = s3.split(",");
  for (let o2 of c3) {
    let n3 = o2.match(/^([ugoa]*)([+\-=])([rwxXst]*)$/);
    if (!n3) throw new Error(`Invalid mode: ${s3}`);
    let d3 = n3[1] || "a", r2 = n3[2], i4 = n3[3];
    (d3 === "a" || d3 === "") && (d3 = "ugo");
    let f3 = 0;
    i4.includes("r") && (f3 |= 4), i4.includes("w") && (f3 |= 2), (i4.includes("x") || i4.includes("X")) && (f3 |= 1);
    let l3 = 0;
    i4.includes("s") && (d3.includes("u") && (l3 |= 2048), d3.includes("g") && (l3 |= 1024)), i4.includes("t") && (l3 |= 512);
    for (let u3 of d3) {
      let t4 = 0;
      u3 === "u" ? t4 = 6 : u3 === "g" ? t4 = 3 : u3 === "o" && (t4 = 0);
      let h3 = f3 << t4;
      r2 === "+" ? e5 |= h3 : r2 === "-" ? e5 &= ~h3 : r2 === "=" && (e5 &= ~(7 << t4), e5 |= h3);
    }
    r2 === "+" ? e5 |= l3 : r2 === "-" ? e5 &= ~l3 : r2 === "=" && (i4.includes("s") && (d3.includes("u") && (e5 &= -2049, e5 |= l3 & 2048), d3.includes("g") && (e5 &= -1025, e5 |= l3 & 1024)), i4.includes("t") && (e5 &= -513, e5 |= l3 & 512));
  }
  return e5;
}
const chmodODWUR7E6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  chmodCommand: R$7
});
var f$4 = { name: "pwd", async execute(r2, t4) {
  let s3 = false;
  for (let e5 of r2) if (e5 === "-P") s3 = true;
  else if (e5 === "-L") s3 = false;
  else {
    if (e5 === "--") break;
    e5.startsWith("-");
  }
  let a3 = t4.cwd;
  if (s3) try {
    a3 = await t4.fs.realpath(t4.cwd);
  } catch {
  }
  return { stdout: `${a3}
`, stderr: "", exitCode: 0 };
} };
const pwdS4NVAMC4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  pwdCommand: f$4
});
var m$c = { name: "readlink", summary: "print resolved symbolic links or canonical file names", usage: "readlink [OPTIONS] FILE...", options: ["-f      canonicalize by following every symlink in every component of the given name recursively", "    --help display this help and exit"] }, y$9 = { name: "readlink", async execute(i4, r2) {
  if (o$3(i4)) return s$1(m$c);
  let s3 = false, t4 = 0;
  for (; t4 < i4.length && i4[t4].startsWith("-"); ) {
    let n3 = i4[t4];
    if (n3 === "-f" || n3 === "--canonicalize") s3 = true, t4++;
    else if (n3 === "--") {
      t4++;
      break;
    } else return { stdout: "", stderr: `readlink: invalid option -- '${n3.slice(1)}'
`, exitCode: 1 };
  }
  let d3 = i4.slice(t4);
  if (d3.length === 0) return { stdout: "", stderr: `readlink: missing operand
`, exitCode: 1 };
  let l3 = "", c3 = false;
  for (let n3 of d3) {
    let a3 = r2.fs.resolvePath(r2.cwd, n3);
    try {
      if (s3) {
        let e5 = a3, f3 = /* @__PURE__ */ new Set();
        for (; !f3.has(e5); ) {
          f3.add(e5);
          try {
            let o2 = await r2.fs.readlink(e5);
            if (o2.startsWith("/")) e5 = o2;
            else {
              let k3 = e5.substring(0, e5.lastIndexOf("/")) || "/";
              e5 = r2.fs.resolvePath(k3, o2);
            }
          } catch {
            break;
          }
        }
        l3 += `${e5}
`;
      } else {
        let e5 = await r2.fs.readlink(a3);
        l3 += `${e5}
`;
      }
    } catch {
      s3 ? l3 += `${a3}
` : c3 = true;
    }
  }
  return { stdout: l3, stderr: "", exitCode: c3 ? 1 : 0 };
} };
const readlinkEM4O3U4P = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  readlinkCommand: y$9
});
function I$d(t4, r2) {
  let i4 = 10, s3 = null, o2 = false, l3 = false, n3 = false, u3 = [];
  for (let f3 = 0; f3 < t4.length; f3++) {
    let e5 = t4[f3];
    if (e5 === "-n" && f3 + 1 < t4.length) {
      let a3 = t4[++f3];
      r2 === "tail" && a3.startsWith("+") ? (n3 = true, i4 = parseInt(a3.slice(1), 10)) : i4 = parseInt(a3, 10);
    } else if (r2 === "tail" && e5.startsWith("-n+")) n3 = true, i4 = parseInt(e5.slice(3), 10);
    else if (e5.startsWith("-n")) i4 = parseInt(e5.slice(2), 10);
    else if (e5 === "-c" && f3 + 1 < t4.length) s3 = parseInt(t4[++f3], 10);
    else if (e5.startsWith("-c")) s3 = parseInt(e5.slice(2), 10);
    else if (e5.startsWith("--bytes=")) s3 = parseInt(e5.slice(8), 10);
    else if (e5.startsWith("--lines=")) i4 = parseInt(e5.slice(8), 10);
    else if (e5 === "-q" || e5 === "--quiet" || e5 === "--silent") o2 = true;
    else if (e5 === "-v" || e5 === "--verbose") l3 = true;
    else if (e5.match(/^-\d+$/)) i4 = parseInt(e5.slice(1), 10);
    else {
      if (e5.startsWith("--")) return { ok: false, error: r$3(r2, e5) };
      if (e5.startsWith("-") && e5 !== "-") return { ok: false, error: r$3(r2, e5) };
      u3.push(e5);
    }
  }
  return s3 !== null && (Number.isNaN(s3) || s3 < 0) ? { ok: false, error: { stdout: "", stderr: `${r2}: invalid number of bytes
`, exitCode: 1 } } : Number.isNaN(i4) || i4 < 0 ? { ok: false, error: { stdout: "", stderr: `${r2}: invalid number of lines
`, exitCode: 1 } } : { ok: true, options: { lines: i4, bytes: s3, quiet: o2, verbose: l3, files: u3, fromLine: n3 } };
}
async function W$b(t4, r2, i4, s3) {
  let { quiet: o2, verbose: l3, files: n3 } = r2;
  if (n3.length === 0) return { stdout: s3(t4.stdin), stderr: "", exitCode: 0 };
  let u3 = "", f3 = "", e5 = 0, a3 = l3 || !o2 && n3.length > 1, h3 = 0;
  for (let d3 = 0; d3 < n3.length; d3++) {
    let p3 = n3[d3];
    try {
      let b4 = t4.fs.resolvePath(t4.cwd, p3), x4 = await t4.fs.readFile(b4);
      a3 && (h3 > 0 && (u3 += `
`), u3 += `==> ${p3} <==
`), u3 += s3(x4), h3++;
    } catch {
      f3 += `${i4}: ${p3}: No such file or directory
`, e5 = 1;
    }
  }
  return { stdout: u3, stderr: f3, exitCode: e5 };
}
function $$8(t4, r2, i4) {
  if (i4 !== null) return t4.slice(0, i4);
  if (r2 === 0) return "";
  let s3 = 0, o2 = 0, l3 = t4.length;
  for (; s3 < l3 && o2 < r2; ) {
    let n3 = t4.indexOf(`
`, s3);
    if (n3 === -1) return `${t4}
`;
    o2++, s3 = n3 + 1;
  }
  return s3 > 0 ? t4.slice(0, s3) : "";
}
function g$e(t4, r2, i4, s3) {
  if (i4 !== null) return t4.slice(-i4);
  let o2 = t4.length;
  if (o2 === 0) return "";
  if (s3) {
    let f3 = 0, e5 = 1;
    for (; f3 < o2 && e5 < r2; ) {
      let h3 = t4.indexOf(`
`, f3);
      if (h3 === -1) break;
      e5++, f3 = h3 + 1;
    }
    let a3 = t4.slice(f3);
    return a3.endsWith(`
`) ? a3 : `${a3}
`;
  }
  if (r2 === 0) return "";
  let l3 = o2 - 1;
  t4[l3] === `
` && l3--;
  let n3 = 0;
  for (; l3 >= 0 && n3 < r2; ) {
    if (t4[l3] === `
` && (n3++, n3 === r2)) {
      l3++;
      break;
    }
    l3--;
  }
  l3 < 0 && (l3 = 0);
  let u3 = t4.slice(l3);
  return t4[o2 - 1] === `
` ? u3 : `${u3}
`;
}
var h$a = { name: "head", summary: "output the first part of files", usage: "head [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the first NUM bytes", "-n, --lines=NUM    print the first NUM lines (default 10)", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, u$7 = { name: "head", async execute(s3, o2) {
  if (o$3(s3)) return s$1(h$a);
  let e5 = I$d(s3, "head");
  if (!e5.ok) return e5.error;
  let { lines: p3, bytes: l3 } = e5.options;
  return W$b(o2, e5.options, "head", (d3) => $$8(d3, p3, l3));
} };
const headSA7P5NJ7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  headCommand: u$7
});
var h$9 = { name: "tail", summary: "output the last part of files", usage: "tail [OPTION]... [FILE]...", options: ["-c, --bytes=NUM    print the last NUM bytes", "-n, --lines=NUM    print the last NUM lines (default 10)", "-n +NUM            print starting from line NUM", "-q, --quiet        never print headers giving file names", "-v, --verbose      always print headers giving file names", "    --help         display this help and exit"] }, c$5 = { name: "tail", async execute(t4, r2) {
  if (o$3(t4)) return s$1(h$9);
  let e5 = I$d(t4, "tail");
  if (!e5.ok) return e5.error;
  let { lines: o2, bytes: p3, fromLine: m3 } = e5.options;
  return W$b(r2, e5.options, "tail", (f3) => g$e(f3, o2, p3, m3 ?? false));
} };
const tail52LRAWXT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  tailCommand: c$5
});
var F$9 = { name: "wc", summary: "print newline, word, and byte counts for each file", usage: "wc [OPTION]... [FILE]...", options: ["-c, --bytes      print the byte counts", "-m, --chars      print the character counts", "-l, --lines      print the newline counts", "-w, --words      print the word counts", "    --help       display this help and exit"] }, H$b = { lines: { short: "l", long: "lines", type: "boolean" }, words: { short: "w", long: "words", type: "boolean" }, bytes: { short: "c", long: "bytes", type: "boolean" }, chars: { short: "m", long: "chars", type: "boolean" } }, I$c = { name: "wc", async execute(a3, c3) {
  if (o$3(a3)) return s$1(F$9);
  let n3 = x$g("wc", a3, H$b);
  if (!n3.ok) return n3.error;
  let { lines: r2, words: s3 } = n3.result.flags, e5 = n3.result.flags.bytes || n3.result.flags.chars, t4 = n3.result.positional;
  !r2 && !s3 && !e5 && (r2 = s3 = e5 = true);
  let i4 = await y$e(c3, t4, { cmdName: "wc", stopOnError: false });
  if (t4.length === 0) {
    let o2 = C$b(i4.files[0].content);
    return { stdout: `${g$d(o2, r2, s3, e5, "", 0)}
`, stderr: "", exitCode: 0 };
  }
  let h3 = [], p3 = 0, d3 = 0, u3 = 0;
  for (let { filename: o2, content: w4 } of i4.files) {
    let f3 = C$b(w4);
    p3 += f3.lines, d3 += f3.words, u3 += f3.chars, h3.push({ filename: o2, stats: f3 });
  }
  let M4 = t4.length > 1 ? p3 : Math.max(...h3.map((o2) => o2.stats.lines)), L4 = t4.length > 1 ? d3 : Math.max(...h3.map((o2) => o2.stats.words)), $5 = t4.length > 1 ? u3 : Math.max(...h3.map((o2) => o2.stats.chars)), l3 = t4.length > 1 ? 3 : 0;
  r2 && (l3 = Math.max(l3, String(M4).length)), s3 && (l3 = Math.max(l3, String(L4).length)), e5 && (l3 = Math.max(l3, String($5).length));
  let m3 = "";
  for (let { filename: o2, stats: w4 } of h3) m3 += `${g$d(w4, r2, s3, e5, o2, l3)}
`;
  return t4.length > 1 && (m3 += `${g$d({ lines: p3, words: d3, chars: u3 }, r2, s3, e5, "total", l3)}
`), { stdout: m3, stderr: i4.stderr, exitCode: i4.exitCode };
} };
function C$b(a3) {
  let c3 = a3.length, n3 = 0, r2 = 0, s3 = false;
  for (let e5 = 0; e5 < c3; e5++) {
    let t4 = a3[e5];
    t4 === `
` ? (n3++, s3 && (r2++, s3 = false)) : t4 === " " || t4 === "	" || t4 === "\r" ? s3 && (r2++, s3 = false) : s3 = true;
  }
  return s3 && r2++, { lines: n3, words: r2, chars: c3 };
}
function g$d(a3, c3, n3, r2, s3, e5) {
  let t4 = [];
  c3 && t4.push(String(a3.lines).padStart(e5)), n3 && t4.push(String(a3.words).padStart(e5)), r2 && t4.push(String(a3.chars).padStart(e5));
  let i4 = t4.join(" ");
  return s3 && (i4 += ` ${s3}`), i4;
}
const wcHE5XARI4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  wcCommand: I$c
});
var S$c = { name: "stat", summary: "display file or file system status", usage: "stat [OPTION]... FILE...", options: ["-c FORMAT   use the specified FORMAT instead of the default", "    --help  display this help and exit"] }, $$7 = { format: { short: "c", type: "string" } }, x$e = { name: "stat", async execute(e5, a3) {
  if (o$3(e5)) return s$1(S$c);
  let s3 = x$g("stat", e5, $$7);
  if (!s3.ok) return s3.error;
  let n3 = s3.result.flags.format ?? null, c3 = s3.result.positional;
  if (c3.length === 0) return { stdout: "", stderr: `stat: missing operand
`, exitCode: 1 };
  let o2 = "", p3 = "", f3 = false;
  for (let i4 of c3) {
    let h3 = a3.fs.resolvePath(a3.cwd, i4);
    try {
      let r2 = await a3.fs.stat(h3);
      if (n3) {
        let t4 = n3, l3 = r2.mode.toString(8), y2 = m$b(r2.mode, r2.isDirectory);
        t4 = t4.replace(/%n/g, i4), t4 = t4.replace(/%N/g, `'${i4}'`), t4 = t4.replace(/%s/g, String(r2.size)), t4 = t4.replace(/%F/g, r2.isDirectory ? "directory" : "regular file"), t4 = t4.replace(/%a/g, l3), t4 = t4.replace(/%A/g, y2), t4 = t4.replace(/%u/g, "1000"), t4 = t4.replace(/%U/g, "user"), t4 = t4.replace(/%g/g, "1000"), t4 = t4.replace(/%G/g, "group"), o2 += `${t4}
`;
      } else {
        let t4 = r2.mode.toString(8).padStart(4, "0"), l3 = m$b(r2.mode, r2.isDirectory);
        o2 += `  File: ${i4}
`, o2 += `  Size: ${r2.size}		Blocks: ${Math.ceil(r2.size / 512)}
`, o2 += `Access: (${t4}/${l3})
`, o2 += `Modify: ${r2.mtime.toISOString()}
`;
      }
    } catch {
      p3 += `stat: cannot stat '${i4}': No such file or directory
`, f3 = true;
    }
  }
  return { stdout: o2, stderr: p3, exitCode: f3 ? 1 : 0 };
} };
function m$b(e5, a3) {
  let s3 = a3 ? "d" : "-", n3 = [e5 & 256 ? "r" : "-", e5 & 128 ? "w" : "-", e5 & 64 ? "x" : "-", e5 & 32 ? "r" : "-", e5 & 16 ? "w" : "-", e5 & 8 ? "x" : "-", e5 & 4 ? "r" : "-", e5 & 2 ? "w" : "-", e5 & 1 ? "x" : "-"];
  return s3 + n3.join("");
}
const statIVQBBOKN = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  statCommand: x$e
});
var c$4 = /* @__PURE__ */ new Map();
function f$3(l3, o2, t4) {
  let s3 = typeof t4 == "boolean" ? { ignoreCase: t4 } : t4 ?? {}, e5 = o2;
  s3.stripQuotes && (e5.startsWith('"') && e5.endsWith('"') || e5.startsWith("'") && e5.endsWith("'")) && (e5 = e5.slice(1, -1));
  let i4 = s3.ignoreCase ? `i:${e5}` : e5, n3 = c$4.get(i4);
  return n3 || (n3 = g$c(e5, s3.ignoreCase), c$4.set(i4, n3)), n3.test(l3);
}
function g$c(l3, o2) {
  let t4 = "^";
  for (let s3 = 0; s3 < l3.length; s3++) {
    let e5 = l3[s3];
    if (e5 === "*") t4 += ".*";
    else if (e5 === "?") t4 += ".";
    else if (e5 === "[") {
      let i4 = s3 + 1;
      for (; i4 < l3.length && l3[i4] !== "]"; ) i4++;
      t4 += l3.slice(s3, i4 + 1), s3 = i4;
    } else e5 === "." || e5 === "+" || e5 === "^" || e5 === "$" || e5 === "{" || e5 === "}" || e5 === "(" || e5 === ")" || e5 === "|" || e5 === "\\" ? t4 += `\\${e5}` : t4 += e5;
  }
  return t4 += "$", new RegExp(t4, o2 ? "i" : "");
}
function N$9(n3, t4) {
  return n3.replace(/\$(&|\d+|<([^>]+)>)/g, (e5, i4, s3) => {
    if (i4 === "&") return t4[0];
    if (s3 !== void 0) return t4.groups?.[s3] ?? "";
    let h3 = parseInt(i4, 10);
    return t4[h3] ?? "";
  });
}
function K$7(n3, t4, e5 = {}) {
  let { invertMatch: i4 = false, showLineNumbers: s3 = false, countOnly: h3 = false, countMatches: d3 = false, filename: a3 = "", onlyMatching: m3 = false, beforeContext: b4 = 0, afterContext: R2 = 0, maxCount: S3 = 0, contextSeparator: G2 = "--", showColumn: O2 = false, vimgrep: T3 = false, showByteOffset: P2 = false, replace: k3 = null, passthru: y2 = false, multiline: j2 = false, kResetGroup: A2 } = e5;
  if (j2) return D$b(n3, t4, { invertMatch: i4, showLineNumbers: s3, countOnly: h3, countMatches: d3, filename: a3, onlyMatching: m3, beforeContext: b4, afterContext: R2, maxCount: S3, contextSeparator: G2, showColumn: O2, showByteOffset: P2, replace: k3, kResetGroup: A2 });
  let x4 = n3.split(`
`), Z3 = x4.length, v2 = Z3 > 0 && x4[Z3 - 1] === "" ? Z3 - 1 : Z3;
  if (h3 || d3) {
    let f3 = 0, r2 = (d3 || m3) && !i4;
    for (let l3 = 0; l3 < v2; l3++) if (t4.lastIndex = 0, r2) for (let u3 = t4.exec(x4[l3]); u3 !== null; u3 = t4.exec(x4[l3])) f3++, u3[0].length === 0 && t4.lastIndex++;
    else t4.test(x4[l3]) !== i4 && f3++;
    return { output: `${a3 ? `${a3}:${f3}` : String(f3)}
`, matched: f3 > 0, matchCount: f3 };
  }
  if (b4 === 0 && R2 === 0 && !y2) {
    let f3 = [], r2 = false, o2 = 0, l3 = 0;
    for (let u3 = 0; u3 < v2 && !(S3 > 0 && o2 >= S3); u3++) {
      let w4 = x4[u3];
      if (t4.lastIndex = 0, t4.test(w4) !== i4) if (r2 = true, o2++, m3) {
        t4.lastIndex = 0;
        for (let $5 = t4.exec(w4); $5 !== null; $5 = t4.exec(w4)) {
          let I2 = A2 !== void 0 ? $5[A2] ?? "" : $5[0], U2 = k3 !== null ? N$9(k3, $5) : I2, z2 = a3 ? `${a3}:` : "";
          P2 && (z2 += `${l3 + $5.index}:`), s3 && (z2 += `${u3 + 1}:`), O2 && (z2 += `${$5.index + 1}:`), f3.push(z2 + U2), $5[0].length === 0 && t4.lastIndex++;
        }
      } else if (T3) {
        t4.lastIndex = 0;
        for (let $5 = t4.exec(w4); $5 !== null; $5 = t4.exec(w4)) {
          let I2 = a3 ? `${a3}:` : "";
          P2 && (I2 += `${l3 + $5.index}:`), s3 && (I2 += `${u3 + 1}:`), O2 && (I2 += `${$5.index + 1}:`), f3.push(I2 + w4), $5[0].length === 0 && t4.lastIndex++;
        }
      } else {
        t4.lastIndex = 0;
        let $5 = t4.exec(w4), I2 = $5 ? $5.index + 1 : 1, U2 = w4;
        k3 !== null && (t4.lastIndex = 0, U2 = w4.replace(t4, (...M4) => {
          if (M4[0].length === 0) return "";
          let E2 = M4, _4 = M4[M4.length - 1];
          return typeof _4 == "object" && _4 !== null ? (E2.groups = _4, E2.input = M4[M4.length - 2], E2.index = M4[M4.length - 3]) : (E2.input = M4[M4.length - 1], E2.index = M4[M4.length - 2]), N$9(k3, E2);
        }));
        let z2 = a3 ? `${a3}:` : "";
        P2 && (z2 += `${l3 + ($5 ? $5.index : 0)}:`), s3 && (z2 += `${u3 + 1}:`), O2 && (z2 += `${I2}:`), f3.push(z2 + U2);
      }
      l3 += w4.length + 1;
    }
    return { output: f3.length > 0 ? `${f3.join(`
`)}
` : "", matched: r2, matchCount: o2 };
  }
  if (y2) {
    let f3 = [], r2 = false, o2 = 0;
    for (let l3 = 0; l3 < v2; l3++) {
      let u3 = x4[l3];
      t4.lastIndex = 0;
      let F2 = t4.test(u3) !== i4;
      F2 && (r2 = true, o2++);
      let $5 = F2 ? ":" : "-", I2 = a3 ? `${a3}${$5}` : "";
      s3 && (I2 += `${l3 + 1}${$5}`), f3.push(I2 + u3);
    }
    return { output: f3.length > 0 ? `${f3.join(`
`)}
` : "", matched: r2, matchCount: o2 };
  }
  let g2 = [], L4 = 0, p3 = /* @__PURE__ */ new Set(), C2 = -1, c3 = [];
  for (let f3 = 0; f3 < v2 && !(S3 > 0 && L4 >= S3); f3++) t4.lastIndex = 0, t4.test(x4[f3]) !== i4 && (c3.push(f3), L4++);
  for (let f3 of c3) {
    let r2 = Math.max(0, f3 - b4);
    C2 >= 0 && r2 > C2 + 1 && g2.push(G2);
    for (let l3 = r2; l3 < f3; l3++) if (!p3.has(l3)) {
      p3.add(l3), C2 = l3;
      let u3 = x4[l3];
      s3 && (u3 = `${l3 + 1}-${u3}`), a3 && (u3 = `${a3}-${u3}`), g2.push(u3);
    }
    if (!p3.has(f3)) {
      p3.add(f3), C2 = f3;
      let l3 = x4[f3];
      if (m3) {
        t4.lastIndex = 0;
        for (let u3 = t4.exec(l3); u3 !== null; u3 = t4.exec(l3)) {
          let w4 = A2 !== void 0 ? u3[A2] ?? "" : u3[0], F2 = k3 !== null ? k3 : w4, $5 = a3 ? `${a3}:` : "";
          s3 && ($5 += `${f3 + 1}:`), O2 && ($5 += `${u3.index + 1}:`), g2.push($5 + F2), u3[0].length === 0 && t4.lastIndex++;
        }
      } else {
        let u3 = l3;
        s3 && (u3 = `${f3 + 1}:${u3}`), a3 && (u3 = `${a3}:${u3}`), g2.push(u3);
      }
    }
    let o2 = Math.min(v2 - 1, f3 + R2);
    for (let l3 = f3 + 1; l3 <= o2; l3++) if (!p3.has(l3)) {
      p3.add(l3), C2 = l3;
      let u3 = x4[l3];
      s3 && (u3 = `${l3 + 1}-${u3}`), a3 && (u3 = `${a3}-${u3}`), g2.push(u3);
    }
  }
  return { output: g2.length > 0 ? `${g2.join(`
`)}
` : "", matched: L4 > 0, matchCount: L4 };
}
function D$b(n3, t4, e5) {
  let { invertMatch: i4, showLineNumbers: s3, countOnly: h3, countMatches: d3, filename: a3, onlyMatching: m3, beforeContext: b4, afterContext: R2, maxCount: S3, contextSeparator: G2, showColumn: O2, showByteOffset: T3, replace: P2, kResetGroup: k3 } = e5, y2 = n3.split(`
`), j2 = y2.length, A2 = j2 > 0 && y2[j2 - 1] === "" ? j2 - 1 : j2, x4 = [0];
  for (let c3 = 0; c3 < n3.length; c3++) n3[c3] === `
` && x4.push(c3 + 1);
  let Z3 = (c3) => {
    let f3 = 0;
    for (let r2 = 0; r2 < x4.length && !(x4[r2] > c3); r2++) f3 = r2;
    return f3;
  }, v2 = (c3) => {
    let f3 = Z3(c3);
    return c3 - x4[f3] + 1;
  }, g2 = [];
  t4.lastIndex = 0;
  for (let c3 = t4.exec(n3); c3 !== null && !(S3 > 0 && g2.length >= S3); c3 = t4.exec(n3)) {
    let f3 = Z3(c3.index), r2 = Z3(c3.index + Math.max(0, c3[0].length - 1)), o2 = k3 !== void 0 ? c3[k3] ?? "" : c3[0];
    g2.push({ startLine: f3, endLine: r2, byteOffset: c3.index, column: v2(c3.index), matchText: o2 }), c3[0].length === 0 && t4.lastIndex++;
  }
  if (h3 || d3) {
    let c3;
    if (d3) c3 = i4 ? 0 : g2.length;
    else {
      let r2 = /* @__PURE__ */ new Set();
      for (let o2 of g2) for (let l3 = o2.startLine; l3 <= o2.endLine; l3++) r2.add(l3);
      c3 = i4 ? A2 - r2.size : r2.size;
    }
    return { output: `${a3 ? `${a3}:${c3}` : String(c3)}
`, matched: c3 > 0, matchCount: c3 };
  }
  if (i4) {
    let c3 = /* @__PURE__ */ new Set();
    for (let r2 of g2) for (let o2 = r2.startLine; o2 <= r2.endLine; o2++) c3.add(o2);
    let f3 = [];
    for (let r2 = 0; r2 < A2; r2++) if (!c3.has(r2)) {
      let o2 = y2[r2];
      s3 && (o2 = `${r2 + 1}:${o2}`), a3 && (o2 = `${a3}:${o2}`), f3.push(o2);
    }
    return { output: f3.length > 0 ? `${f3.join(`
`)}
` : "", matched: f3.length > 0, matchCount: f3.length };
  }
  if (g2.length === 0) return { output: "", matched: false, matchCount: 0 };
  let L4 = /* @__PURE__ */ new Set(), p3 = -1, C2 = [];
  for (let c3 of g2) {
    let f3 = Math.max(0, c3.startLine - b4), r2 = Math.min(A2 - 1, c3.endLine + R2);
    p3 >= 0 && f3 > p3 + 1 && C2.push(G2);
    for (let o2 = f3; o2 < c3.startLine; o2++) if (!L4.has(o2)) {
      L4.add(o2), p3 = o2;
      let l3 = y2[o2];
      s3 && (l3 = `${o2 + 1}-${l3}`), a3 && (l3 = `${a3}-${l3}`), C2.push(l3);
    }
    if (m3) {
      let o2 = P2 !== null ? P2 : c3.matchText, l3 = a3 ? `${a3}:` : "";
      T3 && (l3 += `${c3.byteOffset}:`), s3 && (l3 += `${c3.startLine + 1}:`), O2 && (l3 += `${c3.column}:`), C2.push(l3 + o2);
      for (let u3 = c3.startLine; u3 <= c3.endLine; u3++) L4.add(u3), p3 = u3;
    } else for (let o2 = c3.startLine; o2 <= c3.endLine && o2 < A2; o2++) if (!L4.has(o2)) {
      L4.add(o2), p3 = o2;
      let l3 = y2[o2];
      P2 !== null && o2 === c3.startLine && (t4.lastIndex = 0, l3 = l3.replace(t4, P2));
      let u3 = a3 ? `${a3}:` : "";
      T3 && o2 === c3.startLine && (u3 += `${c3.byteOffset}:`), s3 && (u3 += `${o2 + 1}:`), O2 && o2 === c3.startLine && (u3 += `${c3.column}:`), C2.push(u3 + l3);
    }
    for (let o2 = c3.endLine + 1; o2 <= r2; o2++) if (!L4.has(o2)) {
      L4.add(o2), p3 = o2;
      let l3 = y2[o2];
      s3 && (l3 = `${o2 + 1}-${l3}`), a3 && (l3 = `${a3}-${l3}`), C2.push(l3);
    }
  }
  return { output: C2.length > 0 ? `${C2.join(`
`)}
` : "", matched: true, matchCount: g2.length };
}
var Q$7 = { alpha: "a-zA-Z", digit: "0-9", alnum: "a-zA-Z0-9", lower: "a-z", upper: "A-Z", xdigit: "0-9A-Fa-f", space: " \\t\\n\\r\\f\\v", blank: " \\t", punct: "!-/:-@\\[-`{-~", graph: "!-~", print: " -~", cntrl: "\\x00-\\x1F\\x7F", ascii: "\\x00-\\x7F", word: "a-zA-Z0-9_" };
function B$a(n3) {
  let t4 = "", e5 = 0;
  for (; e5 < n3.length; ) {
    if (n3.slice(e5, e5 + 7) === "[[:<:]]") {
      t4 += "(?<![\\w])", e5 += 7;
      continue;
    }
    if (n3.slice(e5, e5 + 7) === "[[:>:]]") {
      t4 += "(?![\\w])", e5 += 7;
      continue;
    }
    if (n3[e5] === "[") {
      let i4 = "[";
      for (e5++, e5 < n3.length && (n3[e5] === "^" || n3[e5] === "!") && (i4 += "^", e5++), e5 < n3.length && n3[e5] === "]" && (i4 += "\\]", e5++); e5 < n3.length && n3[e5] !== "]"; ) {
        if (n3[e5] === "[" && e5 + 1 < n3.length && n3[e5 + 1] === ":") {
          let s3 = n3.indexOf(":]", e5 + 2);
          if (s3 !== -1) {
            let h3 = n3.slice(e5 + 2, s3), d3 = Q$7[h3];
            if (d3) {
              i4 += d3, e5 = s3 + 2;
              continue;
            }
          }
        }
        if (n3[e5] === "\\" && e5 + 1 < n3.length) {
          i4 += n3[e5] + n3[e5 + 1], e5 += 2;
          continue;
        }
        i4 += n3[e5], e5++;
      }
      e5 < n3.length && n3[e5] === "]" && (i4 += "]", e5++), t4 += i4;
      continue;
    }
    if (n3[e5] === "\\" && e5 + 1 < n3.length) {
      t4 += n3[e5] + n3[e5 + 1], e5 += 2;
      continue;
    }
    t4 += n3[e5], e5++;
  }
  return t4;
}
function q$b(n3, t4) {
  let e5, i4;
  switch (t4.mode) {
    case "fixed":
      e5 = n3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      break;
    case "extended":
    case "perl": {
      if (e5 = B$a(n3), e5 = e5.replace(/\(\?P<([^>]+)>/g, "(?<$1>"), t4.mode === "perl") {
        e5 = W$a(e5), e5 = X$7(e5), e5 = H$a(e5);
        let d3 = ee$2(e5);
        e5 = d3.pattern, i4 = d3.kResetGroup;
      }
      break;
    }
    default:
      e5 = B$a(n3), e5 = le$6(e5);
      break;
  }
  t4.wholeWord && (e5 = `(?<![\\w])(?:${e5})(?![\\w])`), t4.lineRegexp && (e5 = `^${e5}$`);
  let s3 = /\\u\{[0-9A-Fa-f]+\}/.test(e5), h3 = "g" + (t4.ignoreCase ? "i" : "") + (t4.multiline ? "m" : "") + (t4.multilineDotall ? "s" : "") + (s3 ? "u" : "");
  return { regex: new RegExp(e5, h3), kResetGroup: i4 };
}
function W$a(n3) {
  let t4 = "", e5 = 0;
  for (; e5 < n3.length; ) if (n3[e5] === "\\" && e5 + 1 < n3.length && n3[e5 + 1] === "Q") {
    e5 += 2;
    let i4 = "";
    for (; e5 < n3.length; ) {
      if (n3[e5] === "\\" && e5 + 1 < n3.length && n3[e5 + 1] === "E") {
        e5 += 2;
        break;
      }
      i4 += n3[e5], e5++;
    }
    t4 += i4.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  } else t4 += n3[e5], e5++;
  return t4;
}
function X$7(n3) {
  return n3.replace(/\\x\{([0-9A-Fa-f]+)\}/g, "\\u{$1}");
}
function H$a(n3) {
  let t4 = "", e5 = 0;
  for (; e5 < n3.length; ) {
    if (n3[e5] === "(" && e5 + 1 < n3.length && n3[e5 + 1] === "?") {
      let i4 = n3.slice(e5).match(/^\(\?([imsx]*)(-[imsx]*)?(:|$|\))/);
      if (i4) {
        let s3 = i4[1] || "";
        i4[2] || "";
        let d3 = i4[3];
        if (d3 === ":") {
          let a3 = e5 + i4[0].length - 1, m3 = J$9(n3, e5);
          if (m3 !== -1) {
            let b4 = n3.slice(a3 + 1, m3), R2 = V$a(b4, s3);
            t4 += `(?:${R2})`, e5 = m3 + 1;
            continue;
          }
        } else if (d3 === ")" || d3 === "") {
          e5 += i4[0].length;
          continue;
        }
      }
    }
    t4 += n3[e5], e5++;
  }
  return t4;
}
function J$9(n3, t4) {
  let e5 = 0, i4 = t4;
  for (; i4 < n3.length; ) {
    if (n3[i4] === "\\") {
      i4 += 2;
      continue;
    }
    if (n3[i4] === "[") {
      for (i4++; i4 < n3.length && n3[i4] !== "]"; ) n3[i4] === "\\" && i4++, i4++;
      i4++;
      continue;
    }
    if (n3[i4] === "(") e5++;
    else if (n3[i4] === ")" && (e5--, e5 === 0)) return i4;
    i4++;
  }
  return -1;
}
function V$a(n3, t4, e5) {
  let i4 = n3;
  return t4.includes("i") && (i4 = Y$7(i4)), i4;
}
function Y$7(n3) {
  let t4 = "", e5 = 0;
  for (; e5 < n3.length; ) {
    let i4 = n3[e5];
    if (i4 === "\\") {
      e5 + 1 < n3.length ? (t4 += i4 + n3[e5 + 1], e5 += 2) : (t4 += i4, e5++);
      continue;
    }
    if (i4 === "[") {
      t4 += i4, e5++, e5 < n3.length && n3[e5] === "^" && (t4 += n3[e5], e5++);
      let s3 = [];
      for (; e5 < n3.length && n3[e5] !== "]"; ) if (n3[e5] === "\\") s3.push(n3[e5]), e5++, e5 < n3.length && (s3.push(n3[e5]), e5++);
      else if (n3[e5] === "-" && s3.length > 0 && e5 + 1 < n3.length && n3[e5 + 1] !== "]") {
        let h3 = s3[s3.length - 1], d3 = n3[e5 + 1];
        s3.push("-"), s3.push(d3), /[a-z]/.test(h3) && /[a-z]/.test(d3) ? (s3.push(h3.toUpperCase()), s3.push("-"), s3.push(d3.toUpperCase())) : /[A-Z]/.test(h3) && /[A-Z]/.test(d3) && (s3.push(h3.toLowerCase()), s3.push("-"), s3.push(d3.toLowerCase())), e5 += 2;
      } else {
        let h3 = n3[e5];
        if (s3.push(h3), /[a-zA-Z]/.test(h3)) {
          let d3 = h3 === h3.toLowerCase() ? h3.toUpperCase() : h3.toLowerCase();
          s3.includes(d3) || s3.push(d3);
        }
        e5++;
      }
      t4 += s3.join(""), e5 < n3.length && (t4 += n3[e5], e5++);
      continue;
    }
    if (/[a-zA-Z]/.test(i4)) {
      let s3 = i4.toLowerCase(), h3 = i4.toUpperCase();
      t4 += `[${h3}${s3}]`;
    } else t4 += i4;
    e5++;
  }
  return t4;
}
function ee$2(n3) {
  let t4 = ne$5(n3);
  if (t4 === -1) return { pattern: n3 };
  let e5 = n3.slice(0, t4), i4 = n3.slice(t4 + 2), s3 = te$7(e5);
  return { pattern: `(?:${e5})(${i4})`, kResetGroup: s3 + 1 };
}
function ne$5(n3) {
  let t4 = 0;
  for (; t4 < n3.length - 1; ) if (n3[t4] === "\\") {
    if (n3[t4 + 1] === "K") {
      let e5 = 0, i4 = t4 - 1;
      for (; i4 >= 0 && n3[i4] === "\\"; ) e5++, i4--;
      if (e5 % 2 === 0) return t4;
    }
    t4 += 2;
  } else t4++;
  return -1;
}
function te$7(n3) {
  let t4 = 0, e5 = 0;
  for (; e5 < n3.length; ) {
    if (n3[e5] === "\\") {
      e5 += 2;
      continue;
    }
    if (n3[e5] === "[") {
      for (e5++; e5 < n3.length && n3[e5] !== "]"; ) n3[e5] === "\\" && e5++, e5++;
      e5++;
      continue;
    }
    if (n3[e5] === "(") if (e5 + 1 < n3.length && n3[e5 + 1] === "?") {
      if (e5 + 2 < n3.length) {
        let i4 = n3[e5 + 2];
        if (i4 === ":" || i4 === "=" || i4 === "!") {
          e5++;
          continue;
        }
        if (i4 === "<" && e5 + 3 < n3.length) {
          let s3 = n3[e5 + 3];
          if (s3 === "=" || s3 === "!") {
            e5++;
            continue;
          }
          t4++, e5++;
          continue;
        }
      }
    } else t4++;
    e5++;
  }
  return t4;
}
function ie$7(n3) {
  let t4 = n3.replace(/\$\{0\}|\$0(?![0-9])/g, "$$&");
  return t4 = t4.replace(/\$\{([^0-9}][^}]*)\}/g, "$$<$1>"), t4 = t4.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)(?![>0-9])/g, "$$<$1>"), t4;
}
function le$6(n3) {
  let t4 = "", e5 = 0, i4 = true;
  for (; e5 < n3.length; ) {
    let h3 = n3[e5];
    if (h3 === "[") {
      for (t4 += h3, e5++, e5 < n3.length && (n3[e5] === "^" || n3[e5] === "!") && (t4 += n3[e5], e5++), e5 < n3.length && n3[e5] === "]" && (t4 += n3[e5], e5++); e5 < n3.length && n3[e5] !== "]"; ) n3[e5] === "\\" && e5 + 1 < n3.length ? (t4 += n3[e5] + n3[e5 + 1], e5 += 2) : (t4 += n3[e5], e5++);
      e5 < n3.length && n3[e5] === "]" && (t4 += n3[e5], e5++), i4 = false;
      continue;
    }
    if (h3 === "\\" && e5 + 1 < n3.length) {
      let d3 = n3[e5 + 1];
      if (d3 === "|") {
        t4 += "|", e5 += 2, i4 = true;
        continue;
      }
      if (d3 === "(") {
        t4 += "(", e5 += 2, i4 = true;
        continue;
      }
      if (d3 === ")") {
        t4 += ")", e5 += 2, i4 = false;
        continue;
      }
      if (d3 === "{") {
        let m3 = n3.slice(e5).match(/^\\{(\d+)(,(\d*)?)?\\}/);
        if (m3) {
          let b4 = m3[1], R2 = m3[2] !== void 0, S3 = m3[3] || "";
          R2 ? t4 += `{${b4},${S3}}` : t4 += `{${b4}}`, e5 += m3[0].length, i4 = false;
          continue;
        }
        t4 += "\\{", e5 += 2, i4 = false;
        continue;
      }
      if (d3 === "}") {
        t4 += "\\}", e5 += 2, i4 = false;
        continue;
      }
      t4 += h3 + d3, e5 += 2, i4 = false;
      continue;
    }
    if (h3 === "*" && i4) {
      t4 += "\\*", e5++;
      continue;
    }
    if (h3 === "^") {
      if (i4) {
        t4 += "^", e5++;
        continue;
      }
      t4 += "\\^", e5++;
      continue;
    }
    if (h3 === "$") {
      let d3 = e5 === n3.length - 1, a3 = e5 + 2 < n3.length && n3[e5 + 1] === "\\" && n3[e5 + 2] === ")";
      d3 || a3 ? t4 += "$" : t4 += "\\$", e5++, i4 = false;
      continue;
    }
    h3 === "+" || h3 === "?" || h3 === "|" || h3 === "(" || h3 === ")" || h3 === "{" || h3 === "}" ? t4 += `\\${h3}` : t4 += h3, e5++, i4 = false;
  }
  return t4;
}
var te$6 = { name: "grep", summary: "print lines that match patterns", usage: "grep [OPTION]... PATTERN [FILE]...", options: ["-E, --extended-regexp    PATTERN is an extended regular expression", "-P, --perl-regexp        PATTERN is a Perl regular expression", "-F, --fixed-strings      PATTERN is a set of newline-separated strings", "-i, --ignore-case        ignore case distinctions", "-v, --invert-match       select non-matching lines", "-w, --word-regexp        match only whole words", "-x, --line-regexp        match only whole lines", "-c, --count              print only a count of matching lines", "-l, --files-with-matches print only names of files with matches", "-L, --files-without-match print names of files with no matches", "-m NUM, --max-count=NUM  stop after NUM matches", "-n, --line-number        print line number with output lines", "-h, --no-filename        suppress the file name prefix on output", "-o, --only-matching      show only nonempty parts of lines that match", "-q, --quiet, --silent    suppress all normal output", "-r, -R, --recursive      search directories recursively", "-A NUM                   print NUM lines of trailing context", "-B NUM                   print NUM lines of leading context", "-C NUM                   print NUM lines of context", "-e PATTERN               use PATTERN for matching", "    --include=GLOB       search only files matching GLOB", "    --exclude=GLOB       skip files matching GLOB", "    --exclude-dir=DIR    skip directories matching DIR", "    --help               display this help and exit"] }, J$8 = { name: "grep", async execute(t4, s3) {
  if (o$3(t4)) return s$1(te$6);
  let o2 = false, f3 = false, c3 = false, h3 = false, m3 = false, l3 = false, i4 = false, d3 = false, w4 = false, u3 = false, p3 = false, T3 = false, x4 = false, q2 = false, B2 = false, M4 = 0, R2 = 0, F2 = 0, W4 = [], A2 = [], Q4 = [], N2 = null, I2 = [];
  for (let r2 = 0; r2 < t4.length; r2++) {
    let n3 = t4[r2];
    if (n3.startsWith("-") && n3 !== "-") {
      if (n3 === "-e" && r2 + 1 < t4.length) {
        N2 = t4[++r2];
        continue;
      }
      if (n3.startsWith("--include=")) {
        W4.push(n3.slice(10));
        continue;
      }
      if (n3.startsWith("--exclude=")) {
        A2.push(n3.slice(10));
        continue;
      }
      if (n3.startsWith("--exclude-dir=")) {
        Q4.push(n3.slice(14));
        continue;
      }
      if (n3.startsWith("--max-count=")) {
        M4 = parseInt(n3.slice(12), 10);
        continue;
      }
      let C2 = n3.match(/^-m(\d+)$/);
      if (C2) {
        M4 = parseInt(C2[1], 10);
        continue;
      }
      if (n3 === "-m" && r2 + 1 < t4.length) {
        M4 = parseInt(t4[++r2], 10);
        continue;
      }
      let a3 = n3.match(/^-([ABC])(\d+)$/);
      if (a3) {
        let e5 = parseInt(a3[2], 10);
        a3[1] === "A" ? F2 = e5 : a3[1] === "B" ? R2 = e5 : a3[1] === "C" && (R2 = e5, F2 = e5);
        continue;
      }
      if ((n3 === "-A" || n3 === "-B" || n3 === "-C") && r2 + 1 < t4.length) {
        let e5 = parseInt(t4[++r2], 10);
        n3 === "-A" ? F2 = e5 : n3 === "-B" ? R2 = e5 : (R2 = e5, F2 = e5);
        continue;
      }
      let g2 = n3.startsWith("--") ? [n3] : n3.slice(1).split("");
      for (let e5 of g2) if (e5 === "i" || e5 === "--ignore-case") o2 = true;
      else if (e5 === "n" || e5 === "--line-number") f3 = true;
      else if (e5 === "v" || e5 === "--invert-match") c3 = true;
      else if (e5 === "c" || e5 === "--count") h3 = true;
      else if (e5 === "l" || e5 === "--files-with-matches") m3 = true;
      else if (e5 === "L" || e5 === "--files-without-match") l3 = true;
      else if (e5 === "r" || e5 === "R" || e5 === "--recursive") i4 = true;
      else if (e5 === "w" || e5 === "--word-regexp") d3 = true;
      else if (e5 === "x" || e5 === "--line-regexp") w4 = true;
      else if (e5 === "E" || e5 === "--extended-regexp") u3 = true;
      else if (e5 === "P" || e5 === "--perl-regexp") p3 = true;
      else if (e5 === "F" || e5 === "--fixed-strings") T3 = true;
      else if (e5 === "o" || e5 === "--only-matching") x4 = true;
      else if (e5 === "h" || e5 === "--no-filename") q2 = true;
      else if (e5 === "q" || e5 === "--quiet" || e5 === "--silent") B2 = true;
      else {
        if (e5.startsWith("--")) return r$3("grep", e5);
        if (e5.length === 1) return r$3("grep", `-${e5}`);
      }
    } else N2 === null ? N2 = n3 : I2.push(n3);
  }
  if (N2 === null) return { stdout: "", stderr: `grep: missing pattern
`, exitCode: 2 };
  let V4 = T3 ? "fixed" : u3 ? "extended" : p3 ? "perl" : "basic", U2, b4;
  try {
    let r2 = q$b(N2, { mode: V4, ignoreCase: o2, wholeWord: d3, lineRegexp: w4 });
    U2 = r2.regex, b4 = r2.kResetGroup;
  } catch {
    return { stdout: "", stderr: `grep: invalid regular expression: ${N2}
`, exitCode: 2 };
  }
  if (I2.length === 0 && s3.stdin !== void 0) {
    let r2 = K$7(s3.stdin, U2, { invertMatch: c3, showLineNumbers: f3, countOnly: h3, filename: "", onlyMatching: x4, beforeContext: R2, afterContext: F2, maxCount: M4, kResetGroup: b4 });
    return B2 ? { stdout: "", stderr: "", exitCode: r2.matched ? 0 : 1 } : { stdout: r2.output, stderr: "", exitCode: r2.matched ? 0 : 1 };
  }
  if (I2.length === 0) return { stdout: "", stderr: `grep: no input files
`, exitCode: 2 };
  let $5 = "", D3 = "", H2 = false, k3 = false, P2 = [];
  for (let r2 of I2) if (r2.includes("*") || r2.includes("?") || r2.includes("[")) {
    let n3 = await se$6(r2, s3);
    if (i4) for (let C2 of n3) {
      let a3 = await O$b(C2.path, s3, W4, A2, Q4, C2.isFile);
      P2.push(...a3);
    }
    else P2.push(...n3);
  } else if (i4) {
    let n3 = await O$b(r2, s3, W4, A2, Q4);
    P2.push(...n3);
  } else P2.push({ path: r2 });
  let X3 = (P2.length > 1 || i4) && !q2, Z3 = 50;
  for (let r2 = 0; r2 < P2.length; r2 += Z3) {
    let n3 = P2.slice(r2, r2 + Z3), C2 = await Promise.all(n3.map(async (a3) => {
      let g2 = a3.path, e5 = g2.split("/").pop() || g2;
      if (A2.length > 0 && !i4 && A2.some((v2) => f$3(e5, v2, { stripQuotes: true })) || W4.length > 0 && !i4 && !W4.some((v2) => f$3(e5, v2, { stripQuotes: true }))) return null;
      try {
        let v2 = s3.fs.resolvePath(s3.cwd, g2), L4 = false;
        if (a3.isFile === void 0 ? L4 = (await s3.fs.stat(v2)).isDirectory : L4 = !a3.isFile, L4) return i4 ? null : { error: `grep: ${g2}: Is a directory
` };
        let Y2 = await s3.fs.readFile(v2), ee2 = K$7(Y2, U2, { invertMatch: c3, showLineNumbers: f3, countOnly: h3, filename: X3 ? g2 : "", onlyMatching: x4, beforeContext: R2, afterContext: F2, maxCount: M4, kResetGroup: b4 });
        return { file: g2, result: ee2 };
      } catch {
        return { error: `grep: ${g2}: No such file or directory
` };
      }
    }));
    for (let a3 of C2) {
      if (a3 === null) continue;
      if ("error" in a3 && a3.error) {
        D3 += a3.error, a3.error.includes("Is a directory") || (k3 = true);
        continue;
      }
      if (!("file" in a3) || !a3.result) continue;
      let { file: g2, result: e5 } = a3;
      if (e5.matched) {
        if (H2 = true, B2) return { stdout: "", stderr: "", exitCode: 0 };
        m3 ? $5 += `${g2}
` : l3 || ($5 += e5.output);
      } else l3 ? $5 += `${g2}
` : h3 && !m3 && ($5 += e5.output);
    }
  }
  let E2;
  return k3 ? E2 = 2 : l3 ? E2 = $5.length > 0 ? 0 : 1 : E2 = H2 ? 0 : 1, B2 ? { stdout: "", stderr: "", exitCode: E2 } : { stdout: $5, stderr: D3, exitCode: E2 };
} };
async function K$6(t4, s3, o2, f3) {
  let c3 = o2.fs.resolvePath(o2.cwd, t4);
  try {
    if (!(await o2.fs.stat(c3)).isDirectory) {
      let l3 = t4.split("/").pop() || "";
      if (s3) {
        let i4 = s3.replace(/^\//, "");
        f$3(l3, i4, { stripQuotes: true }) && f3.push(t4);
      }
      return;
    }
    let m3 = await o2.fs.readdir(c3);
    for (let l3 of m3) {
      let i4 = t4 === "." ? l3 : `${t4}/${l3}`, d3 = o2.fs.resolvePath(o2.cwd, i4);
      if ((await o2.fs.stat(d3)).isDirectory) await K$6(i4, s3, o2, f3);
      else if (s3) {
        let u3 = s3.replace(/^\//, "");
        f$3(l3, u3, { stripQuotes: true }) && f3.push(i4);
      }
    }
  } catch {
  }
}
async function se$6(t4, s3) {
  let o2 = [], f3 = t4.lastIndexOf("/"), c3, h3;
  if (f3 === -1 ? (c3 = s3.cwd, h3 = t4) : (c3 = t4.slice(0, f3) || "/", h3 = t4.slice(f3 + 1)), t4.includes("**")) {
    let l3 = [], i4 = t4.split("**"), d3 = i4[0].replace(/\/$/, "") || ".", w4 = i4[1] || "";
    return await K$6(d3, w4, s3, l3), l3.map((u3) => ({ path: u3 }));
  }
  let m3 = s3.fs.resolvePath(s3.cwd, c3);
  try {
    if (s3.fs.readdirWithFileTypes) {
      let l3 = await s3.fs.readdirWithFileTypes(m3);
      for (let i4 of l3) if (f$3(i4.name, h3, { stripQuotes: true })) {
        let d3 = f3 === -1 ? i4.name : `${c3}/${i4.name}`;
        o2.push({ path: d3, isFile: i4.isFile });
      }
    } else {
      let l3 = await s3.fs.readdir(m3);
      for (let i4 of l3) if (f$3(i4, h3, { stripQuotes: true })) {
        let d3 = f3 === -1 ? i4 : `${c3}/${i4}`;
        o2.push({ path: d3 });
      }
    }
  } catch {
  }
  return o2.sort((l3, i4) => l3.path.localeCompare(i4.path));
}
async function O$b(t4, s3, o2 = [], f3 = [], c3 = [], h3) {
  let m3 = s3.fs.resolvePath(s3.cwd, t4), l3 = [];
  try {
    let i4, d3;
    if (h3 !== void 0) i4 = h3, d3 = !h3;
    else {
      let u3 = await s3.fs.stat(m3);
      i4 = u3.isFile, d3 = u3.isDirectory;
    }
    if (i4) {
      let u3 = t4.split("/").pop() || t4;
      return f3.length > 0 && f3.some((p3) => f$3(u3, p3, { stripQuotes: true })) ? [] : o2.length > 0 && !o2.some((p3) => f$3(u3, p3, { stripQuotes: true })) ? [] : [{ path: t4, isFile: true }];
    }
    if (!d3) return [];
    let w4 = t4.split("/").pop() || t4;
    if (c3.length > 0 && c3.some((u3) => f$3(w4, u3, { stripQuotes: true }))) return [];
    if (s3.fs.readdirWithFileTypes) {
      let u3 = await s3.fs.readdirWithFileTypes(m3);
      for (let p3 of u3) {
        if (p3.name.startsWith(".")) continue;
        let T3 = t4 === "." ? p3.name : `${t4}/${p3.name}`, x4 = await O$b(T3, s3, o2, f3, c3, p3.isFile);
        l3.push(...x4);
      }
    } else {
      let u3 = await s3.fs.readdir(m3);
      for (let p3 of u3) {
        if (p3.startsWith(".")) continue;
        let T3 = t4 === "." ? p3 : `${t4}/${p3}`, x4 = await O$b(T3, s3, o2, f3, c3);
        l3.push(...x4);
      }
    }
  } catch {
  }
  return l3;
}
var oe$6 = { name: "fgrep", async execute(t4, s3) {
  return J$8.execute(["-F", ...t4], s3);
} }, ae$4 = { name: "egrep", async execute(t4, s3) {
  return J$8.execute(["-E", ...t4], s3);
} };
const grepNIC6JNLH = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  egrepCommand: ae$4,
  fgrepCommand: oe$6,
  grepCommand: J$8
});
var B$9 = { js: { extensions: [".js", ".mjs", ".cjs", ".jsx"], globs: [] }, ts: { extensions: [".ts", ".tsx", ".mts", ".cts"], globs: [] }, html: { extensions: [".html", ".htm", ".xhtml"], globs: [] }, css: { extensions: [".css", ".scss", ".sass", ".less"], globs: [] }, json: { extensions: [".json", ".jsonc", ".json5"], globs: [] }, xml: { extensions: [".xml", ".xsl", ".xslt"], globs: [] }, c: { extensions: [".c", ".h"], globs: [] }, cpp: { extensions: [".cpp", ".cc", ".cxx", ".hpp", ".hh", ".hxx", ".h"], globs: [] }, rust: { extensions: [".rs"], globs: [] }, go: { extensions: [".go"], globs: [] }, zig: { extensions: [".zig"], globs: [] }, java: { extensions: [".java"], globs: [] }, kotlin: { extensions: [".kt", ".kts"], globs: [] }, scala: { extensions: [".scala", ".sc"], globs: [] }, clojure: { extensions: [".clj", ".cljc", ".cljs", ".edn"], globs: [] }, py: { extensions: [".py", ".pyi", ".pyw"], globs: [] }, rb: { extensions: [".rb", ".rake", ".gemspec"], globs: ["Rakefile", "Gemfile"] }, php: { extensions: [".php", ".phtml", ".php3", ".php4", ".php5"], globs: [] }, perl: { extensions: [".pl", ".pm", ".pod", ".t"], globs: [] }, lua: { extensions: [".lua"], globs: [] }, sh: { extensions: [".sh", ".bash", ".zsh", ".fish"], globs: [".bashrc", ".zshrc", ".profile"] }, bat: { extensions: [".bat", ".cmd"], globs: [] }, ps: { extensions: [".ps1", ".psm1", ".psd1"], globs: [] }, yaml: { extensions: [".yaml", ".yml"], globs: [] }, toml: { extensions: [".toml"], globs: ["Cargo.toml", "pyproject.toml"] }, ini: { extensions: [".ini", ".cfg", ".conf"], globs: [] }, csv: { extensions: [".csv", ".tsv"], globs: [] }, md: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, markdown: { extensions: [".md", ".mdx", ".markdown", ".mdown", ".mkd"], globs: [] }, rst: { extensions: [".rst"], globs: [] }, txt: { extensions: [".txt", ".text"], globs: [] }, tex: { extensions: [".tex", ".ltx", ".sty", ".cls"], globs: [] }, sql: { extensions: [".sql"], globs: [] }, graphql: { extensions: [".graphql", ".gql"], globs: [] }, proto: { extensions: [".proto"], globs: [] }, make: { extensions: [".mk", ".mak"], globs: ["Makefile", "GNUmakefile", "makefile"] }, docker: { extensions: [], globs: ["Dockerfile", "Dockerfile.*", "*.dockerfile"] }, tf: { extensions: [".tf", ".tfvars"], globs: [] } }, $$6 = class $2 {
  types;
  constructor() {
    this.types = new Map(Object.entries(B$9).map(([t4, n3]) => [t4, { extensions: [...n3.extensions], globs: [...n3.globs] }]));
  }
  addType(t4) {
    let n3 = t4.indexOf(":");
    if (n3 === -1) return;
    let s3 = t4.slice(0, n3), r2 = t4.slice(n3 + 1);
    if (r2.startsWith("include:")) {
      let l3 = r2.slice(8), i4 = this.types.get(l3);
      if (i4) {
        let o2 = this.types.get(s3) || { extensions: [], globs: [] };
        o2.extensions.push(...i4.extensions), o2.globs.push(...i4.globs), this.types.set(s3, o2);
      }
    } else {
      let l3 = this.types.get(s3) || { extensions: [], globs: [] };
      if (r2.startsWith("*.") && !r2.slice(2).includes("*")) {
        let i4 = r2.slice(1);
        l3.extensions.includes(i4) || l3.extensions.push(i4);
      } else l3.globs.includes(r2) || l3.globs.push(r2);
      this.types.set(s3, l3);
    }
  }
  clearType(t4) {
    let n3 = this.types.get(t4);
    n3 && (n3.extensions = [], n3.globs = []);
  }
  getType(t4) {
    return this.types.get(t4);
  }
  getAllTypes() {
    return this.types;
  }
  matchesType(t4, n3) {
    let s3 = t4.toLowerCase();
    for (let r2 of n3) {
      if (r2 === "all") {
        if (this.matchesAnyType(t4)) return true;
        continue;
      }
      let l3 = this.types.get(r2);
      if (l3) {
        for (let i4 of l3.extensions) if (s3.endsWith(i4)) return true;
        for (let i4 of l3.globs) if (i4.includes("*")) {
          let o2 = i4.replace(/\./g, "\\.").replace(/\*/g, ".*");
          if (new RegExp(`^${o2}$`, "i").test(t4)) return true;
        } else if (s3 === i4.toLowerCase()) return true;
      }
    }
    return false;
  }
  matchesAnyType(t4) {
    let n3 = t4.toLowerCase();
    for (let s3 of this.types.values()) {
      for (let r2 of s3.extensions) if (n3.endsWith(r2)) return true;
      for (let r2 of s3.globs) if (r2.includes("*")) {
        let l3 = r2.replace(/\./g, "\\.").replace(/\*/g, ".*");
        if (new RegExp(`^${l3}$`, "i").test(t4)) return true;
      } else if (n3 === r2.toLowerCase()) return true;
    }
    return false;
  }
};
function G$5() {
  let e5 = [];
  for (let [t4, n3] of Object.entries(B$9).sort()) {
    let s3 = [];
    for (let r2 of n3.extensions) s3.push(`*${r2}`);
    for (let r2 of n3.globs) s3.push(r2);
    e5.push(`${t4}: ${s3.join(", ")}`);
  }
  return `${e5.join(`
`)}
`;
}
function U$6() {
  return { ignoreCase: false, caseSensitive: false, smartCase: true, fixedStrings: false, wordRegexp: false, lineRegexp: false, invertMatch: false, multiline: false, multilineDotall: false, patterns: [], patternFiles: [], count: false, countMatches: false, files: false, filesWithMatches: false, filesWithoutMatch: false, stats: false, onlyMatching: false, maxCount: 0, lineNumber: true, noFilename: false, withFilename: false, nullSeparator: false, byteOffset: false, column: false, vimgrep: false, replace: null, afterContext: 0, beforeContext: 0, contextSeparator: "--", quiet: false, heading: false, passthru: false, includeZero: false, sort: "path", json: false, globs: [], iglobs: [], globCaseInsensitive: false, types: [], typesNot: [], typeAdd: [], typeClear: [], hidden: false, noIgnore: false, noIgnoreDot: false, noIgnoreVcs: false, ignoreFiles: [], maxDepth: 1 / 0, maxFilesize: 0, followSymlinks: false, searchZip: false, searchBinary: false, preprocessor: null, preprocessorGlobs: [] };
}
function X$6(e5) {
  let t4 = e5.match(/^(\d+)([KMG])?$/i);
  if (!t4) return 0;
  let n3 = parseInt(t4[1], 10);
  switch ((t4[2] || "").toUpperCase()) {
    case "K":
      return n3 * 1024;
    case "M":
      return n3 * 1024 * 1024;
    case "G":
      return n3 * 1024 * 1024 * 1024;
    default:
      return n3;
  }
}
function Q$6(e5) {
  return /^\d+[KMG]?$/i.test(e5) ? null : { stdout: "", stderr: `rg: invalid --max-filesize value: ${e5}
`, exitCode: 1 };
}
function q$a(e5) {
  return null;
}
var V$9 = [{ short: "g", long: "glob", target: "globs", multi: true }, { long: "iglob", target: "iglobs", multi: true }, { short: "t", long: "type", target: "types", multi: true, validate: q$a }, { short: "T", long: "type-not", target: "typesNot", multi: true, validate: q$a }, { long: "type-add", target: "typeAdd", multi: true }, { long: "type-clear", target: "typeClear", multi: true }, { short: "m", long: "max-count", target: "maxCount", parse: parseInt }, { short: "e", long: "regexp", target: "patterns", multi: true }, { short: "f", long: "file", target: "patternFiles", multi: true }, { short: "r", long: "replace", target: "replace" }, { short: "d", long: "max-depth", target: "maxDepth", parse: parseInt }, { long: "max-filesize", target: "maxFilesize", parse: X$6, validate: Q$6 }, { long: "context-separator", target: "contextSeparator" }, { short: "j", long: "threads", target: "maxDepth", parse: () => 1 / 0 }, { long: "ignore-file", target: "ignoreFiles", multi: true }, { long: "pre", target: "preprocessor" }, { long: "pre-glob", target: "preprocessorGlobs", multi: true }], ee$1 = { i: (e5) => {
  e5.ignoreCase = true, e5.caseSensitive = false, e5.smartCase = false;
}, "--ignore-case": (e5) => {
  e5.ignoreCase = true, e5.caseSensitive = false, e5.smartCase = false;
}, s: (e5) => {
  e5.caseSensitive = true, e5.ignoreCase = false, e5.smartCase = false;
}, "--case-sensitive": (e5) => {
  e5.caseSensitive = true, e5.ignoreCase = false, e5.smartCase = false;
}, S: (e5) => {
  e5.smartCase = true, e5.ignoreCase = false, e5.caseSensitive = false;
}, "--smart-case": (e5) => {
  e5.smartCase = true, e5.ignoreCase = false, e5.caseSensitive = false;
}, F: (e5) => {
  e5.fixedStrings = true;
}, "--fixed-strings": (e5) => {
  e5.fixedStrings = true;
}, w: (e5) => {
  e5.wordRegexp = true;
}, "--word-regexp": (e5) => {
  e5.wordRegexp = true;
}, x: (e5) => {
  e5.lineRegexp = true;
}, "--line-regexp": (e5) => {
  e5.lineRegexp = true;
}, v: (e5) => {
  e5.invertMatch = true;
}, "--invert-match": (e5) => {
  e5.invertMatch = true;
}, U: (e5) => {
  e5.multiline = true;
}, "--multiline": (e5) => {
  e5.multiline = true;
}, "--multiline-dotall": (e5) => {
  e5.multilineDotall = true, e5.multiline = true;
}, c: (e5) => {
  e5.count = true;
}, "--count": (e5) => {
  e5.count = true;
}, "--count-matches": (e5) => {
  e5.countMatches = true;
}, l: (e5) => {
  e5.filesWithMatches = true;
}, "--files": (e5) => {
  e5.files = true;
}, "--files-with-matches": (e5) => {
  e5.filesWithMatches = true;
}, "--files-without-match": (e5) => {
  e5.filesWithoutMatch = true;
}, "--stats": (e5) => {
  e5.stats = true;
}, o: (e5) => {
  e5.onlyMatching = true;
}, "--only-matching": (e5) => {
  e5.onlyMatching = true;
}, q: (e5) => {
  e5.quiet = true;
}, "--quiet": (e5) => {
  e5.quiet = true;
}, N: (e5) => {
  e5.lineNumber = false;
}, "--no-line-number": (e5) => {
  e5.lineNumber = false;
}, H: (e5) => {
  e5.withFilename = true;
}, "--with-filename": (e5) => {
  e5.withFilename = true;
}, I: (e5) => {
  e5.noFilename = true;
}, "--no-filename": (e5) => {
  e5.noFilename = true;
}, 0: (e5) => {
  e5.nullSeparator = true;
}, "--null": (e5) => {
  e5.nullSeparator = true;
}, b: (e5) => {
  e5.byteOffset = true;
}, "--byte-offset": (e5) => {
  e5.byteOffset = true;
}, "--column": (e5) => {
  e5.column = true, e5.lineNumber = true;
}, "--no-column": (e5) => {
  e5.column = false;
}, "--vimgrep": (e5) => {
  e5.vimgrep = true, e5.column = true, e5.lineNumber = true;
}, "--json": (e5) => {
  e5.json = true;
}, "--hidden": (e5) => {
  e5.hidden = true;
}, "--no-ignore": (e5) => {
  e5.noIgnore = true;
}, "--no-ignore-dot": (e5) => {
  e5.noIgnoreDot = true;
}, "--no-ignore-vcs": (e5) => {
  e5.noIgnoreVcs = true;
}, L: (e5) => {
  e5.followSymlinks = true;
}, "--follow": (e5) => {
  e5.followSymlinks = true;
}, z: (e5) => {
  e5.searchZip = true;
}, "--search-zip": (e5) => {
  e5.searchZip = true;
}, a: (e5) => {
  e5.searchBinary = true;
}, "--text": (e5) => {
  e5.searchBinary = true;
}, "--heading": (e5) => {
  e5.heading = true;
}, "--passthru": (e5) => {
  e5.passthru = true;
}, "--include-zero": (e5) => {
  e5.includeZero = true;
}, "--glob-case-insensitive": (e5) => {
  e5.globCaseInsensitive = true;
} }, te$5 = /* @__PURE__ */ new Set(["n", "--line-number"]);
function se$5(e5) {
  e5.hidden ? e5.searchBinary = true : e5.noIgnore ? e5.hidden = true : e5.noIgnore = true;
}
function ne$4(e5, t4, n3) {
  let s3 = e5[t4];
  for (let r2 of V$9) {
    if (s3.startsWith(`--${r2.long}=`)) {
      let l3 = s3.slice(`--${r2.long}=`.length), i4 = D$a(n3, r2, l3);
      return i4 ? { newIndex: t4, error: i4 } : { newIndex: t4 };
    }
    if (r2.short && s3.startsWith(`-${r2.short}`) && s3.length > 2) {
      let l3 = s3.slice(2), i4 = D$a(n3, r2, l3);
      return i4 ? { newIndex: t4, error: i4 } : { newIndex: t4 };
    }
    if (r2.short && s3 === `-${r2.short}` || s3 === `--${r2.long}`) {
      if (t4 + 1 >= e5.length) return null;
      let l3 = e5[t4 + 1], i4 = D$a(n3, r2, l3);
      return i4 ? { newIndex: t4 + 1, error: i4 } : { newIndex: t4 + 1 };
    }
  }
  return null;
}
function re$3(e5) {
  return V$9.find((t4) => t4.short === e5);
}
function D$a(e5, t4, n3) {
  if (t4.validate) {
    let r2 = t4.validate(n3);
    if (r2) return r2;
  }
  let s3 = t4.parse ? t4.parse(n3) : n3;
  t4.multi ? e5[t4.target].push(s3) : e5[t4.target] = s3;
}
function ie$6(e5, t4) {
  let n3 = e5[t4];
  if (n3 === "--sort" && t4 + 1 < e5.length) {
    let s3 = e5[t4 + 1];
    if (s3 === "path" || s3 === "none") return { value: s3, newIndex: t4 + 1 };
  }
  if (n3.startsWith("--sort=")) {
    let s3 = n3.slice(7);
    if (s3 === "path" || s3 === "none") return { value: s3, newIndex: t4 };
  }
  return null;
}
function le$5(e5, t4) {
  let n3 = e5[t4], s3 = n3.match(/^-([ABC])(\d+)$/);
  return s3 ? { flag: s3[1], value: parseInt(s3[2], 10), newIndex: t4 } : (n3 === "-A" || n3 === "-B" || n3 === "-C") && t4 + 1 < e5.length ? { flag: n3[1], value: parseInt(e5[t4 + 1], 10), newIndex: t4 + 1 } : null;
}
function oe$5(e5) {
  let t4 = e5.match(/^-m(\d+)$/);
  return t4 ? parseInt(t4[1], 10) : null;
}
function Z$5(e5) {
  let t4 = U$6(), n3 = null, s3 = [], r2 = -1, l3 = -1, i4 = -1, o2 = false;
  for (let c3 = 0; c3 < e5.length; c3++) {
    let a3 = e5[c3];
    if (a3.startsWith("-") && a3 !== "-") {
      let u3 = le$5(e5, c3);
      if (u3) {
        let { flag: f3, value: x4, newIndex: b4 } = u3;
        f3 === "A" ? r2 = Math.max(r2, x4) : f3 === "B" ? l3 = Math.max(l3, x4) : i4 = x4, c3 = b4;
        continue;
      }
      let m3 = oe$5(a3);
      if (m3 !== null) {
        t4.maxCount = m3;
        continue;
      }
      let p3 = ne$4(e5, c3, t4);
      if (p3) {
        if (p3.error) return { success: false, error: p3.error };
        c3 = p3.newIndex;
        continue;
      }
      let g2 = ie$6(e5, c3);
      if (g2) {
        t4.sort = g2.value, c3 = g2.newIndex;
        continue;
      }
      let w4 = a3.startsWith("--") ? [a3] : a3.slice(1).split("");
      for (let f3 of w4) {
        if (te$5.has(f3)) {
          t4.lineNumber = true, o2 = true;
          continue;
        }
        if (f3 === "u" || f3 === "--unrestricted") {
          se$5(t4);
          continue;
        }
        if (f3 === "P" || f3 === "--pcre2") return { success: false, error: { stdout: "", stderr: `rg: PCRE2 is not supported. Use standard regex syntax instead.
`, exitCode: 1 } };
        if (f3.length === 1) {
          let b4 = re$3(f3);
          if (b4) {
            if (c3 + 1 >= e5.length) return { success: false, error: r$3("rg", `-${f3}`) };
            let h3 = D$a(t4, b4, e5[c3 + 1]);
            if (h3) return { success: false, error: h3 };
            c3++;
            continue;
          }
        }
        let x4 = ee$1[f3];
        if (x4) {
          x4(t4);
          continue;
        }
        if (f3.startsWith("--")) return { success: false, error: r$3("rg", f3) };
        if (f3.length === 1) return { success: false, error: r$3("rg", `-${f3}`) };
      }
    } else n3 === null && t4.patterns.length === 0 && t4.patternFiles.length === 0 ? n3 = a3 : s3.push(a3);
  }
  return (r2 >= 0 || i4 >= 0) && (t4.afterContext = Math.max(r2 >= 0 ? r2 : 0, i4 >= 0 ? i4 : 0)), (l3 >= 0 || i4 >= 0) && (t4.beforeContext = Math.max(l3 >= 0 ? l3 : 0, i4 >= 0 ? i4 : 0)), n3 !== null && t4.patterns.push(n3), (t4.column || t4.vimgrep) && (o2 = true), { success: true, options: t4, paths: s3, explicitLineNumbers: o2 };
}
var M$a = class M {
  patterns = [];
  basePath;
  constructor(t4 = "/") {
    this.basePath = t4;
  }
  parse(t4) {
    let n3 = t4.split(`
`);
    for (let s3 of n3) {
      let r2 = s3.replace(/\s+$/, "");
      if (!r2 || r2.startsWith("#")) continue;
      let l3 = false;
      r2.startsWith("!") && (l3 = true, r2 = r2.slice(1));
      let i4 = false;
      r2.endsWith("/") && (i4 = true, r2 = r2.slice(0, -1));
      let o2 = false;
      r2.startsWith("/") ? (o2 = true, r2 = r2.slice(1)) : r2.includes("/") && !r2.startsWith("**/") && (o2 = true);
      let c3 = this.patternToRegex(r2, o2);
      this.patterns.push({ pattern: s3, regex: c3, negated: l3, directoryOnly: i4, rooted: o2 });
    }
  }
  patternToRegex(t4, n3) {
    let s3 = "";
    n3 ? s3 = "^" : s3 = "(?:^|/)";
    let r2 = 0;
    for (; r2 < t4.length; ) {
      let l3 = t4[r2];
      if (l3 === "*") t4[r2 + 1] === "*" ? t4[r2 + 2] === "/" ? (s3 += "(?:.*/)?", r2 += 3) : (r2 + 2 >= t4.length, s3 += ".*", r2 += 2) : (s3 += "[^/]*", r2++);
      else if (l3 === "?") s3 += "[^/]", r2++;
      else if (l3 === "[") {
        let i4 = r2 + 1;
        for (i4 < t4.length && t4[i4] === "!" && i4++, i4 < t4.length && t4[i4] === "]" && i4++; i4 < t4.length && t4[i4] !== "]"; ) i4++;
        if (i4 < t4.length) {
          let o2 = t4.slice(r2, i4 + 1);
          o2.startsWith("[!") && (o2 = `[^${o2.slice(2)}`), s3 += o2, r2 = i4 + 1;
        } else s3 += "\\[", r2++;
      } else l3 === "/" ? (s3 += "/", r2++) : (s3 += l3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), r2++);
    }
    return s3 += "(?:/.*)?$", new RegExp(s3);
  }
  matches(t4, n3) {
    let s3 = t4.replace(/^\.\//, "");
    s3 = s3.replace(/^\//, "");
    let r2 = false;
    for (let l3 of this.patterns) l3.directoryOnly && !n3 || l3.regex.test(s3) && (r2 = !l3.negated);
    return r2;
  }
  isWhitelisted(t4, n3) {
    let s3 = t4.replace(/^\.\//, "");
    s3 = s3.replace(/^\//, "");
    for (let r2 of this.patterns) if (!(r2.directoryOnly && !n3) && r2.negated && r2.regex.test(s3)) return true;
    return false;
  }
  getBasePath() {
    return this.basePath;
  }
}, k$9 = class k {
  parsers = [];
  fs;
  skipDotIgnore;
  skipVcsIgnore;
  loadedDirs = /* @__PURE__ */ new Set();
  constructor(t4, n3, s3 = false, r2 = false) {
    this.fs = t4, this.skipDotIgnore = s3, this.skipVcsIgnore = r2;
  }
  async load(t4) {
    let n3 = [], s3 = t4;
    for (; ; ) {
      n3.unshift(s3);
      let l3 = this.fs.resolvePath(s3, "..");
      if (l3 === s3) break;
      s3 = l3;
    }
    let r2 = [];
    this.skipVcsIgnore || r2.push(".gitignore"), this.skipDotIgnore || r2.push(".rgignore", ".ignore");
    for (let l3 of n3) {
      this.loadedDirs.add(l3);
      for (let i4 of r2) {
        let o2 = this.fs.resolvePath(l3, i4);
        try {
          let c3 = await this.fs.readFile(o2), a3 = new M$a(l3);
          a3.parse(c3), this.parsers.push(a3);
        } catch {
        }
      }
    }
  }
  async loadForDirectory(t4) {
    if (this.loadedDirs.has(t4)) return;
    this.loadedDirs.add(t4);
    let n3 = [];
    this.skipVcsIgnore || n3.push(".gitignore"), this.skipDotIgnore || n3.push(".rgignore", ".ignore");
    for (let s3 of n3) {
      let r2 = this.fs.resolvePath(t4, s3);
      try {
        let l3 = await this.fs.readFile(r2), i4 = new M$a(t4);
        i4.parse(l3), this.parsers.push(i4);
      } catch {
      }
    }
  }
  addPatternsFromContent(t4, n3) {
    let s3 = new M$a(n3);
    s3.parse(t4), this.parsers.push(s3);
  }
  matches(t4, n3) {
    for (let s3 of this.parsers) {
      let r2 = s3.getBasePath();
      if (!t4.startsWith(r2)) continue;
      let l3 = t4.slice(r2.length).replace(/^\//, "");
      if (s3.matches(l3, n3)) return true;
    }
    return false;
  }
  isWhitelisted(t4, n3) {
    for (let s3 of this.parsers) {
      let r2 = s3.getBasePath();
      if (!t4.startsWith(r2)) continue;
      let l3 = t4.slice(r2.length).replace(/^\//, "");
      if (s3.isWhitelisted(l3, n3)) return true;
    }
    return false;
  }
  static isCommonIgnored(t4) {
    return (/* @__PURE__ */ new Set(["node_modules", ".git", ".svn", ".hg", "__pycache__", ".pytest_cache", ".mypy_cache", "venv", ".venv", ".next", ".nuxt", ".cargo"])).has(t4);
  }
};
async function P$c(e5, t4, n3 = false, s3 = false, r2 = []) {
  let l3 = new k$9(e5, t4, n3, s3);
  await l3.load(t4);
  for (let i4 of r2) try {
    let o2 = e5.resolvePath(t4, i4), c3 = await e5.readFile(o2);
    l3.addPatternsFromContent(c3, t4);
  } catch {
  }
  return l3;
}
function ce$7(e5) {
  return e5.length >= 2 && e5[0] === 31 && e5[1] === 139;
}
function fe$5(e5) {
  let t4 = false;
  for (let n3 = 0; n3 < e5.length; n3++) {
    let s3 = e5[n3];
    s3 === "[" && !t4 ? t4 = true : s3 === "]" && t4 && (t4 = false);
  }
  return t4 ? `rg: glob '${e5}' has an unclosed character class` : null;
}
async function H$9(e5) {
  let { ctx: t4, options: n3, paths: s3, explicitLineNumbers: r2 } = e5;
  for (let f3 of n3.globs) {
    let x4 = f3.startsWith("!") ? f3.slice(1) : f3, b4 = fe$5(x4);
    if (b4) return { stdout: "", stderr: `${b4}
`, exitCode: 1 };
  }
  if (n3.files) {
    let f3 = [...n3.patterns, ...s3];
    return ge$4(t4, f3, n3);
  }
  let l3 = [...n3.patterns];
  for (let f3 of n3.patternFiles) try {
    let x4;
    if (f3 === "-") x4 = t4.stdin;
    else {
      let h3 = t4.fs.resolvePath(t4.cwd, f3);
      x4 = await t4.fs.readFile(h3);
    }
    let b4 = x4.split(`
`).filter((h3) => h3.length > 0);
    l3.push(...b4);
  } catch {
    return { stdout: "", stderr: `rg: ${f3}: No such file or directory
`, exitCode: 2 };
  }
  if (l3.length === 0) return n3.patternFiles.length > 0 ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `rg: no pattern given
`, exitCode: 2 };
  let i4 = s3.length === 0 ? ["."] : s3, o2 = ue$6(n3, l3), c3, a3;
  try {
    let f3 = he$5(l3, n3, o2);
    c3 = f3.regex, a3 = f3.kResetGroup;
  } catch {
    return { stdout: "", stderr: `rg: invalid regex: ${l3.join(", ")}
`, exitCode: 2 };
  }
  let u3 = null;
  n3.noIgnore || (u3 = await P$c(t4.fs, t4.cwd, n3.noIgnoreDot, n3.noIgnoreVcs, n3.ignoreFiles));
  let m3 = new $$6();
  for (let f3 of n3.typeClear) m3.clearType(f3);
  for (let f3 of n3.typeAdd) m3.addType(f3);
  let { files: p3, singleExplicitFile: g2 } = await J$7(t4, i4, n3, u3, m3);
  if (p3.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
  let w4 = !n3.noFilename && (n3.withFilename || !g2 || p3.length > 1), d3 = n3.lineNumber;
  return r2 || (g2 && p3.length === 1 && (d3 = false), n3.onlyMatching && (d3 = false)), me$3(t4, p3, c3, n3, w4, d3, a3);
}
function ue$6(e5, t4) {
  return e5.caseSensitive ? false : e5.ignoreCase ? true : e5.smartCase ? !t4.some((n3) => /[A-Z]/.test(n3)) : false;
}
function he$5(e5, t4, n3) {
  let s3;
  return e5.length === 1 ? s3 = e5[0] : s3 = e5.map((r2) => t4.fixedStrings ? r2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&") : `(?:${r2})`).join("|"), q$b(s3, { mode: t4.fixedStrings && e5.length === 1 ? "fixed" : "perl", ignoreCase: n3, wholeWord: t4.wordRegexp, lineRegexp: t4.lineRegexp, multiline: t4.multiline, multilineDotall: t4.multilineDotall });
}
async function J$7(e5, t4, n3, s3, r2) {
  let l3 = [], i4 = 0, o2 = 0;
  for (let a3 of t4) {
    let u3 = e5.fs.resolvePath(e5.cwd, a3);
    try {
      let m3 = await e5.fs.stat(u3);
      if (m3.isFile) {
        if (i4++, n3.maxFilesize > 0 && m3.size > n3.maxFilesize) continue;
        K$5(a3, n3, s3, u3, r2) && l3.push(a3);
      } else m3.isDirectory && (o2++, await Y$6(e5, a3, u3, 0, n3, s3, r2, l3));
    } catch {
    }
  }
  return { files: n3.sort === "path" ? l3.sort() : l3, singleExplicitFile: i4 === 1 && o2 === 0 };
}
async function Y$6(e5, t4, n3, s3, r2, l3, i4, o2) {
  if (!(s3 >= r2.maxDepth)) {
    l3 && await l3.loadForDirectory(n3);
    try {
      let c3 = e5.fs.readdirWithFileTypes ? await e5.fs.readdirWithFileTypes(n3) : (await e5.fs.readdir(n3)).map((a3) => ({ name: a3, isFile: void 0 }));
      for (let a3 of c3) {
        let u3 = a3.name;
        if (!r2.noIgnore && k$9.isCommonIgnored(u3)) continue;
        let m3 = u3.startsWith("."), p3 = t4 === "." ? u3 : t4 === "./" ? `./${u3}` : t4.endsWith("/") ? `${t4}${u3}` : `${t4}/${u3}`, g2 = e5.fs.resolvePath(n3, u3), w4, d3, f3 = false;
        if (a3.isFile !== void 0 && "isDirectory" in a3) {
          let h3 = a3;
          if (f3 = h3.isSymbolicLink === true, f3 && !r2.followSymlinks) continue;
          if (f3 && r2.followSymlinks) try {
            let y2 = await e5.fs.stat(g2);
            w4 = y2.isFile, d3 = y2.isDirectory;
          } catch {
            continue;
          }
          else w4 = h3.isFile, d3 = h3.isDirectory;
        } else try {
          let h3 = e5.fs.lstat ? await e5.fs.lstat(g2) : await e5.fs.stat(g2);
          if (f3 = h3.isSymbolicLink === true, f3 && !r2.followSymlinks) continue;
          let y2 = f3 && r2.followSymlinks ? await e5.fs.stat(g2) : h3;
          w4 = y2.isFile, d3 = y2.isDirectory;
        } catch {
          continue;
        }
        if (!l3?.matches(g2, d3) && !(m3 && !r2.hidden && !l3?.isWhitelisted(g2, d3))) {
          if (d3) await Y$6(e5, p3, g2, s3 + 1, r2, l3, i4, o2);
          else if (w4) {
            if (r2.maxFilesize > 0) try {
              if ((await e5.fs.stat(g2)).size > r2.maxFilesize) continue;
            } catch {
              continue;
            }
            K$5(p3, r2, l3, g2, i4) && o2.push(p3);
          }
        }
      }
    } catch {
    }
  }
}
function K$5(e5, t4, n3, s3, r2) {
  let l3 = e5.split("/").pop() || e5;
  if (n3?.matches(s3, false) || t4.types.length > 0 && !r2.matchesType(l3, t4.types) || t4.typesNot.length > 0 && r2.matchesType(l3, t4.typesNot)) return false;
  if (t4.globs.length > 0) {
    let i4 = t4.globCaseInsensitive, o2 = t4.globs.filter((a3) => !a3.startsWith("!")), c3 = t4.globs.filter((a3) => a3.startsWith("!")).map((a3) => a3.slice(1));
    if (o2.length > 0) {
      let a3 = false;
      for (let u3 of o2) if (v$7(l3, u3, i4) || v$7(e5, u3, i4)) {
        a3 = true;
        break;
      }
      if (!a3) return false;
    }
    for (let a3 of c3) if (a3.startsWith("/")) {
      let u3 = a3.slice(1);
      if (v$7(e5, u3, i4)) return false;
    } else if (v$7(l3, a3, i4) || v$7(e5, a3, i4)) return false;
  }
  if (t4.iglobs.length > 0) {
    let i4 = t4.iglobs.filter((c3) => !c3.startsWith("!")), o2 = t4.iglobs.filter((c3) => c3.startsWith("!")).map((c3) => c3.slice(1));
    if (i4.length > 0) {
      let c3 = false;
      for (let a3 of i4) if (v$7(l3, a3, true) || v$7(e5, a3, true)) {
        c3 = true;
        break;
      }
      if (!c3) return false;
    }
    for (let c3 of o2) if (c3.startsWith("/")) {
      let a3 = c3.slice(1);
      if (v$7(e5, a3, true)) return false;
    } else if (v$7(l3, c3, true) || v$7(e5, c3, true)) return false;
  }
  return true;
}
function v$7(e5, t4, n3 = false) {
  let s3 = "^";
  for (let r2 = 0; r2 < t4.length; r2++) {
    let l3 = t4[r2];
    if (l3 === "*") t4[r2 + 1] === "*" ? (s3 += ".*", r2++) : s3 += "[^/]*";
    else if (l3 === "?") s3 += "[^/]";
    else if (l3 === "[") {
      let i4 = r2 + 1;
      for (i4 < t4.length && t4[i4] === "!" && i4++, i4 < t4.length && t4[i4] === "]" && i4++; i4 < t4.length && t4[i4] !== "]"; ) i4++;
      if (i4 < t4.length) {
        let o2 = t4.slice(r2, i4 + 1);
        o2.startsWith("[!") && (o2 = `[^${o2.slice(2)}`), s3 += o2, r2 = i4;
      } else s3 += "\\[";
    } else s3 += l3.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  return s3 += "$", new RegExp(s3, n3 ? "i" : "").test(e5);
}
async function ge$4(e5, t4, n3) {
  let s3 = null;
  n3.noIgnore || (s3 = await P$c(e5.fs, e5.cwd, n3.noIgnoreDot, n3.noIgnoreVcs, n3.ignoreFiles));
  let r2 = new $$6();
  for (let a3 of n3.typeClear) r2.clearType(a3);
  for (let a3 of n3.typeAdd) r2.addType(a3);
  let l3 = t4.length === 0 ? ["."] : t4, { files: i4 } = await J$7(e5, l3, n3, s3, r2);
  if (i4.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
  if (n3.quiet) return { stdout: "", stderr: "", exitCode: 0 };
  let o2 = n3.nullSeparator ? "\0" : `
`;
  return { stdout: i4.map((a3) => a3 + o2).join(""), stderr: "", exitCode: 0 };
}
function pe$4(e5, t4) {
  if (t4.length === 0) return true;
  for (let n3 of t4) if (v$7(e5, n3, false)) return true;
  return false;
}
async function de$4(e5, t4, n3, s3) {
  try {
    if (s3.preprocessor && e5.exec) {
      let i4 = n3.split("/").pop() || n3;
      if (pe$4(i4, s3.preprocessorGlobs)) {
        let o2 = await e5.exec(`${s3.preprocessor} "${t4}"`, { cwd: e5.cwd });
        if (o2.exitCode === 0 && o2.stdout) {
          let c3 = o2.stdout.slice(0, 8192);
          return { content: o2.stdout, isBinary: c3.includes("\0") };
        }
      }
    }
    if (s3.searchZip && n3.endsWith(".gz")) {
      let i4 = await e5.fs.readFileBuffer(t4);
      if (ce$7(i4)) try {
        let o2 = gunzipSync(i4), c3 = new TextDecoder().decode(o2), a3 = c3.slice(0, 8192);
        return { content: c3, isBinary: a3.includes("\0") };
      } catch {
        return null;
      }
    }
    let r2 = await e5.fs.readFile(t4), l3 = r2.slice(0, 8192);
    return { content: r2, isBinary: l3.includes("\0") };
  } catch {
    return null;
  }
}
async function me$3(e5, t4, n3, s3, r2, l3, i4) {
  let o2 = "", c3 = false, a3 = [], u3 = 0, m3 = 0, p3 = 0, g2 = 50;
  e: for (let f3 = 0; f3 < t4.length; f3 += g2) {
    let x4 = t4.slice(f3, f3 + g2), b4 = await Promise.all(x4.map(async (h3) => {
      let y2 = e5.fs.resolvePath(e5.cwd, h3), F2 = await de$4(e5, y2, h3, s3);
      if (!F2) return null;
      let { content: C2, isBinary: T3 } = F2;
      if (p3 += C2.length, T3 && !s3.searchBinary) return null;
      let W4 = r2 && !s3.heading ? h3 : "", S3 = K$7(C2, n3, { invertMatch: s3.invertMatch, showLineNumbers: l3, countOnly: s3.count, countMatches: s3.countMatches, filename: W4, onlyMatching: s3.onlyMatching, beforeContext: s3.beforeContext, afterContext: s3.afterContext, maxCount: s3.maxCount, contextSeparator: s3.contextSeparator, showColumn: s3.column, vimgrep: s3.vimgrep, showByteOffset: s3.byteOffset, replace: s3.replace !== null ? ie$7(s3.replace) : null, passthru: s3.passthru, multiline: s3.multiline, kResetGroup: i4 });
      return s3.json && S3.matched ? { file: h3, result: S3, content: C2, isBinary: false } : { file: h3, result: S3 };
    }));
    for (let h3 of b4) {
      if (!h3) continue;
      let { file: y2, result: F2 } = h3;
      if (F2.matched) {
        if (c3 = true, m3++, u3 += F2.matchCount, s3.quiet && !s3.json) break e;
        if (s3.json && !s3.quiet) {
          let C2 = h3.content || "";
          a3.push(JSON.stringify({ type: "begin", data: { path: { text: y2 } } }));
          let T3 = C2.split(`
`);
          n3.lastIndex = 0;
          let W4 = 0;
          for (let S3 = 0; S3 < T3.length; S3++) {
            let N2 = T3[S3];
            n3.lastIndex = 0;
            let O2 = [];
            for (let I2 = n3.exec(N2); I2 !== null; I2 = n3.exec(N2)) {
              let R2 = { match: { text: I2[0] }, start: I2.index, end: I2.index + I2[0].length };
              s3.replace !== null && (R2.replacement = { text: s3.replace }), O2.push(R2), I2[0].length === 0 && n3.lastIndex++;
            }
            if (O2.length > 0) {
              let I2 = { type: "match", data: { path: { text: y2 }, lines: { text: `${N2}
` }, line_number: S3 + 1, absolute_offset: W4, submatches: O2 } };
              a3.push(JSON.stringify(I2));
            }
            W4 += N2.length + 1;
          }
          a3.push(JSON.stringify({ type: "end", data: { path: { text: y2 }, binary_offset: null, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: 1, searches_with_match: 1, bytes_searched: C2.length, bytes_printed: 0, matched_lines: F2.matchCount, matches: F2.matchCount } } }));
        } else if (s3.filesWithMatches) {
          let C2 = s3.nullSeparator ? "\0" : `
`;
          o2 += `${y2}${C2}`;
        } else s3.filesWithoutMatch || (s3.heading && !s3.noFilename && (o2 += `${y2}
`), o2 += F2.output);
      } else if (s3.filesWithoutMatch) {
        let C2 = s3.nullSeparator ? "\0" : `
`;
        o2 += `${y2}${C2}`;
      } else s3.includeZero && (s3.count || s3.countMatches) && (o2 += F2.output);
    }
  }
  s3.json && (a3.push(JSON.stringify({ type: "summary", data: { elapsed_total: { secs: 0, nanos: 0, human: "0s" }, stats: { elapsed: { secs: 0, nanos: 0, human: "0s" }, searches: t4.length, searches_with_match: m3, bytes_searched: p3, bytes_printed: 0, matched_lines: u3, matches: u3 } } })), o2 = `${a3.join(`
`)}
`);
  let w4 = s3.quiet && !s3.json ? "" : o2;
  if (s3.stats && !s3.json) {
    let f3 = ["", `${u3} matches`, `${u3} matched lines`, `${m3} files contained matches`, `${t4.length} files searched`, `${p3} bytes searched`].join(`
`);
    w4 += `${f3}
`;
  }
  let d3;
  return s3.filesWithoutMatch ? d3 = o2.length > 0 ? 0 : 1 : d3 = c3 ? 0 : 1, { stdout: w4, stderr: "", exitCode: d3 };
}
var xe$7 = { name: "rg", summary: "recursively search for a pattern", usage: "rg [OPTIONS] PATTERN [PATH ...]", description: `rg (ripgrep) recursively searches directories for a regex pattern.
Unlike grep, rg is recursive by default and respects .gitignore files.

EXAMPLES:
  rg foo                    Search for 'foo' in current directory
  rg foo src/               Search in src/ directory
  rg -i foo                 Case-insensitive search
  rg -w foo                 Match whole words only
  rg -t js foo              Search only JavaScript files
  rg -g '*.ts' foo          Search files matching glob
  rg --hidden foo           Include hidden files
  rg -l foo                 List files with matches only`, options: ["-e, --regexp PATTERN    search for PATTERN (can be used multiple times)", "-f, --file FILE         read patterns from FILE, one per line", "-i, --ignore-case       case-insensitive search", "-s, --case-sensitive    case-sensitive search (overrides smart-case)", "-S, --smart-case        smart case (default: case-insensitive unless pattern has uppercase)", "-F, --fixed-strings     treat pattern as literal string", "-w, --word-regexp       match whole words only", "-x, --line-regexp       match whole lines only", "-v, --invert-match      select non-matching lines", "-r, --replace TEXT      replace matches with TEXT", "-c, --count             print count of matching lines per file", "    --count-matches     print count of individual matches per file", "-l, --files-with-matches print only file names with matches", "    --files-without-match print file names without matches", "    --files             list files that would be searched", "-o, --only-matching     print only matching parts", "-m, --max-count NUM     stop after NUM matches per file", "-q, --quiet             suppress output, exit 0 on match", "    --stats             print search statistics", "-n, --line-number       print line numbers (default: on)", "-N, --no-line-number    do not print line numbers", "-I, --no-filename       suppress the prefixing of file names", "-0, --null              use NUL as filename separator", "-b, --byte-offset       show byte offset of each match", "    --column            show column number of first match", "    --vimgrep           show results in vimgrep format", "    --json              show results in JSON Lines format", "-A NUM                  print NUM lines after each match", "-B NUM                  print NUM lines before each match", "-C NUM                  print NUM lines before and after each match", "    --context-separator SEP  separator for context groups (default: --)", "-U, --multiline         match patterns across lines", "-z, --search-zip        search in compressed files (gzip only)", "-g, --glob GLOB         include files matching GLOB", "-t, --type TYPE         only search files of TYPE (e.g., js, py, ts)", "-T, --type-not TYPE     exclude files of TYPE", "-L, --follow            follow symbolic links", "-u, --unrestricted      reduce filtering (-u: no ignore, -uu: +hidden, -uuu: +binary)", "-a, --text              search binary files as text", "    --hidden            search hidden files and directories", "    --no-ignore         don't respect .gitignore/.ignore files", "-d, --max-depth NUM     maximum search depth", "    --sort TYPE         sort files (path, none)", "    --heading           show file path above matches", "    --passthru          print all lines (non-matches use - separator)", "    --include-zero      include files with 0 matches in count output", "    --type-list         list all available file types", "    --help              display this help and exit"] }, De$4 = { name: "rg", async execute(e5, t4) {
  if (o$3(e5)) return s$1(xe$7);
  if (e5.includes("--type-list")) return { stdout: G$5(), stderr: "", exitCode: 0 };
  let n3 = Z$5(e5);
  return n3.success ? H$9({ ctx: t4, options: n3.options, paths: n3.paths, explicitLineNumbers: n3.explicitLineNumbers }) : n3.error;
} };
const rgSRMB7L6G = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  rgCommand: De$4
});
var _$8 = { alnum: "a-zA-Z0-9", alpha: "a-zA-Z", ascii: "\\x00-\\x7F", blank: " \\t", cntrl: "\\x00-\\x1F\\x7F", digit: "0-9", graph: "!-~", lower: "a-z", print: " -~", punct: "!-/:-@\\[-`{-~", space: " \\t\\n\\r\\f\\v", upper: "A-Z", word: "a-zA-Z0-9_", xdigit: "0-9A-Fa-f" };
function M$9(i4) {
  let e5 = "", t4 = 0, n3 = false;
  for (; t4 < i4.length; ) {
    if (i4[t4] === "[" && !n3) {
      if (i4[t4 + 1] === "[" && i4[t4 + 2] === ":") {
        let s3 = i4.indexOf(":]]", t4 + 3);
        if (s3 !== -1) {
          let r2 = i4.slice(t4 + 3, s3), a3 = _$8[r2];
          if (a3) {
            e5 += `[${a3}]`, t4 = s3 + 3;
            continue;
          }
        }
      }
      if (i4[t4 + 1] === "^" && i4[t4 + 2] === "[" && i4[t4 + 3] === ":") {
        let s3 = i4.indexOf(":]]", t4 + 4);
        if (s3 !== -1) {
          let r2 = i4.slice(t4 + 4, s3), a3 = _$8[r2];
          if (a3) {
            e5 += `[^${a3}]`, t4 = s3 + 3;
            continue;
          }
        }
      }
      e5 += "[", t4++, n3 = true, t4 < i4.length && i4[t4] === "^" && (e5 += "^", t4++), t4 < i4.length && i4[t4] === "]" && (e5 += "\\]", t4++);
      continue;
    }
    if (n3) {
      if (i4[t4] === "]") {
        e5 += "]", t4++, n3 = false;
        continue;
      }
      if (i4[t4] === "[" && i4[t4 + 1] === ":") {
        let s3 = i4.indexOf(":]", t4 + 2);
        if (s3 !== -1) {
          let r2 = i4.slice(t4 + 2, s3), a3 = _$8[r2];
          if (a3) {
            e5 += a3, t4 = s3 + 2;
            continue;
          }
        }
      }
      if (i4[t4] === "\\" && t4 + 1 < i4.length) {
        e5 += i4[t4] + i4[t4 + 1], t4 += 2;
        continue;
      }
      e5 += i4[t4], t4++;
      continue;
    }
    if (i4[t4] === "\\" && t4 + 1 < i4.length) {
      let s3 = i4[t4 + 1];
      if (s3 === "+" || s3 === "?" || s3 === "|") {
        e5 += s3, t4 += 2;
        continue;
      }
      if (s3 === "(" || s3 === ")") {
        e5 += s3, t4 += 2;
        continue;
      }
      if (s3 === "{" || s3 === "}") {
        e5 += s3, t4 += 2;
        continue;
      }
      if (s3 === "t") {
        e5 += "	", t4 += 2;
        continue;
      }
      if (s3 === "n") {
        e5 += `
`, t4 += 2;
        continue;
      }
      if (s3 === "r") {
        e5 += "\r", t4 += 2;
        continue;
      }
      e5 += i4[t4] + s3, t4 += 2;
      continue;
    }
    if (i4[t4] === "+" || i4[t4] === "?" || i4[t4] === "|" || i4[t4] === "(" || i4[t4] === ")") {
      e5 += `\\${i4[t4]}`, t4++;
      continue;
    }
    if (i4[t4] === "^" && !(e5 === "" || e5.endsWith("("))) {
      e5 += "\\^", t4++;
      continue;
    }
    if (i4[t4] === "$") {
      let s3 = t4 === i4.length - 1, r2 = t4 + 2 < i4.length && i4[t4 + 1] === "\\" && i4[t4 + 2] === ")";
      if (!s3 && !r2) {
        e5 += "\\$", t4++;
        continue;
      }
    }
    e5 += i4[t4], t4++;
  }
  return e5;
}
function T$8(i4) {
  let e5 = "", t4 = false;
  for (let n3 = 0; n3 < i4.length; n3++) i4[n3] === "[" && !t4 ? (t4 = true, e5 += "[", n3++, n3 < i4.length && i4[n3] === "^" && (e5 += "^", n3++), n3 < i4.length && i4[n3] === "]" && (e5 += "]", n3++), n3--) : i4[n3] === "]" && t4 ? (t4 = false, e5 += "]") : !t4 && i4[n3] === "{" && i4[n3 + 1] === "," ? (e5 += "{0,", n3++) : e5 += i4[n3];
  return e5;
}
function X$5(i4) {
  let e5 = "";
  for (let t4 = 0; t4 < i4.length; t4++) {
    let n3 = i4[t4], s3 = n3.charCodeAt(0);
    n3 === "\\" ? e5 += "\\\\" : n3 === "	" ? e5 += "\\t" : n3 === `
` ? e5 += `$
` : n3 === "\r" ? e5 += "\\r" : n3 === "\x07" ? e5 += "\\a" : n3 === "\b" ? e5 += "\\b" : n3 === "\f" ? e5 += "\\f" : n3 === "\v" ? e5 += "\\v" : s3 < 32 || s3 >= 127 ? e5 += `\\${s3.toString(8).padStart(3, "0")}` : e5 += n3;
  }
  return `${e5}$`;
}
var ne$3 = 1e4;
function G$4(i4, e5, t4) {
  return { patternSpace: "", holdSpace: "", lineNumber: 0, totalLines: i4, deleted: false, printed: false, quit: false, quitSilent: false, exitCode: void 0, errorMessage: void 0, appendBuffer: [], substitutionMade: false, lineNumberOutput: [], nCommandOutput: [], restartCycle: false, inDRestartedCycle: false, currentFilename: e5, pendingFileReads: [], pendingFileWrites: [], pendingExecute: void 0, rangeStates: t4 || /* @__PURE__ */ new Map(), linesConsumedInCycle: 0 };
}
function ie$5(i4) {
  return typeof i4 == "object" && "first" in i4 && "step" in i4;
}
function se$4(i4) {
  return typeof i4 == "object" && "offset" in i4;
}
function O$a(i4, e5, t4, n3, s3) {
  if (i4 === "$") return e5 === t4;
  if (typeof i4 == "number") return e5 === i4;
  if (ie$5(i4)) {
    let { first: r2, step: a3 } = i4;
    return a3 === 0 ? e5 === r2 : (e5 - r2) % a3 === 0 && e5 >= r2;
  }
  if (typeof i4 == "object" && "pattern" in i4) try {
    let r2 = i4.pattern;
    r2 === "" && s3?.lastPattern ? r2 = s3.lastPattern : r2 !== "" && s3 && (s3.lastPattern = r2);
    let a3 = T$8(M$9(r2));
    return new RegExp(a3).test(n3);
  } catch {
    return false;
  }
  return false;
}
function B$8(i4) {
  let e5 = (t4) => t4 === void 0 ? "undefined" : t4 === "$" ? "$" : typeof t4 == "number" ? String(t4) : "pattern" in t4 ? `/${t4.pattern}/` : "first" in t4 ? `${t4.first}~${t4.step}` : "unknown";
  return `${e5(i4.start)},${e5(i4.end)}`;
}
function re$2(i4, e5, t4, n3, s3, r2) {
  if (!i4 || !i4.start && !i4.end) return true;
  let a3 = i4.start, c3 = i4.end;
  if (a3 !== void 0 && c3 === void 0) return O$a(a3, e5, t4, n3, r2);
  if (a3 !== void 0 && c3 !== void 0) {
    let o2 = typeof a3 == "object" && "pattern" in a3, u3 = typeof c3 == "object" && "pattern" in c3, b4 = se$4(c3);
    if (b4 && s3) {
      let m3 = B$8(i4), d3 = s3.get(m3);
      if (d3 || (d3 = { active: false }, s3.set(m3, d3)), d3.active) {
        let h3 = d3.startLine || e5;
        return e5 >= h3 + c3.offset && (d3.active = false, s3.set(m3, d3)), true;
      } else return O$a(a3, e5, t4, n3, r2) ? (d3.active = true, d3.startLine = e5, s3.set(m3, d3), c3.offset === 0 && (d3.active = false, s3.set(m3, d3)), true) : false;
    }
    if (!o2 && !u3 && !b4) {
      let m3 = typeof a3 == "number" ? a3 : a3 === "$" ? t4 : 1, d3 = typeof c3 == "number" ? c3 : t4;
      if (m3 <= d3) return e5 >= m3 && e5 <= d3;
      if (s3) {
        let h3 = B$8(i4), f3 = s3.get(h3);
        return f3 || (f3 = { active: false }, s3.set(h3, f3)), !f3.completed && e5 >= m3 ? (f3.completed = true, s3.set(h3, f3), true) : false;
      }
      return false;
    }
    if (s3) {
      let m3 = B$8(i4), d3 = s3.get(m3);
      if (d3 || (d3 = { active: false }, s3.set(m3, d3)), d3.active) return O$a(c3, e5, t4, n3, r2) && (d3.active = false, typeof a3 == "number" && (d3.completed = true), s3.set(m3, d3)), true;
      {
        if (d3.completed) return false;
        let h3 = false;
        return typeof a3 == "number" ? h3 = e5 >= a3 : h3 = O$a(a3, e5, t4, n3, r2), h3 ? (d3.active = true, d3.startLine = e5, s3.set(m3, d3), O$a(c3, e5, t4, n3, r2) && (d3.active = false, typeof a3 == "number" && (d3.completed = true), s3.set(m3, d3)), true) : false;
      }
    }
    return O$a(a3, e5, t4, n3, r2);
  }
  return true;
}
function N$8(i4, e5, t4, n3, s3, r2) {
  let a3 = re$2(i4, e5, t4, n3, s3, r2);
  return i4?.negated ? !a3 : a3;
}
function ae$3(i4, e5, t4, n3) {
  let s3 = "", r2 = 0, a3 = false;
  for (; r2 <= i4.length; ) {
    e5.lastIndex = r2;
    let c3 = e5.exec(i4);
    if (!c3) {
      s3 += i4.slice(r2);
      break;
    }
    if (c3.index !== r2) {
      s3 += i4.slice(r2, c3.index), r2 = c3.index, a3 = false;
      continue;
    }
    let o2 = c3[0], u3 = c3.slice(1);
    if (a3 && o2.length === 0) {
      if (r2 < i4.length) s3 += i4[r2], r2++;
      else break;
      a3 = false;
      continue;
    }
    if (s3 += n3(o2, u3), a3 = false, o2.length === 0) if (r2 < i4.length) s3 += i4[r2], r2++;
    else break;
    else r2 += o2.length, a3 = true;
  }
  return s3;
}
function P$b(i4, e5, t4) {
  let n3 = "", s3 = 0;
  for (; s3 < i4.length; ) {
    if (i4[s3] === "\\" && s3 + 1 < i4.length) {
      let r2 = i4[s3 + 1];
      if (r2 === "&") {
        n3 += "&", s3 += 2;
        continue;
      }
      if (r2 === "n") {
        n3 += `
`, s3 += 2;
        continue;
      }
      if (r2 === "t") {
        n3 += "	", s3 += 2;
        continue;
      }
      if (r2 === "r") {
        n3 += "\r", s3 += 2;
        continue;
      }
      let a3 = parseInt(r2, 10);
      if (a3 === 0) {
        n3 += e5, s3 += 2;
        continue;
      }
      if (a3 >= 1 && a3 <= 9) {
        n3 += t4[a3 - 1] || "", s3 += 2;
        continue;
      }
      n3 += r2, s3 += 2;
      continue;
    }
    if (i4[s3] === "&") {
      n3 += e5, s3++;
      continue;
    }
    n3 += i4[s3], s3++;
  }
  return n3;
}
function ce$6(i4, e5) {
  let { lineNumber: t4, totalLines: n3, patternSpace: s3 } = e5;
  if (i4.type !== "label" && N$8(i4.address, t4, n3, s3, e5.rangeStates, e5)) switch (i4.type) {
    case "substitute": {
      let r2 = i4, a3 = "";
      r2.global && (a3 += "g"), r2.ignoreCase && (a3 += "i");
      let c3 = r2.pattern;
      c3 === "" && e5.lastPattern ? c3 = e5.lastPattern : c3 !== "" && (e5.lastPattern = c3);
      let o2 = T$8(r2.extendedRegex ? c3 : M$9(c3));
      try {
        let u3 = new RegExp(o2, a3), b4 = u3.test(e5.patternSpace);
        if (u3.lastIndex = 0, b4) {
          if (e5.substitutionMade = true, r2.nthOccurrence && r2.nthOccurrence > 0 && !r2.global) {
            let g2 = 0, m3 = r2.nthOccurrence;
            e5.patternSpace = e5.patternSpace.replace(new RegExp(o2, `g${r2.ignoreCase ? "i" : ""}`), (d3, ...h3) => {
              if (g2++, g2 === m3) {
                let f3 = h3.slice(0, -2);
                return P$b(r2.replacement, d3, f3);
              }
              return d3;
            });
          } else r2.global ? e5.patternSpace = ae$3(e5.patternSpace, new RegExp(o2, `g${r2.ignoreCase ? "i" : ""}`), r2.replacement, (g2, m3) => P$b(r2.replacement, g2, m3)) : e5.patternSpace = e5.patternSpace.replace(u3, (g2, ...m3) => {
            let d3 = m3.slice(0, -2);
            return P$b(r2.replacement, g2, d3);
          });
          r2.printOnMatch && e5.lineNumberOutput.push(e5.patternSpace);
        }
      } catch {
      }
      break;
    }
    case "print":
      e5.lineNumberOutput.push(e5.patternSpace);
      break;
    case "printFirstLine": {
      let r2 = e5.patternSpace.indexOf(`
`);
      r2 !== -1 ? e5.lineNumberOutput.push(e5.patternSpace.slice(0, r2)) : e5.lineNumberOutput.push(e5.patternSpace);
      break;
    }
    case "delete":
      e5.deleted = true;
      break;
    case "deleteFirstLine": {
      let r2 = e5.patternSpace.indexOf(`
`);
      r2 !== -1 ? (e5.patternSpace = e5.patternSpace.slice(r2 + 1), e5.restartCycle = true, e5.inDRestartedCycle = true) : e5.deleted = true;
      break;
    }
    case "zap":
      e5.patternSpace = "";
      break;
    case "append":
      e5.appendBuffer.push(i4.text);
      break;
    case "insert":
      e5.appendBuffer.unshift(`__INSERT__${i4.text}`);
      break;
    case "change":
      e5.deleted = true, e5.changedText = i4.text;
      break;
    case "hold":
      e5.holdSpace = e5.patternSpace;
      break;
    case "holdAppend":
      e5.holdSpace ? e5.holdSpace += `
${e5.patternSpace}` : e5.holdSpace = e5.patternSpace;
      break;
    case "get":
      e5.patternSpace = e5.holdSpace;
      break;
    case "getAppend":
      e5.patternSpace += `
${e5.holdSpace}`;
      break;
    case "exchange": {
      let r2 = e5.patternSpace;
      e5.patternSpace = e5.holdSpace, e5.holdSpace = r2;
      break;
    }
    case "next":
      e5.printed = true;
      break;
    case "quit":
      e5.quit = true, i4.exitCode !== void 0 && (e5.exitCode = i4.exitCode);
      break;
    case "quitSilent":
      e5.quit = true, e5.quitSilent = true, i4.exitCode !== void 0 && (e5.exitCode = i4.exitCode);
      break;
    case "list": {
      let r2 = X$5(e5.patternSpace);
      e5.lineNumberOutput.push(r2);
      break;
    }
    case "printFilename":
      e5.currentFilename && e5.lineNumberOutput.push(e5.currentFilename);
      break;
    case "version": {
      let r2 = [4, 8, 0];
      if (i4.minVersion) {
        let a3 = i4.minVersion.split("."), c3 = [], o2 = false;
        for (let u3 of a3) {
          let b4 = parseInt(u3, 10);
          if (Number.isNaN(b4) || b4 < 0) {
            e5.quit = true, e5.exitCode = 1, e5.errorMessage = `sed: invalid version string: ${i4.minVersion}`, o2 = true;
            break;
          }
          c3.push(b4);
        }
        if (!o2) {
          for (; c3.length < 3; ) c3.push(0);
          for (let u3 = 0; u3 < 3; u3++) {
            if (c3[u3] > r2[u3]) {
              e5.quit = true, e5.exitCode = 1, e5.errorMessage = `sed: this is not GNU sed version ${i4.minVersion}`;
              break;
            }
            if (c3[u3] < r2[u3]) break;
          }
        }
      }
      break;
    }
    case "readFile":
      e5.pendingFileReads.push({ filename: i4.filename, wholeFile: true });
      break;
    case "readFileLine":
      e5.pendingFileReads.push({ filename: i4.filename, wholeFile: false });
      break;
    case "writeFile":
      e5.pendingFileWrites.push({ filename: i4.filename, content: `${e5.patternSpace}
` });
      break;
    case "writeFirstLine": {
      let r2 = e5.patternSpace.indexOf(`
`), a3 = r2 !== -1 ? e5.patternSpace.slice(0, r2) : e5.patternSpace;
      e5.pendingFileWrites.push({ filename: i4.filename, content: `${a3}
` });
      break;
    }
    case "execute":
      i4.command ? e5.pendingExecute = { command: i4.command, replacePattern: false } : e5.pendingExecute = { command: e5.patternSpace, replacePattern: true };
      break;
    case "transliterate":
      e5.patternSpace = le$4(e5.patternSpace, i4);
      break;
    case "lineNumber":
      e5.lineNumberOutput.push(String(e5.lineNumber));
      break;
  }
}
function le$4(i4, e5) {
  let t4 = "";
  for (let n3 of i4) {
    let s3 = e5.source.indexOf(n3);
    s3 !== -1 ? t4 += e5.dest[s3] : t4 += n3;
  }
  return t4;
}
function D$9(i4, e5, t4, n3) {
  let s3 = /* @__PURE__ */ new Map();
  for (let o2 = 0; o2 < i4.length; o2++) {
    let u3 = i4[o2];
    u3.type === "label" && s3.set(u3.name, o2);
  }
  let r2 = n3?.maxIterations ?? ne$3, a3 = 0, c3 = 0;
  for (; c3 < i4.length; ) {
    if (a3++, a3 > r2) throw new b$i(`sed: command execution exceeded maximum iterations (${r2})`, "iterations");
    if (e5.deleted || e5.quit || e5.quitSilent || e5.restartCycle) break;
    let o2 = i4[c3];
    if (o2.type === "next") {
      if (N$8(o2.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5)) if (e5.nCommandOutput.push(e5.patternSpace), t4 && t4.currentLineIndex + e5.linesConsumedInCycle + 1 < t4.lines.length) {
        e5.linesConsumedInCycle++;
        let u3 = t4.lines[t4.currentLineIndex + e5.linesConsumedInCycle];
        e5.patternSpace = u3, e5.lineNumber = t4.currentLineIndex + e5.linesConsumedInCycle + 1, e5.substitutionMade = false;
      } else {
        e5.quit = true, e5.deleted = true;
        break;
      }
      c3++;
      continue;
    }
    if (o2.type === "nextAppend") {
      if (N$8(o2.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5)) if (t4 && t4.currentLineIndex + e5.linesConsumedInCycle + 1 < t4.lines.length) {
        e5.linesConsumedInCycle++;
        let u3 = t4.lines[t4.currentLineIndex + e5.linesConsumedInCycle];
        e5.patternSpace += `
${u3}`, e5.lineNumber = t4.currentLineIndex + e5.linesConsumedInCycle + 1;
      } else {
        e5.quit = true;
        break;
      }
      c3++;
      continue;
    }
    if (o2.type === "branch") {
      let u3 = o2;
      if (N$8(u3.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5)) {
        if (u3.label) {
          let b4 = s3.get(u3.label);
          if (b4 !== void 0) {
            c3 = b4;
            continue;
          }
          e5.branchRequest = u3.label;
          break;
        }
        break;
      }
      c3++;
      continue;
    }
    if (o2.type === "branchOnSubst") {
      let u3 = o2;
      if (N$8(u3.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5) && e5.substitutionMade) {
        if (e5.substitutionMade = false, u3.label) {
          let b4 = s3.get(u3.label);
          if (b4 !== void 0) {
            c3 = b4;
            continue;
          }
          e5.branchRequest = u3.label;
          break;
        }
        break;
      }
      c3++;
      continue;
    }
    if (o2.type === "branchOnNoSubst") {
      let u3 = o2;
      if (N$8(u3.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5) && !e5.substitutionMade) {
        if (u3.label) {
          let b4 = s3.get(u3.label);
          if (b4 !== void 0) {
            c3 = b4;
            continue;
          }
          e5.branchRequest = u3.label;
          break;
        }
        break;
      }
      c3++;
      continue;
    }
    if (o2.type === "group") {
      let u3 = o2;
      if (N$8(u3.address, e5.lineNumber, e5.totalLines, e5.patternSpace, e5.rangeStates, e5) && (D$9(u3.commands, e5, t4, n3), e5.branchRequest)) {
        let b4 = s3.get(e5.branchRequest);
        if (b4 !== void 0) {
          e5.branchRequest = void 0, c3 = b4;
          continue;
        }
        break;
      }
      c3++;
      continue;
    }
    ce$6(o2, e5), c3++;
  }
  return e5.linesConsumedInCycle;
}
var l$5;
(function(i4) {
  i4.NUMBER = "NUMBER", i4.DOLLAR = "DOLLAR", i4.PATTERN = "PATTERN", i4.STEP = "STEP", i4.RELATIVE_OFFSET = "RELATIVE_OFFSET", i4.LBRACE = "LBRACE", i4.RBRACE = "RBRACE", i4.SEMICOLON = "SEMICOLON", i4.NEWLINE = "NEWLINE", i4.COMMA = "COMMA", i4.NEGATION = "NEGATION", i4.COMMAND = "COMMAND", i4.SUBSTITUTE = "SUBSTITUTE", i4.TRANSLITERATE = "TRANSLITERATE", i4.LABEL_DEF = "LABEL_DEF", i4.BRANCH = "BRANCH", i4.BRANCH_ON_SUBST = "BRANCH_ON_SUBST", i4.BRANCH_ON_NO_SUBST = "BRANCH_ON_NO_SUBST", i4.TEXT_CMD = "TEXT_CMD", i4.FILE_READ = "FILE_READ", i4.FILE_READ_LINE = "FILE_READ_LINE", i4.FILE_WRITE = "FILE_WRITE", i4.FILE_WRITE_LINE = "FILE_WRITE_LINE", i4.EXECUTE = "EXECUTE", i4.VERSION = "VERSION", i4.EOF = "EOF", i4.ERROR = "ERROR";
})(l$5 || (l$5 = {}));
var w$d = class w {
  input;
  pos = 0;
  line = 1;
  column = 1;
  constructor(e5) {
    this.input = e5;
  }
  tokenize() {
    let e5 = [];
    for (; this.pos < this.input.length; ) {
      let t4 = this.nextToken();
      t4 && e5.push(t4);
    }
    return e5.push(this.makeToken(l$5.EOF, "")), e5;
  }
  makeToken(e5, t4, n3) {
    return { type: e5, value: t4, line: this.line, column: this.column, ...n3 };
  }
  peek(e5 = 0) {
    return this.input[this.pos + e5] || "";
  }
  advance() {
    let e5 = this.input[this.pos++] || "";
    return e5 === `
` ? (this.line++, this.column = 1) : this.column++, e5;
  }
  readEscapedString(e5) {
    let t4 = "";
    for (; this.pos < this.input.length && this.peek() !== e5; ) if (this.peek() === "\\") {
      this.advance();
      let n3 = this.advance();
      n3 === "n" ? t4 += `
` : n3 === "t" ? t4 += "	" : t4 += n3;
    } else {
      if (this.peek() === `
`) return null;
      t4 += this.advance();
    }
    return t4;
  }
  skipWhitespace() {
    for (; this.pos < this.input.length; ) {
      let e5 = this.peek();
      if (e5 === " " || e5 === "	" || e5 === "\r") this.advance();
      else if (e5 === "#") for (; this.pos < this.input.length && this.peek() !== `
`; ) this.advance();
      else break;
    }
  }
  nextToken() {
    if (this.skipWhitespace(), this.pos >= this.input.length) return null;
    let e5 = this.line, t4 = this.column, n3 = this.peek();
    return n3 === `
` ? (this.advance(), { type: l$5.NEWLINE, value: `
`, line: e5, column: t4 }) : n3 === ";" ? (this.advance(), { type: l$5.SEMICOLON, value: ";", line: e5, column: t4 }) : n3 === "{" ? (this.advance(), { type: l$5.LBRACE, value: "{", line: e5, column: t4 }) : n3 === "}" ? (this.advance(), { type: l$5.RBRACE, value: "}", line: e5, column: t4 }) : n3 === "," ? (this.advance(), { type: l$5.COMMA, value: ",", line: e5, column: t4 }) : n3 === "!" ? (this.advance(), { type: l$5.NEGATION, value: "!", line: e5, column: t4 }) : n3 === "$" ? (this.advance(), { type: l$5.DOLLAR, value: "$", line: e5, column: t4 }) : this.isDigit(n3) ? this.readNumber() : n3 === "+" && this.isDigit(this.input[this.pos + 1] || "") ? this.readRelativeOffset() : n3 === "/" ? this.readPattern() : n3 === ":" ? this.readLabelDef() : this.readCommand();
  }
  readNumber() {
    let e5 = this.line, t4 = this.column, n3 = "";
    for (; this.isDigit(this.peek()); ) n3 += this.advance();
    if (this.peek() === "~") {
      this.advance();
      let s3 = "";
      for (; this.isDigit(this.peek()); ) s3 += this.advance();
      let r2 = parseInt(n3, 10), a3 = parseInt(s3, 10) || 0;
      return { type: l$5.STEP, value: `${r2}~${a3}`, first: r2, step: a3, line: e5, column: t4 };
    }
    return { type: l$5.NUMBER, value: parseInt(n3, 10), line: e5, column: t4 };
  }
  readRelativeOffset() {
    let e5 = this.line, t4 = this.column;
    this.advance();
    let n3 = "";
    for (; this.isDigit(this.peek()); ) n3 += this.advance();
    let s3 = parseInt(n3, 10) || 0;
    return { type: l$5.RELATIVE_OFFSET, value: `+${s3}`, offset: s3, line: e5, column: t4 };
  }
  readPattern() {
    let e5 = this.line, t4 = this.column;
    this.advance();
    let n3 = "", s3 = false;
    for (; this.pos < this.input.length; ) {
      let r2 = this.peek();
      if (r2 === "/" && !s3) break;
      if (r2 === "\\") n3 += this.advance(), this.pos < this.input.length && this.peek() !== `
` && (n3 += this.advance());
      else {
        if (r2 === `
`) break;
        r2 === "[" && !s3 ? (s3 = true, n3 += this.advance(), this.peek() === "^" && (n3 += this.advance()), this.peek() === "]" && (n3 += this.advance())) : r2 === "]" && s3 ? (s3 = false, n3 += this.advance()) : n3 += this.advance();
      }
    }
    return this.peek() === "/" && this.advance(), { type: l$5.PATTERN, value: n3, pattern: n3, line: e5, column: t4 };
  }
  readLabelDef() {
    let e5 = this.line, t4 = this.column;
    for (this.advance(); this.peek() === " " || this.peek() === "	"; ) this.advance();
    let n3 = "";
    for (; this.pos < this.input.length; ) {
      let s3 = this.peek();
      if (s3 === " " || s3 === "	" || s3 === `
` || s3 === ";" || s3 === "}" || s3 === "{") break;
      n3 += this.advance();
    }
    return { type: l$5.LABEL_DEF, value: n3, label: n3, line: e5, column: t4 };
  }
  readCommand() {
    let e5 = this.line, t4 = this.column, n3 = this.advance();
    switch (n3) {
      case "s":
        return this.readSubstitute(e5, t4);
      case "y":
        return this.readTransliterate(e5, t4);
      case "a":
      case "i":
      case "c":
        return this.readTextCommand(n3, e5, t4);
      case "b":
        return this.readBranch(l$5.BRANCH, "b", e5, t4);
      case "t":
        return this.readBranch(l$5.BRANCH_ON_SUBST, "t", e5, t4);
      case "T":
        return this.readBranch(l$5.BRANCH_ON_NO_SUBST, "T", e5, t4);
      case "r":
        return this.readFileCommand(l$5.FILE_READ, "r", e5, t4);
      case "R":
        return this.readFileCommand(l$5.FILE_READ_LINE, "R", e5, t4);
      case "w":
        return this.readFileCommand(l$5.FILE_WRITE, "w", e5, t4);
      case "W":
        return this.readFileCommand(l$5.FILE_WRITE_LINE, "W", e5, t4);
      case "e":
        return this.readExecute(e5, t4);
      case "p":
      case "P":
      case "d":
      case "D":
      case "h":
      case "H":
      case "g":
      case "G":
      case "x":
      case "n":
      case "N":
      case "q":
      case "Q":
      case "z":
      case "=":
      case "l":
      case "F":
        return { type: l$5.COMMAND, value: n3, line: e5, column: t4 };
      case "v":
        return this.readVersion(e5, t4);
      default:
        return { type: l$5.ERROR, value: n3, line: e5, column: t4 };
    }
  }
  readSubstitute(e5, t4) {
    let n3 = this.advance();
    if (!n3 || n3 === `
`) return { type: l$5.ERROR, value: "s", line: e5, column: t4 };
    let s3 = "", r2 = false;
    for (; this.pos < this.input.length; ) {
      let o2 = this.peek();
      if (o2 === n3 && !r2) break;
      if (o2 === "\\") this.advance(), this.pos < this.input.length && this.peek() !== `
` ? this.peek() === n3 && !r2 ? s3 += this.advance() : (s3 += "\\", s3 += this.advance()) : s3 += "\\";
      else {
        if (o2 === `
`) break;
        o2 === "[" && !r2 ? (r2 = true, s3 += this.advance(), this.peek() === "^" && (s3 += this.advance()), this.peek() === "]" && (s3 += this.advance())) : o2 === "]" && r2 ? (r2 = false, s3 += this.advance()) : s3 += this.advance();
      }
    }
    if (this.peek() !== n3) return { type: l$5.ERROR, value: "unterminated substitution pattern", line: e5, column: t4 };
    this.advance();
    let a3 = "";
    for (; this.pos < this.input.length && this.peek() !== n3; ) if (this.peek() === "\\") if (this.advance(), this.pos < this.input.length) {
      let o2 = this.peek();
      o2 === "\\" ? (this.advance(), this.pos < this.input.length && this.peek() === `
` ? (a3 += `
`, this.advance()) : a3 += "\\") : o2 === `
` ? (a3 += `
`, this.advance()) : a3 += `\\${this.advance()}`;
    } else a3 += "\\";
    else {
      if (this.peek() === `
`) break;
      a3 += this.advance();
    }
    this.peek() === n3 && this.advance();
    let c3 = "";
    for (; this.pos < this.input.length; ) {
      let o2 = this.peek();
      if (o2 === "g" || o2 === "i" || o2 === "p" || o2 === "I" || this.isDigit(o2)) c3 += this.advance();
      else break;
    }
    return { type: l$5.SUBSTITUTE, value: `s${n3}${s3}${n3}${a3}${n3}${c3}`, pattern: s3, replacement: a3, flags: c3, line: e5, column: t4 };
  }
  readTransliterate(e5, t4) {
    let n3 = this.advance();
    if (!n3 || n3 === `
`) return { type: l$5.ERROR, value: "y", line: e5, column: t4 };
    let s3 = this.readEscapedString(n3);
    if (s3 === null || this.peek() !== n3) return { type: l$5.ERROR, value: "unterminated transliteration source", line: e5, column: t4 };
    this.advance();
    let r2 = this.readEscapedString(n3);
    if (r2 === null || this.peek() !== n3) return { type: l$5.ERROR, value: "unterminated transliteration dest", line: e5, column: t4 };
    this.advance();
    let a3 = this.peek();
    for (; a3 === " " || a3 === "	"; ) this.advance(), a3 = this.peek();
    return a3 !== "" && a3 !== ";" && a3 !== `
` && a3 !== "}" ? { type: l$5.ERROR, value: "extra text at the end of a transform command", line: e5, column: t4 } : { type: l$5.TRANSLITERATE, value: `y${n3}${s3}${n3}${r2}${n3}`, source: s3, dest: r2, line: e5, column: t4 };
  }
  readTextCommand(e5, t4, n3) {
    let s3 = false;
    this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === `
` || this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && (s3 = true, this.advance()), (this.peek() === " " || this.peek() === "	") && this.advance(), this.peek() === "\\" && this.pos + 1 < this.input.length && (this.input[this.pos + 1] === " " || this.input[this.pos + 1] === "	") && this.advance(), s3 && this.peek() === `
` && this.advance();
    let r2 = "";
    for (; this.pos < this.input.length; ) {
      let a3 = this.peek();
      if (a3 === `
`) {
        if (r2.endsWith("\\")) {
          r2 = `${r2.slice(0, -1)}
`, this.advance();
          continue;
        }
        break;
      }
      if (a3 === "\\" && this.pos + 1 < this.input.length) {
        let c3 = this.input[this.pos + 1];
        if (c3 === "n") {
          r2 += `
`, this.advance(), this.advance();
          continue;
        }
        if (c3 === "t") {
          r2 += "	", this.advance(), this.advance();
          continue;
        }
        if (c3 === "r") {
          r2 += "\r", this.advance(), this.advance();
          continue;
        }
      }
      r2 += this.advance();
    }
    return { type: l$5.TEXT_CMD, value: e5, text: r2, line: t4, column: n3 };
  }
  readBranch(e5, t4, n3, s3) {
    for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
    let r2 = "";
    for (; this.pos < this.input.length; ) {
      let a3 = this.peek();
      if (a3 === " " || a3 === "	" || a3 === `
` || a3 === ";" || a3 === "}" || a3 === "{") break;
      r2 += this.advance();
    }
    return { type: e5, value: t4, label: r2 || void 0, line: n3, column: s3 };
  }
  readVersion(e5, t4) {
    for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
    let n3 = "";
    for (; this.pos < this.input.length; ) {
      let s3 = this.peek();
      if (s3 === " " || s3 === "	" || s3 === `
` || s3 === ";" || s3 === "}" || s3 === "{") break;
      n3 += this.advance();
    }
    return { type: l$5.VERSION, value: "v", label: n3 || void 0, line: e5, column: t4 };
  }
  readFileCommand(e5, t4, n3, s3) {
    for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
    let r2 = "";
    for (; this.pos < this.input.length; ) {
      let a3 = this.peek();
      if (a3 === `
` || a3 === ";") break;
      r2 += this.advance();
    }
    return { type: e5, value: t4, filename: r2.trim(), line: n3, column: s3 };
  }
  readExecute(e5, t4) {
    for (; this.peek() === " " || this.peek() === "	"; ) this.advance();
    let n3 = "";
    for (; this.pos < this.input.length; ) {
      let s3 = this.peek();
      if (s3 === `
` || s3 === ";") break;
      n3 += this.advance();
    }
    return { type: l$5.EXECUTE, value: "e", command: n3.trim() || void 0, line: e5, column: t4 };
  }
  isDigit(e5) {
    return e5 >= "0" && e5 <= "9";
  }
};
var W$9 = class W {
  scripts;
  tokens = [];
  pos = 0;
  extendedRegex = false;
  constructor(e5, t4 = false) {
    this.scripts = e5, this.extendedRegex = t4;
  }
  parse() {
    let e5 = [];
    for (let t4 of this.scripts) {
      let n3 = new w$d(t4);
      for (this.tokens = n3.tokenize(), this.pos = 0; !this.isAtEnd(); ) {
        if (this.check(l$5.NEWLINE) || this.check(l$5.SEMICOLON)) {
          this.advance();
          continue;
        }
        let s3 = this.parseCommand();
        if (s3.error) return { commands: [], error: s3.error };
        s3.command && e5.push(s3.command);
      }
    }
    return { commands: e5 };
  }
  parseCommand() {
    let e5 = this.parseAddressRange();
    if (e5?.error) return { command: null, error: e5.error };
    let t4 = e5?.address;
    for (this.check(l$5.NEGATION) && (this.advance(), t4 && (t4.negated = true)); this.check(l$5.NEWLINE) || this.check(l$5.SEMICOLON); ) this.advance();
    if (this.isAtEnd()) return t4 && (t4.start !== void 0 || t4.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
    let n3 = this.peek();
    switch (n3.type) {
      case l$5.COMMAND:
        return this.parseSimpleCommand(n3, t4);
      case l$5.SUBSTITUTE:
        return this.parseSubstituteFromToken(n3, t4);
      case l$5.TRANSLITERATE:
        return this.parseTransliterateFromToken(n3, t4);
      case l$5.LABEL_DEF:
        return this.advance(), { command: { type: "label", name: n3.label || "" } };
      case l$5.BRANCH:
        return this.advance(), { command: { type: "branch", address: t4, label: n3.label } };
      case l$5.BRANCH_ON_SUBST:
        return this.advance(), { command: { type: "branchOnSubst", address: t4, label: n3.label } };
      case l$5.BRANCH_ON_NO_SUBST:
        return this.advance(), { command: { type: "branchOnNoSubst", address: t4, label: n3.label } };
      case l$5.TEXT_CMD:
        return this.advance(), this.parseTextCommand(n3, t4);
      case l$5.FILE_READ:
        return this.advance(), { command: { type: "readFile", address: t4, filename: n3.filename || "" } };
      case l$5.FILE_READ_LINE:
        return this.advance(), { command: { type: "readFileLine", address: t4, filename: n3.filename || "" } };
      case l$5.FILE_WRITE:
        return this.advance(), { command: { type: "writeFile", address: t4, filename: n3.filename || "" } };
      case l$5.FILE_WRITE_LINE:
        return this.advance(), { command: { type: "writeFirstLine", address: t4, filename: n3.filename || "" } };
      case l$5.EXECUTE:
        return this.advance(), { command: { type: "execute", address: t4, command: n3.command } };
      case l$5.VERSION:
        return this.advance(), { command: { type: "version", address: t4, minVersion: n3.label } };
      case l$5.LBRACE:
        return this.parseGroup(t4);
      case l$5.RBRACE:
        return { command: null };
      case l$5.ERROR:
        return { command: null, error: `invalid command: ${n3.value}` };
      default:
        return t4 && (t4.start !== void 0 || t4.end !== void 0) ? { command: null, error: "command expected" } : { command: null };
    }
  }
  parseSimpleCommand(e5, t4) {
    this.advance();
    let n3 = e5.value;
    switch (n3) {
      case "p":
        return { command: { type: "print", address: t4 } };
      case "P":
        return { command: { type: "printFirstLine", address: t4 } };
      case "d":
        return { command: { type: "delete", address: t4 } };
      case "D":
        return { command: { type: "deleteFirstLine", address: t4 } };
      case "h":
        return { command: { type: "hold", address: t4 } };
      case "H":
        return { command: { type: "holdAppend", address: t4 } };
      case "g":
        return { command: { type: "get", address: t4 } };
      case "G":
        return { command: { type: "getAppend", address: t4 } };
      case "x":
        return { command: { type: "exchange", address: t4 } };
      case "n":
        return { command: { type: "next", address: t4 } };
      case "N":
        return { command: { type: "nextAppend", address: t4 } };
      case "q":
        return { command: { type: "quit", address: t4 } };
      case "Q":
        return { command: { type: "quitSilent", address: t4 } };
      case "z":
        return { command: { type: "zap", address: t4 } };
      case "=":
        return { command: { type: "lineNumber", address: t4 } };
      case "l":
        return { command: { type: "list", address: t4 } };
      case "F":
        return { command: { type: "printFilename", address: t4 } };
      default:
        return { command: null, error: `unknown command: ${n3}` };
    }
  }
  parseSubstituteFromToken(e5, t4) {
    this.advance();
    let n3 = e5.flags || "", s3, r2 = n3.match(/(\d+)/);
    return r2 && (s3 = parseInt(r2[1], 10)), { command: { type: "substitute", address: t4, pattern: e5.pattern || "", replacement: e5.replacement || "", global: n3.includes("g"), ignoreCase: n3.includes("i") || n3.includes("I"), printOnMatch: n3.includes("p"), nthOccurrence: s3, extendedRegex: this.extendedRegex } };
  }
  parseTransliterateFromToken(e5, t4) {
    this.advance();
    let n3 = e5.source || "", s3 = e5.dest || "";
    return n3.length !== s3.length ? { command: null, error: "transliteration sets must have same length" } : { command: { type: "transliterate", address: t4, source: n3, dest: s3 } };
  }
  parseTextCommand(e5, t4) {
    let n3 = e5.value, s3 = e5.text || "";
    switch (n3) {
      case "a":
        return { command: { type: "append", address: t4, text: s3 } };
      case "i":
        return { command: { type: "insert", address: t4, text: s3 } };
      case "c":
        return { command: { type: "change", address: t4, text: s3 } };
      default:
        return { command: null, error: `unknown text command: ${n3}` };
    }
  }
  parseGroup(e5) {
    this.advance();
    let t4 = [];
    for (; !this.isAtEnd() && !this.check(l$5.RBRACE); ) {
      if (this.check(l$5.NEWLINE) || this.check(l$5.SEMICOLON)) {
        this.advance();
        continue;
      }
      let n3 = this.parseCommand();
      if (n3.error) return { command: null, error: n3.error };
      n3.command && t4.push(n3.command);
    }
    return this.check(l$5.RBRACE) ? (this.advance(), { command: { type: "group", address: e5, commands: t4 } }) : { command: null, error: "unmatched brace in grouped commands" };
  }
  parseAddressRange() {
    let e5 = this.parseAddress();
    if (e5 === void 0) return;
    let t4;
    if (this.check(l$5.RELATIVE_OFFSET)) t4 = { offset: this.advance().offset || 0 };
    else if (this.check(l$5.COMMA) && (this.advance(), t4 = this.parseAddress(), t4 === void 0)) return { error: "expected context address" };
    return { address: { start: e5, end: t4 } };
  }
  parseAddress() {
    let e5 = this.peek();
    switch (e5.type) {
      case l$5.NUMBER:
        return this.advance(), e5.value;
      case l$5.DOLLAR:
        return this.advance(), "$";
      case l$5.PATTERN:
        return this.advance(), { pattern: e5.pattern || e5.value };
      case l$5.STEP:
        return this.advance(), { first: e5.first || 0, step: e5.step || 0 };
      case l$5.RELATIVE_OFFSET:
        return this.advance(), { offset: e5.offset || 0 };
      default:
        return;
    }
  }
  peek() {
    return this.tokens[this.pos] || { type: l$5.EOF, value: "", line: 0, column: 0 };
  }
  advance() {
    return this.isAtEnd() || this.pos++, this.tokens[this.pos - 1];
  }
  check(e5) {
    return this.peek().type === e5;
  }
  isAtEnd() {
    return this.peek().type === l$5.EOF;
  }
};
function j$9(i4, e5 = false) {
  let t4 = false, n3 = false, s3 = [];
  for (let o2 = 0; o2 < i4.length; o2++) {
    let u3 = i4[o2];
    if (s3.length === 0 && o2 === 0) {
      let b4 = u3.match(/^#([nr]+)\s*(?:\n|$)/i);
      if (b4) {
        let g2 = b4[1].toLowerCase();
        g2.includes("n") && (t4 = true), g2.includes("r") && (n3 = true), u3 = u3.slice(b4[0].length);
      }
    }
    if (s3.length > 0 && s3[s3.length - 1].endsWith("\\")) {
      let b4 = s3[s3.length - 1];
      s3[s3.length - 1] = `${b4}
${u3}`;
    } else s3.push(u3);
  }
  let r2 = s3.join(`
`), c3 = new W$9([r2], e5 || n3).parse();
  if (!c3.error && c3.commands.length > 0) {
    let o2 = oe$4(c3.commands);
    if (o2) return { commands: [], error: o2, silentMode: t4, extendedRegexMode: n3 };
  }
  return { ...c3, silentMode: t4, extendedRegexMode: n3 };
}
function oe$4(i4) {
  let e5 = /* @__PURE__ */ new Set();
  Z$4(i4, e5);
  let t4 = K$4(i4, e5);
  if (t4) return `undefined label '${t4}'`;
}
function Z$4(i4, e5) {
  for (let t4 of i4) t4.type === "label" ? e5.add(t4.name) : t4.type === "group" && Z$4(t4.commands, e5);
}
function K$4(i4, e5) {
  for (let t4 of i4) {
    if ((t4.type === "branch" || t4.type === "branchOnSubst" || t4.type === "branchOnNoSubst") && t4.label && !e5.has(t4.label)) return t4.label;
    if (t4.type === "group") {
      let n3 = K$4(t4.commands, e5);
      if (n3) return n3;
    }
  }
}
var ue$5 = { name: "sed", summary: "stream editor for filtering and transforming text", usage: "sed [OPTION]... {script} [input-file]...", options: ["-n, --quiet, --silent  suppress automatic printing of pattern space", "-e script              add the script to commands to be executed", "-f script-file         read script from file", "-i, --in-place         edit files in place", "-E, -r, --regexp-extended  use extended regular expressions", "    --help             display this help and exit"], description: `Commands:
  s/regexp/replacement/[flags]  substitute
  d                             delete pattern space
  p                             print pattern space
  a\\ text                       append text after line
  i\\ text                       insert text before line
  c\\ text                       change (replace) line with text
  h                             copy pattern space to hold space
  H                             append pattern space to hold space
  g                             copy hold space to pattern space
  G                             append hold space to pattern space
  x                             exchange pattern and hold spaces
  n                             read next line into pattern space
  N                             append next line to pattern space
  y/source/dest/                transliterate characters
  =                             print line number
  l                             list pattern space (escape special chars)
  b [label]                     branch to label
  t [label]                     branch on substitution
  T [label]                     branch if no substitution
  :label                        define label
  q                             quit
  Q                             quit without printing

Addresses:
  N                             line number
  $                             last line
  /regexp/                      lines matching regexp
  N,M                           range from line N to M
  first~step                    every step-th line starting at first` };
async function q$9(i4, e5, t4, n3 = {}) {
  let { limits: s3, filename: r2, fs: a3, cwd: c3 } = n3, o2 = i4.endsWith(`
`), u3 = i4.split(`
`);
  u3.length > 0 && u3[u3.length - 1] === "" && u3.pop();
  let b4 = u3.length, g2 = "", m3, d3 = false, h3 = "", f3, E2 = /* @__PURE__ */ new Map(), C2 = /* @__PURE__ */ new Map(), S3 = /* @__PURE__ */ new Map(), A2 = /* @__PURE__ */ new Map(), Q4 = s3 ? { maxIterations: s3.maxSedIterations } : void 0;
  for (let k3 = 0; k3 < u3.length; k3++) {
    let p3 = { ...G$4(b4, r2, E2), patternSpace: u3[k3], holdSpace: h3, lastPattern: f3, lineNumber: k3 + 1, totalLines: b4, substitutionMade: false }, J3 = { lines: u3, currentLineIndex: k3 }, U2 = 0, Y2 = 1e4;
    p3.linesConsumedInCycle = 0;
    do {
      if (U2++, U2 > Y2) break;
      if (p3.restartCycle = false, p3.pendingFileReads = [], p3.pendingFileWrites = [], D$9(e5, p3, J3, Q4), a3 && c3) {
        for (let v2 of p3.pendingFileReads) {
          let x4 = a3.resolvePath(c3, v2.filename);
          try {
            if (v2.wholeFile) {
              let I2 = await a3.readFile(x4);
              p3.appendBuffer.push(I2.replace(/\n$/, ""));
            } else {
              if (!C2.has(x4)) {
                let te2 = await a3.readFile(x4);
                C2.set(x4, te2.split(`
`)), S3.set(x4, 0);
              }
              let I2 = C2.get(x4), L4 = S3.get(x4);
              I2 && L4 !== void 0 && L4 < I2.length && (p3.appendBuffer.push(I2[L4]), S3.set(x4, L4 + 1));
            }
          } catch {
          }
        }
        for (let v2 of p3.pendingFileWrites) {
          let x4 = a3.resolvePath(c3, v2.filename), I2 = A2.get(x4) || "";
          A2.set(x4, I2 + v2.content);
        }
      }
    } while (p3.restartCycle && !p3.deleted && !p3.quit && !p3.quitSilent);
    if (k3 += p3.linesConsumedInCycle, h3 = p3.holdSpace, f3 = p3.lastPattern, !t4) for (let v2 of p3.nCommandOutput) g2 += `${v2}
`;
    let ee2 = p3.lineNumberOutput.length > 0;
    for (let v2 of p3.lineNumberOutput) g2 += `${v2}
`;
    let H2 = [], F2 = [];
    for (let v2 of p3.appendBuffer) v2.startsWith("__INSERT__") ? H2.push(v2.slice(10)) : F2.push(v2);
    for (let v2 of H2) g2 += `${v2}
`;
    let y2 = false;
    !p3.deleted && !p3.quitSilent ? t4 ? p3.printed && (g2 += `${p3.patternSpace}
`, y2 = true) : (g2 += `${p3.patternSpace}
`, y2 = true) : p3.changedText !== void 0 && (g2 += `${p3.changedText}
`, y2 = true);
    for (let v2 of F2) g2 += `${v2}
`;
    if (d3 = (ee2 || y2) && F2.length === 0, p3.quit || p3.quitSilent) {
      if (p3.exitCode !== void 0 && (m3 = p3.exitCode), p3.errorMessage) return { output: "", exitCode: m3 || 1, errorMessage: p3.errorMessage };
      break;
    }
  }
  if (a3 && c3) for (let [k3, p3] of A2) try {
    await a3.writeFile(k3, p3);
  } catch {
  }
  return !o2 && d3 && g2.endsWith(`
`) && (g2 = g2.slice(0, -1)), { output: g2, exitCode: m3 };
}
var ke$5 = { name: "sed", async execute(i4, e5) {
  if (o$3(i4)) return s$1(ue$5);
  let t4 = [], n3 = [], s3 = false, r2 = false, a3 = false, c3 = [];
  for (let h3 = 0; h3 < i4.length; h3++) {
    let f3 = i4[h3];
    if (f3 === "-n" || f3 === "--quiet" || f3 === "--silent") s3 = true;
    else if (f3 === "-i" || f3 === "--in-place") r2 = true;
    else if (f3.startsWith("-i")) r2 = true;
    else if (f3 === "-E" || f3 === "-r" || f3 === "--regexp-extended") a3 = true;
    else if (f3 === "-e") h3 + 1 < i4.length && t4.push(i4[++h3]);
    else if (f3 === "-f") h3 + 1 < i4.length && n3.push(i4[++h3]);
    else {
      if (f3.startsWith("--")) return r$3("sed", f3);
      if (f3 === "-") c3.push(f3);
      else if (f3.startsWith("-") && f3.length > 1) {
        for (let E2 of f3.slice(1)) if (E2 !== "n" && E2 !== "e" && E2 !== "f" && E2 !== "i" && E2 !== "E" && E2 !== "r") return r$3("sed", `-${E2}`);
        f3.includes("n") && (s3 = true), f3.includes("i") && (r2 = true), (f3.includes("E") || f3.includes("r")) && (a3 = true), f3.includes("e") && !f3.includes("n") && !f3.includes("i") && h3 + 1 < i4.length && t4.push(i4[++h3]), f3.includes("f") && !f3.includes("e") && h3 + 1 < i4.length && n3.push(i4[++h3]);
      } else !f3.startsWith("-") && t4.length === 0 && n3.length === 0 ? t4.push(f3) : f3.startsWith("-") || c3.push(f3);
    }
  }
  for (let h3 of n3) {
    let f3 = e5.fs.resolvePath(e5.cwd, h3);
    try {
      let E2 = await e5.fs.readFile(f3);
      for (let C2 of E2.split(`
`)) {
        let S3 = C2.trim();
        S3 && !S3.startsWith("#") && t4.push(S3);
      }
    } catch {
      return { stdout: "", stderr: `sed: couldn't open file ${h3}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (t4.length === 0) return { stdout: "", stderr: `sed: no script specified
`, exitCode: 1 };
  let { commands: o2, error: u3, silentMode: b4 } = j$9(t4, a3);
  if (u3) return { stdout: "", stderr: `sed: ${u3}
`, exitCode: 1 };
  let g2 = !!(s3 || b4);
  if (r2) {
    if (c3.length === 0) return { stdout: "", stderr: `sed: -i requires at least one file argument
`, exitCode: 1 };
    for (let h3 of c3) {
      if (h3 === "-") continue;
      let f3 = e5.fs.resolvePath(e5.cwd, h3);
      try {
        let E2 = await e5.fs.readFile(f3), C2 = await q$9(E2, o2, g2, { limits: e5.limits, filename: h3, fs: e5.fs, cwd: e5.cwd });
        if (C2.errorMessage) return { stdout: "", stderr: `${C2.errorMessage}
`, exitCode: C2.exitCode ?? 1 };
        await e5.fs.writeFile(f3, C2.output);
      } catch (E2) {
        return E2 instanceof b$i ? { stdout: "", stderr: `sed: ${E2.message}
`, exitCode: b$i.EXIT_CODE } : { stdout: "", stderr: `sed: ${h3}: No such file or directory
`, exitCode: 1 };
      }
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  }
  let m3 = "";
  if (c3.length === 0) {
    m3 = e5.stdin;
    try {
      let h3 = await q$9(m3, o2, g2, { limits: e5.limits, fs: e5.fs, cwd: e5.cwd });
      return { stdout: h3.output, stderr: h3.errorMessage ? `${h3.errorMessage}
` : "", exitCode: h3.exitCode ?? 0 };
    } catch (h3) {
      if (h3 instanceof b$i) return { stdout: "", stderr: `sed: ${h3.message}
`, exitCode: b$i.EXIT_CODE };
      throw h3;
    }
  }
  let d3 = false;
  for (let h3 of c3) {
    let f3;
    if (h3 === "-") d3 ? f3 = "" : (f3 = e5.stdin, d3 = true);
    else {
      let E2 = e5.fs.resolvePath(e5.cwd, h3);
      try {
        f3 = await e5.fs.readFile(E2);
      } catch (C2) {
        return C2 instanceof b$i ? { stdout: "", stderr: `sed: ${C2.message}
`, exitCode: b$i.EXIT_CODE } : { stdout: "", stderr: `sed: ${h3}: No such file or directory
`, exitCode: 1 };
      }
    }
    m3.length > 0 && f3.length > 0 && !m3.endsWith(`
`) && (m3 += `
`), m3 += f3;
  }
  try {
    let h3 = await q$9(m3, o2, g2, { limits: e5.limits, filename: c3.length === 1 ? c3[0] : void 0, fs: e5.fs, cwd: e5.cwd });
    return { stdout: h3.output, stderr: h3.errorMessage ? `${h3.errorMessage}
` : "", exitCode: h3.exitCode ?? 0 };
  } catch (h3) {
    if (h3 instanceof b$i) return { stdout: "", stderr: `sed: ${h3.message}
`, exitCode: b$i.EXIT_CODE };
    throw h3;
  }
} };
const sedIV6HLDXU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sedCommand: ke$5
});
function K$3(e5 = {}) {
  let { fieldSep: t4 = /\s+/, maxIterations: n3 = 1e4, maxRecursionDepth: i4 = 100, fs: a3, cwd: s3, exec: o2 } = e5;
  return { FS: " ", OFS: " ", ORS: `
`, OFMT: "%.6g", NR: 0, NF: 0, FNR: 0, FILENAME: "", RSTART: 0, RLENGTH: -1, SUBSEP: "", fields: [], line: "", vars: {}, arrays: {}, arrayAliases: /* @__PURE__ */ new Map(), ARGC: 0, ARGV: {}, ENVIRON: {}, functions: /* @__PURE__ */ new Map(), fieldSep: t4, maxIterations: n3, maxRecursionDepth: i4, currentRecursionDepth: 0, exitCode: 0, shouldExit: false, shouldNext: false, shouldNextFile: false, loopBreak: false, loopContinue: false, hasReturn: false, inEndBlock: false, output: "", openedFiles: /* @__PURE__ */ new Set(), fs: a3, cwd: s3, exec: o2 };
}
function re$1(e5, t4, n3) {
  switch (n3) {
    case "+":
      return e5 + t4;
    case "-":
      return e5 - t4;
    case "*":
      return e5 * t4;
    case "/":
      return t4 !== 0 ? e5 / t4 : 0;
    case "%":
      return t4 !== 0 ? e5 % t4 : 0;
    case "^":
    case "**":
      return e5 ** t4;
    default:
      return 0;
  }
}
function k$8(e5) {
  if (typeof e5 == "number") return e5;
  let t4 = parseFloat(e5);
  return Number.isNaN(t4) ? 0 : t4;
}
function m$a(e5) {
  return typeof e5 == "string" ? e5 : String(e5);
}
async function G$3(e5, t4) {
  if (e5.type === "regex") return e5.pattern;
  let n3 = m$a(await t4.evalExpr(e5));
  return n3.startsWith("/") && n3.endsWith("/") && (n3 = n3.slice(1, -1)), n3;
}
async function se$3(e5, t4) {
  return e5 ? e5.type === "variable" ? e5.name : e5.type === "field" ? `$${Math.floor(k$8(await t4.evalExpr(e5.index)))}` : "$0" : "$0";
}
function ae$2(e5, t4) {
  if (e5 === "$0") return t4.line;
  if (e5.startsWith("$")) {
    let n3 = parseInt(e5.slice(1), 10) - 1;
    return t4.fields[n3] || "";
  }
  return m$a(t4.vars[e5] ?? "");
}
function oe$3(e5, t4, n3) {
  if (e5 === "$0") n3.line = t4, n3.fields = n3.FS === " " ? t4.trim().split(/\s+/).filter(Boolean) : t4.split(n3.fieldSep), n3.NF = n3.fields.length;
  else if (e5.startsWith("$")) {
    let i4 = parseInt(e5.slice(1), 10) - 1;
    for (; n3.fields.length <= i4; ) n3.fields.push("");
    n3.fields[i4] = t4, n3.NF = n3.fields.length, n3.line = n3.fields.join(n3.OFS);
  } else n3.vars[e5] = t4;
}
async function ge$3(e5, t4, n3) {
  return e5.length === 0 ? t4.line.length : m$a(await n3.evalExpr(e5[0])).length;
}
async function ke$4(e5, t4, n3) {
  if (e5.length < 2) return "";
  let i4 = m$a(await n3.evalExpr(e5[0])), a3 = Math.floor(k$8(await n3.evalExpr(e5[1]))) - 1;
  if (e5.length >= 3) {
    let s3 = Math.floor(k$8(await n3.evalExpr(e5[2])));
    return i4.substr(Math.max(0, a3), s3);
  }
  return i4.substr(Math.max(0, a3));
}
async function Ce$2(e5, t4, n3) {
  if (e5.length < 2) return 0;
  let i4 = m$a(await n3.evalExpr(e5[0])), a3 = m$a(await n3.evalExpr(e5[1])), s3 = i4.indexOf(a3);
  return s3 === -1 ? 0 : s3 + 1;
}
async function Le$3(e5, t4, n3) {
  if (e5.length < 2) return 0;
  let i4 = m$a(await n3.evalExpr(e5[0])), a3 = e5[1];
  if (a3.type !== "variable") return 0;
  let s3 = a3.name, o2 = t4.FS;
  if (e5.length >= 3) {
    let h3 = e5[2];
    if (h3.type === "regex") o2 = new RegExp(h3.pattern);
    else {
      let N2 = m$a(await n3.evalExpr(h3));
      o2 = N2 === " " ? /\s+/ : N2;
    }
  } else t4.FS === " " && (o2 = /\s+/);
  let l3 = i4.split(o2);
  t4.arrays[s3] = {};
  for (let h3 = 0; h3 < l3.length; h3++) t4.arrays[s3][String(h3 + 1)] = l3[h3];
  return l3.length;
}
async function be$4(e5, t4, n3) {
  if (e5.length < 2) return 0;
  let i4 = await G$3(e5[0], n3), a3 = m$a(await n3.evalExpr(e5[1])), s3 = await se$3(e5[2], n3), o2 = ae$2(s3, t4);
  try {
    let l3 = new RegExp(i4), h3 = o2.replace(l3, ce$5(a3)), N2 = h3 !== o2 ? 1 : 0;
    return oe$3(s3, h3, t4), N2;
  } catch {
    return 0;
  }
}
async function Oe$4(e5, t4, n3) {
  if (e5.length < 2) return 0;
  let i4 = await G$3(e5[0], n3), a3 = m$a(await n3.evalExpr(e5[1])), s3 = await se$3(e5[2], n3), o2 = ae$2(s3, t4);
  try {
    let l3 = new RegExp(i4, "g"), h3 = o2.match(l3), N2 = h3 ? h3.length : 0, v2 = o2.replace(l3, ce$5(a3));
    return oe$3(s3, v2, t4), N2;
  } catch {
    return 0;
  }
}
function ce$5(e5) {
  return (t4) => {
    let n3 = "", i4 = 0;
    for (; i4 < e5.length; ) if (e5[i4] === "\\" && i4 + 1 < e5.length) {
      let a3 = e5[i4 + 1];
      a3 === "&" ? (n3 += "&", i4 += 2) : a3 === "\\" ? (n3 += "\\", i4 += 2) : (n3 += e5[i4 + 1], i4 += 2);
    } else e5[i4] === "&" ? (n3 += t4, i4++) : (n3 += e5[i4], i4++);
    return n3;
  };
}
async function Pe$3(e5, t4, n3) {
  if (e5.length < 2) return t4.RSTART = 0, t4.RLENGTH = -1, 0;
  let i4 = m$a(await n3.evalExpr(e5[0])), a3 = await G$3(e5[1], n3);
  try {
    let o2 = new RegExp(a3).exec(i4);
    if (o2) return t4.RSTART = o2.index + 1, t4.RLENGTH = o2[0].length, t4.RSTART;
  } catch {
  }
  return t4.RSTART = 0, t4.RLENGTH = -1, 0;
}
async function Me$4(e5, t4, n3) {
  if (e5.length < 3) return "";
  let i4 = await G$3(e5[0], n3), a3 = m$a(await n3.evalExpr(e5[1])), s3 = m$a(await n3.evalExpr(e5[2])), o2 = e5.length >= 4 ? m$a(await n3.evalExpr(e5[3])) : t4.line;
  try {
    let l3 = s3.toLowerCase() === "g", h3 = l3 ? 0 : parseInt(s3, 10) || 1;
    if (l3) {
      let N2 = new RegExp(i4, "g");
      return o2.replace(N2, (v2, ...R2) => ie$4(a3, v2, R2.slice(0, -2)));
    } else {
      let N2 = 0, v2 = new RegExp(i4, "g");
      return o2.replace(v2, (R2, ...I2) => (N2++, N2 === h3 ? ie$4(a3, R2, I2.slice(0, -2)) : R2));
    }
  } catch {
    return o2;
  }
}
function ie$4(e5, t4, n3) {
  let i4 = "", a3 = 0;
  for (; a3 < e5.length; ) if (e5[a3] === "\\" && a3 + 1 < e5.length) {
    let s3 = e5[a3 + 1];
    if (s3 === "&") i4 += "&", a3 += 2;
    else if (s3 === "0") i4 += t4, a3 += 2;
    else if (s3 >= "1" && s3 <= "9") {
      let o2 = parseInt(s3, 10) - 1;
      i4 += n3[o2] || "", a3 += 2;
    } else s3 === "n" ? (i4 += `
`, a3 += 2) : s3 === "t" ? (i4 += "	", a3 += 2) : (i4 += s3, a3 += 2);
  } else e5[a3] === "&" ? (i4 += t4, a3++) : (i4 += e5[a3], a3++);
  return i4;
}
async function Te$3(e5, t4, n3) {
  return e5.length === 0 ? "" : m$a(await n3.evalExpr(e5[0])).toLowerCase();
}
async function Fe$4(e5, t4, n3) {
  return e5.length === 0 ? "" : m$a(await n3.evalExpr(e5[0])).toUpperCase();
}
async function _e$4(e5, t4, n3) {
  if (e5.length === 0) return "";
  let i4 = m$a(await n3.evalExpr(e5[0])), a3 = [];
  for (let s3 = 1; s3 < e5.length; s3++) a3.push(await n3.evalExpr(e5[s3]));
  return D$8(i4, a3);
}
async function Ge$2(e5, t4, n3) {
  return e5.length === 0 ? 0 : Math.floor(k$8(await n3.evalExpr(e5[0])));
}
async function De$3(e5, t4, n3) {
  return e5.length === 0 ? 0 : Math.sqrt(k$8(await n3.evalExpr(e5[0])));
}
async function xe$6(e5, t4, n3) {
  return e5.length === 0 ? 0 : Math.sin(k$8(await n3.evalExpr(e5[0])));
}
async function Ue$3(e5, t4, n3) {
  return e5.length === 0 ? 0 : Math.cos(k$8(await n3.evalExpr(e5[0])));
}
async function Be$4(e5, t4, n3) {
  let i4 = e5.length > 0 ? k$8(await n3.evalExpr(e5[0])) : 0, a3 = e5.length > 1 ? k$8(await n3.evalExpr(e5[1])) : 0;
  return Math.atan2(i4, a3);
}
async function He$4(e5, t4, n3) {
  return e5.length === 0 ? 0 : Math.log(k$8(await n3.evalExpr(e5[0])));
}
async function $e$3(e5, t4, n3) {
  return e5.length === 0 ? 1 : Math.exp(k$8(await n3.evalExpr(e5[0])));
}
function We$4(e5, t4, n3) {
  return t4.random ? t4.random() : Math.random();
}
async function Ve$4(e5, t4, n3) {
  let i4 = e5.length > 0 ? k$8(await n3.evalExpr(e5[0])) : Date.now();
  return t4.vars._srand_seed = i4, i4;
}
function Xe$2(e5, t4) {
  return () => {
    throw new Error(`${e5}() is not supported - ${t4}`);
  };
}
function Q$5(e5) {
  return () => {
    throw new Error(`function '${e5}()' is not implemented`);
  };
}
function D$8(e5, t4) {
  let n3 = 0, i4 = "", a3 = 0;
  for (; a3 < e5.length; ) if (e5[a3] === "%" && a3 + 1 < e5.length) {
    let s3 = a3 + 1, o2 = "", l3 = "", h3 = "", N2, v2 = s3;
    for (; s3 < e5.length && /\d/.test(e5[s3]); ) s3++;
    s3 > v2 && e5[s3] === "$" ? (N2 = parseInt(e5.substring(v2, s3), 10) - 1, s3++) : s3 = v2;
    let R2 = () => {
      if (s3 < e5.length) {
        if (s3 + 1 < e5.length && (e5[s3] === "h" && e5[s3 + 1] === "h" || e5[s3] === "l" && e5[s3 + 1] === "l")) {
          s3 += 2;
          return;
        }
        /[lzjh]/.test(e5[s3]) && s3++;
      }
    };
    for (; s3 < e5.length && /[-+ #0]/.test(e5[s3]); ) o2 += e5[s3++];
    if (e5[s3] === "*") {
      let c3 = t4[n3++], p3 = c3 !== void 0 ? Math.floor(Number(c3)) : 0;
      p3 < 0 ? (o2 += "-", l3 = String(-p3)) : l3 = String(p3), s3++;
    } else for (; s3 < e5.length && /\d/.test(e5[s3]); ) l3 += e5[s3++];
    if (e5[s3] === ".") if (s3++, e5[s3] === "*") {
      let c3 = t4[n3++];
      h3 = String(c3 !== void 0 ? Math.floor(Number(c3)) : 0), s3++;
    } else for (; s3 < e5.length && /\d/.test(e5[s3]); ) h3 += e5[s3++];
    R2();
    let I2 = e5[s3], w4 = t4[N2 !== void 0 ? N2 : n3];
    switch (I2) {
      case "s": {
        let c3 = w4 !== void 0 ? String(w4) : "";
        if (h3 && (c3 = c3.substring(0, parseInt(h3, 10))), l3) {
          let p3 = parseInt(l3, 10);
          o2.includes("-") ? c3 = c3.padEnd(p3) : c3 = c3.padStart(p3);
        }
        i4 += c3, N2 === void 0 && n3++;
        break;
      }
      case "d":
      case "i": {
        let c3 = w4 !== void 0 ? Math.floor(Number(w4)) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = c3 < 0, E2 = Math.abs(c3).toString();
        if (h3) {
          let L4 = parseInt(h3, 10);
          E2 = E2.padStart(L4, "0");
        }
        let d3 = "";
        p3 ? d3 = "-" : o2.includes("+") ? d3 = "+" : o2.includes(" ") && (d3 = " ");
        let y2 = d3 + E2;
        if (l3) {
          let L4 = parseInt(l3, 10);
          o2.includes("-") ? y2 = y2.padEnd(L4) : o2.includes("0") && !h3 ? y2 = d3 + E2.padStart(L4 - d3.length, "0") : y2 = y2.padStart(L4);
        }
        i4 += y2, N2 === void 0 && n3++;
        break;
      }
      case "f": {
        let c3 = w4 !== void 0 ? Number(w4) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = h3 ? parseInt(h3, 10) : 6, E2 = c3.toFixed(p3);
        if (l3) {
          let d3 = parseInt(l3, 10);
          o2.includes("-") ? E2 = E2.padEnd(d3) : E2 = E2.padStart(d3);
        }
        i4 += E2, N2 === void 0 && n3++;
        break;
      }
      case "e":
      case "E": {
        let c3 = w4 !== void 0 ? Number(w4) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = h3 ? parseInt(h3, 10) : 6, E2 = c3.toExponential(p3);
        if (I2 === "E" && (E2 = E2.toUpperCase()), l3) {
          let d3 = parseInt(l3, 10);
          o2.includes("-") ? E2 = E2.padEnd(d3) : E2 = E2.padStart(d3);
        }
        i4 += E2, N2 === void 0 && n3++;
        break;
      }
      case "g":
      case "G": {
        let c3 = w4 !== void 0 ? Number(w4) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = h3 ? parseInt(h3, 10) : 6, E2 = c3 !== 0 ? Math.floor(Math.log10(Math.abs(c3))) : 0, d3;
        if (c3 === 0 ? d3 = "0" : E2 < -4 || E2 >= p3 ? (d3 = c3.toExponential(p3 - 1), I2 === "G" && (d3 = d3.toUpperCase())) : d3 = c3.toPrecision(p3), d3.includes(".") && (d3 = d3.replace(/\.?0+$/, "").replace(/\.?0+e/, "e")), d3.includes("e") && (d3 = d3.replace(/\.?0+e/, "e")), l3) {
          let y2 = parseInt(l3, 10);
          o2.includes("-") ? d3 = d3.padEnd(y2) : d3 = d3.padStart(y2);
        }
        i4 += d3, N2 === void 0 && n3++;
        break;
      }
      case "x":
      case "X": {
        let c3 = w4 !== void 0 ? Math.floor(Number(w4)) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = Math.abs(c3).toString(16);
        if (I2 === "X" && (p3 = p3.toUpperCase()), h3) {
          let y2 = parseInt(h3, 10);
          p3 = p3.padStart(y2, "0");
        }
        let E2 = c3 < 0 ? "-" : "", d3 = E2 + p3;
        if (l3) {
          let y2 = parseInt(l3, 10);
          o2.includes("-") ? d3 = d3.padEnd(y2) : o2.includes("0") && !h3 ? d3 = E2 + p3.padStart(y2 - E2.length, "0") : d3 = d3.padStart(y2);
        }
        i4 += d3, N2 === void 0 && n3++;
        break;
      }
      case "o": {
        let c3 = w4 !== void 0 ? Math.floor(Number(w4)) : 0;
        Number.isNaN(c3) && (c3 = 0);
        let p3 = Math.abs(c3).toString(8);
        if (h3) {
          let y2 = parseInt(h3, 10);
          p3 = p3.padStart(y2, "0");
        }
        let E2 = c3 < 0 ? "-" : "", d3 = E2 + p3;
        if (l3) {
          let y2 = parseInt(l3, 10);
          o2.includes("-") ? d3 = d3.padEnd(y2) : o2.includes("0") && !h3 ? d3 = E2 + p3.padStart(y2 - E2.length, "0") : d3 = d3.padStart(y2);
        }
        i4 += d3, N2 === void 0 && n3++;
        break;
      }
      case "c": {
        typeof w4 == "number" ? i4 += String.fromCharCode(w4) : i4 += String(w4 ?? "").charAt(0) || "", N2 === void 0 && n3++;
        break;
      }
      case "%":
        i4 += "%";
        break;
      default:
        i4 += e5.substring(a3, s3 + 1);
    }
    a3 = s3 + 1;
  } else if (e5[a3] === "\\" && a3 + 1 < e5.length) {
    let s3 = e5[a3 + 1];
    switch (s3) {
      case "n":
        i4 += `
`;
        break;
      case "t":
        i4 += "	";
        break;
      case "r":
        i4 += "\r";
        break;
      case "\\":
        i4 += "\\";
        break;
      default:
        i4 += s3;
    }
    a3 += 2;
  } else i4 += e5[a3++];
  return i4;
}
var le$3 = { length: ge$3, substr: ke$4, index: Ce$2, split: Le$3, sub: be$4, gsub: Oe$4, match: Pe$3, gensub: Me$4, tolower: Te$3, toupper: Fe$4, sprintf: _e$4, int: Ge$2, sqrt: De$3, sin: xe$6, cos: Ue$3, atan2: Be$4, log: He$4, exp: $e$3, rand: We$4, srand: Ve$4, system: Xe$2("system", "shell execution not allowed in sandboxed environment"), close: () => 0, fflush: () => 0, systime: Q$5("systime"), mktime: Q$5("mktime"), strftime: Q$5("strftime") };
function g$b(e5) {
  return typeof e5 == "number" ? e5 !== 0 : !(e5 === "" || e5 === "0");
}
function A$6(e5) {
  if (typeof e5 == "number") return e5;
  let t4 = parseFloat(e5);
  return Number.isNaN(t4) ? 0 : t4;
}
function S$b(e5) {
  return typeof e5 == "string" ? e5 : String(e5);
}
function j$8(e5) {
  if (typeof e5 == "number") return true;
  let t4 = String(e5).trim();
  return t4 === "" ? false : !Number.isNaN(Number(t4));
}
function T$7(e5, t4) {
  try {
    return new RegExp(e5).test(t4);
  } catch {
    return false;
  }
}
function ue$4(e5, t4) {
  return t4 === "" ? [] : e5.FS === " " ? t4.trim().split(/\s+/).filter(Boolean) : t4.split(e5.fieldSep);
}
function x$d(e5, t4) {
  return t4 === 0 ? e5.line : t4 < 0 || t4 > e5.fields.length ? "" : e5.fields[t4 - 1] ?? "";
}
function q$8(e5, t4, n3) {
  if (t4 === 0) e5.line = S$b(n3), e5.fields = ue$4(e5, e5.line), e5.NF = e5.fields.length;
  else if (t4 > 0) {
    for (; e5.fields.length < t4; ) e5.fields.push("");
    e5.fields[t4 - 1] = S$b(n3), e5.NF = e5.fields.length, e5.line = e5.fields.join(e5.OFS);
  }
}
function O$9(e5, t4) {
  e5.line = t4, e5.fields = ue$4(e5, t4), e5.NF = e5.fields.length;
}
function he$4(e5, t4) {
  if (e5.FS = t4, t4 === " ") e5.fieldSep = /\s+/;
  else try {
    e5.fieldSep = new RegExp(t4);
  } catch {
    e5.fieldSep = new RegExp(t4.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"));
  }
}
function U$5(e5, t4) {
  switch (t4) {
    case "FS":
      return e5.FS;
    case "OFS":
      return e5.OFS;
    case "ORS":
      return e5.ORS;
    case "OFMT":
      return e5.OFMT;
    case "NR":
      return e5.NR;
    case "NF":
      return e5.NF;
    case "FNR":
      return e5.FNR;
    case "FILENAME":
      return e5.FILENAME;
    case "RSTART":
      return e5.RSTART;
    case "RLENGTH":
      return e5.RLENGTH;
    case "SUBSEP":
      return e5.SUBSEP;
    case "ARGC":
      return e5.ARGC;
  }
  return e5.vars[t4] ?? "";
}
function P$a(e5, t4, n3) {
  switch (t4) {
    case "FS":
      he$4(e5, S$b(n3));
      return;
    case "OFS":
      e5.OFS = S$b(n3);
      return;
    case "ORS":
      e5.ORS = S$b(n3);
      return;
    case "OFMT":
      e5.OFMT = S$b(n3);
      return;
    case "NR":
      e5.NR = Math.floor(A$6(n3));
      return;
    case "NF": {
      let i4 = Math.floor(A$6(n3));
      if (i4 < e5.NF) e5.fields = e5.fields.slice(0, i4), e5.line = e5.fields.join(e5.OFS);
      else if (i4 > e5.NF) {
        for (; e5.fields.length < i4; ) e5.fields.push("");
        e5.line = e5.fields.join(e5.OFS);
      }
      e5.NF = i4;
      return;
    }
    case "FNR":
      e5.FNR = Math.floor(A$6(n3));
      return;
    case "FILENAME":
      e5.FILENAME = S$b(n3);
      return;
    case "RSTART":
      e5.RSTART = Math.floor(A$6(n3));
      return;
    case "RLENGTH":
      e5.RLENGTH = Math.floor(A$6(n3));
      return;
    case "SUBSEP":
      e5.SUBSEP = S$b(n3);
      return;
  }
  e5.vars[t4] = n3;
}
function F$8(e5, t4) {
  let n3 = t4, i4 = /* @__PURE__ */ new Set(), a3 = e5.arrayAliases.get(n3);
  for (; a3 !== void 0 && !i4.has(n3); ) i4.add(n3), n3 = a3, a3 = e5.arrayAliases.get(n3);
  return n3;
}
function B$7(e5, t4, n3) {
  if (t4 === "ARGV") return e5.ARGV[n3] ?? "";
  if (t4 === "ENVIRON") return e5.ENVIRON[n3] ?? "";
  let i4 = F$8(e5, t4);
  return e5.arrays[i4]?.[n3] ?? "";
}
function z$4(e5, t4, n3, i4) {
  let a3 = F$8(e5, t4);
  e5.arrays[a3] || (e5.arrays[a3] = {}), e5.arrays[a3][n3] = i4;
}
function pe$3(e5, t4, n3) {
  if (t4 === "ARGV") return e5.ARGV[n3] !== void 0;
  if (t4 === "ENVIRON") return e5.ENVIRON[n3] !== void 0;
  let i4 = F$8(e5, t4);
  return e5.arrays[i4]?.[n3] !== void 0;
}
function fe$4(e5, t4, n3) {
  let i4 = F$8(e5, t4);
  e5.arrays[i4] && delete e5.arrays[i4][n3];
}
function de$3(e5, t4) {
  let n3 = F$8(e5, t4);
  delete e5.arrays[n3];
}
var J$6 = null;
function Ee$4(e5) {
  J$6 = e5;
}
async function f$2(e5, t4) {
  switch (t4.type) {
    case "number":
      return t4.value;
    case "string":
      return t4.value;
    case "regex":
      return T$7(t4.pattern, e5.line) ? 1 : 0;
    case "field":
      return Ke$2(e5, t4);
    case "variable":
      return U$5(e5, t4.name);
    case "array_access":
      return Qe$4(e5, t4);
    case "binary":
      return je$4(e5, t4);
    case "unary":
      return Je$4(e5, t4);
    case "ternary":
      return g$b(await f$2(e5, t4.condition)) ? await f$2(e5, t4.consequent) : await f$2(e5, t4.alternate);
    case "call":
      return Ze$3(e5, t4.name, t4.args);
    case "assignment":
      return et$5(e5, t4);
    case "pre_increment":
      return tt$4(e5, t4.operand);
    case "pre_decrement":
      return nt$3(e5, t4.operand);
    case "post_increment":
      return rt$1(e5, t4.operand);
    case "post_decrement":
      return it$3(e5, t4.operand);
    case "in":
      return st$4(e5, t4.key, t4.array);
    case "getline":
      return at$3(e5, t4.variable, t4.file, t4.command);
    case "tuple":
      return lt$1(e5, t4.elements);
    default:
      return "";
  }
}
async function Ke$2(e5, t4) {
  let n3 = Math.floor(A$6(await f$2(e5, t4.index)));
  return x$d(e5, n3);
}
async function Qe$4(e5, t4) {
  let n3 = S$b(await f$2(e5, t4.key));
  return B$7(e5, t4.array, n3);
}
async function je$4(e5, t4) {
  let n3 = t4.operator;
  if (n3 === "||") return g$b(await f$2(e5, t4.left)) || g$b(await f$2(e5, t4.right)) ? 1 : 0;
  if (n3 === "&&") return g$b(await f$2(e5, t4.left)) && g$b(await f$2(e5, t4.right)) ? 1 : 0;
  if (n3 === "~") {
    let l3 = await f$2(e5, t4.left), h3 = t4.right.type === "regex" ? t4.right.pattern : S$b(await f$2(e5, t4.right));
    try {
      return new RegExp(h3).test(S$b(l3)) ? 1 : 0;
    } catch {
      return 0;
    }
  }
  if (n3 === "!~") {
    let l3 = await f$2(e5, t4.left), h3 = t4.right.type === "regex" ? t4.right.pattern : S$b(await f$2(e5, t4.right));
    try {
      return new RegExp(h3).test(S$b(l3)) ? 0 : 1;
    } catch {
      return 1;
    }
  }
  let i4 = await f$2(e5, t4.left), a3 = await f$2(e5, t4.right);
  if (n3 === " ") return S$b(i4) + S$b(a3);
  if (qe$5(n3)) return ze$2(i4, a3, n3);
  let s3 = A$6(i4), o2 = A$6(a3);
  return re$1(s3, o2, n3);
}
function qe$5(e5) {
  return ["<", "<=", ">", ">=", "==", "!="].includes(e5);
}
function ze$2(e5, t4, n3) {
  let i4 = j$8(e5), a3 = j$8(t4);
  if (i4 && a3) {
    let l3 = A$6(e5), h3 = A$6(t4);
    switch (n3) {
      case "<":
        return l3 < h3 ? 1 : 0;
      case "<=":
        return l3 <= h3 ? 1 : 0;
      case ">":
        return l3 > h3 ? 1 : 0;
      case ">=":
        return l3 >= h3 ? 1 : 0;
      case "==":
        return l3 === h3 ? 1 : 0;
      case "!=":
        return l3 !== h3 ? 1 : 0;
    }
  }
  let s3 = S$b(e5), o2 = S$b(t4);
  switch (n3) {
    case "<":
      return s3 < o2 ? 1 : 0;
    case "<=":
      return s3 <= o2 ? 1 : 0;
    case ">":
      return s3 > o2 ? 1 : 0;
    case ">=":
      return s3 >= o2 ? 1 : 0;
    case "==":
      return s3 === o2 ? 1 : 0;
    case "!=":
      return s3 !== o2 ? 1 : 0;
  }
  return 0;
}
async function Je$4(e5, t4) {
  let n3 = await f$2(e5, t4.operand);
  switch (t4.operator) {
    case "!":
      return g$b(n3) ? 0 : 1;
    case "-":
      return -A$6(n3);
    case "+":
      return +A$6(n3);
    default:
      return n3;
  }
}
async function Ze$3(e5, t4, n3) {
  let i4 = le$3[t4];
  if (i4) return i4(n3, e5, { evalExpr: (s3) => f$2(e5, s3) });
  let a3 = e5.functions.get(t4);
  return a3 ? Ye$3(e5, a3, n3) : "";
}
async function Ye$3(e5, t4, n3) {
  if (e5.currentRecursionDepth++, e5.currentRecursionDepth > e5.maxRecursionDepth) throw e5.currentRecursionDepth--, new b$i(`awk: recursion depth exceeded maximum (${e5.maxRecursionDepth})`, "recursion", e5.output);
  let i4 = {};
  for (let o2 of t4.params) i4[o2] = e5.vars[o2];
  let a3 = [];
  for (let o2 = 0; o2 < t4.params.length; o2++) {
    let l3 = t4.params[o2];
    if (o2 < n3.length) {
      let h3 = n3[o2];
      h3.type === "variable" && (e5.arrayAliases.set(l3, h3.name), a3.push(l3));
      let N2 = await f$2(e5, h3);
      e5.vars[l3] = N2;
    } else e5.vars[l3] = "";
  }
  e5.hasReturn = false, e5.returnValue = void 0, J$6 && await J$6(e5, t4.body.statements);
  let s3 = e5.returnValue ?? "";
  for (let o2 of t4.params) i4[o2] !== void 0 ? e5.vars[o2] = i4[o2] : delete e5.vars[o2];
  for (let o2 of a3) e5.arrayAliases.delete(o2);
  return e5.hasReturn = false, e5.returnValue = void 0, e5.currentRecursionDepth--, s3;
}
async function et$5(e5, t4) {
  let n3 = await f$2(e5, t4.value), i4 = t4.target, a3 = t4.operator, s3;
  if (a3 === "=") s3 = n3;
  else {
    let o2;
    if (i4.type === "field") {
      let N2 = Math.floor(A$6(await f$2(e5, i4.index)));
      o2 = x$d(e5, N2);
    } else if (i4.type === "variable") o2 = U$5(e5, i4.name);
    else {
      let N2 = S$b(await f$2(e5, i4.key));
      o2 = B$7(e5, i4.array, N2);
    }
    let l3 = A$6(o2), h3 = A$6(n3);
    switch (a3) {
      case "+=":
        s3 = l3 + h3;
        break;
      case "-=":
        s3 = l3 - h3;
        break;
      case "*=":
        s3 = l3 * h3;
        break;
      case "/=":
        s3 = h3 !== 0 ? l3 / h3 : 0;
        break;
      case "%=":
        s3 = h3 !== 0 ? l3 % h3 : 0;
        break;
      case "^=":
        s3 = l3 ** h3;
        break;
      default:
        s3 = n3;
    }
  }
  if (i4.type === "field") {
    let o2 = Math.floor(A$6(await f$2(e5, i4.index)));
    q$8(e5, o2, s3);
  } else if (i4.type === "variable") P$a(e5, i4.name, s3);
  else {
    let o2 = S$b(await f$2(e5, i4.key));
    z$4(e5, i4.array, o2, s3);
  }
  return s3;
}
async function H$8(e5, t4, n3, i4) {
  let a3;
  if (t4.type === "field") {
    let s3 = Math.floor(A$6(await f$2(e5, t4.index)));
    a3 = A$6(x$d(e5, s3)), q$8(e5, s3, a3 + n3);
  } else if (t4.type === "variable") a3 = A$6(U$5(e5, t4.name)), P$a(e5, t4.name, a3 + n3);
  else {
    let s3 = S$b(await f$2(e5, t4.key));
    a3 = A$6(B$7(e5, t4.array, s3)), z$4(e5, t4.array, s3, a3 + n3);
  }
  return i4 ? a3 + n3 : a3;
}
async function tt$4(e5, t4) {
  return H$8(e5, t4, 1, true);
}
async function nt$3(e5, t4) {
  return H$8(e5, t4, -1, true);
}
async function rt$1(e5, t4) {
  return H$8(e5, t4, 1, false);
}
async function it$3(e5, t4) {
  return H$8(e5, t4, -1, false);
}
async function st$4(e5, t4, n3) {
  let i4;
  if (t4.type === "tuple") {
    let a3 = [];
    for (let s3 of t4.elements) a3.push(S$b(await f$2(e5, s3)));
    i4 = a3.join(e5.SUBSEP);
  } else i4 = S$b(await f$2(e5, t4));
  return pe$3(e5, n3, i4) ? 1 : 0;
}
async function at$3(e5, t4, n3, i4) {
  if (i4) return ot$2(e5, t4, i4);
  if (n3) return ct$1(e5, t4, n3);
  if (!e5.lines || e5.lineIndex === void 0) return -1;
  let a3 = e5.lineIndex + 1;
  if (a3 >= e5.lines.length) return 0;
  let s3 = e5.lines[a3];
  return t4 ? P$a(e5, t4, s3) : O$9(e5, s3), e5.NR++, e5.lineIndex = a3, 1;
}
async function ot$2(e5, t4, n3) {
  if (!e5.exec) return -1;
  let i4 = S$b(await f$2(e5, n3)), a3 = `__cmd_${i4}`, s3 = `__cmdi_${i4}`, o2, l3;
  if (e5.vars[a3] === void 0) try {
    o2 = (await e5.exec(i4)).stdout.split(`
`), o2.length > 0 && o2[o2.length - 1] === "" && o2.pop(), e5.vars[a3] = JSON.stringify(o2), e5.vars[s3] = -1, l3 = -1;
  } catch {
    return -1;
  }
  else o2 = JSON.parse(e5.vars[a3]), l3 = e5.vars[s3];
  let h3 = l3 + 1;
  if (h3 >= o2.length) return 0;
  let N2 = o2[h3];
  return e5.vars[s3] = h3, t4 ? P$a(e5, t4, N2) : O$9(e5, N2), 1;
}
async function ct$1(e5, t4, n3) {
  if (!e5.fs || !e5.cwd) return -1;
  let i4 = S$b(await f$2(e5, n3));
  if (i4 === "/dev/null") return 0;
  let a3 = e5.fs.resolvePath(e5.cwd, i4), s3 = `__fc_${a3}`, o2 = `__fi_${a3}`, l3, h3;
  if (e5.vars[s3] === void 0) try {
    l3 = (await e5.fs.readFile(a3)).split(`
`), l3.length > 0 && l3[l3.length - 1] === "" && l3.pop(), e5.vars[s3] = JSON.stringify(l3), e5.vars[o2] = -1, h3 = -1;
  } catch {
    return -1;
  }
  else l3 = JSON.parse(e5.vars[s3]), h3 = e5.vars[o2];
  let N2 = h3 + 1;
  if (N2 >= l3.length) return 0;
  let v2 = l3[N2];
  return e5.vars[o2] = N2, t4 ? P$a(e5, t4, v2) : O$9(e5, v2), 1;
}
async function lt$1(e5, t4) {
  if (t4.length === 0) return "";
  for (let n3 = 0; n3 < t4.length - 1; n3++) await f$2(e5, t4[n3]);
  return f$2(e5, t4[t4.length - 1]);
}
Ee$4(M$8);
async function M$8(e5, t4) {
  for (let n3 of t4) if (await b$c(e5, n3), ut$2(e5)) break;
}
function ut$2(e5) {
  return e5.shouldExit || e5.shouldNext || e5.shouldNextFile || e5.loopBreak || e5.loopContinue || e5.hasReturn;
}
async function b$c(e5, t4) {
  switch (t4.type) {
    case "block":
      await M$8(e5, t4.statements);
      break;
    case "expr_stmt":
      await f$2(e5, t4.expression);
      break;
    case "print":
      await ht$2(e5, t4.args, t4.output);
      break;
    case "printf":
      await pt(e5, t4.format, t4.args, t4.output);
      break;
    case "if":
      await ft$2(e5, t4);
      break;
    case "while":
      await dt$2(e5, t4);
      break;
    case "do_while":
      await Et$1(e5, t4);
      break;
    case "for":
      await Nt(e5, t4);
      break;
    case "for_in":
      await St$1(e5, t4);
      break;
    case "break":
      e5.loopBreak = true;
      break;
    case "continue":
      e5.loopContinue = true;
      break;
    case "next":
      e5.shouldNext = true;
      break;
    case "nextfile":
      e5.shouldNextFile = true;
      break;
    case "exit":
      e5.shouldExit = true, e5.exitCode = t4.code ? Math.floor(A$6(await f$2(e5, t4.code))) : 0;
      break;
    case "return":
      e5.hasReturn = true, e5.returnValue = t4.value ? await f$2(e5, t4.value) : "";
      break;
    case "delete":
      await yt$2(e5, t4.target);
      break;
  }
}
async function ht$2(e5, t4, n3) {
  let i4 = [];
  for (let s3 of t4) {
    let o2 = await f$2(e5, s3);
    typeof o2 == "number" ? Number.isInteger(o2) && Math.abs(o2) < Number.MAX_SAFE_INTEGER ? i4.push(String(o2)) : i4.push(D$8(e5.OFMT, [o2])) : i4.push(S$b(o2));
  }
  let a3 = i4.join(e5.OFS) + e5.ORS;
  n3 ? await Ne$2(e5, n3.redirect, n3.file, a3) : e5.output += a3;
}
async function pt(e5, t4, n3, i4) {
  let a3 = S$b(await f$2(e5, t4)), s3 = [];
  for (let l3 of n3) s3.push(await f$2(e5, l3));
  let o2 = D$8(a3, s3);
  i4 ? await Ne$2(e5, i4.redirect, i4.file, o2) : e5.output += o2;
}
async function Ne$2(e5, t4, n3, i4) {
  if (!e5.fs || !e5.cwd) {
    e5.output += i4;
    return;
  }
  let a3 = S$b(await f$2(e5, n3)), s3 = e5.fs.resolvePath(e5.cwd, a3);
  t4 === ">" ? e5.openedFiles.has(s3) ? await e5.fs.appendFile(s3, i4) : (await e5.fs.writeFile(s3, i4), e5.openedFiles.add(s3)) : (e5.openedFiles.has(s3) || e5.openedFiles.add(s3), await e5.fs.appendFile(s3, i4));
}
async function ft$2(e5, t4) {
  g$b(await f$2(e5, t4.condition)) ? await b$c(e5, t4.consequent) : t4.alternate && await b$c(e5, t4.alternate);
}
async function dt$2(e5, t4) {
  let n3 = 0;
  for (; g$b(await f$2(e5, t4.condition)); ) {
    if (n3++, n3 > e5.maxIterations) throw new b$i(`awk: while loop exceeded maximum iterations (${e5.maxIterations})`, "iterations", e5.output);
    if (e5.loopContinue = false, await b$c(e5, t4.body), e5.loopBreak) {
      e5.loopBreak = false;
      break;
    }
    if (e5.shouldExit || e5.shouldNext || e5.hasReturn) break;
  }
}
async function Et$1(e5, t4) {
  let n3 = 0;
  do {
    if (n3++, n3 > e5.maxIterations) throw new b$i(`awk: do-while loop exceeded maximum iterations (${e5.maxIterations})`, "iterations", e5.output);
    if (e5.loopContinue = false, await b$c(e5, t4.body), e5.loopBreak) {
      e5.loopBreak = false;
      break;
    }
    if (e5.shouldExit || e5.shouldNext || e5.hasReturn) break;
  } while (g$b(await f$2(e5, t4.condition)));
}
async function Nt(e5, t4) {
  t4.init && await f$2(e5, t4.init);
  let n3 = 0;
  for (; !t4.condition || g$b(await f$2(e5, t4.condition)); ) {
    if (n3++, n3 > e5.maxIterations) throw new b$i(`awk: for loop exceeded maximum iterations (${e5.maxIterations})`, "iterations", e5.output);
    if (e5.loopContinue = false, await b$c(e5, t4.body), e5.loopBreak) {
      e5.loopBreak = false;
      break;
    }
    if (e5.shouldExit || e5.shouldNext || e5.hasReturn) break;
    t4.update && await f$2(e5, t4.update);
  }
}
async function St$1(e5, t4) {
  let n3 = e5.arrays[t4.array];
  if (n3) for (let i4 of Object.keys(n3)) {
    if (e5.vars[t4.variable] = i4, e5.loopContinue = false, await b$c(e5, t4.body), e5.loopBreak) {
      e5.loopBreak = false;
      break;
    }
    if (e5.shouldExit || e5.shouldNext || e5.hasReturn) break;
  }
}
async function yt$2(e5, t4) {
  if (t4.type === "array_access") {
    let n3 = S$b(await f$2(e5, t4.key));
    fe$4(e5, t4.array, n3);
  } else t4.type === "variable" && de$3(e5, t4.name);
}
var _$7 = class _ {
  ctx;
  program = null;
  rangeStates = [];
  constructor(t4) {
    this.ctx = t4;
  }
  execute(t4) {
    this.program = t4, this.ctx.output = "";
    for (let n3 of t4.functions) this.ctx.functions.set(n3.name, n3);
    this.rangeStates = t4.rules.map(() => false);
  }
  async executeBegin() {
    if (this.program) {
      for (let t4 of this.program.rules) if (t4.pattern?.type === "begin" && (await M$8(this.ctx, t4.action.statements), this.ctx.shouldExit)) break;
    }
  }
  async executeLine(t4) {
    if (!(!this.program || this.ctx.shouldExit)) {
      O$9(this.ctx, t4), this.ctx.NR++, this.ctx.FNR++, this.ctx.shouldNext = false;
      for (let n3 = 0; n3 < this.program.rules.length && !(this.ctx.shouldExit || this.ctx.shouldNext || this.ctx.shouldNextFile); n3++) {
        let i4 = this.program.rules[n3];
        i4.pattern?.type === "begin" || i4.pattern?.type === "end" || await this.matchesRule(i4, n3) && await M$8(this.ctx, i4.action.statements);
      }
    }
  }
  async executeEnd() {
    if (this.program && !this.ctx.inEndBlock) {
      this.ctx.inEndBlock = true, this.ctx.shouldExit = false;
      for (let t4 of this.program.rules) if (t4.pattern?.type === "end" && (await M$8(this.ctx, t4.action.statements), this.ctx.shouldExit)) break;
      this.ctx.inEndBlock = false;
    }
  }
  getOutput() {
    return this.ctx.output;
  }
  getExitCode() {
    return this.ctx.exitCode;
  }
  getContext() {
    return this.ctx;
  }
  async matchesRule(t4, n3) {
    let i4 = t4.pattern;
    if (!i4) return true;
    switch (i4.type) {
      case "begin":
      case "end":
        return false;
      case "regex_pattern":
        return T$7(i4.pattern, this.ctx.line);
      case "expr_pattern":
        return g$b(await f$2(this.ctx, i4.expression));
      case "range": {
        let a3 = await this.matchPattern(i4.start), s3 = await this.matchPattern(i4.end);
        return this.rangeStates[n3] ? (s3 && (this.rangeStates[n3] = false), true) : a3 ? (this.rangeStates[n3] = true, s3 && (this.rangeStates[n3] = false), true) : false;
      }
      default:
        return false;
    }
  }
  async matchPattern(t4) {
    switch (t4.type) {
      case "regex_pattern":
        return T$7(t4.pattern, this.ctx.line);
      case "expr_pattern":
        return g$b(await f$2(this.ctx, t4.expression));
      default:
        return false;
    }
  }
};
var r$1;
(function(e5) {
  e5.NUMBER = "NUMBER", e5.STRING = "STRING", e5.REGEX = "REGEX", e5.IDENT = "IDENT", e5.BEGIN = "BEGIN", e5.END = "END", e5.IF = "IF", e5.ELSE = "ELSE", e5.WHILE = "WHILE", e5.DO = "DO", e5.FOR = "FOR", e5.IN = "IN", e5.BREAK = "BREAK", e5.CONTINUE = "CONTINUE", e5.NEXT = "NEXT", e5.NEXTFILE = "NEXTFILE", e5.EXIT = "EXIT", e5.RETURN = "RETURN", e5.DELETE = "DELETE", e5.FUNCTION = "FUNCTION", e5.PRINT = "PRINT", e5.PRINTF = "PRINTF", e5.GETLINE = "GETLINE", e5.PLUS = "PLUS", e5.MINUS = "MINUS", e5.STAR = "STAR", e5.SLASH = "SLASH", e5.PERCENT = "PERCENT", e5.CARET = "CARET", e5.EQ = "EQ", e5.NE = "NE", e5.LT = "LT", e5.GT = "GT", e5.LE = "LE", e5.GE = "GE", e5.MATCH = "MATCH", e5.NOT_MATCH = "NOT_MATCH", e5.AND = "AND", e5.OR = "OR", e5.NOT = "NOT", e5.ASSIGN = "ASSIGN", e5.PLUS_ASSIGN = "PLUS_ASSIGN", e5.MINUS_ASSIGN = "MINUS_ASSIGN", e5.STAR_ASSIGN = "STAR_ASSIGN", e5.SLASH_ASSIGN = "SLASH_ASSIGN", e5.PERCENT_ASSIGN = "PERCENT_ASSIGN", e5.CARET_ASSIGN = "CARET_ASSIGN", e5.INCREMENT = "INCREMENT", e5.DECREMENT = "DECREMENT", e5.QUESTION = "QUESTION", e5.COLON = "COLON", e5.COMMA = "COMMA", e5.SEMICOLON = "SEMICOLON", e5.NEWLINE = "NEWLINE", e5.LPAREN = "LPAREN", e5.RPAREN = "RPAREN", e5.LBRACE = "LBRACE", e5.RBRACE = "RBRACE", e5.LBRACKET = "LBRACKET", e5.RBRACKET = "RBRACKET", e5.DOLLAR = "DOLLAR", e5.APPEND = "APPEND", e5.PIPE = "PIPE", e5.EOF = "EOF";
})(r$1 || (r$1 = {}));
var Rt = { BEGIN: r$1.BEGIN, END: r$1.END, if: r$1.IF, else: r$1.ELSE, while: r$1.WHILE, do: r$1.DO, for: r$1.FOR, in: r$1.IN, break: r$1.BREAK, continue: r$1.CONTINUE, next: r$1.NEXT, nextfile: r$1.NEXTFILE, exit: r$1.EXIT, return: r$1.RETURN, delete: r$1.DELETE, function: r$1.FUNCTION, print: r$1.PRINT, printf: r$1.PRINTF, getline: r$1.GETLINE };
function At$2(e5) {
  return e5.replace(/\[\[:space:\]\]/g, "[ \\t\\n\\r\\f\\v]").replace(/\[\[:blank:\]\]/g, "[ \\t]").replace(/\[\[:alpha:\]\]/g, "[a-zA-Z]").replace(/\[\[:digit:\]\]/g, "[0-9]").replace(/\[\[:alnum:\]\]/g, "[a-zA-Z0-9]").replace(/\[\[:upper:\]\]/g, "[A-Z]").replace(/\[\[:lower:\]\]/g, "[a-z]").replace(/\[\[:punct:\]\]/g, "[!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~]").replace(/\[\[:xdigit:\]\]/g, "[0-9A-Fa-f]").replace(/\[\[:graph:\]\]/g, "[!-~]").replace(/\[\[:print:\]\]/g, "[ -~]").replace(/\[\[:cntrl:\]\]/g, "[\\x00-\\x1f\\x7f]");
}
var $$5 = class $3 {
  input;
  pos = 0;
  line = 1;
  column = 1;
  lastTokenType = null;
  constructor(t4) {
    this.input = t4;
  }
  tokenize() {
    let t4 = [];
    for (; this.pos < this.input.length; ) {
      let n3 = this.nextToken();
      n3 && (t4.push(n3), this.lastTokenType = n3.type);
    }
    return t4.push(this.makeToken(r$1.EOF, "")), t4;
  }
  makeToken(t4, n3) {
    return { type: t4, value: n3, line: this.line, column: this.column };
  }
  peek(t4 = 0) {
    return this.input[this.pos + t4] || "";
  }
  advance() {
    let t4 = this.input[this.pos++] || "";
    return t4 === `
` ? (this.line++, this.column = 1) : this.column++, t4;
  }
  skipWhitespace() {
    for (; this.pos < this.input.length; ) {
      let t4 = this.peek();
      if (t4 === " " || t4 === "	" || t4 === "\r") this.advance();
      else if (t4 === "\\") if (this.peek(1) === `
`) this.advance(), this.advance();
      else break;
      else if (t4 === "#") for (; this.pos < this.input.length && this.peek() !== `
`; ) this.advance();
      else break;
    }
  }
  nextToken() {
    if (this.skipWhitespace(), this.pos >= this.input.length) return null;
    let t4 = this.line, n3 = this.column, i4 = this.peek();
    return i4 === `
` ? (this.advance(), { type: r$1.NEWLINE, value: `
`, line: t4, column: n3 }) : i4 === '"' ? this.readString() : i4 === "/" && this.canBeRegex() ? this.readRegex() : this.isDigit(i4) || i4 === "." && this.isDigit(this.peek(1)) ? this.readNumber() : this.isAlpha(i4) || i4 === "_" ? this.readIdentifier() : this.readOperator();
  }
  canBeRegex() {
    return (/* @__PURE__ */ new Set([null, r$1.NEWLINE, r$1.SEMICOLON, r$1.LBRACE, r$1.RBRACE, r$1.LPAREN, r$1.LBRACKET, r$1.COMMA, r$1.ASSIGN, r$1.PLUS_ASSIGN, r$1.MINUS_ASSIGN, r$1.STAR_ASSIGN, r$1.SLASH_ASSIGN, r$1.PERCENT_ASSIGN, r$1.CARET_ASSIGN, r$1.AND, r$1.OR, r$1.NOT, r$1.MATCH, r$1.NOT_MATCH, r$1.QUESTION, r$1.COLON, r$1.LT, r$1.GT, r$1.LE, r$1.GE, r$1.EQ, r$1.NE, r$1.PLUS, r$1.MINUS, r$1.STAR, r$1.PERCENT, r$1.CARET, r$1.PRINT, r$1.PRINTF, r$1.IF, r$1.WHILE, r$1.DO, r$1.FOR, r$1.RETURN])).has(this.lastTokenType);
  }
  readString() {
    let t4 = this.line, n3 = this.column;
    this.advance();
    let i4 = "";
    for (; this.pos < this.input.length && this.peek() !== '"'; ) if (this.peek() === "\\") {
      this.advance();
      let a3 = this.advance();
      switch (a3) {
        case "n":
          i4 += `
`;
          break;
        case "t":
          i4 += "	";
          break;
        case "r":
          i4 += "\r";
          break;
        case "f":
          i4 += "\f";
          break;
        case "b":
          i4 += "\b";
          break;
        case "v":
          i4 += "\v";
          break;
        case "a":
          i4 += "\x07";
          break;
        case "\\":
          i4 += "\\";
          break;
        case '"':
          i4 += '"';
          break;
        case "/":
          i4 += "/";
          break;
        case "x": {
          let s3 = "";
          for (; s3.length < 2 && /[0-9a-fA-F]/.test(this.peek()); ) s3 += this.advance();
          s3.length > 0 ? i4 += String.fromCharCode(parseInt(s3, 16)) : i4 += "x";
          break;
        }
        default:
          if (/[0-7]/.test(a3)) {
            let s3 = a3;
            for (; s3.length < 3 && /[0-7]/.test(this.peek()); ) s3 += this.advance();
            i4 += String.fromCharCode(parseInt(s3, 8));
          } else i4 += a3;
      }
    } else i4 += this.advance();
    return this.peek() === '"' && this.advance(), { type: r$1.STRING, value: i4, line: t4, column: n3 };
  }
  readRegex() {
    let t4 = this.line, n3 = this.column;
    this.advance();
    let i4 = "";
    for (; this.pos < this.input.length && this.peek() !== "/"; ) if (this.peek() === "\\") i4 += this.advance(), this.pos < this.input.length && (i4 += this.advance());
    else {
      if (this.peek() === `
`) break;
      i4 += this.advance();
    }
    return this.peek() === "/" && this.advance(), i4 = At$2(i4), { type: r$1.REGEX, value: i4, line: t4, column: n3 };
  }
  readNumber() {
    let t4 = this.line, n3 = this.column, i4 = "";
    for (; this.isDigit(this.peek()); ) i4 += this.advance();
    if (this.peek() === "." && this.isDigit(this.peek(1))) for (i4 += this.advance(); this.isDigit(this.peek()); ) i4 += this.advance();
    if (this.peek() === "e" || this.peek() === "E") for (i4 += this.advance(), (this.peek() === "+" || this.peek() === "-") && (i4 += this.advance()); this.isDigit(this.peek()); ) i4 += this.advance();
    return { type: r$1.NUMBER, value: parseFloat(i4), line: t4, column: n3 };
  }
  readIdentifier() {
    let t4 = this.line, n3 = this.column, i4 = "";
    for (; this.isAlphaNumeric(this.peek()) || this.peek() === "_"; ) i4 += this.advance();
    let a3 = Rt[i4];
    return a3 ? { type: a3, value: i4, line: t4, column: n3 } : { type: r$1.IDENT, value: i4, line: t4, column: n3 };
  }
  readOperator() {
    let t4 = this.line, n3 = this.column, i4 = this.advance(), a3 = this.peek();
    switch (i4) {
      case "+":
        return a3 === "+" ? (this.advance(), { type: r$1.INCREMENT, value: "++", line: t4, column: n3 }) : a3 === "=" ? (this.advance(), { type: r$1.PLUS_ASSIGN, value: "+=", line: t4, column: n3 }) : { type: r$1.PLUS, value: "+", line: t4, column: n3 };
      case "-":
        return a3 === "-" ? (this.advance(), { type: r$1.DECREMENT, value: "--", line: t4, column: n3 }) : a3 === "=" ? (this.advance(), { type: r$1.MINUS_ASSIGN, value: "-=", line: t4, column: n3 }) : { type: r$1.MINUS, value: "-", line: t4, column: n3 };
      case "*":
        return a3 === "*" ? (this.advance(), { type: r$1.CARET, value: "**", line: t4, column: n3 }) : a3 === "=" ? (this.advance(), { type: r$1.STAR_ASSIGN, value: "*=", line: t4, column: n3 }) : { type: r$1.STAR, value: "*", line: t4, column: n3 };
      case "/":
        return a3 === "=" ? (this.advance(), { type: r$1.SLASH_ASSIGN, value: "/=", line: t4, column: n3 }) : { type: r$1.SLASH, value: "/", line: t4, column: n3 };
      case "%":
        return a3 === "=" ? (this.advance(), { type: r$1.PERCENT_ASSIGN, value: "%=", line: t4, column: n3 }) : { type: r$1.PERCENT, value: "%", line: t4, column: n3 };
      case "^":
        return a3 === "=" ? (this.advance(), { type: r$1.CARET_ASSIGN, value: "^=", line: t4, column: n3 }) : { type: r$1.CARET, value: "^", line: t4, column: n3 };
      case "=":
        return a3 === "=" ? (this.advance(), { type: r$1.EQ, value: "==", line: t4, column: n3 }) : { type: r$1.ASSIGN, value: "=", line: t4, column: n3 };
      case "!":
        return a3 === "=" ? (this.advance(), { type: r$1.NE, value: "!=", line: t4, column: n3 }) : a3 === "~" ? (this.advance(), { type: r$1.NOT_MATCH, value: "!~", line: t4, column: n3 }) : { type: r$1.NOT, value: "!", line: t4, column: n3 };
      case "<":
        return a3 === "=" ? (this.advance(), { type: r$1.LE, value: "<=", line: t4, column: n3 }) : { type: r$1.LT, value: "<", line: t4, column: n3 };
      case ">":
        return a3 === "=" ? (this.advance(), { type: r$1.GE, value: ">=", line: t4, column: n3 }) : a3 === ">" ? (this.advance(), { type: r$1.APPEND, value: ">>", line: t4, column: n3 }) : { type: r$1.GT, value: ">", line: t4, column: n3 };
      case "&":
        return a3 === "&" ? (this.advance(), { type: r$1.AND, value: "&&", line: t4, column: n3 }) : { type: r$1.IDENT, value: "&", line: t4, column: n3 };
      case "|":
        return a3 === "|" ? (this.advance(), { type: r$1.OR, value: "||", line: t4, column: n3 }) : { type: r$1.PIPE, value: "|", line: t4, column: n3 };
      case "~":
        return { type: r$1.MATCH, value: "~", line: t4, column: n3 };
      case "?":
        return { type: r$1.QUESTION, value: "?", line: t4, column: n3 };
      case ":":
        return { type: r$1.COLON, value: ":", line: t4, column: n3 };
      case ",":
        return { type: r$1.COMMA, value: ",", line: t4, column: n3 };
      case ";":
        return { type: r$1.SEMICOLON, value: ";", line: t4, column: n3 };
      case "(":
        return { type: r$1.LPAREN, value: "(", line: t4, column: n3 };
      case ")":
        return { type: r$1.RPAREN, value: ")", line: t4, column: n3 };
      case "{":
        return { type: r$1.LBRACE, value: "{", line: t4, column: n3 };
      case "}":
        return { type: r$1.RBRACE, value: "}", line: t4, column: n3 };
      case "[":
        return { type: r$1.LBRACKET, value: "[", line: t4, column: n3 };
      case "]":
        return { type: r$1.RBRACKET, value: "]", line: t4, column: n3 };
      case "$":
        return { type: r$1.DOLLAR, value: "$", line: t4, column: n3 };
      default:
        return { type: r$1.IDENT, value: i4, line: t4, column: n3 };
    }
  }
  isDigit(t4) {
    return t4 >= "0" && t4 <= "9";
  }
  isAlpha(t4) {
    return t4 >= "a" && t4 <= "z" || t4 >= "A" && t4 <= "Z";
  }
  isAlphaNumeric(t4) {
    return this.isDigit(t4) || this.isAlpha(t4);
  }
};
var u$6 = { LPAREN: "LPAREN", RPAREN: "RPAREN", QUESTION: "QUESTION", NEWLINE: "NEWLINE", SEMICOLON: "SEMICOLON", RBRACE: "RBRACE", COMMA: "COMMA", PIPE: "PIPE", GT: "GT", APPEND: "APPEND", AND: "AND", OR: "OR", ASSIGN: "ASSIGN", PLUS_ASSIGN: "PLUS_ASSIGN", MINUS_ASSIGN: "MINUS_ASSIGN", STAR_ASSIGN: "STAR_ASSIGN", SLASH_ASSIGN: "SLASH_ASSIGN", PERCENT_ASSIGN: "PERCENT_ASSIGN", CARET_ASSIGN: "CARET_ASSIGN", RBRACKET: "RBRACKET", COLON: "COLON", IN: "IN", PRINT: "PRINT", PRINTF: "PRINTF", IDENT: "IDENT", LT: "LT", LE: "LE", GE: "GE", EQ: "EQ", NE: "NE", MATCH: "MATCH", NOT_MATCH: "NOT_MATCH", NUMBER: "NUMBER", STRING: "STRING", DOLLAR: "DOLLAR", NOT: "NOT", MINUS: "MINUS", PLUS: "PLUS", INCREMENT: "INCREMENT", DECREMENT: "DECREMENT" };
function Ie$4(e5) {
  e5.expect(u$6.PRINT);
  let t4 = [];
  if (e5.check(u$6.NEWLINE) || e5.check(u$6.SEMICOLON) || e5.check(u$6.RBRACE) || e5.check(u$6.PIPE) || e5.check(u$6.GT) || e5.check(u$6.APPEND)) t4.push({ type: "field", index: { type: "number", value: 0 } });
  else for (t4.push(W$8(e5)); e5.check(u$6.COMMA); ) e5.advance(), t4.push(W$8(e5));
  let n3;
  return e5.check(u$6.GT) ? (e5.advance(), n3 = { redirect: ">", file: e5.parsePrimary() }) : e5.check(u$6.APPEND) && (e5.advance(), n3 = { redirect: ">>", file: e5.parsePrimary() }), { type: "print", args: t4, output: n3 };
}
function W$8(e5) {
  return It(e5) ? Z$3(e5, true) : Z$3(e5, false);
}
function Z$3(e5, t4) {
  let n3 = t4 ? e5.parseTernary() : wt$3(e5);
  if (e5.match(u$6.ASSIGN, u$6.PLUS_ASSIGN, u$6.MINUS_ASSIGN, u$6.STAR_ASSIGN, u$6.SLASH_ASSIGN, u$6.PERCENT_ASSIGN, u$6.CARET_ASSIGN)) {
    let i4 = e5.advance(), a3 = Z$3(e5, t4);
    if (n3.type !== "variable" && n3.type !== "field" && n3.type !== "array_access") throw new Error("Invalid assignment target");
    return { type: "assignment", operator: { "=": "=", "+=": "+=", "-=": "-=", "*=": "*=", "/=": "/=", "%=": "%=", "^=": "^=" }[i4.value], target: n3, value: a3 };
  }
  return n3;
}
function It(e5) {
  let t4 = 0, n3 = e5.pos;
  for (; n3 < e5.tokens.length; ) {
    let i4 = e5.tokens[n3];
    if (i4.type === u$6.LPAREN && t4++, i4.type === u$6.RPAREN && t4--, i4.type === u$6.QUESTION && t4 === 0) return true;
    if (i4.type === u$6.NEWLINE || i4.type === u$6.SEMICOLON || i4.type === u$6.RBRACE || i4.type === u$6.COMMA || i4.type === u$6.PIPE) return false;
    n3++;
  }
  return false;
}
function wt$3(e5) {
  let t4 = Se$4(e5);
  for (; e5.check(u$6.OR); ) {
    e5.advance();
    let n3 = Se$4(e5);
    t4 = { type: "binary", operator: "||", left: t4, right: n3 };
  }
  return t4;
}
function Se$4(e5) {
  let t4 = ye$3(e5);
  for (; e5.check(u$6.AND); ) {
    e5.advance();
    let n3 = ye$3(e5);
    t4 = { type: "binary", operator: "&&", left: t4, right: n3 };
  }
  return t4;
}
function ye$3(e5) {
  let t4 = mt$1(e5);
  if (e5.check(u$6.IN)) {
    e5.advance();
    let n3 = String(e5.expect(u$6.IDENT).value);
    return { type: "in", key: t4, array: n3 };
  }
  return t4;
}
function mt$1(e5) {
  let t4 = Re$1(e5);
  for (; vt$1(e5) && !gt$2(e5); ) {
    let n3 = Re$1(e5);
    t4 = { type: "binary", operator: " ", left: t4, right: n3 };
  }
  return t4;
}
function Re$1(e5) {
  let t4 = Ae$2(e5);
  for (; e5.match(u$6.MATCH, u$6.NOT_MATCH); ) {
    let n3 = e5.advance().type === u$6.MATCH ? "~" : "!~", i4 = Ae$2(e5);
    t4 = { type: "binary", operator: n3, left: t4, right: i4 };
  }
  return t4;
}
function Ae$2(e5) {
  let t4 = e5.parseAddSub();
  for (; e5.match(u$6.LT, u$6.LE, u$6.GE, u$6.EQ, u$6.NE); ) {
    let n3 = e5.advance(), i4 = e5.parseAddSub();
    t4 = { type: "binary", operator: { "<": "<", "<=": "<=", ">=": ">=", "==": "==", "!=": "!=" }[n3.value], left: t4, right: i4 };
  }
  return t4;
}
function vt$1(e5) {
  return e5.match(u$6.NUMBER, u$6.STRING, u$6.IDENT, u$6.DOLLAR, u$6.LPAREN, u$6.NOT, u$6.MINUS, u$6.PLUS, u$6.INCREMENT, u$6.DECREMENT);
}
function gt$2(e5) {
  return e5.match(u$6.AND, u$6.OR, u$6.QUESTION, u$6.ASSIGN, u$6.PLUS_ASSIGN, u$6.MINUS_ASSIGN, u$6.STAR_ASSIGN, u$6.SLASH_ASSIGN, u$6.PERCENT_ASSIGN, u$6.CARET_ASSIGN, u$6.COMMA, u$6.SEMICOLON, u$6.NEWLINE, u$6.RBRACE, u$6.RPAREN, u$6.RBRACKET, u$6.COLON, u$6.PIPE, u$6.APPEND, u$6.GT, u$6.IN);
}
function we$4(e5) {
  e5.expect(u$6.PRINTF);
  let t4 = e5.check(u$6.LPAREN);
  t4 && (e5.advance(), e5.skipNewlines());
  let n3 = t4 ? e5.parseExpression() : W$8(e5), i4 = [];
  for (; e5.check(u$6.COMMA); ) e5.advance(), t4 && e5.skipNewlines(), i4.push(t4 ? e5.parseExpression() : W$8(e5));
  t4 && (e5.skipNewlines(), e5.expect(u$6.RPAREN));
  let a3;
  return e5.check(u$6.GT) ? (e5.advance(), a3 = { redirect: ">", file: e5.parsePrimary() }) : e5.check(u$6.APPEND) && (e5.advance(), a3 = { redirect: ">>", file: e5.parsePrimary() }), { type: "printf", format: n3, args: i4, output: a3 };
}
var V$8 = class V {
  tokens = [];
  pos = 0;
  parse(t4) {
    let n3 = new $$5(t4);
    return this.tokens = n3.tokenize(), this.pos = 0, this.parseProgram();
  }
  setPos(t4) {
    this.pos = t4;
  }
  current() {
    return this.tokens[this.pos] || { type: r$1.EOF, value: "", line: 0, column: 0 };
  }
  advance() {
    let t4 = this.current();
    return this.pos < this.tokens.length && this.pos++, t4;
  }
  match(...t4) {
    return t4.includes(this.current().type);
  }
  check(t4) {
    return this.current().type === t4;
  }
  expect(t4, n3) {
    if (!this.check(t4)) {
      let i4 = this.current();
      throw new Error(n3 || `Expected ${t4}, got ${i4.type} at line ${i4.line}:${i4.column}`);
    }
    return this.advance();
  }
  skipNewlines() {
    for (; this.check(r$1.NEWLINE); ) this.advance();
  }
  skipTerminators() {
    for (; this.check(r$1.NEWLINE) || this.check(r$1.SEMICOLON); ) this.advance();
  }
  parseProgram() {
    let t4 = [], n3 = [];
    for (this.skipNewlines(); !this.check(r$1.EOF) && (this.skipNewlines(), !this.check(r$1.EOF)); ) this.check(r$1.FUNCTION) ? t4.push(this.parseFunction()) : n3.push(this.parseRule()), this.skipTerminators();
    return { functions: t4, rules: n3 };
  }
  parseFunction() {
    this.expect(r$1.FUNCTION);
    let t4 = this.expect(r$1.IDENT).value;
    this.expect(r$1.LPAREN);
    let n3 = [];
    if (!this.check(r$1.RPAREN)) for (n3.push(this.expect(r$1.IDENT).value); this.check(r$1.COMMA); ) this.advance(), n3.push(this.expect(r$1.IDENT).value);
    this.expect(r$1.RPAREN), this.skipNewlines();
    let i4 = this.parseBlock();
    return { name: t4, params: n3, body: i4 };
  }
  parseRule() {
    let t4;
    if (this.check(r$1.BEGIN)) this.advance(), t4 = { type: "begin" };
    else if (this.check(r$1.END)) this.advance(), t4 = { type: "end" };
    else if (this.check(r$1.LBRACE)) t4 = void 0;
    else if (this.check(r$1.REGEX)) {
      let i4 = this.advance();
      if (this.check(r$1.AND) || this.check(r$1.OR)) {
        let a3 = { type: "binary", operator: "~", left: { type: "field", index: { type: "number", value: 0 } }, right: { type: "regex", pattern: i4.value } };
        t4 = { type: "expr_pattern", expression: this.parseLogicalOrRest(a3) };
      } else {
        let a3 = { type: "regex_pattern", pattern: i4.value };
        if (this.check(r$1.COMMA)) {
          this.advance();
          let s3;
          this.check(r$1.REGEX) ? s3 = { type: "regex_pattern", pattern: this.advance().value } : s3 = { type: "expr_pattern", expression: this.parseExpression() }, t4 = { type: "range", start: a3, end: s3 };
        } else t4 = a3;
      }
    } else {
      let a3 = { type: "expr_pattern", expression: this.parseExpression() };
      if (this.check(r$1.COMMA)) {
        this.advance();
        let s3;
        this.check(r$1.REGEX) ? s3 = { type: "regex_pattern", pattern: this.advance().value } : s3 = { type: "expr_pattern", expression: this.parseExpression() }, t4 = { type: "range", start: a3, end: s3 };
      } else t4 = a3;
    }
    this.skipNewlines();
    let n3;
    return this.check(r$1.LBRACE) ? n3 = this.parseBlock() : n3 = { type: "block", statements: [{ type: "print", args: [{ type: "field", index: { type: "number", value: 0 } }] }] }, { pattern: t4, action: n3 };
  }
  parseBlock() {
    this.expect(r$1.LBRACE), this.skipNewlines();
    let t4 = [];
    for (; !this.check(r$1.RBRACE) && !this.check(r$1.EOF); ) t4.push(this.parseStatement()), this.skipTerminators();
    return this.expect(r$1.RBRACE), { type: "block", statements: t4 };
  }
  parseStatement() {
    if (this.check(r$1.SEMICOLON) || this.check(r$1.NEWLINE)) return this.advance(), { type: "block", statements: [] };
    if (this.check(r$1.LBRACE)) return this.parseBlock();
    if (this.check(r$1.IF)) return this.parseIf();
    if (this.check(r$1.WHILE)) return this.parseWhile();
    if (this.check(r$1.DO)) return this.parseDoWhile();
    if (this.check(r$1.FOR)) return this.parseFor();
    if (this.check(r$1.BREAK)) return this.advance(), { type: "break" };
    if (this.check(r$1.CONTINUE)) return this.advance(), { type: "continue" };
    if (this.check(r$1.NEXT)) return this.advance(), { type: "next" };
    if (this.check(r$1.NEXTFILE)) return this.advance(), { type: "nextfile" };
    if (this.check(r$1.EXIT)) {
      this.advance();
      let n3;
      return !this.check(r$1.NEWLINE) && !this.check(r$1.SEMICOLON) && !this.check(r$1.RBRACE) && !this.check(r$1.EOF) && (n3 = this.parseExpression()), { type: "exit", code: n3 };
    }
    if (this.check(r$1.RETURN)) {
      this.advance();
      let n3;
      return !this.check(r$1.NEWLINE) && !this.check(r$1.SEMICOLON) && !this.check(r$1.RBRACE) && !this.check(r$1.EOF) && (n3 = this.parseExpression()), { type: "return", value: n3 };
    }
    if (this.check(r$1.DELETE)) {
      this.advance();
      let n3 = this.parsePrimary();
      if (n3.type !== "array_access" && n3.type !== "variable") throw new Error("delete requires array element or array");
      return { type: "delete", target: n3 };
    }
    return this.check(r$1.PRINT) ? Ie$4(this) : this.check(r$1.PRINTF) ? we$4(this) : { type: "expr_stmt", expression: this.parseExpression() };
  }
  parseIf() {
    this.expect(r$1.IF), this.expect(r$1.LPAREN);
    let t4 = this.parseExpression();
    this.expect(r$1.RPAREN), this.skipNewlines();
    let n3 = this.parseStatement();
    this.skipTerminators();
    let i4;
    return this.check(r$1.ELSE) && (this.advance(), this.skipNewlines(), i4 = this.parseStatement()), { type: "if", condition: t4, consequent: n3, alternate: i4 };
  }
  parseWhile() {
    this.expect(r$1.WHILE), this.expect(r$1.LPAREN);
    let t4 = this.parseExpression();
    this.expect(r$1.RPAREN), this.skipNewlines();
    let n3 = this.parseStatement();
    return { type: "while", condition: t4, body: n3 };
  }
  parseDoWhile() {
    this.expect(r$1.DO), this.skipNewlines();
    let t4 = this.parseStatement();
    this.skipNewlines(), this.expect(r$1.WHILE), this.expect(r$1.LPAREN);
    let n3 = this.parseExpression();
    return this.expect(r$1.RPAREN), { type: "do_while", body: t4, condition: n3 };
  }
  parseFor() {
    if (this.expect(r$1.FOR), this.expect(r$1.LPAREN), this.check(r$1.IDENT)) {
      let s3 = this.advance();
      if (this.check(r$1.IN)) {
        this.advance();
        let o2 = this.expect(r$1.IDENT).value;
        this.expect(r$1.RPAREN), this.skipNewlines();
        let l3 = this.parseStatement();
        return { type: "for_in", variable: s3.value, array: o2, body: l3 };
      }
      this.pos--;
    }
    let t4;
    this.check(r$1.SEMICOLON) || (t4 = this.parseExpression()), this.expect(r$1.SEMICOLON);
    let n3;
    this.check(r$1.SEMICOLON) || (n3 = this.parseExpression()), this.expect(r$1.SEMICOLON);
    let i4;
    this.check(r$1.RPAREN) || (i4 = this.parseExpression()), this.expect(r$1.RPAREN), this.skipNewlines();
    let a3 = this.parseStatement();
    return { type: "for", init: t4, condition: n3, update: i4, body: a3 };
  }
  parseExpression() {
    return this.parseAssignment();
  }
  parseAssignment() {
    let t4 = this.parseTernary();
    if (this.match(r$1.ASSIGN, r$1.PLUS_ASSIGN, r$1.MINUS_ASSIGN, r$1.STAR_ASSIGN, r$1.SLASH_ASSIGN, r$1.PERCENT_ASSIGN, r$1.CARET_ASSIGN)) {
      let n3 = this.advance(), i4 = this.parseAssignment();
      if (t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access") throw new Error("Invalid assignment target");
      return { type: "assignment", operator: { "=": "=", "+=": "+=", "-=": "-=", "*=": "*=", "/=": "/=", "%=": "%=", "^=": "^=" }[n3.value], target: t4, value: i4 };
    }
    return t4;
  }
  parseTernary() {
    let t4 = this.parsePipeGetline();
    if (this.check(r$1.QUESTION)) {
      this.advance();
      let n3 = this.parseExpression();
      this.expect(r$1.COLON);
      let i4 = this.parseExpression();
      t4 = { type: "ternary", condition: t4, consequent: n3, alternate: i4 };
    }
    return t4;
  }
  parsePipeGetline() {
    let t4 = this.parseOr();
    if (this.check(r$1.PIPE)) {
      if (this.advance(), !this.check(r$1.GETLINE)) throw new Error("Expected 'getline' after '|' in expression context");
      this.advance();
      let n3;
      return this.check(r$1.IDENT) && (n3 = this.advance().value), { type: "getline", command: t4, variable: n3 };
    }
    return t4;
  }
  parseOr() {
    let t4 = this.parseAnd();
    for (; this.check(r$1.OR); ) {
      this.advance();
      let n3 = this.parseAnd();
      t4 = { type: "binary", operator: "||", left: t4, right: n3 };
    }
    return t4;
  }
  parseLogicalOrRest(t4) {
    for (t4 = this.parseLogicalAndRest(t4); this.check(r$1.OR); ) {
      this.advance();
      let n3 = this.parseAnd();
      t4 = { type: "binary", operator: "||", left: t4, right: n3 };
    }
    return t4;
  }
  parseLogicalAndRest(t4) {
    for (; this.check(r$1.AND); ) {
      this.advance();
      let n3 = this.parseIn();
      t4 = { type: "binary", operator: "&&", left: t4, right: n3 };
    }
    return t4;
  }
  parseAnd() {
    let t4 = this.parseIn();
    for (; this.check(r$1.AND); ) {
      this.advance();
      let n3 = this.parseIn();
      t4 = { type: "binary", operator: "&&", left: t4, right: n3 };
    }
    return t4;
  }
  parseIn() {
    let t4 = this.parseConcatenation();
    if (this.check(r$1.IN)) {
      this.advance();
      let n3 = this.expect(r$1.IDENT).value;
      return { type: "in", key: t4, array: n3 };
    }
    return t4;
  }
  parseConcatenation() {
    let t4 = this.parseMatch();
    for (; this.canStartExpression() && !this.isConcatTerminator(); ) {
      let n3 = this.parseMatch();
      t4 = { type: "binary", operator: " ", left: t4, right: n3 };
    }
    return t4;
  }
  parseMatch() {
    let t4 = this.parseComparison();
    for (; this.match(r$1.MATCH, r$1.NOT_MATCH); ) {
      let n3 = this.advance().type === r$1.MATCH ? "~" : "!~", i4 = this.parseComparison();
      t4 = { type: "binary", operator: n3, left: t4, right: i4 };
    }
    return t4;
  }
  parseComparison() {
    let t4 = this.parseAddSub();
    for (; this.match(r$1.LT, r$1.LE, r$1.GT, r$1.GE, r$1.EQ, r$1.NE); ) {
      let n3 = this.advance(), i4 = this.parseAddSub();
      t4 = { type: "binary", operator: { "<": "<", "<=": "<=", ">": ">", ">=": ">=", "==": "==", "!=": "!=" }[n3.value], left: t4, right: i4 };
    }
    return t4;
  }
  canStartExpression() {
    return this.match(r$1.NUMBER, r$1.STRING, r$1.IDENT, r$1.DOLLAR, r$1.LPAREN, r$1.NOT, r$1.MINUS, r$1.PLUS, r$1.INCREMENT, r$1.DECREMENT);
  }
  isConcatTerminator() {
    return this.match(r$1.AND, r$1.OR, r$1.QUESTION, r$1.ASSIGN, r$1.PLUS_ASSIGN, r$1.MINUS_ASSIGN, r$1.STAR_ASSIGN, r$1.SLASH_ASSIGN, r$1.PERCENT_ASSIGN, r$1.CARET_ASSIGN, r$1.COMMA, r$1.SEMICOLON, r$1.NEWLINE, r$1.RBRACE, r$1.RPAREN, r$1.RBRACKET, r$1.COLON, r$1.PIPE, r$1.APPEND, r$1.IN);
  }
  parseAddSub() {
    let t4 = this.parseMulDiv();
    for (; this.match(r$1.PLUS, r$1.MINUS); ) {
      let n3 = this.advance().value, i4 = this.parseMulDiv();
      t4 = { type: "binary", operator: n3, left: t4, right: i4 };
    }
    return t4;
  }
  parseMulDiv() {
    let t4 = this.parseUnary();
    for (; this.match(r$1.STAR, r$1.SLASH, r$1.PERCENT); ) {
      let n3 = this.advance(), i4 = this.parseUnary();
      t4 = { type: "binary", operator: { "*": "*", "/": "/", "%": "%" }[n3.value], left: t4, right: i4 };
    }
    return t4;
  }
  parseUnary() {
    if (this.check(r$1.INCREMENT)) {
      this.advance();
      let t4 = this.parseUnary();
      return t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t4 } } : { type: "pre_increment", operand: t4 };
    }
    if (this.check(r$1.DECREMENT)) {
      this.advance();
      let t4 = this.parseUnary();
      return t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t4 } } : { type: "pre_decrement", operand: t4 };
    }
    if (this.match(r$1.NOT, r$1.MINUS, r$1.PLUS)) {
      let t4 = this.advance().value, n3 = this.parseUnary();
      return { type: "unary", operator: t4, operand: n3 };
    }
    return this.parsePower();
  }
  parsePower() {
    let t4 = this.parsePostfix();
    if (this.check(r$1.CARET)) {
      this.advance();
      let n3 = this.parsePower();
      t4 = { type: "binary", operator: "^", left: t4, right: n3 };
    }
    return t4;
  }
  parsePostfix() {
    let t4 = this.parsePrimary();
    if (this.check(r$1.INCREMENT)) {
      if (this.advance(), t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access") throw new Error("Invalid increment operand");
      return { type: "post_increment", operand: t4 };
    }
    if (this.check(r$1.DECREMENT)) {
      if (this.advance(), t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access") throw new Error("Invalid decrement operand");
      return { type: "post_decrement", operand: t4 };
    }
    return t4;
  }
  parseFieldIndex() {
    if (this.check(r$1.INCREMENT)) {
      this.advance();
      let t4 = this.parseFieldIndex();
      return t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access" ? { type: "unary", operator: "+", operand: { type: "unary", operator: "+", operand: t4 } } : { type: "pre_increment", operand: t4 };
    }
    if (this.check(r$1.DECREMENT)) {
      this.advance();
      let t4 = this.parseFieldIndex();
      return t4.type !== "variable" && t4.type !== "field" && t4.type !== "array_access" ? { type: "unary", operator: "-", operand: { type: "unary", operator: "-", operand: t4 } } : { type: "pre_decrement", operand: t4 };
    }
    if (this.match(r$1.NOT, r$1.MINUS, r$1.PLUS)) {
      let t4 = this.advance().value, n3 = this.parseFieldIndex();
      return { type: "unary", operator: t4, operand: n3 };
    }
    return this.parseFieldIndexPower();
  }
  parseFieldIndexPower() {
    let t4 = this.parseFieldIndexPrimary();
    if (this.check(r$1.CARET)) {
      this.advance();
      let n3 = this.parseFieldIndexPower();
      t4 = { type: "binary", operator: "^", left: t4, right: n3 };
    }
    return t4;
  }
  parseFieldIndexPrimary() {
    if (this.check(r$1.NUMBER)) return { type: "number", value: this.advance().value };
    if (this.check(r$1.STRING)) return { type: "string", value: this.advance().value };
    if (this.check(r$1.DOLLAR)) return this.advance(), { type: "field", index: this.parseFieldIndex() };
    if (this.check(r$1.LPAREN)) {
      this.advance();
      let t4 = this.parseExpression();
      return this.expect(r$1.RPAREN), t4;
    }
    if (this.check(r$1.IDENT)) {
      let t4 = this.advance().value;
      if (this.check(r$1.LPAREN)) {
        this.advance();
        let n3 = [];
        if (!this.check(r$1.RPAREN)) for (n3.push(this.parseExpression()); this.check(r$1.COMMA); ) this.advance(), n3.push(this.parseExpression());
        return this.expect(r$1.RPAREN), { type: "call", name: t4, args: n3 };
      }
      if (this.check(r$1.LBRACKET)) {
        this.advance();
        let n3 = this.parseExpression();
        if (this.check(r$1.COMMA)) {
          let i4 = [n3];
          for (; this.check(r$1.COMMA); ) this.advance(), i4.push(this.parseExpression());
          this.expect(r$1.RBRACKET);
          let a3 = i4.reduce((s3, o2) => ({ type: "binary", operator: " ", left: { type: "binary", operator: " ", left: s3, right: { type: "variable", name: "SUBSEP" } }, right: o2 }));
          return { type: "array_access", array: t4, key: a3 };
        }
        return this.expect(r$1.RBRACKET), { type: "array_access", array: t4, key: n3 };
      }
      return { type: "variable", name: t4 };
    }
    throw new Error(`Unexpected token in field index: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
  }
  parsePrimary() {
    if (this.check(r$1.NUMBER)) return { type: "number", value: this.advance().value };
    if (this.check(r$1.STRING)) return { type: "string", value: this.advance().value };
    if (this.check(r$1.REGEX)) return { type: "regex", pattern: this.advance().value };
    if (this.check(r$1.DOLLAR)) return this.advance(), { type: "field", index: this.parseFieldIndex() };
    if (this.check(r$1.LPAREN)) {
      this.advance();
      let t4 = this.parseExpression();
      if (this.check(r$1.COMMA)) {
        let n3 = [t4];
        for (; this.check(r$1.COMMA); ) this.advance(), n3.push(this.parseExpression());
        return this.expect(r$1.RPAREN), { type: "tuple", elements: n3 };
      }
      return this.expect(r$1.RPAREN), t4;
    }
    if (this.check(r$1.GETLINE)) {
      this.advance();
      let t4, n3;
      return this.check(r$1.IDENT) && (t4 = this.advance().value), this.check(r$1.LT) && (this.advance(), n3 = this.parsePrimary()), { type: "getline", variable: t4, file: n3 };
    }
    if (this.check(r$1.IDENT)) {
      let t4 = this.advance().value;
      if (this.check(r$1.LPAREN)) {
        this.advance();
        let n3 = [];
        if (this.skipNewlines(), !this.check(r$1.RPAREN)) for (n3.push(this.parseExpression()); this.check(r$1.COMMA); ) this.advance(), this.skipNewlines(), n3.push(this.parseExpression());
        return this.skipNewlines(), this.expect(r$1.RPAREN), { type: "call", name: t4, args: n3 };
      }
      if (this.check(r$1.LBRACKET)) {
        this.advance();
        let n3 = [this.parseExpression()];
        for (; this.check(r$1.COMMA); ) this.advance(), n3.push(this.parseExpression());
        this.expect(r$1.RBRACKET);
        let i4;
        if (n3.length === 1) i4 = n3[0];
        else {
          i4 = n3[0];
          for (let a3 = 1; a3 < n3.length; a3++) i4 = { type: "binary", operator: " ", left: { type: "binary", operator: " ", left: i4, right: { type: "variable", name: "SUBSEP" } }, right: n3[a3] };
        }
        return { type: "array_access", array: t4, key: i4 };
      }
      return { type: "variable", name: t4 };
    }
    throw new Error(`Unexpected token: ${this.current().type} at line ${this.current().line}:${this.current().column}`);
  }
};
var kt = { name: "awk", summary: "pattern scanning and text processing language", usage: "awk [OPTIONS] 'PROGRAM' [FILE...]", options: ["-F FS      use FS as field separator", "-v VAR=VAL assign VAL to variable VAR", "    --help display this help and exit"] }, fn$1 = { name: "awk", async execute(e5, t4) {
  if (o$3(e5)) return s$1(kt);
  let n3 = /\s+/, i4 = " ", a3 = {}, s3 = 0;
  for (let c3 = 0; c3 < e5.length; c3++) {
    let p3 = e5[c3];
    if (p3 === "-F" && c3 + 1 < e5.length) i4 = Y$5(e5[++c3]), n3 = me$2(i4), s3 = c3 + 1;
    else if (p3.startsWith("-F")) i4 = Y$5(p3.slice(2)), n3 = me$2(i4), s3 = c3 + 1;
    else if (p3 === "-v" && c3 + 1 < e5.length) {
      let E2 = e5[++c3], d3 = E2.indexOf("=");
      if (d3 > 0) {
        let y2 = E2.slice(0, d3), L4 = Y$5(E2.slice(d3 + 1));
        a3[y2] = L4;
      }
      s3 = c3 + 1;
    } else {
      if (p3.startsWith("--")) return r$3("awk", p3);
      if (p3.startsWith("-") && p3.length > 1) {
        let E2 = p3[1];
        if (E2 !== "F" && E2 !== "v") return r$3("awk", `-${E2}`);
        s3 = c3 + 1;
      } else if (!p3.startsWith("-")) {
        s3 = c3;
        break;
      }
    }
  }
  if (s3 >= e5.length) return { stdout: "", stderr: `awk: missing program
`, exitCode: 1 };
  let o2 = e5[s3], l3 = e5.slice(s3 + 1), h3 = new V$8(), N2;
  try {
    N2 = h3.parse(o2);
  } catch (c3) {
    return { stdout: "", stderr: `awk: ${c3 instanceof Error ? c3.message : String(c3)}
`, exitCode: 1 };
  }
  let v2 = { readFile: t4.fs.readFile.bind(t4.fs), writeFile: t4.fs.writeFile.bind(t4.fs), appendFile: async (c3, p3) => {
    try {
      let E2 = await t4.fs.readFile(c3);
      await t4.fs.writeFile(c3, E2 + p3);
    } catch {
      await t4.fs.writeFile(c3, p3);
    }
  }, resolvePath: t4.fs.resolvePath.bind(t4.fs) }, R2 = K$3({ fieldSep: n3, maxIterations: t4.limits?.maxAwkIterations, fs: v2, cwd: t4.cwd, exec: t4.exec ? (c3) => t4.exec(c3, { cwd: t4.cwd }) : void 0 });
  R2.FS = i4, R2.vars = { ...a3 }, R2.ARGC = l3.length + 1, R2.ARGV = { 0: "awk" };
  for (let c3 = 0; c3 < l3.length; c3++) R2.ARGV[String(c3 + 1)] = l3[c3];
  R2.ENVIRON = { ...t4.env };
  let I2 = new _$7(R2);
  I2.execute(N2);
  let ee2 = N2.rules.some((c3) => c3.pattern?.type !== "begin" && c3.pattern?.type !== "end"), w4 = N2.rules.some((c3) => c3.pattern?.type === "end");
  try {
    if (await I2.executeBegin(), R2.shouldExit) return await I2.executeEnd(), { stdout: I2.getOutput(), stderr: "", exitCode: I2.getExitCode() };
    if (!ee2 && !w4) return { stdout: I2.getOutput(), stderr: "", exitCode: I2.getExitCode() };
    let c3 = [];
    if (l3.length > 0) for (let p3 of l3) try {
      let E2 = t4.fs.resolvePath(t4.cwd, p3), y2 = (await t4.fs.readFile(E2)).split(`
`);
      y2.length > 0 && y2[y2.length - 1] === "" && y2.pop(), c3.push({ filename: p3, lines: y2 });
    } catch {
      return { stdout: "", stderr: `awk: ${p3}: No such file or directory
`, exitCode: 1 };
    }
    else {
      let p3 = t4.stdin.split(`
`);
      p3.length > 0 && p3[p3.length - 1] === "" && p3.pop(), c3.push({ filename: "", lines: p3 });
    }
    for (let p3 of c3) {
      for (R2.FILENAME = p3.filename, R2.FNR = 0, R2.lines = p3.lines, R2.lineIndex = -1, R2.shouldNextFile = false; R2.lineIndex < p3.lines.length - 1 && (R2.lineIndex++, await I2.executeLine(p3.lines[R2.lineIndex]), !(R2.shouldExit || R2.shouldNextFile)); ) ;
      if (R2.shouldExit) break;
    }
    return await I2.executeEnd(), { stdout: I2.getOutput(), stderr: "", exitCode: I2.getExitCode() };
  } catch (c3) {
    let p3 = c3 instanceof Error ? c3.message : String(c3), E2 = c3 instanceof b$i ? b$i.EXIT_CODE : 2;
    return { stdout: I2.getOutput(), stderr: `awk: ${p3}
`, exitCode: E2 };
  }
} };
function Y$5(e5) {
  return e5.replace(/\\t/g, "	").replace(/\\n/g, `
`).replace(/\\r/g, "\r").replace(/\\b/g, "\b").replace(/\\f/g, "\f").replace(/\\a/g, "\x07").replace(/\\v/g, "\v").replace(/\\\\/g, "\\");
}
function me$2(e5) {
  if (e5 === " ") return /\s+/;
  if (/[[\](){}.*+?^$|\\]/.test(e5)) try {
    return new RegExp(e5);
  } catch {
    return new RegExp(ve$4(e5));
  }
  return new RegExp(ve$4(e5));
}
function ve$4(e5) {
  return e5.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
const awk26FBZTP57 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  awkCommand2: fn$1
});
var P$9 = { "": 1, k: 1024, m: 1048576, g: 1073741824, t: 1099511627776, p: 1125899906842624, e: 1152921504606847e3 }, V$7 = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 };
function w$c(u3) {
  let r2 = u3.trim(), e5 = r2.match(/^([+-]?\d*\.?\d+)\s*([kmgtpeKMGTPE])?[iI]?[bB]?$/);
  if (!e5) {
    let n3 = parseFloat(r2);
    return Number.isNaN(n3) ? 0 : n3;
  }
  let l3 = parseFloat(e5[1]), s3 = (e5[2] || "").toLowerCase(), i4 = P$9[s3] || 1;
  return l3 * i4;
}
function L$a(u3) {
  let r2 = u3.trim().toLowerCase().slice(0, 3);
  return V$7[r2] || 0;
}
function D$7(u3, r2) {
  let e5 = u3.split(/(\d+)/), l3 = r2.split(/(\d+)/), s3 = Math.max(e5.length, l3.length);
  for (let i4 = 0; i4 < s3; i4++) {
    let n3 = e5[i4] || "", d3 = l3[i4] || "", o2 = /^\d+$/.test(n3) ? parseInt(n3, 10) : null, c3 = /^\d+$/.test(d3) ? parseInt(d3, 10) : null;
    if (o2 !== null && c3 !== null) {
      if (o2 !== c3) return o2 - c3;
    } else if (n3 !== d3) return n3.localeCompare(d3);
  }
  return 0;
}
function x$c(u3) {
  return u3.replace(/[^a-zA-Z0-9\s]/g, "");
}
function v$6(u3, r2, e5) {
  let l3 = e5 !== null ? e5 : /\s+/, s3 = u3.split(l3), i4 = r2.startField - 1;
  if (i4 >= s3.length) return "";
  if (r2.endField === void 0) {
    let o2 = s3[i4] || "";
    return r2.startChar !== void 0 && (o2 = o2.slice(r2.startChar - 1)), r2.ignoreLeading && (o2 = o2.trimStart()), o2;
  }
  let n3 = Math.min(r2.endField - 1, s3.length - 1), d3 = "";
  for (let o2 = i4; o2 <= n3 && o2 < s3.length; o2++) {
    let c3 = s3[o2] || "";
    if (o2 === i4 && r2.startChar !== void 0 && (c3 = c3.slice(r2.startChar - 1)), o2 === n3 && r2.endChar !== void 0) {
      let t4 = o2 === i4 && r2.startChar !== void 0 ? r2.endChar - r2.startChar + 1 : r2.endChar;
      c3 = c3.slice(0, t4);
    }
    o2 > i4 && (d3 += e5 || " "), d3 += c3;
  }
  return r2.ignoreLeading && (d3 = d3.trimStart()), d3;
}
function I$b(u3, r2, e5) {
  let l3 = u3, s3 = r2;
  if (e5.dictionaryOrder && (l3 = x$c(l3), s3 = x$c(s3)), e5.ignoreCase && (l3 = l3.toLowerCase(), s3 = s3.toLowerCase()), e5.monthSort) {
    let i4 = L$a(l3), n3 = L$a(s3);
    return i4 - n3;
  }
  if (e5.humanNumeric) {
    let i4 = w$c(l3), n3 = w$c(s3);
    return i4 - n3;
  }
  if (e5.versionSort) return D$7(l3, s3);
  if (e5.numeric) {
    let i4 = parseFloat(l3) || 0, n3 = parseFloat(s3) || 0;
    return i4 - n3;
  }
  return l3.localeCompare(s3);
}
function M$7(u3) {
  let { keys: r2, fieldDelimiter: e5, numeric: l3, ignoreCase: s3, reverse: i4, humanNumeric: n3, versionSort: d3, dictionaryOrder: o2, monthSort: c3, ignoreLeadingBlanks: t4, stable: a3 } = u3;
  return (f3, S3) => {
    let g2 = f3, b4 = S3;
    if (t4 && (g2 = g2.trimStart(), b4 = b4.trimStart()), r2.length === 0) {
      let h3 = I$b(g2, b4, { numeric: l3, ignoreCase: s3, humanNumeric: n3, versionSort: d3, dictionaryOrder: o2, monthSort: c3 });
      if (h3 !== 0) return i4 ? -h3 : h3;
      if (!a3) {
        let p3 = f3.localeCompare(S3);
        return i4 ? -p3 : p3;
      }
      return 0;
    }
    for (let m3 of r2) {
      let h3 = v$6(g2, m3, e5), p3 = v$6(b4, m3, e5);
      m3.ignoreLeading && (h3 = h3.trimStart(), p3 = p3.trimStart());
      let B2 = { numeric: m3.numeric ?? l3, ignoreCase: m3.ignoreCase ?? s3, humanNumeric: m3.humanNumeric ?? n3, versionSort: m3.versionSort ?? d3, dictionaryOrder: m3.dictionaryOrder ?? o2, monthSort: m3.monthSort ?? c3 }, A2 = m3.reverse ?? i4, y2 = I$b(h3, p3, B2);
      if (y2 !== 0) return A2 ? -y2 : y2;
    }
    if (!a3) {
      let m3 = f3.localeCompare(S3);
      return i4 ? -m3 : m3;
    }
    return 0;
  };
}
function E$a(u3, r2) {
  if (r2.keys.length === 0) {
    if (r2.ignoreCase) {
      let s3 = /* @__PURE__ */ new Set();
      return u3.filter((i4) => {
        let n3 = i4.toLowerCase();
        return s3.has(n3) ? false : (s3.add(n3), true);
      });
    }
    return [...new Set(u3)];
  }
  let e5 = r2.keys[0], l3 = /* @__PURE__ */ new Set();
  return u3.filter((s3) => {
    let i4 = v$6(s3, e5, r2.fieldDelimiter);
    return (e5.ignoreCase ?? r2.ignoreCase) && (i4 = i4.toLowerCase()), l3.has(i4) ? false : (l3.add(i4), true);
  });
}
function C$a(u3) {
  let r2 = { startField: 1 }, e5 = "", l3 = u3, s3 = l3.match(/([bdfhMnrV]+)$/);
  s3 && (e5 = s3[1], l3 = l3.slice(0, -e5.length)), e5.includes("n") && (r2.numeric = true), e5.includes("r") && (r2.reverse = true), e5.includes("f") && (r2.ignoreCase = true), e5.includes("b") && (r2.ignoreLeading = true), e5.includes("h") && (r2.humanNumeric = true), e5.includes("V") && (r2.versionSort = true), e5.includes("d") && (r2.dictionaryOrder = true), e5.includes("M") && (r2.monthSort = true);
  let i4 = l3.split(",");
  if (i4.length === 0 || i4[0] === "") return null;
  let n3 = i4[0].split("."), d3 = parseInt(n3[0], 10);
  if (Number.isNaN(d3) || d3 < 1) return null;
  if (r2.startField = d3, n3.length > 1 && n3[1]) {
    let o2 = parseInt(n3[1], 10);
    !Number.isNaN(o2) && o2 >= 1 && (r2.startChar = o2);
  }
  if (i4.length > 1 && i4[1]) {
    let o2 = i4[1], c3 = o2.match(/([bdfhMnrV]+)$/);
    if (c3) {
      let a3 = c3[1];
      a3.includes("n") && (r2.numeric = true), a3.includes("r") && (r2.reverse = true), a3.includes("f") && (r2.ignoreCase = true), a3.includes("b") && (r2.ignoreLeading = true), a3.includes("h") && (r2.humanNumeric = true), a3.includes("V") && (r2.versionSort = true), a3.includes("d") && (r2.dictionaryOrder = true), a3.includes("M") && (r2.monthSort = true), o2 = o2.slice(0, -a3.length);
    }
    let t4 = o2.split(".");
    if (t4[0]) {
      let a3 = parseInt(t4[0], 10);
      if (!Number.isNaN(a3) && a3 >= 1 && (r2.endField = a3), t4.length > 1 && t4[1]) {
        let f3 = parseInt(t4[1], 10);
        !Number.isNaN(f3) && f3 >= 1 && (r2.endChar = f3);
      }
    }
  }
  return r2;
}
var q$7 = { name: "sort", summary: "sort lines of text files", usage: "sort [OPTION]... [FILE]...", options: ["-b, --ignore-leading-blanks  ignore leading blanks", "-d, --dictionary-order  consider only blanks and alphanumeric characters", "-f, --ignore-case    fold lower case to upper case characters", "-h, --human-numeric-sort  compare human readable numbers (e.g., 2K 1G)", "-M, --month-sort     compare (unknown) < 'JAN' < ... < 'DEC'", "-n, --numeric-sort   compare according to string numerical value", "-r, --reverse        reverse the result of comparisons", "-V, --version-sort   natural sort of (version) numbers within text", "-c, --check          check for sorted input; do not sort", "-o, --output=FILE    write result to FILE instead of stdout", "-s, --stable         stabilize sort by disabling last-resort comparison", "-u, --unique         output only unique lines", "-k, --key=KEYDEF     sort via a key; KEYDEF gives location and type", "-t, --field-separator=SEP  use SEP as field separator", "    --help           display this help and exit"], description: `KEYDEF is F[.C][OPTS][,F[.C][OPTS]]
  F is a field number (1-indexed)
  C is a character position within the field (1-indexed)
  OPTS can be: b d f h M n r V (per-key modifiers)

Examples:
  -k1        sort by first field
  -k2,2      sort by second field only
  -k1.3      sort by first field starting at 3rd character
  -k1,2n     sort by fields 1-2 numerically
  -k2 -k1    sort by field 2, then by field 1` }, j$7 = { name: "sort", async execute(u3, r2) {
  if (o$3(u3)) return s$1(q$7);
  let e5 = { reverse: false, numeric: false, unique: false, ignoreCase: false, humanNumeric: false, versionSort: false, dictionaryOrder: false, monthSort: false, ignoreLeadingBlanks: false, stable: false, checkOnly: false, outputFile: null, keys: [], fieldDelimiter: null }, l3 = [];
  for (let c3 = 0; c3 < u3.length; c3++) {
    let t4 = u3[c3];
    if (t4 === "-r" || t4 === "--reverse") e5.reverse = true;
    else if (t4 === "-n" || t4 === "--numeric-sort") e5.numeric = true;
    else if (t4 === "-u" || t4 === "--unique") e5.unique = true;
    else if (t4 === "-f" || t4 === "--ignore-case") e5.ignoreCase = true;
    else if (t4 === "-h" || t4 === "--human-numeric-sort") e5.humanNumeric = true;
    else if (t4 === "-V" || t4 === "--version-sort") e5.versionSort = true;
    else if (t4 === "-d" || t4 === "--dictionary-order") e5.dictionaryOrder = true;
    else if (t4 === "-M" || t4 === "--month-sort") e5.monthSort = true;
    else if (t4 === "-b" || t4 === "--ignore-leading-blanks") e5.ignoreLeadingBlanks = true;
    else if (t4 === "-s" || t4 === "--stable") e5.stable = true;
    else if (t4 === "-c" || t4 === "--check") e5.checkOnly = true;
    else if (t4 === "-o" || t4 === "--output") e5.outputFile = u3[++c3] || null;
    else if (t4.startsWith("-o")) e5.outputFile = t4.slice(2) || null;
    else if (t4.startsWith("--output=")) e5.outputFile = t4.slice(9) || null;
    else if (t4 === "-t" || t4 === "--field-separator") e5.fieldDelimiter = u3[++c3] || null;
    else if (t4.startsWith("-t")) e5.fieldDelimiter = t4.slice(2) || null;
    else if (t4.startsWith("--field-separator=")) e5.fieldDelimiter = t4.slice(18) || null;
    else if (t4 === "-k" || t4 === "--key") {
      let a3 = u3[++c3];
      if (a3) {
        let f3 = C$a(a3);
        f3 && e5.keys.push(f3);
      }
    } else if (t4.startsWith("-k")) {
      let a3 = C$a(t4.slice(2));
      a3 && e5.keys.push(a3);
    } else if (t4.startsWith("--key=")) {
      let a3 = C$a(t4.slice(6));
      a3 && e5.keys.push(a3);
    } else {
      if (t4.startsWith("--")) return r$3("sort", t4);
      if (t4.startsWith("-") && !t4.startsWith("--")) {
        let a3 = false;
        for (let f3 of t4.slice(1)) if (f3 === "r") e5.reverse = true;
        else if (f3 === "n") e5.numeric = true;
        else if (f3 === "u") e5.unique = true;
        else if (f3 === "f") e5.ignoreCase = true;
        else if (f3 === "h") e5.humanNumeric = true;
        else if (f3 === "V") e5.versionSort = true;
        else if (f3 === "d") e5.dictionaryOrder = true;
        else if (f3 === "M") e5.monthSort = true;
        else if (f3 === "b") e5.ignoreLeadingBlanks = true;
        else if (f3 === "s") e5.stable = true;
        else if (f3 === "c") e5.checkOnly = true;
        else {
          a3 = true;
          break;
        }
        if (a3) return r$3("sort", t4);
      } else l3.push(t4);
    }
  }
  let s3 = await b$g(r2, l3, { cmdName: "sort" });
  if (!s3.ok) return s3.error;
  let n3 = s3.content.split(`
`);
  n3.length > 0 && n3[n3.length - 1] === "" && n3.pop();
  let d3 = M$7(e5);
  if (e5.checkOnly) {
    let c3 = l3.length > 0 ? l3[0] : "-";
    for (let t4 = 1; t4 < n3.length; t4++) if (d3(n3[t4 - 1], n3[t4]) > 0) return { stdout: "", stderr: `sort: ${c3}:${t4 + 1}: disorder: ${n3[t4]}
`, exitCode: 1 };
    return { stdout: "", stderr: "", exitCode: 0 };
  }
  n3.sort(d3), e5.unique && (n3 = E$a(n3, e5));
  let o2 = n3.length > 0 ? `${n3.join(`
`)}
` : "";
  if (e5.outputFile) {
    let c3 = r2.fs.resolvePath(r2.cwd, e5.outputFile);
    return await r2.fs.writeFile(c3, o2), { stdout: "", stderr: "", exitCode: 0 };
  }
  return { stdout: o2, stderr: "", exitCode: 0 };
} };
const sortEJUT5LXD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sortCommand: j$7
});
var b$b = { name: "uniq", summary: "report or omit repeated lines", usage: "uniq [OPTION]... [INPUT [OUTPUT]]", options: ["-c, --count        prefix lines by the number of occurrences", "-d, --repeated     only print duplicate lines", "-i, --ignore-case  ignore case when comparing", "-u, --unique       only print unique lines", "    --help         display this help and exit"] }, w$b = { count: { short: "c", long: "count", type: "boolean" }, duplicatesOnly: { short: "d", long: "repeated", type: "boolean" }, uniqueOnly: { short: "u", long: "unique", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, P$8 = { name: "uniq", async execute(a3, m3) {
  if (o$3(a3)) return s$1(b$b);
  let o2 = x$g("uniq", a3, w$b);
  if (!o2.ok) return o2.error;
  let { count: h3, duplicatesOnly: y2, uniqueOnly: q2, ignoreCase: C2 } = o2.result.flags, O2 = o2.result.positional, u3 = await b$g(m3, O2, { cmdName: "uniq" });
  if (!u3.ok) return u3.error;
  let n3 = u3.content.split(`
`);
  if (n3.length > 0 && n3[n3.length - 1] === "" && n3.pop(), n3.length === 0) return { stdout: "", stderr: "", exitCode: 0 };
  let t4 = [], r2 = n3[0], i4 = 1, x4 = (e5, s3) => C2 ? e5.toLowerCase() === s3.toLowerCase() : e5 === s3;
  for (let e5 = 1; e5 < n3.length; e5++) x4(n3[e5], r2) ? i4++ : (t4.push({ line: r2, count: i4 }), r2 = n3[e5], i4 = 1);
  t4.push({ line: r2, count: i4 });
  let l3 = t4;
  y2 ? l3 = t4.filter((e5) => e5.count > 1) : q2 && (l3 = t4.filter((e5) => e5.count === 1));
  let c3 = "";
  for (let { line: e5, count: s3 } of l3) h3 ? c3 += `${String(s3).padStart(4)} ${e5}
` : c3 += `${e5}
`;
  return { stdout: c3, stderr: "", exitCode: 0 };
} };
const uniq47QVBRNC = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  uniqCommand: P$8
});
var x$b = { name: "comm", summary: "compare two sorted files line by line", usage: "comm [OPTION]... FILE1 FILE2", options: ["-1             suppress column 1 (lines unique to FILE1)", "-2             suppress column 2 (lines unique to FILE2)", "-3             suppress column 3 (lines that appear in both files)", "    --help     display this help and exit"] }, I$a = { name: "comm", async execute(p3, c3) {
  if (o$3(p3)) return s$1(x$b);
  let o2 = false, i4 = false, f3 = false, l3 = [];
  for (let e5 of p3) if (e5 === "-1") o2 = true;
  else if (e5 === "-2") i4 = true;
  else if (e5 === "-3") f3 = true;
  else if (e5 === "-12" || e5 === "-21") o2 = true, i4 = true;
  else if (e5 === "-13" || e5 === "-31") o2 = true, f3 = true;
  else if (e5 === "-23" || e5 === "-32") i4 = true, f3 = true;
  else if (e5 === "-123" || e5 === "-132" || e5 === "-213" || e5 === "-231" || e5 === "-312" || e5 === "-321") o2 = true, i4 = true, f3 = true;
  else {
    if (e5.startsWith("-") && e5 !== "-") return r$3("comm", e5);
    l3.push(e5);
  }
  if (l3.length !== 2) return { stdout: "", stderr: `comm: missing operand
Try 'comm --help' for more information.
`, exitCode: 1 };
  let m3 = async (e5) => {
    if (e5 === "-") return c3.stdin;
    try {
      let F2 = c3.fs.resolvePath(c3.cwd, e5);
      return await c3.fs.readFile(F2);
    } catch {
      return null;
    }
  }, a3 = await m3(l3[0]);
  if (a3 === null) return { stdout: "", stderr: `comm: ${l3[0]}: No such file or directory
`, exitCode: 1 };
  let h3 = await m3(l3[1]);
  if (h3 === null) return { stdout: "", stderr: `comm: ${l3[1]}: No such file or directory
`, exitCode: 1 };
  let t4 = a3.split(`
`), s3 = h3.split(`
`);
  t4.length > 0 && t4[t4.length - 1] === "" && t4.pop(), s3.length > 0 && s3[s3.length - 1] === "" && s3.pop();
  let n3 = 0, r2 = 0, u3 = "", d3 = o2 ? "" : "	", w4 = (o2 ? "" : "	") + (i4 ? "" : "	");
  for (; n3 < t4.length || r2 < s3.length; ) n3 >= t4.length ? (i4 || (u3 += `${d3}${s3[r2]}
`), r2++) : r2 >= s3.length ? (o2 || (u3 += `${t4[n3]}
`), n3++) : t4[n3] < s3[r2] ? (o2 || (u3 += `${t4[n3]}
`), n3++) : t4[n3] > s3[r2] ? (i4 || (u3 += `${d3}${s3[r2]}
`), r2++) : (f3 || (u3 += `${w4}${t4[n3]}
`), n3++, r2++);
  return { stdout: u3, stderr: "", exitCode: 0 };
} };
const commAXQM7FFF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  commCommand: I$a
});
var W$7 = { name: "cut", summary: "remove sections from each line of files", usage: "cut [OPTION]... [FILE]...", options: ["-c LIST              select only these characters", "-d DELIM             use DELIM instead of TAB for field delimiter", "-f LIST              select only these fields", "-s, --only-delimited  do not print lines without delimiters", "    --help           display this help and exit"] };
function k$7(t4) {
  let c3 = [], l3 = t4.split(",");
  for (let n3 of l3) if (n3.includes("-")) {
    let [s3, r2] = n3.split("-");
    c3.push({ start: s3 ? parseInt(s3, 10) : 1, end: r2 ? parseInt(r2, 10) : null });
  } else {
    let s3 = parseInt(n3, 10);
    c3.push({ start: s3, end: s3 });
  }
  return c3;
}
function C$9(t4, c3) {
  let l3 = [];
  for (let n3 of c3) {
    let s3 = n3.start - 1, r2 = n3.end === null ? t4.length : n3.end;
    for (let i4 = s3; i4 < r2 && i4 < t4.length; i4++) i4 >= 0 && !l3.includes(t4[i4]) && l3.push(t4[i4]);
  }
  return l3;
}
var E$9 = { name: "cut", async execute(t4, c3) {
  if (o$3(t4)) return s$1(W$7);
  let l3 = "	", n3 = null, s3 = null, r2 = false, i4 = [];
  for (let o2 = 0; o2 < t4.length; o2++) {
    let e5 = t4[o2];
    if (e5 === "-d") l3 = t4[++o2] || "	";
    else if (e5.startsWith("-d")) l3 = e5.slice(2);
    else if (e5 === "-f") n3 = t4[++o2];
    else if (e5.startsWith("-f")) n3 = e5.slice(2);
    else if (e5 === "-c") s3 = t4[++o2];
    else if (e5.startsWith("-c")) s3 = e5.slice(2);
    else if (e5 === "-s" || e5 === "--only-delimited") r2 = true;
    else {
      if (e5.startsWith("--")) return r$3("cut", e5);
      if (e5.startsWith("-")) {
        let f3 = false;
        for (let u3 of e5.slice(1)) if (u3 === "s") r2 = true;
        else if (!"dfc".includes(u3)) {
          f3 = true;
          break;
        }
        if (f3) return r$3("cut", e5);
      } else i4.push(e5);
    }
  }
  if (!n3 && !s3) return { stdout: "", stderr: `cut: you must specify a list of bytes, characters, or fields
`, exitCode: 1 };
  let p3 = await b$g(c3, i4, { cmdName: "cut" });
  if (!p3.ok) return p3.error;
  let a3 = p3.content.split(`
`);
  a3.length > 0 && a3[a3.length - 1] === "" && a3.pop();
  let g2 = k$7(n3 || s3 || "1"), h3 = "";
  for (let o2 of a3) if (s3) {
    let e5 = o2.split(""), f3 = [];
    for (let u3 of g2) {
      let w4 = u3.start - 1, L4 = u3.end === null ? e5.length : u3.end;
      for (let d3 = w4; d3 < L4 && d3 < e5.length; d3++) d3 >= 0 && f3.push(e5[d3]);
    }
    h3 += `${f3.join("")}
`;
  } else {
    if (r2 && !o2.includes(l3)) continue;
    let e5 = o2.split(l3), f3 = C$9(e5, g2);
    h3 += `${f3.join(l3)}
`;
  }
  return { stdout: h3, stderr: "", exitCode: 0 };
} };
const cutNVKWEAZF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  cutCommand: E$9
});
var L$9 = { name: "paste", summary: "merge lines of files", usage: "paste [OPTION]... [FILE]...", description: ["Write lines consisting of the sequentially corresponding lines from", "each FILE, separated by TABs, to standard output.", "", "With no FILE, or when FILE is -, read standard input."], options: ["-d, --delimiters=LIST   reuse characters from LIST instead of TABs", "-s, --serial            paste one file at a time instead of in parallel", "    --help              display this help and exit"], examples: ["paste file1 file2       Merge file1 and file2 side by side", "paste -d, file1 file2   Use comma as delimiter", "paste -s file1          Paste all lines of file1 on one line", "paste - - < file        Paste pairs of lines from file"] }, x$a = { delimiter: { short: "d", long: "delimiters", type: "string", default: "	" }, serial: { short: "s", long: "serial", type: "boolean" } }, P$7 = { name: "paste", async execute(s3, i4) {
  if (o$3(s3)) return s$1(L$9);
  let n3 = x$g("paste", s3, x$a);
  if (!n3.ok) return n3.error;
  let l3 = n3.result.flags.delimiter, d3 = n3.result.flags.serial, p3 = n3.result.positional;
  if (p3.length === 0) return { stdout: "", stderr: `usage: paste [-s] [-d delimiters] file ...
`, exitCode: 1 };
  let a3 = i4.stdin ? i4.stdin.split(`
`) : [""];
  a3.length > 0 && a3[a3.length - 1] === "" && a3.pop();
  let I2 = p3.filter((e5) => e5 === "-").length, f3 = [], u3 = 0;
  for (let e5 of p3) if (e5 === "-") {
    let t4 = [];
    for (let o2 = u3; o2 < a3.length; o2 += I2) t4.push(a3[o2]);
    f3.push(t4), u3++;
  } else {
    let t4 = i4.fs.resolvePath(i4.cwd, e5);
    try {
      let r2 = (await i4.fs.readFile(t4)).split(`
`);
      r2.length > 0 && r2[r2.length - 1] === "" && r2.pop(), f3.push(r2);
    } catch {
      return { stdout: "", stderr: `paste: ${e5}: No such file or directory
`, exitCode: 1 };
    }
  }
  let h3 = "";
  if (d3) for (let e5 of f3) e5 && (h3 += `${y$8(e5, l3)}
`);
  else {
    let e5 = Math.max(...f3.map((t4) => t4?.length ?? 0));
    for (let t4 = 0; t4 < e5; t4++) {
      let o2 = [];
      for (let r2 of f3) o2.push(r2?.[t4] ?? "");
      h3 += `${y$8(o2, l3)}
`;
    }
  }
  return { stdout: h3, stderr: "", exitCode: 0 };
} };
function y$8(s3, i4) {
  if (s3.length === 0) return "";
  if (s3.length === 1) return s3[0];
  let n3 = s3[0];
  for (let l3 = 1; l3 < s3.length; l3++) {
    let d3 = (l3 - 1) % i4.length;
    n3 += i4[d3] + s3[l3];
  }
  return n3;
}
const pasteQTGVEPH5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  pasteCommand: P$7
});
var x$9 = { name: "tr", summary: "translate or delete characters", usage: "tr [OPTION]... SET1 [SET2]", options: ["-c, -C, --complement   use the complement of SET1", "-d, --delete           delete characters in SET1", "-s, --squeeze-repeats  squeeze repeated characters", "    --help             display this help and exit"], description: `SET syntax:
  a-z         character range
  [:alnum:]   all letters and digits
  [:alpha:]   all letters
  [:digit:]   all digits
  [:lower:]   all lowercase letters
  [:upper:]   all uppercase letters
  [:space:]   all whitespace
  [:blank:]   horizontal whitespace
  [:punct:]   all punctuation
  [:print:]   all printable characters
  [:graph:]   all printable characters except space
  [:cntrl:]   all control characters
  [:xdigit:]  all hexadecimal digits
  \\n, \\t, \\r  escape sequences` }, b$a = { "[:alnum:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", "[:alpha:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", "[:blank:]": " 	", "[:cntrl:]": Array.from({ length: 32 }, (r2, n3) => String.fromCharCode(n3)).join("").concat(""), "[:digit:]": "0123456789", "[:graph:]": Array.from({ length: 94 }, (r2, n3) => String.fromCharCode(33 + n3)).join(""), "[:lower:]": "abcdefghijklmnopqrstuvwxyz", "[:print:]": Array.from({ length: 95 }, (r2, n3) => String.fromCharCode(32 + n3)).join(""), "[:punct:]": "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~", "[:space:]": ` 	
\r\f\v`, "[:upper:]": "ABCDEFGHIJKLMNOPQRSTUVWXYZ", "[:xdigit:]": "0123456789ABCDEFabcdef" };
function S$a(r2) {
  let n3 = "", e5 = 0;
  for (; e5 < r2.length; ) {
    if (r2[e5] === "[" && r2[e5 + 1] === ":") {
      let l3 = false;
      for (let [i4, a3] of Object.entries(b$a)) if (r2.slice(e5).startsWith(i4)) {
        n3 += a3, e5 += i4.length, l3 = true;
        break;
      }
      if (l3) continue;
    }
    if (r2[e5] === "\\" && e5 + 1 < r2.length) {
      let l3 = r2[e5 + 1];
      l3 === "n" ? n3 += `
` : l3 === "t" ? n3 += "	" : l3 === "r" ? n3 += "\r" : n3 += l3, e5 += 2;
      continue;
    }
    if (e5 + 2 < r2.length && r2[e5 + 1] === "-") {
      let l3 = r2.charCodeAt(e5), i4 = r2.charCodeAt(e5 + 2);
      for (let a3 = l3; a3 <= i4; a3++) n3 += String.fromCharCode(a3);
      e5 += 3;
      continue;
    }
    n3 += r2[e5], e5++;
  }
  return n3;
}
var y$7 = { complement: { short: "c", long: "complement", type: "boolean" }, complementUpper: { short: "C", type: "boolean" }, delete: { short: "d", long: "delete", type: "boolean" }, squeeze: { short: "s", long: "squeeze-repeats", type: "boolean" } }, q$6 = { name: "tr", async execute(r2, n3) {
  if (o$3(r2)) return s$1(x$9);
  let e5 = x$g("tr", r2, y$7);
  if (!e5.ok) return e5.error;
  let l3 = e5.result.flags.complement || e5.result.flags.complementUpper, i4 = e5.result.flags.delete, a3 = e5.result.flags.squeeze, p3 = e5.result.positional;
  if (p3.length < 1) return { stdout: "", stderr: `tr: missing operand
`, exitCode: 1 };
  if (!i4 && !a3 && p3.length < 2) return { stdout: "", stderr: `tr: missing operand after SET1
`, exitCode: 1 };
  let f3 = S$a(p3[0]), s3 = p3.length > 1 ? S$a(p3[1]) : "", d3 = n3.stdin, u3 = (o2) => {
    let t4 = f3.includes(o2);
    return l3 ? !t4 : t4;
  }, c3 = "";
  if (i4) for (let o2 of d3) u3(o2) || (c3 += o2);
  else if (a3 && p3.length === 1) {
    let o2 = "";
    for (let t4 of d3) u3(t4) && t4 === o2 || (c3 += t4, o2 = t4);
  } else {
    if (l3) {
      let o2 = s3.length > 0 ? s3[s3.length - 1] : "";
      for (let t4 of d3) f3.includes(t4) ? c3 += t4 : c3 += o2;
    } else {
      let o2 = /* @__PURE__ */ new Map();
      for (let t4 = 0; t4 < f3.length; t4++) {
        let h3 = t4 < s3.length ? s3[t4] : s3[s3.length - 1];
        o2.set(f3[t4], h3);
      }
      for (let t4 of d3) c3 += o2.get(t4) ?? t4;
    }
    if (a3) {
      let o2 = "", t4 = "";
      for (let h3 of c3) s3.includes(h3) && h3 === t4 || (o2 += h3, t4 = h3);
      c3 = o2;
    }
  }
  return { stdout: c3, stderr: "", exitCode: 0 };
} };
const trEDGW5FG6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  trCommand: q$6
});
var u$5 = { name: "rev", summary: "reverse lines characterwise", usage: "rev [file ...]", description: "Copies the specified files to standard output, reversing the order of characters in every line. If no files are specified, standard input is read.", examples: ["echo 'hello' | rev     # Output: olleh", "rev file.txt           # Reverse each line in file"] };
function d$7(t4) {
  return Array.from(t4).reverse().join("");
}
var v$5 = { name: "rev", execute: async (t4, n3) => {
  if (o$3(t4)) return s$1(u$5);
  let o2 = [];
  for (let e5 of t4) if (e5 === "--") {
    let r2 = t4.indexOf(e5);
    o2.push(...t4.slice(r2 + 1));
    break;
  } else {
    if (e5.startsWith("-") && e5 !== "-") return r$3("rev", e5);
    o2.push(e5);
  }
  let s3 = "", l3 = (e5) => {
    let r2 = e5.split(`
`), i4 = e5.endsWith(`
`) && r2[r2.length - 1] === "";
    return i4 && r2.pop(), r2.map(d$7).join(`
`) + (i4 ? `
` : "");
  };
  if (o2.length === 0) {
    let e5 = n3.stdin ?? "";
    s3 = l3(e5);
  } else for (let e5 of o2) if (e5 === "-") {
    let r2 = n3.stdin ?? "";
    s3 += l3(r2);
  } else {
    let r2 = n3.fs.resolvePath(n3.cwd, e5), i4 = await n3.fs.readFile(r2);
    if (i4 === null) return { exitCode: 1, stdout: s3, stderr: `rev: ${e5}: No such file or directory
` };
    s3 += l3(i4);
  }
  return { exitCode: 0, stdout: s3, stderr: "" };
} };
const revFKUV5GH5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  rev: v$5
});
var h$8 = { name: "nl", summary: "number lines of files", usage: "nl [OPTION]... [FILE]...", description: "Write each FILE to standard output, with line numbers added. If no FILE is specified, standard input is read.", options: ["-b STYLE     Body numbering style: a (all), t (non-empty), n (none)", "-n FORMAT    Number format: ln (left), rn (right), rz (right zeros)", "-w WIDTH     Number width (default: 6)", "-s SEP       Separator after number (default: TAB)", "-v START     Starting line number (default: 1)", "-i INCR      Line number increment (default: 1)"], examples: ["nl file.txt              # Number non-empty lines", "nl -ba file.txt          # Number all lines", "nl -n rz -w 3 file.txt   # Right-justified with zeros", "nl -s ': ' file.txt      # Use ': ' as separator"] };
function p$a(r2, s3, i4) {
  let l3 = String(r2);
  switch (s3) {
    case "ln":
      return l3.padEnd(i4);
    case "rn":
      return l3.padStart(i4);
    case "rz":
      return l3.padStart(i4, "0");
    default:
      return s3;
  }
}
function N$7(r2, s3) {
  switch (s3) {
    case "a":
      return true;
    case "t":
      return r2.trim().length > 0;
    case "n":
      return false;
    default:
      return s3;
  }
}
function b$9(r2, s3, i4) {
  if (r2 === "") return { output: "", nextNumber: i4 };
  let l3 = r2.split(`
`), t4 = [], u3 = i4, o2 = r2.endsWith(`
`) && l3[l3.length - 1] === "";
  o2 && l3.pop();
  for (let n3 of l3) if (N$7(n3, s3.bodyStyle)) {
    let e5 = p$a(u3, s3.numberFormat, s3.width);
    t4.push(`${e5}${s3.separator}${n3}`), u3 += s3.increment;
  } else {
    let e5 = " ".repeat(s3.width);
    t4.push(`${e5}${s3.separator}${n3}`);
  }
  return { output: t4.join(`
`) + (o2 ? `
` : ""), nextNumber: u3 };
}
var w$a = { name: "nl", execute: async (r2, s3) => {
  if (o$3(r2)) return s$1(h$8);
  let i4 = { bodyStyle: "t", numberFormat: "rn", width: 6, separator: "	", startNumber: 1, increment: 1 }, l3 = [], t4 = 0;
  for (; t4 < r2.length; ) {
    let n3 = r2[t4];
    if (n3 === "-b" && t4 + 1 < r2.length) {
      let e5 = r2[t4 + 1];
      if (e5 !== "a" && e5 !== "t" && e5 !== "n") return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${e5}'
` };
      i4.bodyStyle = e5, t4 += 2;
    } else if (n3.startsWith("-b")) {
      let e5 = n3.slice(2);
      if (e5 !== "a" && e5 !== "t" && e5 !== "n") return { exitCode: 1, stdout: "", stderr: `nl: invalid body numbering style: '${e5}'
` };
      i4.bodyStyle = e5, t4++;
    } else if (n3 === "-n" && t4 + 1 < r2.length) {
      let e5 = r2[t4 + 1];
      if (e5 !== "ln" && e5 !== "rn" && e5 !== "rz") return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${e5}'
` };
      i4.numberFormat = e5, t4 += 2;
    } else if (n3.startsWith("-n")) {
      let e5 = n3.slice(2);
      if (e5 !== "ln" && e5 !== "rn" && e5 !== "rz") return { exitCode: 1, stdout: "", stderr: `nl: invalid line numbering format: '${e5}'
` };
      i4.numberFormat = e5, t4++;
    } else if (n3 === "-w" && t4 + 1 < r2.length) {
      let e5 = parseInt(r2[t4 + 1], 10);
      if (Number.isNaN(e5) || e5 < 1) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${r2[t4 + 1]}'
` };
      i4.width = e5, t4 += 2;
    } else if (n3.startsWith("-w")) {
      let e5 = parseInt(n3.slice(2), 10);
      if (Number.isNaN(e5) || e5 < 1) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number field width: '${n3.slice(2)}'
` };
      i4.width = e5, t4++;
    } else if (n3 === "-s" && t4 + 1 < r2.length) i4.separator = r2[t4 + 1], t4 += 2;
    else if (n3.startsWith("-s")) i4.separator = n3.slice(2), t4++;
    else if (n3 === "-v" && t4 + 1 < r2.length) {
      let e5 = parseInt(r2[t4 + 1], 10);
      if (Number.isNaN(e5)) return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${r2[t4 + 1]}'
` };
      i4.startNumber = e5, t4 += 2;
    } else if (n3.startsWith("-v")) {
      let e5 = parseInt(n3.slice(2), 10);
      if (Number.isNaN(e5)) return { exitCode: 1, stdout: "", stderr: `nl: invalid starting line number: '${n3.slice(2)}'
` };
      i4.startNumber = e5, t4++;
    } else if (n3 === "-i" && t4 + 1 < r2.length) {
      let e5 = parseInt(r2[t4 + 1], 10);
      if (Number.isNaN(e5)) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${r2[t4 + 1]}'
` };
      i4.increment = e5, t4 += 2;
    } else if (n3.startsWith("-i")) {
      let e5 = parseInt(n3.slice(2), 10);
      if (Number.isNaN(e5)) return { exitCode: 1, stdout: "", stderr: `nl: invalid line number increment: '${n3.slice(2)}'
` };
      i4.increment = e5, t4++;
    } else if (n3 === "--") {
      l3.push(...r2.slice(t4 + 1));
      break;
    } else {
      if (n3.startsWith("-") && n3 !== "-") return r$3("nl", n3);
      l3.push(n3), t4++;
    }
  }
  let u3 = "", o2 = i4.startNumber;
  if (l3.length === 0) {
    let n3 = s3.stdin ?? "";
    u3 = b$9(n3, i4, o2).output;
  } else for (let n3 of l3) {
    let e5 = s3.fs.resolvePath(s3.cwd, n3), a3 = await s3.fs.readFile(e5);
    if (a3 === null) return { exitCode: 1, stdout: u3, stderr: `nl: ${n3}: No such file or directory
` };
    let d3 = b$9(a3, i4, o2);
    u3 += d3.output, o2 = d3.nextNumber;
  }
  return { exitCode: 0, stdout: u3, stderr: "" };
} };
const nlKWQGFZH5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  nl: w$a
});
var m$9 = { name: "fold", summary: "wrap each input line to fit in specified width", usage: "fold [OPTION]... [FILE]...", description: "Wrap input lines in each FILE, writing to standard output. If no FILE is specified, standard input is read.", options: ["-w WIDTH    Use WIDTH columns instead of 80", "-s          Break at spaces", "-b          Count bytes rather than columns"], examples: ["fold -w 40 file.txt           # Wrap at 40 columns", "fold -sw 40 file.txt          # Word wrap at 40 columns", "echo 'long line' | fold -w 5  # Force wrap at 5"] };
function N$6(s3, l3, n3) {
  return n3 ? new TextEncoder().encode(s3).length : s3 === "	" ? 8 - l3 % 8 : s3 === "\b" ? -1 : 1;
}
function g$a(s3, l3) {
  if (s3.length === 0) return s3;
  let { width: n3, breakAtSpaces: u3, countBytes: i4 } = l3, r2 = [], e5 = "", t4 = 0, o2 = -1, f3 = 0;
  for (let a3 = 0; a3 < s3.length; a3++) {
    let d3 = s3[a3], c3 = N$6(d3, t4, i4);
    t4 + c3 > n3 && e5.length > 0 ? u3 && o2 >= 0 ? (r2.push(e5.slice(0, o2 + 1)), e5 = e5.slice(o2 + 1) + d3, t4 = t4 - f3 - 1 + c3, o2 = -1, f3 = 0) : (r2.push(e5), e5 = d3, t4 = c3, o2 = -1, f3 = 0) : (e5 += d3, t4 += c3, (d3 === " " || d3 === "	") && (o2 = e5.length - 1, f3 = t4 - c3));
  }
  return e5.length > 0 && r2.push(e5), r2.join(`
`);
}
function b$8(s3, l3) {
  if (s3 === "") return "";
  let n3 = s3.split(`
`), u3 = s3.endsWith(`
`) && n3[n3.length - 1] === "";
  return u3 && n3.pop(), n3.map((r2) => g$a(r2, l3)).join(`
`) + (u3 ? `
` : "");
}
var I$9 = { name: "fold", execute: async (s3, l3) => {
  if (o$3(s3)) return s$1(m$9);
  let n3 = { width: 80, breakAtSpaces: false, countBytes: false }, u3 = [], i4 = 0;
  for (; i4 < s3.length; ) {
    let e5 = s3[i4];
    if (e5 === "-w" && i4 + 1 < s3.length) {
      let t4 = parseInt(s3[i4 + 1], 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${s3[i4 + 1]}'
` };
      n3.width = t4, i4 += 2;
    } else if (e5.startsWith("-w") && e5.length > 2) {
      let t4 = parseInt(e5.slice(2), 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${e5.slice(2)}'
` };
      n3.width = t4, i4++;
    } else if (e5 === "-s") n3.breakAtSpaces = true, i4++;
    else if (e5 === "-b") n3.countBytes = true, i4++;
    else if (e5 === "-bs" || e5 === "-sb") n3.breakAtSpaces = true, n3.countBytes = true, i4++;
    else if (e5.match(/^-[sb]+w\d+$/)) {
      e5.includes("s") && (n3.breakAtSpaces = true), e5.includes("b") && (n3.countBytes = true);
      let t4 = e5.replace(/^-[sb]+w/, ""), o2 = parseInt(t4, 10);
      if (Number.isNaN(o2) || o2 < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${t4}'
` };
      n3.width = o2, i4++;
    } else if (e5.match(/^-[sb]+w$/) && i4 + 1 < s3.length) {
      e5.includes("s") && (n3.breakAtSpaces = true), e5.includes("b") && (n3.countBytes = true);
      let t4 = parseInt(s3[i4 + 1], 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `fold: invalid number of columns: '${s3[i4 + 1]}'
` };
      n3.width = t4, i4 += 2;
    } else if (e5 === "--") {
      u3.push(...s3.slice(i4 + 1));
      break;
    } else if (e5.startsWith("-") && e5 !== "-") {
      let t4 = e5.slice(1), o2 = false;
      for (let f3 of t4) if (f3 === "s") n3.breakAtSpaces = true;
      else if (f3 === "b") n3.countBytes = true;
      else {
        o2 = true;
        break;
      }
      if (o2) return r$3("fold", e5);
      i4++;
    } else u3.push(e5), i4++;
  }
  let r2 = "";
  if (u3.length === 0) {
    let e5 = l3.stdin ?? "";
    r2 = b$8(e5, n3);
  } else for (let e5 of u3) {
    let t4 = l3.fs.resolvePath(l3.cwd, e5), o2 = await l3.fs.readFile(t4);
    if (o2 === null) return { exitCode: 1, stdout: r2, stderr: `fold: ${e5}: No such file or directory
` };
    r2 += b$8(o2, n3);
  }
  return { exitCode: 0, stdout: r2, stderr: "" };
} };
const fold6CFXIPYZ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fold: I$9
});
var h$7 = { name: "expand", summary: "convert tabs to spaces", usage: "expand [OPTION]... [FILE]...", description: "Convert TABs in each FILE to spaces, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-i          Only convert leading tabs on each line"], examples: ["expand file.txt             # Convert all tabs to 8 spaces", "expand -t 4 file.txt        # Use 4-space tabs", "expand -t 4,8,12 file.txt   # Custom tab stops"] };
function p$9(n3) {
  let i4 = n3.split(",").map((o2) => o2.trim()), t4 = [];
  for (let o2 of i4) {
    let e5 = parseInt(o2, 10);
    if (Number.isNaN(e5) || e5 < 1) return null;
    t4.push(e5);
  }
  for (let o2 = 1; o2 < t4.length; o2++) if (t4[o2] <= t4[o2 - 1]) return null;
  return t4;
}
function x$8(n3, i4) {
  if (i4.length === 1) {
    let t4 = i4[0];
    return t4 - n3 % t4;
  }
  for (let t4 of i4) if (t4 > n3) return t4 - n3;
  if (i4.length >= 2) {
    let t4 = i4[i4.length - 1] - i4[i4.length - 2], o2 = i4[i4.length - 1], e5 = Math.floor((n3 - o2) / t4) + 1;
    return o2 + e5 * t4 - n3;
  }
  return 1;
}
function b$7(n3, i4) {
  let { tabStops: t4, leadingOnly: o2 } = i4, e5 = "", r2 = 0, s3 = true;
  for (let a3 of n3) if (a3 === "	") if (o2 && !s3) e5 += a3, r2++;
  else {
    let l3 = x$8(r2, t4);
    e5 += " ".repeat(l3), r2 += l3;
  }
  else a3 !== " " && a3 !== "	" && (s3 = false), e5 += a3, r2++;
  return e5;
}
function u$4(n3, i4) {
  if (n3 === "") return "";
  let t4 = n3.split(`
`), o2 = n3.endsWith(`
`) && t4[t4.length - 1] === "";
  return o2 && t4.pop(), t4.map((r2) => b$7(r2, i4)).join(`
`) + (o2 ? `
` : "");
}
var m$8 = { name: "expand", execute: async (n3, i4) => {
  if (o$3(n3)) return s$1(h$7);
  let t4 = { tabStops: [8], leadingOnly: false }, o2 = [], e5 = 0;
  for (; e5 < n3.length; ) {
    let s3 = n3[e5];
    if (s3 === "-t" && e5 + 1 < n3.length) {
      let a3 = p$9(n3[e5 + 1]);
      if (!a3) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${n3[e5 + 1]}'
` };
      t4.tabStops = a3, e5 += 2;
    } else if (s3.startsWith("-t") && s3.length > 2) {
      let a3 = p$9(s3.slice(2));
      if (!a3) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${s3.slice(2)}'
` };
      t4.tabStops = a3, e5++;
    } else if (s3 === "--tabs" && e5 + 1 < n3.length) {
      let a3 = p$9(n3[e5 + 1]);
      if (!a3) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${n3[e5 + 1]}'
` };
      t4.tabStops = a3, e5 += 2;
    } else if (s3.startsWith("--tabs=")) {
      let a3 = p$9(s3.slice(7));
      if (!a3) return { exitCode: 1, stdout: "", stderr: `expand: invalid tab size: '${s3.slice(7)}'
` };
      t4.tabStops = a3, e5++;
    } else if (s3 === "-i" || s3 === "--initial") t4.leadingOnly = true, e5++;
    else if (s3 === "--") {
      o2.push(...n3.slice(e5 + 1));
      break;
    } else {
      if (s3.startsWith("-") && s3 !== "-") return r$3("expand", s3);
      o2.push(s3), e5++;
    }
  }
  let r2 = "";
  if (o2.length === 0) {
    let s3 = i4.stdin ?? "";
    r2 = u$4(s3, t4);
  } else for (let s3 of o2) {
    let a3 = i4.fs.resolvePath(i4.cwd, s3), l3 = await i4.fs.readFile(a3);
    if (l3 === null) return { exitCode: 1, stdout: r2, stderr: `expand: ${s3}: No such file or directory
` };
    r2 += u$4(l3, t4);
  }
  return { exitCode: 0, stdout: r2, stderr: "" };
} };
const expandVSTNOVF5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  expand: m$8
});
var k$6 = { name: "unexpand", summary: "convert spaces to tabs", usage: "unexpand [OPTION]... [FILE]...", description: "Convert blanks in each FILE to TABs, writing to standard output. If no FILE is specified, standard input is read.", options: ["-t N        Use N spaces per tab (default: 8)", "-t LIST     Use comma-separated list of tab stops", "-a          Convert all sequences of blanks (not just leading)"], examples: ["unexpand file.txt           # Convert leading spaces to tabs", "unexpand -a file.txt        # Convert all space sequences", "unexpand -t 4 file.txt      # Use 4-space tabs"] };
function d$6(s3) {
  let i4 = s3.split(",").map((o2) => o2.trim()), e5 = [];
  for (let o2 of i4) {
    let n3 = parseInt(o2, 10);
    if (Number.isNaN(n3) || n3 < 1) return null;
    e5.push(n3);
  }
  for (let o2 = 1; o2 < e5.length; o2++) if (e5[o2] <= e5[o2 - 1]) return null;
  return e5;
}
function v$4(s3, i4) {
  if (i4.length === 1) {
    let e5 = i4[0];
    return s3 + (e5 - s3 % e5);
  }
  for (let e5 of i4) if (e5 > s3) return e5;
  if (i4.length >= 2) {
    let e5 = i4[i4.length - 1] - i4[i4.length - 2], o2 = i4[i4.length - 1], n3 = Math.floor((s3 - o2) / e5) + 1;
    return o2 + n3 * e5;
  }
  return -1;
}
function L$8(s3, i4) {
  let { tabStops: e5, allBlanks: o2 } = i4, n3 = "", a3 = 0, t4 = "", l3 = 0, u3 = true, f3 = () => {
    if (t4.length === 0) return;
    let r2 = l3 + t4.length;
    if (!o2 && !u3) {
      n3 += t4, t4 = "";
      return;
    }
    let p3 = l3, c3 = "";
    for (; p3 < r2; ) {
      let h3 = v$4(p3, e5);
      if (h3 <= r2 && h3 > p3) c3 += "	", p3 = h3;
      else break;
    }
    let x4 = r2 - p3;
    x4 > 0 && (c3 += " ".repeat(x4)), n3 += c3, t4 = "";
  };
  for (let r2 of s3) r2 === " " ? (t4.length === 0 && (l3 = a3), t4 += r2, a3++) : r2 === "	" ? (f3(), n3 += r2, a3 = v$4(a3, e5)) : (f3(), n3 += r2, a3++, u3 = false);
  return f3(), n3;
}
function C$8(s3, i4) {
  if (s3 === "") return "";
  let e5 = s3.split(`
`), o2 = s3.endsWith(`
`) && e5[e5.length - 1] === "";
  return o2 && e5.pop(), e5.map((a3) => L$8(a3, i4)).join(`
`) + (o2 ? `
` : "");
}
var w$9 = { name: "unexpand", execute: async (s3, i4) => {
  if (o$3(s3)) return s$1(k$6);
  let e5 = { tabStops: [8], allBlanks: false }, o2 = [], n3 = 0;
  for (; n3 < s3.length; ) {
    let t4 = s3[n3];
    if (t4 === "-t" && n3 + 1 < s3.length) {
      let l3 = d$6(s3[n3 + 1]);
      if (!l3) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${s3[n3 + 1]}'
` };
      e5.tabStops = l3, n3 += 2;
    } else if (t4.startsWith("-t") && t4.length > 2) {
      let l3 = d$6(t4.slice(2));
      if (!l3) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${t4.slice(2)}'
` };
      e5.tabStops = l3, n3++;
    } else if (t4 === "--tabs" && n3 + 1 < s3.length) {
      let l3 = d$6(s3[n3 + 1]);
      if (!l3) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${s3[n3 + 1]}'
` };
      e5.tabStops = l3, n3 += 2;
    } else if (t4.startsWith("--tabs=")) {
      let l3 = d$6(t4.slice(7));
      if (!l3) return { exitCode: 1, stdout: "", stderr: `unexpand: invalid tab size: '${t4.slice(7)}'
` };
      e5.tabStops = l3, n3++;
    } else if (t4 === "-a" || t4 === "--all") e5.allBlanks = true, n3++;
    else if (t4 === "--") {
      o2.push(...s3.slice(n3 + 1));
      break;
    } else {
      if (t4.startsWith("-") && t4 !== "-") return r$3("unexpand", t4);
      o2.push(t4), n3++;
    }
  }
  let a3 = "";
  if (o2.length === 0) {
    let t4 = i4.stdin ?? "";
    a3 = C$8(t4, e5);
  } else for (let t4 of o2) {
    let l3 = i4.fs.resolvePath(i4.cwd, t4), u3 = await i4.fs.readFile(l3);
    if (u3 === null) return { exitCode: 1, stdout: a3, stderr: `unexpand: ${t4}: No such file or directory
` };
    a3 += C$8(u3, e5);
  }
  return { exitCode: 0, stdout: a3, stderr: "" };
} };
const unexpandI7A2VXFD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  unexpand: w$9
});
var m$7 = { name: "strings", summary: "print the sequences of printable characters in files", usage: "strings [OPTION]... [FILE]...", description: "For each FILE, print the printable character sequences that are at least MIN characters long. If no FILE is specified, standard input is read.", options: ["-n MIN       Print sequences of at least MIN characters (default: 4)", "-t FORMAT    Print offset before each string (o=octal, x=hex, d=decimal)", "-a           Scan the entire file (default behavior)", "-e ENCODING  Select character encoding (s=7-bit, S=8-bit)"], examples: ["strings file.bin          # Extract strings (min 4 chars)", "strings -n 8 file.bin     # Extract strings (min 8 chars)", "strings -t x file.bin     # Show hex offset", "echo 'hello' | strings    # Read from stdin"] };
function p$8(n3) {
  return n3 >= 32 && n3 <= 126 || n3 === 9;
}
function u$3(n3, s3) {
  if (s3 === null) return "";
  switch (s3) {
    case "o":
      return `${n3.toString(8).padStart(7, " ")} `;
    case "x":
      return `${n3.toString(16).padStart(7, " ")} `;
    case "d":
      return `${n3.toString(10).padStart(7, " ")} `;
    default:
      return s3;
  }
}
function h$6(n3, s3) {
  let o2 = [], r2 = "", i4 = 0, l3 = typeof n3 == "string" ? new TextEncoder().encode(n3) : n3;
  for (let e5 = 0; e5 < l3.length; e5++) {
    let t4 = l3[e5];
    if (p$8(t4)) r2.length === 0 && (i4 = e5), r2 += String.fromCharCode(t4);
    else {
      if (r2.length >= s3.minLength) {
        let a3 = u$3(i4, s3.offsetFormat);
        o2.push(`${a3}${r2}`);
      }
      r2 = "";
    }
  }
  if (r2.length >= s3.minLength) {
    let e5 = u$3(i4, s3.offsetFormat);
    o2.push(`${e5}${r2}`);
  }
  return o2;
}
var N$5 = { name: "strings", execute: async (n3, s3) => {
  if (o$3(n3)) return s$1(m$7);
  let o2 = { minLength: 4, offsetFormat: null }, r2 = [], i4 = 0;
  for (; i4 < n3.length; ) {
    let e5 = n3[i4];
    if (e5 === "-n" && i4 + 1 < n3.length) {
      let t4 = Number.parseInt(n3[i4 + 1], 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${n3[i4 + 1]}'
` };
      o2.minLength = t4, i4 += 2;
    } else if (e5.match(/^-n\d+$/)) {
      let t4 = Number.parseInt(e5.slice(2), 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${e5.slice(2)}'
` };
      o2.minLength = t4, i4++;
    } else if (e5.match(/^-\d+$/)) {
      let t4 = Number.parseInt(e5.slice(1), 10);
      if (Number.isNaN(t4) || t4 < 1) return { exitCode: 1, stdout: "", stderr: `strings: invalid minimum string length: '${e5.slice(1)}'
` };
      o2.minLength = t4, i4++;
    } else if (e5 === "-t" && i4 + 1 < n3.length) {
      let t4 = n3[i4 + 1];
      if (t4 !== "o" && t4 !== "x" && t4 !== "d") return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${t4}'
` };
      o2.offsetFormat = t4, i4 += 2;
    } else if (e5.startsWith("-t") && e5.length === 3) {
      let t4 = e5[2];
      if (t4 !== "o" && t4 !== "x" && t4 !== "d") return { exitCode: 1, stdout: "", stderr: `strings: invalid radix: '${t4}'
` };
      o2.offsetFormat = t4, i4++;
    } else if (e5 === "-a" || e5 === "--all" || e5 === "-") e5 === "-" && r2.push(e5), i4++;
    else if (e5 === "-e" && i4 + 1 < n3.length) {
      let t4 = n3[i4 + 1];
      if (t4 !== "s" && t4 !== "S") return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${t4}'
` };
      i4 += 2;
    } else if (e5.startsWith("-e") && e5.length === 3) {
      let t4 = e5[2];
      if (t4 !== "s" && t4 !== "S") return { exitCode: 1, stdout: "", stderr: `strings: invalid encoding: '${t4}'
` };
      i4++;
    } else if (e5 === "--") {
      r2.push(...n3.slice(i4 + 1));
      break;
    } else {
      if (e5.startsWith("-") && e5 !== "-") return r$3("strings", e5);
      r2.push(e5), i4++;
    }
  }
  let l3 = "";
  if (r2.length === 0) {
    let e5 = s3.stdin ?? "", t4 = h$6(e5, o2);
    l3 = t4.length > 0 ? `${t4.join(`
`)}
` : "";
  } else for (let e5 of r2) {
    let t4;
    if (e5 === "-") t4 = s3.stdin ?? "";
    else {
      let g2 = s3.fs.resolvePath(s3.cwd, e5);
      if (t4 = await s3.fs.readFile(g2), t4 === null) return { exitCode: 1, stdout: l3, stderr: `strings: ${e5}: No such file or directory
` };
    }
    let a3 = h$6(t4, o2);
    a3.length > 0 && (l3 += `${a3.join(`
`)}
`);
  }
  return { exitCode: 0, stdout: l3, stderr: "" };
} };
const stringsLRU5XCFP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  strings: N$5
});
var N$4 = { name: "split", summary: "split a file into pieces", usage: "split [OPTION]... [FILE [PREFIX]]", description: "Output pieces of FILE to PREFIXaa, PREFIXab, ...; default size is 1000 lines, and default PREFIX is 'x'.", options: ["-l N         Put N lines per output file", "-b SIZE      Put SIZE bytes per output file (K, M, G suffixes)", "-n CHUNKS    Split into CHUNKS equal-sized files", "-d           Use numeric suffixes (00, 01, ...) instead of alphabetic", "-a LENGTH    Use suffixes of length LENGTH (default: 2)", "--additional-suffix=SUFFIX  Append SUFFIX to file names"], examples: ["split -l 100 file.txt        # Split into 100-line chunks", "split -b 1M file.bin         # Split into 1MB chunks", "split -n 5 file.txt          # Split into 5 equal parts", "split -d file.txt part_      # part_00, part_01, ...", "split -a 3 -d file.txt x     # x000, x001, ..."] };
function p$7(s3) {
  let l3 = s3.match(/^(\d+)([KMGTPEZY]?)([B]?)$/i);
  if (!l3) return null;
  let e5 = Number.parseInt(l3[1], 10);
  if (Number.isNaN(e5) || e5 < 1) return null;
  let u3 = (l3[2] || "").toUpperCase(), o2 = { "": 1, K: 1024, M: 1024 * 1024, G: 1024 * 1024 * 1024, T: 1024 * 1024 * 1024 * 1024, P: 1024 * 1024 * 1024 * 1024 * 1024 }[u3];
  return o2 === void 0 ? null : e5 * o2;
}
function k$5(s3, l3, e5) {
  if (l3) return s3.toString().padStart(e5, "0");
  let u3 = "abcdefghijklmnopqrstuvwxyz", t4 = "", o2 = s3;
  for (let r2 = 0; r2 < e5; r2++) t4 = u3[o2 % 26] + t4, o2 = Math.floor(o2 / 26);
  return t4;
}
function y$6(s3, l3) {
  let e5 = s3.split(`
`), u3 = s3.endsWith(`
`) && e5[e5.length - 1] === "";
  u3 && e5.pop();
  let t4 = [];
  for (let o2 = 0; o2 < e5.length; o2 += l3) {
    let r2 = e5.slice(o2, o2 + l3), c3 = o2 + l3 >= e5.length && !u3 ? r2.join(`
`) : `${r2.join(`
`)}
`;
    t4.push({ content: c3, hasContent: true });
  }
  return t4;
}
function C$7(s3, l3) {
  let u3 = new TextEncoder().encode(s3), t4 = new TextDecoder(), o2 = [];
  for (let r2 = 0; r2 < u3.length; r2 += l3) {
    let f3 = u3.slice(r2, r2 + l3);
    o2.push({ content: t4.decode(f3), hasContent: f3.length > 0 });
  }
  return o2;
}
function S$9(s3, l3) {
  let u3 = new TextEncoder().encode(s3), t4 = new TextDecoder(), o2 = [], r2 = Math.ceil(u3.length / l3);
  for (let f3 = 0; f3 < l3; f3++) {
    let c3 = f3 * r2, i4 = Math.min(c3 + r2, u3.length), n3 = u3.slice(c3, i4);
    o2.push({ content: t4.decode(n3), hasContent: n3.length > 0 });
  }
  return o2;
}
var $$4 = { name: "split", execute: async (s3, l3) => {
  if (o$3(s3)) return s$1(N$4);
  let e5 = { mode: "lines", lines: 1e3, bytes: 0, chunks: 0, useNumericSuffix: false, suffixLength: 2, additionalSuffix: "" }, u3 = [], t4 = 0;
  for (; t4 < s3.length; ) {
    let i4 = s3[t4];
    if (i4 === "-l" && t4 + 1 < s3.length) {
      let n3 = Number.parseInt(s3[t4 + 1], 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${s3[t4 + 1]}'
` };
      e5.mode = "lines", e5.lines = n3, t4 += 2;
    } else if (i4.match(/^-l\d+$/)) {
      let n3 = Number.parseInt(i4.slice(2), 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of lines: '${i4.slice(2)}'
` };
      e5.mode = "lines", e5.lines = n3, t4++;
    } else if (i4 === "-b" && t4 + 1 < s3.length) {
      let n3 = p$7(s3[t4 + 1]);
      if (n3 === null) return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${s3[t4 + 1]}'
` };
      e5.mode = "bytes", e5.bytes = n3, t4 += 2;
    } else if (i4.match(/^-b.+$/)) {
      let n3 = p$7(i4.slice(2));
      if (n3 === null) return { exitCode: 1, stdout: "", stderr: `split: invalid number of bytes: '${i4.slice(2)}'
` };
      e5.mode = "bytes", e5.bytes = n3, t4++;
    } else if (i4 === "-n" && t4 + 1 < s3.length) {
      let n3 = Number.parseInt(s3[t4 + 1], 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${s3[t4 + 1]}'
` };
      e5.mode = "chunks", e5.chunks = n3, t4 += 2;
    } else if (i4.match(/^-n\d+$/)) {
      let n3 = Number.parseInt(i4.slice(2), 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid number of chunks: '${i4.slice(2)}'
` };
      e5.mode = "chunks", e5.chunks = n3, t4++;
    } else if (i4 === "-a" && t4 + 1 < s3.length) {
      let n3 = Number.parseInt(s3[t4 + 1], 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${s3[t4 + 1]}'
` };
      e5.suffixLength = n3, t4 += 2;
    } else if (i4.match(/^-a\d+$/)) {
      let n3 = Number.parseInt(i4.slice(2), 10);
      if (Number.isNaN(n3) || n3 < 1) return { exitCode: 1, stdout: "", stderr: `split: invalid suffix length: '${i4.slice(2)}'
` };
      e5.suffixLength = n3, t4++;
    } else if (i4 === "-d" || i4 === "--numeric-suffixes") e5.useNumericSuffix = true, t4++;
    else if (i4.startsWith("--additional-suffix=")) e5.additionalSuffix = i4.slice(20), t4++;
    else if (i4 === "--additional-suffix" && t4 + 1 < s3.length) e5.additionalSuffix = s3[t4 + 1], t4 += 2;
    else if (i4 === "--") {
      u3.push(...s3.slice(t4 + 1));
      break;
    } else {
      if (i4.startsWith("-") && i4 !== "-") return r$3("split", i4);
      u3.push(i4), t4++;
    }
  }
  let o2 = "-", r2 = "x";
  u3.length >= 1 && (o2 = u3[0]), u3.length >= 2 && (r2 = u3[1]);
  let f3;
  if (o2 === "-") f3 = l3.stdin ?? "";
  else {
    let i4 = l3.fs.resolvePath(l3.cwd, o2), n3 = await l3.fs.readFile(i4);
    if (n3 === null) return { exitCode: 1, stdout: "", stderr: `split: ${o2}: No such file or directory
` };
    f3 = n3;
  }
  if (f3 === "") return { exitCode: 0, stdout: "", stderr: "" };
  let c3;
  switch (e5.mode) {
    case "lines":
      c3 = y$6(f3, e5.lines);
      break;
    case "bytes":
      c3 = C$7(f3, e5.bytes);
      break;
    case "chunks":
      c3 = S$9(f3, e5.chunks);
      break;
    default:
      return e5.mode;
  }
  for (let i4 = 0; i4 < c3.length; i4++) {
    let n3 = c3[i4];
    if (!n3.hasContent) continue;
    let m3 = k$5(i4, e5.useNumericSuffix, e5.suffixLength), x4 = `${r2}${m3}${e5.additionalSuffix}`, b4 = l3.fs.resolvePath(l3.cwd, x4);
    await l3.fs.writeFile(b4, n3.content);
  }
  return { exitCode: 0, stdout: "", stderr: "" };
} };
const splitYBTFW7MT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  split: $$4
});
var W$6 = { name: "column", summary: "columnate lists", usage: "column [OPTION]... [FILE]...", description: "Format input into multiple columns. By default, fills rows first. Use -t to create a table based on whitespace-delimited input.", options: ["-t           Create a table (determine columns from input)", "-s SEP       Input field delimiter (default: whitespace)", "-o SEP       Output field delimiter (default: two spaces)", "-c WIDTH     Output width for fill mode (default: 80)", "-n           Don't merge multiple adjacent delimiters"], examples: ["ls | column              # Fill columns with ls output", "cat data | column -t     # Format as table", "column -t -s ',' file    # Format CSV as table", "column -c 40 file        # Fill 40-char wide columns"] }, j$6 = { table: { short: "t", long: "table", type: "boolean" }, separator: { short: "s", type: "string" }, outputSep: { short: "o", type: "string" }, width: { short: "c", type: "number", default: 80 }, noMerge: { short: "n", type: "boolean" } };
function I$8(t4, e5, o2) {
  return e5 ? o2 ? t4.split(e5) : t4.split(e5).filter((n3) => n3.length > 0) : o2 ? t4.split(/[ \t]/) : t4.split(/[ \t]+/).filter((n3) => n3.length > 0);
}
function x$7(t4) {
  let e5 = [];
  for (let o2 of t4) for (let n3 = 0; n3 < o2.length; n3++) {
    let l3 = o2[n3].length;
    (e5[n3] === void 0 || l3 > e5[n3]) && (e5[n3] = l3);
  }
  return e5;
}
function E$8(t4, e5) {
  if (t4.length === 0) return "";
  let o2 = x$7(t4), n3 = [];
  for (let l3 of t4) {
    let a3 = [];
    for (let s3 = 0; s3 < l3.length; s3++) s3 === l3.length - 1 ? a3.push(l3[s3]) : a3.push(l3[s3].padEnd(o2[s3]));
    n3.push(a3.join(e5));
  }
  return n3.join(`
`);
}
function M$6(t4, e5, o2) {
  if (t4.length === 0) return "";
  let n3 = Math.max(...t4.map((c3) => c3.length)), l3 = o2.length, a3 = n3 + l3, s3 = Math.max(1, Math.floor((e5 + l3) / a3)), h3 = Math.ceil(t4.length / s3), p3 = [];
  for (let c3 = 0; c3 < h3; c3++) {
    let i4 = [];
    for (let r2 = 0; r2 < s3; r2++) {
      let m3 = r2 * h3 + c3;
      m3 < t4.length && (r2 === s3 - 1 || (r2 + 1) * h3 + c3 >= t4.length ? i4.push(t4[m3]) : i4.push(t4[m3].padEnd(n3)));
    }
    p3.push(i4.join(o2));
  }
  return p3.join(`
`);
}
var T$6 = { name: "column", execute: async (t4, e5) => {
  if (o$3(t4)) return s$1(W$6);
  let o2 = x$g("column", t4, j$6);
  if (!o2.ok) return o2.error;
  let { table: n3, separator: l3, outputSep: a3, width: s3, noMerge: h3 } = o2.result.flags, p3 = o2.result.positional, c3 = a3 ?? "  ", i4;
  if (p3.length === 0) i4 = e5.stdin ?? "";
  else {
    let u3 = [];
    for (let f3 of p3) if (f3 === "-") u3.push(e5.stdin ?? "");
    else {
      let w4 = e5.fs.resolvePath(e5.cwd, f3), b4 = await e5.fs.readFile(w4);
      if (b4 === null) return { exitCode: 1, stdout: "", stderr: `column: ${f3}: No such file or directory
` };
      u3.push(b4);
    }
    i4 = u3.join("");
  }
  if (i4 === "" || i4.trim() === "") return { exitCode: 0, stdout: "", stderr: "" };
  let r2 = i4.split(`
`);
  i4.endsWith(`
`) && r2[r2.length - 1] === "" && r2.pop();
  let g2 = r2.filter((u3) => u3.trim().length > 0), d3;
  if (n3) {
    let u3 = g2.map((f3) => I$8(f3, l3, h3));
    d3 = E$8(u3, c3);
  } else {
    let u3 = [];
    for (let f3 of g2) {
      let w4 = I$8(f3, l3, h3);
      u3.push(...w4);
    }
    d3 = M$6(u3, s3, c3);
  }
  return d3.length > 0 && (d3 += `
`), { exitCode: 0, stdout: d3, stderr: "" };
} };
const columnXPDNNO5Y = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  column: T$6
});
var I$7 = { name: "join", summary: "join lines of two files on a common field", usage: "join [OPTION]... FILE1 FILE2", description: "For each pair of input lines with identical join fields, write a line to standard output. The default join field is the first, delimited by blanks.", options: ["-1 FIELD     Join on this FIELD of file 1 (default: 1)", "-2 FIELD     Join on this FIELD of file 2 (default: 1)", "-t CHAR      Use CHAR as input and output field separator", "-a FILENUM   Also print unpairable lines from file FILENUM (1 or 2)", "-v FILENUM   Like -a but only output unpairable lines", "-e STRING    Replace missing fields with STRING", "-o FORMAT    Output format (comma-separated list of FILENUM.FIELD)", "-i           Ignore case when comparing fields"], examples: ["join file1 file2               # Join on first field", "join -1 2 -2 1 file1 file2     # Join file1 col 2 with file2 col 1", "join -t ',' file1.csv file2.csv  # Join CSV files", "join -a 1 file1 file2          # Left outer join"] };
function F$7(t4, s3) {
  return s3 ? t4.split(s3) : t4.split(/[ \t]+/).filter((n3) => n3.length > 0);
}
function L$7(t4, s3, n3, f3) {
  let e5 = F$7(t4, s3), r2 = e5[n3 - 1] ?? "";
  return f3 && (r2 = r2.toLowerCase()), { fields: e5, joinKey: r2, original: t4 };
}
function m$6(t4, s3, n3) {
  let f3 = n3.separator ?? " ";
  if (n3.outputFormat) {
    let l3 = [];
    for (let { file: c3, field: d3 } of n3.outputFormat) {
      let a3 = c3 === 1 ? t4 : s3;
      a3 && d3 === 0 ? l3.push(a3.joinKey) : a3 && a3.fields[d3 - 1] !== void 0 ? l3.push(a3.fields[d3 - 1]) : l3.push(n3.emptyString);
    }
    return l3.join(f3);
  }
  let e5 = [], r2 = t4?.joinKey ?? s3?.joinKey ?? "";
  if (e5.push(r2), t4) for (let l3 = 0; l3 < t4.fields.length; l3++) l3 !== n3.field1 - 1 && e5.push(t4.fields[l3]);
  if (s3) for (let l3 = 0; l3 < s3.fields.length; l3++) l3 !== n3.field2 - 1 && e5.push(s3.fields[l3]);
  return e5.join(f3);
}
function w$8(t4) {
  let s3 = t4.split(","), n3 = [];
  for (let f3 of s3) {
    let e5 = f3.trim().match(/^(\d+)\.(\d+)$/);
    if (!e5) return null;
    let r2 = Number.parseInt(e5[1], 10), l3 = Number.parseInt(e5[2], 10);
    if (r2 !== 1 && r2 !== 2) return null;
    n3.push({ file: r2, field: l3 });
  }
  return n3;
}
var C$6 = { name: "join", execute: async (t4, s3) => {
  if (o$3(t4)) return s$1(I$7);
  let n3 = { field1: 1, field2: 1, separator: null, printUnpairable: /* @__PURE__ */ new Set(), onlyUnpairable: /* @__PURE__ */ new Set(), emptyString: "", outputFormat: null, ignoreCase: false }, f3 = [], e5 = 0;
  for (; e5 < t4.length; ) {
    let i4 = t4[e5];
    if (i4 === "-1" && e5 + 1 < t4.length) {
      let o2 = Number.parseInt(t4[e5 + 1], 10);
      if (Number.isNaN(o2) || o2 < 1) return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${t4[e5 + 1]}'
` };
      n3.field1 = o2, e5 += 2;
    } else if (i4 === "-2" && e5 + 1 < t4.length) {
      let o2 = Number.parseInt(t4[e5 + 1], 10);
      if (Number.isNaN(o2) || o2 < 1) return { exitCode: 1, stdout: "", stderr: `join: invalid field number: '${t4[e5 + 1]}'
` };
      n3.field2 = o2, e5 += 2;
    } else if ((i4 === "-t" || i4 === "--field-separator") && e5 + 1 < t4.length) n3.separator = t4[e5 + 1], e5 += 2;
    else if (i4.startsWith("-t") && i4.length > 2) n3.separator = i4.slice(2), e5++;
    else if (i4 === "-a" && e5 + 1 < t4.length) {
      let o2 = Number.parseInt(t4[e5 + 1], 10);
      if (o2 !== 1 && o2 !== 2) return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${t4[e5 + 1]}'
` };
      n3.printUnpairable.add(o2), e5 += 2;
    } else if (i4.match(/^-a[12]$/)) n3.printUnpairable.add(Number.parseInt(i4[2], 10)), e5++;
    else if (i4 === "-v" && e5 + 1 < t4.length) {
      let o2 = Number.parseInt(t4[e5 + 1], 10);
      if (o2 !== 1 && o2 !== 2) return { exitCode: 1, stdout: "", stderr: `join: invalid file number: '${t4[e5 + 1]}'
` };
      n3.onlyUnpairable.add(o2), e5 += 2;
    } else if (i4.match(/^-v[12]$/)) n3.onlyUnpairable.add(Number.parseInt(i4[2], 10)), e5++;
    else if (i4 === "-e" && e5 + 1 < t4.length) n3.emptyString = t4[e5 + 1], e5 += 2;
    else if (i4 === "-o" && e5 + 1 < t4.length) {
      let o2 = w$8(t4[e5 + 1]);
      if (!o2) return { exitCode: 1, stdout: "", stderr: `join: invalid field spec: '${t4[e5 + 1]}'
` };
      n3.outputFormat = o2, e5 += 2;
    } else if (i4 === "-i" || i4 === "--ignore-case") n3.ignoreCase = true, e5++;
    else if (i4 === "--") {
      f3.push(...t4.slice(e5 + 1));
      break;
    } else {
      if (i4.startsWith("-") && i4 !== "-") return r$3("join", i4);
      f3.push(i4), e5++;
    }
  }
  if (f3.length !== 2) return { exitCode: 1, stdout: "", stderr: f3.length < 2 ? `join: missing file operand
` : `join: extra operand
` };
  let r2 = [];
  for (let i4 of f3) if (i4 === "-") r2.push(s3.stdin ?? "");
  else {
    let o2 = s3.fs.resolvePath(s3.cwd, i4), u3 = await s3.fs.readFile(o2);
    if (u3 === null) return { exitCode: 1, stdout: "", stderr: `join: ${i4}: No such file or directory
` };
    r2.push(u3);
  }
  let l3 = (i4, o2) => {
    let u3 = i4.split(`
`);
    return i4.endsWith(`
`) && u3[u3.length - 1] === "" && u3.pop(), u3.filter((h3) => h3.length > 0).map((h3) => L$7(h3, n3.separator, o2, n3.ignoreCase));
  }, c3 = l3(r2[0], n3.field1), d3 = l3(r2[1], n3.field2), a3 = /* @__PURE__ */ new Map();
  for (let i4 of d3) {
    let o2 = a3.get(i4.joinKey);
    o2 ? o2.push(i4) : a3.set(i4.joinKey, [i4]);
  }
  let p3 = [], j2 = /* @__PURE__ */ new Set();
  for (let i4 of c3) {
    let o2 = a3.get(i4.joinKey);
    if (o2 && o2.length > 0) {
      if (j2.add(i4.joinKey), n3.onlyUnpairable.size === 0) for (let u3 of o2) p3.push(m$6(i4, u3, n3));
    } else (n3.printUnpairable.has(1) || n3.onlyUnpairable.has(1)) && p3.push(m$6(i4, null, n3));
  }
  if (n3.printUnpairable.has(2) || n3.onlyUnpairable.has(2)) for (let i4 of d3) j2.has(i4.joinKey) || p3.push(m$6(null, i4, n3));
  return { exitCode: 0, stdout: p3.length > 0 ? `${p3.join(`
`)}
` : "", stderr: "" };
} };
const joinX3QYPZUA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  join: C$6
});
var h$5 = { name: "tee", summary: "read from stdin and write to stdout and files", usage: "tee [OPTION]... [FILE]...", options: ["-a, --append     append to the given FILEs, do not overwrite", "    --help       display this help and exit"] }, m$5 = { append: { short: "a", long: "append", type: "boolean" } }, g$9 = { name: "tee", async execute(r2, e5) {
  if (o$3(r2)) return s$1(h$5);
  let t4 = x$g("tee", r2, m$5);
  if (!t4.ok) return t4.error;
  let { append: f3 } = t4.result.flags, c3 = t4.result.positional, o2 = e5.stdin, n3 = "", a3 = 0;
  for (let i4 of c3) try {
    let s3 = e5.fs.resolvePath(e5.cwd, i4);
    f3 ? await e5.fs.appendFile(s3, o2) : await e5.fs.writeFile(s3, o2);
  } catch {
    n3 += `tee: ${i4}: No such file or directory
`, a3 = 1;
  }
  return { stdout: o2, stderr: n3, exitCode: a3 };
} };
const tee2QU4NRSJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  teeCommand: g$9
});
function N$3(e5, t4) {
  switch (e5.type) {
    case "name": {
      let n3 = e5.pattern, r2 = n3.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (r2) {
        let s3 = r2[1], o2 = t4.name;
        if (e5.ignoreCase) {
          if (!o2.toLowerCase().endsWith(s3.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!o2.endsWith(s3)) return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: f$3(t4.name, n3, e5.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let n3 = e5.pattern, r2 = t4.relativePath, s3 = n3.split("/");
      for (let a3 = 0; a3 < s3.length - 1; a3++) {
        let i4 = s3[a3];
        if (i4 && i4 !== "." && i4 !== ".." && !i4.includes("*") && !i4.includes("?") && !i4.includes("[")) {
          let c3 = `/${i4}/`;
          if (e5.ignoreCase) {
            if (!r2.toLowerCase().includes(c3.toLowerCase())) return { matches: false, pruned: false, printed: false };
          } else if (!r2.includes(c3)) return { matches: false, pruned: false, printed: false };
        }
      }
      let o2 = n3.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (o2) {
        let a3 = o2[1];
        if (e5.ignoreCase) {
          if (!r2.toLowerCase().endsWith(a3.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!r2.endsWith(a3)) return { matches: false, pruned: false, printed: false };
      }
      return { matches: f$3(r2, n3, e5.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let n3 = e5.ignoreCase ? "i" : "";
        return { matches: new RegExp(e5.pattern, n3).test(t4.relativePath), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e5.fileType === "f" ? { matches: t4.isFile, pruned: false, printed: false } : e5.fileType === "d" ? { matches: t4.isDirectory, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "empty":
      return { matches: t4.isEmpty, pruned: false, printed: false };
    case "mtime": {
      let r2 = (Date.now() - t4.mtime) / (1e3 * 60 * 60 * 24), s3;
      return e5.comparison === "more" ? s3 = r2 > e5.days : e5.comparison === "less" ? s3 = r2 < e5.days : s3 = Math.floor(r2) === e5.days, { matches: s3, pruned: false, printed: false };
    }
    case "newer": {
      let n3 = t4.newerRefTimes.get(e5.refPath);
      return n3 === void 0 ? { matches: false, pruned: false, printed: false } : { matches: t4.mtime > n3, pruned: false, printed: false };
    }
    case "size": {
      let n3 = e5.value;
      switch (e5.unit) {
        case "c":
          n3 = e5.value;
          break;
        case "k":
          n3 = e5.value * 1024;
          break;
        case "M":
          n3 = e5.value * 1024 * 1024;
          break;
        case "G":
          n3 = e5.value * 1024 * 1024 * 1024;
          break;
        case "b":
          n3 = e5.value * 512;
          break;
      }
      let r2;
      return e5.comparison === "more" ? r2 = t4.size > n3 : e5.comparison === "less" ? r2 = t4.size < n3 : e5.unit === "b" ? r2 = Math.ceil(t4.size / 512) === e5.value : r2 = t4.size === n3, { matches: r2, pruned: false, printed: false };
    }
    case "perm": {
      let n3 = t4.mode & 511, r2 = e5.mode & 511, s3;
      return e5.matchType === "exact" ? s3 = n3 === r2 : e5.matchType === "all" ? s3 = (n3 & r2) === r2 : s3 = (n3 & r2) !== 0, { matches: s3, pruned: false, printed: false };
    }
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let n3 = N$3(e5.expr, t4);
      return { matches: !n3.matches, pruned: n3.pruned, printed: false };
    }
    case "and": {
      let n3 = N$3(e5.left, t4);
      if (!n3.matches) return { matches: false, pruned: n3.pruned, printed: false };
      let r2 = N$3(e5.right, t4);
      return { matches: r2.matches, pruned: n3.pruned || r2.pruned, printed: n3.printed || r2.printed };
    }
    case "or": {
      let n3 = N$3(e5.left, t4);
      if (n3.matches) return n3;
      let r2 = N$3(e5.right, t4);
      return { matches: r2.matches, pruned: n3.pruned || r2.pruned, printed: r2.printed };
    }
  }
}
function Y$4(e5) {
  if (!e5) return false;
  switch (e5.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return false;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return true;
    case "not":
      return Y$4(e5.expr);
    case "and":
    case "or":
      return Y$4(e5.left) || Y$4(e5.right);
  }
}
function _$6(e5) {
  if (!e5) return false;
  switch (e5.type) {
    case "empty":
      return true;
    case "not":
      return _$6(e5.expr);
    case "and":
    case "or":
      return _$6(e5.left) || _$6(e5.right);
    default:
      return false;
  }
}
function ce$4(e5) {
  let t4 = { terminalDirName: null, requiredExtension: null };
  if (!e5) return t4;
  let n3 = Se$3(e5);
  if (Ee$3(e5) && n3.length === 1) {
    let o2 = n3[0].split("/").filter((a3) => a3.length > 0);
    if (o2.length >= 2) for (let a3 = o2.length - 2; a3 >= 0; a3--) {
      let i4 = o2[a3];
      if (!i4.includes("*") && !i4.includes("?") && !i4.includes("[") && i4 !== "." && i4 !== "..") {
        let c3 = o2[a3 + 1];
        if (c3 && (c3.includes("*") || c3.includes("?"))) {
          t4.terminalDirName = i4;
          let l3 = c3.match(/^\*(\.[a-zA-Z0-9]+)$/);
          l3 && (t4.requiredExtension = l3[1]);
        }
        break;
      }
    }
  }
  return t4;
}
function Se$3(e5) {
  let t4 = [], n3 = (r2) => {
    r2.type === "path" ? t4.push(r2.pattern) : r2.type === "not" ? n3(r2.expr) : (r2.type === "and" || r2.type === "or") && (n3(r2.left), n3(r2.right));
  };
  return n3(e5), t4;
}
function Ee$3(e5) {
  let t4 = (n3) => n3.type === "type" && n3.fileType === "f" ? true : n3.type === "not" ? t4(n3.expr) : n3.type === "and" || n3.type === "or" ? t4(n3.left) || t4(n3.right) : false;
  return t4(e5);
}
function pe$2(e5) {
  let t4 = [], n3 = (r2) => {
    r2 && (r2.type === "newer" ? t4.push(r2.refPath) : r2.type === "not" ? n3(r2.expr) : (r2.type === "and" || r2.type === "or") && (n3(r2.left), n3(r2.right)));
  };
  return n3(e5), t4;
}
function V$6(e5) {
  if (!e5) return true;
  switch (e5.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return V$6(e5.expr);
    case "and":
    case "or":
      return V$6(e5.left) && V$6(e5.right);
  }
}
function O$8(e5, t4, n3, r2, s3) {
  switch (e5.type) {
    case "name": {
      let o2 = e5.pattern, a3 = o2.match(/^\*(\.[a-zA-Z0-9]+)$/);
      if (a3) {
        let i4 = a3[1];
        if (e5.ignoreCase) {
          if (!t4.toLowerCase().endsWith(i4.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!t4.endsWith(i4)) return { matches: false, pruned: false, printed: false };
        return { matches: true, pruned: false, printed: false };
      }
      return { matches: f$3(t4, o2, e5.ignoreCase), pruned: false, printed: false };
    }
    case "path": {
      let o2 = e5.pattern, a3 = o2.split("/");
      for (let c3 = 0; c3 < a3.length - 1; c3++) {
        let l3 = a3[c3];
        if (l3 && l3 !== "." && l3 !== ".." && !l3.includes("*") && !l3.includes("?") && !l3.includes("[")) {
          let d3 = `/${l3}/`;
          if (e5.ignoreCase) {
            if (!n3.toLowerCase().includes(d3.toLowerCase())) return { matches: false, pruned: false, printed: false };
          } else if (!n3.includes(d3)) return { matches: false, pruned: false, printed: false };
        }
      }
      let i4 = o2.match(/\*(\.[a-zA-Z0-9]+)$/);
      if (i4) {
        let c3 = i4[1];
        if (e5.ignoreCase) {
          if (!n3.toLowerCase().endsWith(c3.toLowerCase())) return { matches: false, pruned: false, printed: false };
        } else if (!n3.endsWith(c3)) return { matches: false, pruned: false, printed: false };
      }
      return { matches: f$3(n3, o2, e5.ignoreCase), pruned: false, printed: false };
    }
    case "regex":
      try {
        let o2 = e5.ignoreCase ? "i" : "";
        return { matches: new RegExp(e5.pattern, o2).test(n3), pruned: false, printed: false };
      } catch {
        return { matches: false, pruned: false, printed: false };
      }
    case "type":
      return e5.fileType === "f" ? { matches: r2, pruned: false, printed: false } : e5.fileType === "d" ? { matches: s3, pruned: false, printed: false } : { matches: false, pruned: false, printed: false };
    case "prune":
      return { matches: true, pruned: true, printed: false };
    case "print":
      return { matches: true, pruned: false, printed: true };
    case "not": {
      let o2 = O$8(e5.expr, t4, n3, r2, s3);
      return { matches: !o2.matches, pruned: o2.pruned, printed: false };
    }
    case "and": {
      let o2 = O$8(e5.left, t4, n3, r2, s3);
      if (!o2.matches) return { matches: false, pruned: o2.pruned, printed: false };
      let a3 = O$8(e5.right, t4, n3, r2, s3);
      return { matches: a3.matches, pruned: o2.pruned || a3.pruned, printed: o2.printed || a3.printed };
    }
    case "or": {
      let o2 = O$8(e5.left, t4, n3, r2, s3);
      if (o2.matches) return o2;
      let a3 = O$8(e5.right, t4, n3, r2, s3);
      return { matches: a3.matches, pruned: o2.pruned || a3.pruned, printed: a3.printed };
    }
    default:
      return { matches: false, pruned: false, printed: false };
  }
}
function J$5(e5) {
  if (!e5) return false;
  switch (e5.type) {
    case "prune":
      return true;
    case "not":
      return J$5(e5.expr);
    case "and":
    case "or":
      return J$5(e5.left) || J$5(e5.right);
    default:
      return false;
  }
}
function z$3(e5) {
  switch (e5.type) {
    case "name":
    case "path":
    case "regex":
    case "type":
    case "prune":
    case "print":
      return true;
    case "empty":
    case "mtime":
    case "newer":
    case "size":
    case "perm":
      return false;
    case "not":
      return z$3(e5.expr);
    case "and":
    case "or":
      return z$3(e5.left) && z$3(e5.right);
  }
}
function fe$3(e5, t4) {
  if (!e5 || !t4.isDirectory) return { shouldPrune: false };
  if (!z$3(e5)) return te$4(e5, t4);
  let n3 = { name: t4.name, relativePath: t4.relativePath, isFile: t4.isFile, isDirectory: t4.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
  return { shouldPrune: N$3(e5, n3).pruned };
}
function te$4(e5, t4) {
  switch (e5.type) {
    case "or": {
      if (z$3(e5.left)) {
        let n3 = { name: t4.name, relativePath: t4.relativePath, isFile: t4.isFile, isDirectory: t4.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        if (N$3(e5.left, n3).pruned) return { shouldPrune: true };
      }
      return te$4(e5.right, t4);
    }
    case "and": {
      if (z$3(e5.left) && z$3(e5.right)) {
        let n3 = { name: t4.name, relativePath: t4.relativePath, isFile: t4.isFile, isDirectory: t4.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return { shouldPrune: N$3(e5, n3).pruned };
      }
      if (z$3(e5.left)) {
        let n3 = { name: t4.name, relativePath: t4.relativePath, isFile: t4.isFile, isDirectory: t4.isDirectory, isEmpty: false, mtime: 0, size: 0, mode: 0, newerRefTimes: /* @__PURE__ */ new Map() };
        return N$3(e5.left, n3).matches ? te$4(e5.right, t4) : { shouldPrune: false };
      }
      return { shouldPrune: false };
    }
    case "not":
      return { shouldPrune: false };
    default:
      return { shouldPrune: false };
  }
}
function ue$3(e5, t4) {
  let n3 = [], r2 = [], s3 = t4;
  for (; s3 < e5.length; ) {
    let a3 = e5[s3];
    if (a3 === "(" || a3 === "\\(") {
      n3.push({ type: "lparen" }), s3++;
      continue;
    }
    if (a3 === ")" || a3 === "\\)") {
      n3.push({ type: "rparen" }), s3++;
      continue;
    }
    if (a3 === "-name" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "name", pattern: e5[++s3] } });
    else if (a3 === "-iname" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "name", pattern: e5[++s3], ignoreCase: true } });
    else if (a3 === "-path" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "path", pattern: e5[++s3] } });
    else if (a3 === "-ipath" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "path", pattern: e5[++s3], ignoreCase: true } });
    else if (a3 === "-regex" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "regex", pattern: e5[++s3] } });
    else if (a3 === "-iregex" && s3 + 1 < e5.length) n3.push({ type: "expr", expr: { type: "regex", pattern: e5[++s3], ignoreCase: true } });
    else if (a3 === "-type" && s3 + 1 < e5.length) {
      let i4 = e5[++s3];
      if (i4 === "f" || i4 === "d") n3.push({ type: "expr", expr: { type: "type", fileType: i4 } });
      else return { expr: null, pathIndex: s3, error: `find: Unknown argument to -type: ${i4}
`, actions: [] };
    } else if (a3 === "-empty") n3.push({ type: "expr", expr: { type: "empty" } });
    else if (a3 === "-mtime" && s3 + 1 < e5.length) {
      let i4 = e5[++s3], c3 = "exact", l3 = i4;
      i4.startsWith("+") ? (c3 = "more", l3 = i4.slice(1)) : i4.startsWith("-") && (c3 = "less", l3 = i4.slice(1));
      let d3 = parseInt(l3, 10);
      Number.isNaN(d3) || n3.push({ type: "expr", expr: { type: "mtime", days: d3, comparison: c3 } });
    } else if (a3 === "-newer" && s3 + 1 < e5.length) {
      let i4 = e5[++s3];
      n3.push({ type: "expr", expr: { type: "newer", refPath: i4 } });
    } else if (a3 === "-size" && s3 + 1 < e5.length) {
      let i4 = e5[++s3], c3 = "exact", l3 = i4;
      i4.startsWith("+") ? (c3 = "more", l3 = i4.slice(1)) : i4.startsWith("-") && (c3 = "less", l3 = i4.slice(1));
      let d3 = l3.match(/^(\d+)([ckMGb])?$/);
      if (d3) {
        let B2 = parseInt(d3[1], 10), F2 = d3[2] || "b";
        n3.push({ type: "expr", expr: { type: "size", value: B2, unit: F2, comparison: c3 } });
      }
    } else if (a3 === "-perm" && s3 + 1 < e5.length) {
      let i4 = e5[++s3], c3 = "exact", l3 = i4;
      i4.startsWith("-") ? (c3 = "all", l3 = i4.slice(1)) : i4.startsWith("/") && (c3 = "any", l3 = i4.slice(1));
      let d3 = parseInt(l3, 8);
      Number.isNaN(d3) || n3.push({ type: "expr", expr: { type: "perm", mode: d3, matchType: c3 } });
    } else if (a3 === "-prune") n3.push({ type: "expr", expr: { type: "prune" } });
    else if (a3 === "-not" || a3 === "!") n3.push({ type: "not" });
    else if (a3 === "-o" || a3 === "-or") n3.push({ type: "op", op: "or" });
    else if (a3 === "-a" || a3 === "-and") n3.push({ type: "op", op: "and" });
    else if (a3 === "-maxdepth" || a3 === "-mindepth") s3++;
    else if (a3 !== "-depth") if (a3 === "-exec") {
      let i4 = [];
      for (s3++; s3 < e5.length && e5[s3] !== ";" && e5[s3] !== "+"; ) i4.push(e5[s3]), s3++;
      if (s3 >= e5.length) return { expr: null, pathIndex: s3, error: "find: missing argument to `-exec'\n", actions: [] };
      let c3 = e5[s3] === "+";
      r2.push({ type: "exec", command: i4, batchMode: c3 });
    } else if (a3 === "-print") n3.push({ type: "expr", expr: { type: "print" } }), r2.push({ type: "print" });
    else if (a3 === "-print0") r2.push({ type: "print0" });
    else if (a3 === "-printf" && s3 + 1 < e5.length) {
      let i4 = e5[++s3];
      r2.push({ type: "printf", format: i4 });
    } else if (a3 === "-delete") r2.push({ type: "delete" });
    else {
      if (a3.startsWith("-")) return { expr: null, pathIndex: s3, error: `find: unknown predicate '${a3}'
`, actions: [] };
      if (n3.length === 0) {
        s3++;
        continue;
      }
      break;
    }
    s3++;
  }
  if (n3.length === 0) return { expr: null, pathIndex: s3, actions: r2 };
  let o2 = be$3(n3);
  return o2.error ? { expr: null, pathIndex: s3, error: o2.error, actions: r2 } : { expr: o2.expr, pathIndex: s3, actions: r2 };
}
function be$3(e5) {
  let t4 = 0;
  function n3() {
    let i4 = r2();
    if (!i4) return null;
    for (; t4 < e5.length; ) {
      let c3 = e5[t4];
      if (c3.type === "op" && c3.op === "or") {
        t4++;
        let l3 = r2();
        if (!l3) return i4;
        i4 = { type: "or", left: i4, right: l3 };
      } else break;
    }
    return i4;
  }
  function r2() {
    let i4 = s3();
    if (!i4) return null;
    for (; t4 < e5.length; ) {
      let c3 = e5[t4];
      if (c3.type === "op" && c3.op === "and") {
        t4++;
        let l3 = s3();
        if (!l3) return i4;
        i4 = { type: "and", left: i4, right: l3 };
      } else if (c3.type === "expr" || c3.type === "not" || c3.type === "lparen") {
        let l3 = s3();
        if (!l3) return i4;
        i4 = { type: "and", left: i4, right: l3 };
      } else break;
    }
    return i4;
  }
  function s3() {
    if (t4 < e5.length && e5[t4].type === "not") {
      t4++;
      let i4 = s3();
      return i4 ? { type: "not", expr: i4 } : null;
    }
    return o2();
  }
  function o2() {
    if (t4 >= e5.length) return null;
    let i4 = e5[t4];
    if (i4.type === "lparen") {
      t4++;
      let c3 = n3();
      return t4 < e5.length && e5[t4].type === "rparen" && t4++, c3;
    }
    return i4.type === "expr" ? (t4++, i4.expr) : (i4.type === "rparen", null);
  }
  return { expr: n3() };
}
var he$3 = 500;
function Me$3() {
  return { readdirCalls: 0, readdirTime: 0, statCalls: 0, statTime: 0, evalCalls: 0, evalTime: 0, nodeCount: 0, batchCount: 0, batchTime: 0, earlyPrunes: 0 };
}
function ve$3(e5, t4, n3) {
  e5({ category: "find", name: "summary", durationMs: n3, details: { readdirCalls: t4.readdirCalls, readdirTimeMs: t4.readdirTime, statCalls: t4.statCalls, statTimeMs: t4.statTime, evalCalls: t4.evalCalls, evalTimeMs: t4.evalTime, nodeCount: t4.nodeCount, batchCount: t4.batchCount, batchTimeMs: t4.batchTime, earlyPrunes: t4.earlyPrunes, otherTimeMs: n3 - t4.readdirTime - t4.statTime - t4.evalTime - t4.batchTime } });
}
var xe$5 = { name: "find", summary: "search for files in a directory hierarchy", usage: "find [path...] [expression]", options: ["-name PATTERN    file name matches shell pattern PATTERN", "-iname PATTERN   like -name but case insensitive", "-path PATTERN    file path matches shell pattern PATTERN", "-ipath PATTERN   like -path but case insensitive", "-regex PATTERN   file path matches regular expression PATTERN", "-iregex PATTERN  like -regex but case insensitive", "-type TYPE       file is of type: f (regular file), d (directory)", "-empty           file is empty or directory is empty", "-mtime N         file's data was modified N*24 hours ago", "-newer FILE      file was modified more recently than FILE", "-size N[ckMGb]   file uses N units of space (c=bytes, k=KB, M=MB, G=GB, b=512B blocks)", "-perm MODE       file's permission bits are exactly MODE (octal)", "-perm -MODE      all permission bits MODE are set", "-perm /MODE      any permission bits MODE are set", "-maxdepth LEVELS descend at most LEVELS directories", "-mindepth LEVELS do not apply tests at levels less than LEVELS", "-depth           process directory contents before directory itself", "-prune           do not descend into this directory", "-not, !          negate the following expression", "-a, -and         logical AND (default)", "-o, -or          logical OR", "-exec CMD {} ;   execute CMD on each file ({} is replaced by filename)", "-exec CMD {} +   execute CMD with multiple files at once", "-print           print the full file name (default action)", "-print0          print the full file name followed by a null character", "-printf FORMAT   print FORMAT with directives: %f %h %p %P %s %d %m %M %t", "-delete          delete found files/directories", "    --help       display this help and exit"] }, Ie$3 = /* @__PURE__ */ new Set(["-name", "-iname", "-path", "-ipath", "-regex", "-iregex", "-type", "-maxdepth", "-mindepth", "-mtime", "-newer", "-size", "-perm"]), qe$4 = { name: "find", async execute(e5, t4) {
  if (o$3(e5)) return s$1(xe$5);
  let n3 = [], r2 = null, s3 = null, o2 = false, a3 = false;
  for (let p3 = 0; p3 < e5.length; p3++) {
    let f3 = e5[p3];
    if (f3 === "-maxdepth" && p3 + 1 < e5.length) a3 = true, r2 = parseInt(e5[++p3], 10);
    else if (f3 === "-mindepth" && p3 + 1 < e5.length) a3 = true, s3 = parseInt(e5[++p3], 10);
    else if (f3 === "-depth") a3 = true, o2 = true;
    else if (f3 === "-exec") for (a3 = true, p3++; p3 < e5.length && e5[p3] !== ";" && e5[p3] !== "+"; ) p3++;
    else !f3.startsWith("-") && f3 !== ";" && f3 !== "+" && f3 !== "(" && f3 !== ")" && f3 !== "\\(" && f3 !== "\\)" && f3 !== "!" ? a3 || n3.push(f3) : Ie$3.has(f3) ? (a3 = true, p3++) : (f3.startsWith("-") || f3 === "(" || f3 === "\\(" || f3 === "!") && (a3 = true);
  }
  n3.length === 0 && n3.push(".");
  let { expr: i4, error: c3, actions: l3 } = ue$3(e5, 0);
  if (c3) return { stdout: "", stderr: c3, exitCode: 1 };
  let d3 = l3.some((p3) => p3.type === "print"), B2 = l3.length === 0, F2 = [], de2 = l3.some((p3) => p3.type === "printf"), ne2 = [], q2 = "", G2 = 0, me2 = pe$2(i4), K2 = /* @__PURE__ */ new Map();
  for (let p3 of me2) {
    let f3 = t4.fs.resolvePath(t4.cwd, p3);
    try {
      let h3 = await t4.fs.stat(f3);
      K2.set(p3, h3.mtime?.getTime() ?? Date.now());
    } catch {
    }
  }
  let ye2 = l3.some((p3) => {
    if (p3.type !== "printf") return false;
    let f3 = p3.format.replace(/%%/g, "");
    return /%[-+]?[0-9]*\.?[0-9]*(s|m|M|t|T)/.test(f3);
  }), ge2 = Y$4(i4) || ye2, we3 = _$6(i4), U2 = ce$4(i4), se3 = J$5(i4), De2 = V$6(i4), Te2 = typeof t4.fs.readdirWithFileTypes == "function";
  for (let p3 of n3) {
    let W4 = function(u3) {
      let R2 = s3 === null || u3.depth >= s3, P2 = false;
      if (R2 && i4 !== null) {
        let S3 = Date.now(), y2;
        if (De2) y2 = O$8(i4, u3.name, u3.relativePath, u3.isFile, u3.isDirectory);
        else {
          let m3 = { name: u3.name, relativePath: u3.relativePath, isFile: u3.isFile, isDirectory: u3.isDirectory, isEmpty: u3.isEmpty, mtime: u3.stat?.mtime?.getTime() ?? Date.now(), size: u3.stat?.size ?? 0, mode: u3.stat?.mode ?? 420, newerRefTimes: K2 };
          y2 = N$3(i4, m3);
        }
        R2 = y2.matches, P2 = d3 ? y2.printed : R2, h3.evalCalls++, h3.evalTime += Date.now() - S3;
      } else R2 && (P2 = true);
      return P2 ? { print: true, printfData: de2 ? { path: u3.relativePath, name: u3.name, size: u3.stat?.size ?? 0, mtime: u3.stat?.mtime?.getTime() ?? Date.now(), mode: u3.stat?.mode ?? 420, isDirectory: u3.isDirectory, depth: u3.depth, startingPoint: p3 } : null } : { print: false, printfData: null };
    };
    p3.length > 1 && p3.endsWith("/") && (p3 = p3.slice(0, -1));
    let f3 = t4.fs.resolvePath(t4.cwd, p3);
    try {
      await t4.fs.stat(f3);
    } catch {
      q2 += `find: ${p3}: No such file or directory
`, G2 = 1;
      continue;
    }
    let h3 = Me$3(), $5 = Date.now();
    async function E2(u3) {
      let { path: b4, depth: R2, typeInfo: P2 } = u3;
      if (h3.nodeCount++, r2 !== null && R2 > r2) return null;
      let M4, S3, y2;
      if (P2 && !ge2) M4 = P2.isFile, S3 = P2.isDirectory;
      else {
        try {
          let L4 = Date.now();
          y2 = await t4.fs.stat(b4), h3.statCalls++, h3.statTime += Date.now() - L4;
        } catch {
          return null;
        }
        if (!y2) return null;
        M4 = y2.isFile, S3 = y2.isDirectory;
      }
      let m3;
      b4 === f3 ? m3 = p3.split("/").pop() || p3 : m3 = b4.split("/").pop() || "";
      let g2 = b4 === f3 ? p3 : p3 === "." ? `./${b4.slice(f3 === "/" ? f3.length : f3.length + 1)}` : p3 + b4.slice(f3.length), T3 = [], C2 = null, w4 = null, D3 = false;
      S3 && se3 && !o2 && (D3 = fe$3(i4, { name: m3, relativePath: g2, isFile: M4, isDirectory: S3 }).shouldPrune, D3 && h3.earlyPrunes++);
      let x4 = r2 !== null && R2 >= r2, I2 = U2.terminalDirName !== null && m3 === U2.terminalDirName, j2 = !x4 && !I2 && !D3;
      if (S3 && ((j2 || we3 || I2) && !D3)) {
        let L4 = Date.now();
        if (Te2 && t4.fs.readdirWithFileTypes) {
          if (C2 = await t4.fs.readdirWithFileTypes(b4), w4 = C2.map((v2) => v2.name), h3.readdirCalls++, h3.readdirTime += Date.now() - L4, j2) T3 = C2.map((v2, k3) => ({ path: b4 === "/" ? `/${v2.name}` : `${b4}/${v2.name}`, depth: R2 + 1, typeInfo: { isFile: v2.isFile, isDirectory: v2.isDirectory }, resultIndex: k3 }));
          else if (I2) {
            let v2 = U2.requiredExtension;
            T3 = C2.filter((k3) => k3.isFile && (!v2 || k3.name.endsWith(v2))).map((k3, Pe2) => ({ path: b4 === "/" ? `/${k3.name}` : `${b4}/${k3.name}`, depth: R2 + 1, typeInfo: { isFile: k3.isFile, isDirectory: k3.isDirectory }, resultIndex: Pe2 }));
          }
        } else w4 = await t4.fs.readdir(b4), h3.readdirCalls++, h3.readdirTime += Date.now() - L4, j2 && (T3 = w4.map((v2, k3) => ({ path: b4 === "/" ? `/${v2}` : `${b4}/${v2}`, depth: R2 + 1, resultIndex: k3 })));
      }
      let Q4 = M4 ? (y2?.size ?? 0) === 0 : w4 !== null && w4.length === 0, H2 = D3;
      if (!o2 && i4 !== null && !D3 && se3) {
        let L4 = Date.now(), v2 = { name: m3, relativePath: g2, isFile: M4, isDirectory: S3, isEmpty: Q4, mtime: y2?.mtime?.getTime() ?? Date.now(), size: y2?.size ?? 0, mode: y2?.mode ?? 420, newerRefTimes: K2 };
        H2 = N$3(i4, v2).pruned, h3.evalCalls++, h3.evalTime += Date.now() - L4;
      }
      return { relativePath: g2, name: m3, isFile: M4, isDirectory: S3, isEmpty: Q4, stat: y2, depth: R2, children: H2 ? [] : T3, pruned: H2 };
    }
    async function Ce2() {
      let u3 = { paths: [], printfData: [] };
      if (o2) {
        let y2 = function(m3) {
          let g2 = { paths: [], printfData: [] }, T3 = P2[m3];
          if (!T3) return g2;
          for (let D3 of T3.childIndices) {
            let x4 = y2(D3);
            g2.paths.push(...x4.paths), g2.printfData.push(...x4.printfData);
          }
          let { print: C2, printfData: w4 } = W4(T3.node);
          return C2 && (g2.paths.push(T3.node.relativePath), w4 && g2.printfData.push(w4)), g2;
        };
        let P2 = [], M4 = [{ item: { path: f3, depth: 0, resultIndex: 0 }, parentIndex: -1, childOrderInParent: 0 }], S3 = /* @__PURE__ */ new Map();
        for (; M4.length > 0; ) {
          let m3 = Date.now(), g2 = M4.splice(0, he$3), T3 = await Promise.all(g2.map((C2) => E2(C2.item)));
          h3.batchCount++, h3.batchTime += Date.now() - m3;
          for (let C2 = 0; C2 < g2.length; C2++) {
            let w4 = T3[C2], D3 = g2[C2];
            if (!w4) continue;
            let x4 = P2.length;
            if (D3.parentIndex >= 0) {
              let I2 = S3.get(D3.parentIndex) || [];
              I2.push(x4), S3.set(D3.parentIndex, I2);
            }
            P2.push({ node: w4, parentIndex: D3.parentIndex, childIndices: [] });
            for (let I2 = 0; I2 < w4.children.length; I2++) M4.push({ item: w4.children[I2], parentIndex: x4, childOrderInParent: I2 });
          }
        }
        for (let [m3, g2] of S3) m3 >= 0 && m3 < P2.length && (P2[m3].childIndices = g2);
        if (P2.length > 0) {
          let m3 = y2(0);
          u3.paths.push(...m3.paths), u3.printfData.push(...m3.printfData);
        }
      } else {
        let m3 = function(g2) {
          let T3 = P2.get(g2);
          T3 && (u3.paths.push(T3.path), T3.printfData && u3.printfData.push(T3.printfData));
          let C2 = y2.get(g2);
          if (C2) for (let w4 of C2) m3(w4);
        };
        let P2 = /* @__PURE__ */ new Map(), M4 = 0, S3 = [{ item: { path: f3, depth: 0, resultIndex: 0 }, orderIndex: M4++ }], y2 = /* @__PURE__ */ new Map();
        for (; S3.length > 0; ) {
          let g2 = Date.now(), T3 = S3.splice(0, he$3), C2 = await Promise.all(T3.map(async ({ item: w4, orderIndex: D3 }) => {
            let x4 = await E2(w4);
            return x4 ? { node: x4, orderIndex: D3 } : null;
          }));
          h3.batchCount++, h3.batchTime += Date.now() - g2;
          for (let w4 of C2) {
            if (!w4) continue;
            let { node: D3, orderIndex: x4 } = w4, { print: I2, printfData: j2 } = W4(D3);
            if (I2 && P2.set(x4, { path: D3.relativePath, printfData: j2 }), D3.children.length > 0) {
              let ee2 = [];
              for (let Q4 of D3.children) {
                let H2 = M4++;
                ee2.push(H2), S3.push({ item: Q4, orderIndex: H2 });
              }
              y2.set(x4, ee2);
            }
          }
        }
        m3(0);
      }
      return u3;
    }
    let X3 = await Ce2();
    if (F2.push(...X3.paths), ne2.push(...X3.printfData), t4.trace) {
      let u3 = Date.now() - $5;
      ve$3(t4.trace, h3, u3), t4.trace({ category: "find", name: "searchPath", durationMs: u3, details: { path: p3, resultsFound: X3.paths.length } });
    }
  }
  let A2 = "";
  if (l3.length > 0) for (let p3 of l3) switch (p3.type) {
    case "print":
      A2 += F2.length > 0 ? `${F2.join(`
`)}
` : "";
      break;
    case "print0":
      A2 += F2.length > 0 ? `${F2.join("\0")}\0` : "";
      break;
    case "delete": {
      let f3 = [...F2].sort((h3, $5) => $5.length - h3.length);
      for (let h3 of f3) {
        let $5 = t4.fs.resolvePath(t4.cwd, h3);
        try {
          await t4.fs.rm($5, { recursive: false });
        } catch (E2) {
          let W4 = E2 instanceof Error ? E2.message : String(E2);
          q2 += `find: cannot delete '${h3}': ${W4}
`, G2 = 1;
        }
      }
      break;
    }
    case "printf":
      for (let f3 of ne2) A2 += Fe$3(p3.format, f3);
      break;
    case "exec":
      if (!t4.exec) return { stdout: "", stderr: `find: -exec not supported in this context
`, exitCode: 1 };
      if (p3.batchMode) {
        let f3 = [];
        for (let E2 of p3.command) E2 === "{}" ? f3.push(...F2) : f3.push(E2);
        let h3 = f3.map((E2) => `"${E2}"`).join(" "), $5 = await t4.exec(h3, { cwd: t4.cwd });
        A2 += $5.stdout, q2 += $5.stderr, $5.exitCode !== 0 && (G2 = $5.exitCode);
      } else for (let f3 of F2) {
        let $5 = p3.command.map((W4) => W4 === "{}" ? f3 : W4).map((W4) => `"${W4}"`).join(" "), E2 = await t4.exec($5, { cwd: t4.cwd });
        A2 += E2.stdout, q2 += E2.stderr, E2.exitCode !== 0 && (G2 = E2.exitCode);
      }
      break;
  }
  else B2 && (A2 = F2.length > 0 ? `${F2.join(`
`)}
` : "");
  return { stdout: A2, stderr: q2, exitCode: G2 };
} };
function Fe$3(e5, t4) {
  let n3 = r$2(e5), r2 = "", s3 = 0;
  for (; s3 < n3.length; ) if (n3[s3] === "%" && s3 + 1 < n3.length) {
    if (s3++, n3[s3] === "%") {
      r2 += "%", s3++;
      continue;
    }
    let [o2, a3, i4] = h$c(n3, s3);
    if (s3 += i4, s3 >= n3.length) {
      r2 += "%";
      break;
    }
    let c3 = n3[s3], l3;
    switch (c3) {
      case "f":
        l3 = t4.name, s3++;
        break;
      case "h": {
        let d3 = t4.path.lastIndexOf("/");
        l3 = d3 > 0 ? t4.path.slice(0, d3) : ".", s3++;
        break;
      }
      case "p":
        l3 = t4.path, s3++;
        break;
      case "P": {
        let d3 = t4.startingPoint;
        t4.path === d3 ? l3 = "" : t4.path.startsWith(`${d3}/`) ? l3 = t4.path.slice(d3.length + 1) : d3 === "." && t4.path.startsWith("./") ? l3 = t4.path.slice(2) : l3 = t4.path, s3++;
        break;
      }
      case "s":
        l3 = String(t4.size), s3++;
        break;
      case "d":
        l3 = String(t4.depth), s3++;
        break;
      case "m":
        l3 = (t4.mode & 511).toString(8), s3++;
        break;
      case "M":
        l3 = $e$2(t4.mode, t4.isDirectory), s3++;
        break;
      case "t": {
        let d3 = new Date(t4.mtime);
        l3 = Re2(d3), s3++;
        break;
      }
      case "T": {
        if (s3 + 1 < n3.length) {
          let d3 = n3[s3 + 1], B2 = new Date(t4.mtime);
          l3 = ke$3(B2, d3), s3 += 2;
        } else l3 = "%T", s3++;
        break;
      }
      default:
        r2 += `%${o2 !== 0 || a3 !== -1 ? `${o2}.${a3}` : ""}${c3}`, s3++;
        continue;
    }
    r2 += i$4(l3, o2, a3);
  } else r2 += n3[s3], s3++;
  return r2;
}
function $e$2(e5, t4) {
  let n3 = e5 & 511, r2 = t4 ? "d" : "-";
  return r2 += n3 & 256 ? "r" : "-", r2 += n3 & 128 ? "w" : "-", r2 += n3 & 64 ? "x" : "-", r2 += n3 & 32 ? "r" : "-", r2 += n3 & 16 ? "w" : "-", r2 += n3 & 8 ? "x" : "-", r2 += n3 & 4 ? "r" : "-", r2 += n3 & 2 ? "w" : "-", r2 += n3 & 1 ? "x" : "-", r2;
}
function Re2(e5) {
  let t4 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], n3 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], r2 = t4[e5.getDay()], s3 = n3[e5.getMonth()], o2 = String(e5.getDate()).padStart(2, " "), a3 = String(e5.getHours()).padStart(2, "0"), i4 = String(e5.getMinutes()).padStart(2, "0"), c3 = String(e5.getSeconds()).padStart(2, "0"), l3 = e5.getFullYear();
  return `${r2} ${s3} ${o2} ${a3}:${i4}:${c3} ${l3}`;
}
function ke$3(e5, t4) {
  switch (t4) {
    case "@":
      return String(e5.getTime() / 1e3);
    case "Y":
      return String(e5.getFullYear());
    case "m":
      return String(e5.getMonth() + 1).padStart(2, "0");
    case "d":
      return String(e5.getDate()).padStart(2, "0");
    case "H":
      return String(e5.getHours()).padStart(2, "0");
    case "M":
      return String(e5.getMinutes()).padStart(2, "0");
    case "S":
      return String(e5.getSeconds()).padStart(2, "0");
    case "T":
      return `${String(e5.getHours()).padStart(2, "0")}:${String(e5.getMinutes()).padStart(2, "0")}:${String(e5.getSeconds()).padStart(2, "0")}`;
    case "F":
      return `${e5.getFullYear()}-${String(e5.getMonth() + 1).padStart(2, "0")}-${String(e5.getDate()).padStart(2, "0")}`;
    default:
      return `%T${t4}`;
  }
}
const findYGMSVGUV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  findCommand: qe$4
});
var p$6 = { name: "basename", summary: "strip directory and suffix from filenames", usage: `basename NAME [SUFFIX]
basename OPTION... NAME...`, options: ["-a, --multiple   support multiple arguments", "-s, --suffix=SUFFIX  remove a trailing SUFFIX", "    --help       display this help and exit"] }, c$3 = { name: "basename", async execute(n3, u3) {
  if (o$3(n3)) return s$1(p$6);
  let i4 = false, s3 = "", a3 = [];
  for (let t4 = 0; t4 < n3.length; t4++) {
    let e5 = n3[t4];
    e5 === "-a" || e5 === "--multiple" ? i4 = true : e5 === "-s" && t4 + 1 < n3.length ? (s3 = n3[++t4], i4 = true) : e5.startsWith("--suffix=") ? (s3 = e5.slice(9), i4 = true) : e5.startsWith("-") || a3.push(e5);
  }
  if (a3.length === 0) return { stdout: "", stderr: `basename: missing operand
`, exitCode: 1 };
  !i4 && a3.length >= 2 && (s3 = a3.pop() ?? "");
  let o2 = [];
  for (let t4 of a3) {
    let e5 = t4.replace(/\/+$/, ""), l3 = e5.split("/").pop() || e5;
    s3 && l3.endsWith(s3) && (l3 = l3.slice(0, -s3.length)), o2.push(l3);
  }
  return { stdout: `${o2.join(`
`)}
`, stderr: "", exitCode: 0 };
} };
const basenameCFA5ZIGT = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  basenameCommand: c$3
});
var m$4 = { name: "dirname", summary: "strip last component from file name", usage: "dirname [OPTION] NAME...", options: ["    --help       display this help and exit"] }, p$5 = { name: "dirname", async execute(t4, l3) {
  if (o$3(t4)) return s$1(m$4);
  let a3 = t4.filter((n3) => !n3.startsWith("-"));
  if (a3.length === 0) return { stdout: "", stderr: `dirname: missing operand
`, exitCode: 1 };
  let e5 = [];
  for (let n3 of a3) {
    let r2 = n3.replace(/\/+$/, ""), s3 = r2.lastIndexOf("/");
    s3 === -1 ? e5.push(".") : s3 === 0 ? e5.push("/") : e5.push(r2.slice(0, s3));
  }
  return { stdout: `${e5.join(`
`)}
`, stderr: "", exitCode: 0 };
} };
const dirnameYPJLCQYA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  dirnameCommand: p$5
});
var g$8 = { name: "tree", summary: "list contents of directories in a tree-like format", usage: "tree [OPTION]... [DIRECTORY]...", options: ["-a          include hidden files", "-d          list directories only", "-L LEVEL    limit depth of directory tree", "-f          print full path prefix for each file", "    --help  display this help and exit"] }, T$5 = { showHidden: { short: "a", type: "boolean" }, directoriesOnly: { short: "d", type: "boolean" }, fullPath: { short: "f", type: "boolean" }, maxDepth: { short: "L", type: "number" } }, E$7 = { name: "tree", async execute(i4, o2) {
  if (o$3(i4)) return s$1(g$8);
  let s3 = x$g("tree", i4, T$5);
  if (!s3.ok) return s3.error;
  let f3 = { showHidden: s3.result.flags.showHidden, directoriesOnly: s3.result.flags.directoriesOnly, maxDepth: s3.result.flags.maxDepth ?? null, fullPath: s3.result.flags.fullPath }, d3 = s3.result.positional;
  d3.length === 0 && d3.push(".");
  let t4 = "", l3 = "", a3 = 0, n3 = 0;
  for (let e5 of d3) {
    let r2 = await b$6(o2, e5, f3, "", 0);
    t4 += r2.output, l3 += r2.stderr, a3 += r2.dirCount, n3 += r2.fileCount;
  }
  return t4 += `
${a3} director${a3 === 1 ? "y" : "ies"}`, f3.directoriesOnly || (t4 += `, ${n3} file${n3 === 1 ? "" : "s"}`), t4 += `
`, { stdout: t4, stderr: l3, exitCode: l3 ? 1 : 0 };
} };
async function b$6(i4, o2, s3, f3, d3) {
  let t4 = { output: "", stderr: "", dirCount: 0, fileCount: 0 }, l3 = i4.fs.resolvePath(i4.cwd, o2);
  try {
    if (!(await i4.fs.stat(l3)).isDirectory) return t4.output = `${o2}
`, t4.fileCount = 1, t4;
  } catch {
    return t4.stderr = `tree: ${o2}: No such file or directory
`, t4;
  }
  if (t4.output = `${o2}
`, s3.maxDepth !== null && d3 >= s3.maxDepth) return t4;
  try {
    let a3 = [];
    if (i4.fs.readdirWithFileTypes) a3 = (await i4.fs.readdirWithFileTypes(l3)).map((r2) => ({ name: r2.name, isDirectory: r2.isDirectory }));
    else {
      let e5 = await i4.fs.readdir(l3);
      for (let r2 = 0; r2 < e5.length; r2 += 100) {
        let h3 = e5.slice(r2, r2 + 100), u3 = await Promise.all(h3.map(async (c3) => {
          let m3 = l3 === "/" ? `/${c3}` : `${l3}/${c3}`;
          try {
            let y2 = await i4.fs.stat(m3);
            return { name: c3, isDirectory: y2.isDirectory };
          } catch {
            return null;
          }
        }));
        a3.push(...u3.filter((c3) => c3 !== null));
      }
    }
    let n3 = a3.filter((e5) => !(!s3.showHidden && e5.name.startsWith(".") || s3.directoriesOnly && !e5.isDirectory));
    n3.sort((e5, r2) => e5.name.localeCompare(r2.name));
    for (let e5 = 0; e5 < n3.length; e5++) {
      let r2 = n3[e5], h3 = l3 === "/" ? `/${r2.name}` : `${l3}/${r2.name}`, u3 = e5 === n3.length - 1, c3 = u3 ? "`-- " : "|-- ", m3 = f3 + (u3 ? "    " : "|   ");
      if (r2.isDirectory) {
        t4.dirCount++;
        let y2 = s3.fullPath ? h3 : r2.name;
        if (t4.output += `${f3 + c3 + y2}
`, s3.maxDepth === null || d3 + 1 < s3.maxDepth) {
          let C2 = await P$6(i4, h3, s3, m3, d3 + 1);
          t4.output += C2.output, t4.dirCount += C2.dirCount, t4.fileCount += C2.fileCount;
        }
      } else {
        t4.fileCount++;
        let y2 = s3.fullPath ? h3 : r2.name;
        t4.output += `${f3 + c3 + y2}
`;
      }
    }
  } catch {
    t4.stderr = `tree: ${o2}: Permission denied
`;
  }
  return t4;
}
async function P$6(i4, o2, s3, f3, d3) {
  let t4 = { output: "", stderr: "", dirCount: 0, fileCount: 0 };
  if (s3.maxDepth !== null && d3 >= s3.maxDepth) return t4;
  try {
    let l3 = [];
    if (i4.fs.readdirWithFileTypes) l3 = (await i4.fs.readdirWithFileTypes(o2)).map((e5) => ({ name: e5.name, isDirectory: e5.isDirectory }));
    else {
      let n3 = await i4.fs.readdir(o2);
      for (let e5 = 0; e5 < n3.length; e5 += 100) {
        let r2 = n3.slice(e5, e5 + 100), h3 = await Promise.all(r2.map(async (u3) => {
          let c3 = o2 === "/" ? `/${u3}` : `${o2}/${u3}`;
          try {
            let m3 = await i4.fs.stat(c3);
            return { name: u3, isDirectory: m3.isDirectory };
          } catch {
            return null;
          }
        }));
        l3.push(...h3.filter((u3) => u3 !== null));
      }
    }
    let a3 = l3.filter((n3) => !(!s3.showHidden && n3.name.startsWith(".") || s3.directoriesOnly && !n3.isDirectory));
    a3.sort((n3, e5) => n3.name.localeCompare(e5.name));
    for (let n3 = 0; n3 < a3.length; n3++) {
      let e5 = a3[n3], r2 = o2 === "/" ? `/${e5.name}` : `${o2}/${e5.name}`, h3 = n3 === a3.length - 1, u3 = h3 ? "`-- " : "|-- ", c3 = f3 + (h3 ? "    " : "|   ");
      if (e5.isDirectory) {
        t4.dirCount++;
        let m3 = s3.fullPath ? r2 : e5.name;
        t4.output += `${f3 + u3 + m3}
`;
        let y2 = await P$6(i4, r2, s3, c3, d3 + 1);
        t4.output += y2.output, t4.dirCount += y2.dirCount, t4.fileCount += y2.fileCount;
      } else {
        t4.fileCount++;
        let m3 = s3.fullPath ? r2 : e5.name;
        t4.output += `${f3 + u3 + m3}
`;
      }
    }
  } catch {
  }
  return t4;
}
const treeMEM64BW3 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  treeCommand: E$7
});
var R$6 = { name: "du", summary: "estimate file space usage", usage: "du [OPTION]... [FILE]...", options: ["-a          write counts for all files, not just directories", "-h          print sizes in human readable format", "-s          display only a total for each argument", "-c          produce a grand total", "--max-depth=N  print total for directory only if N or fewer levels deep", "    --help  display this help and exit"] }, x$6 = { allFiles: { short: "a", type: "boolean" }, humanReadable: { short: "h", type: "boolean" }, summarize: { short: "s", type: "boolean" }, grandTotal: { short: "c", type: "boolean" }, maxDepth: { long: "max-depth", type: "number" } }, H$7 = { name: "du", async execute(a3, s3) {
  if (o$3(a3)) return s$1(R$6);
  let n3 = x$g("du", a3, x$6);
  if (!n3.ok) return n3.error;
  let r2 = { allFiles: n3.result.flags.allFiles, humanReadable: n3.result.flags.humanReadable, summarize: n3.result.flags.summarize, grandTotal: n3.result.flags.grandTotal, maxDepth: n3.result.flags.maxDepth ?? null }, c3 = n3.result.positional;
  c3.length === 0 && c3.push(".");
  let o2 = "", m3 = "", h3 = 0;
  for (let l3 of c3) {
    let z2 = s3.fs.resolvePath(s3.cwd, l3);
    try {
      await s3.fs.stat(z2);
      let p3 = await b$5(s3, z2, l3, r2, 0);
      o2 += p3.output, h3 += p3.totalSize, m3 += p3.stderr;
    } catch {
      m3 += `du: cannot access '${l3}': No such file or directory
`;
    }
  }
  return r2.grandTotal && c3.length > 0 && (o2 += `${D$6(h3, r2.humanReadable)}	total
`), { stdout: o2, stderr: m3, exitCode: m3 ? 1 : 0 };
} };
async function b$5(a3, s3, n3, r2, c3) {
  let o2 = { output: "", totalSize: 0, stderr: "" };
  try {
    let m3 = await a3.fs.stat(s3);
    if (!m3.isDirectory) return o2.totalSize = m3.size, (r2.allFiles || c3 === 0) && (o2.output = D$6(m3.size, r2.humanReadable) + "	" + n3 + `
`), o2;
    let h3 = 0, l3 = [];
    if (a3.fs.readdirWithFileTypes) {
      let t4 = await a3.fs.readdirWithFileTypes(s3), i4 = t4.filter((e5) => e5.isFile), f3 = t4.filter((e5) => e5.isDirectory);
      for (let e5 = 0; e5 < i4.length; e5 += 100) {
        let u3 = i4.slice(e5, e5 + 100), g2 = await Promise.all(u3.map(async (d3) => {
          let T3 = s3 === "/" ? `/${d3.name}` : `${s3}/${d3.name}`;
          try {
            let S3 = await a3.fs.stat(T3);
            return { name: d3.name, isDirectory: false, size: S3.size };
          } catch {
            return { name: d3.name, isDirectory: false, size: 0 };
          }
        }));
        l3.push(...g2);
      }
      l3.push(...f3.map((e5) => ({ name: e5.name, isDirectory: true })));
    } else {
      let t4 = await a3.fs.readdir(s3);
      for (let i4 = 0; i4 < t4.length; i4 += 100) {
        let f3 = t4.slice(i4, i4 + 100), e5 = await Promise.all(f3.map(async (u3) => {
          let g2 = s3 === "/" ? `/${u3}` : `${s3}/${u3}`;
          try {
            let d3 = await a3.fs.stat(g2);
            return { name: u3, isDirectory: d3.isDirectory, size: d3.isDirectory ? void 0 : d3.size };
          } catch {
            return { name: u3, isDirectory: false, size: 0 };
          }
        }));
        l3.push(...e5);
      }
    }
    l3.sort((t4, i4) => t4.name.localeCompare(i4.name));
    let z2 = l3.filter((t4) => !t4.isDirectory);
    for (let t4 of z2) {
      let i4 = t4.size ?? 0;
      if (h3 += i4, r2.allFiles && !r2.summarize) {
        let f3 = n3 === "." ? t4.name : `${n3}/${t4.name}`;
        o2.output += D$6(i4, r2.humanReadable) + "	" + f3 + `
`;
      }
    }
    let p3 = l3.filter((t4) => t4.isDirectory);
    for (let t4 = 0; t4 < p3.length; t4 += 100) {
      let i4 = p3.slice(t4, t4 + 100), f3 = await Promise.all(i4.map(async (e5) => {
        let u3 = s3 === "/" ? `/${e5.name}` : `${s3}/${e5.name}`, g2 = n3 === "." ? e5.name : `${n3}/${e5.name}`;
        return { name: e5.name, result: await b$5(a3, u3, g2, r2, c3 + 1) };
      }));
      f3.sort((e5, u3) => e5.name.localeCompare(u3.name));
      for (let { result: e5 } of f3) h3 += e5.totalSize, r2.summarize || (r2.maxDepth === null || c3 + 1 <= r2.maxDepth) && (o2.output += e5.output);
    }
    o2.totalSize = h3, (r2.summarize || r2.maxDepth === null || c3 <= r2.maxDepth) && (o2.output += `${D$6(h3, r2.humanReadable)}	${n3}
`);
  } catch {
    o2.stderr = `du: cannot read directory '${n3}': Permission denied
`;
  }
  return o2;
}
function D$6(a3, s3) {
  return s3 ? a3 < 1024 ? `${a3}` : a3 < 1024 * 1024 ? `${(a3 / 1024).toFixed(1)}K` : a3 < 1024 * 1024 * 1024 ? `${(a3 / (1024 * 1024)).toFixed(1)}M` : `${(a3 / (1024 * 1024 * 1024)).toFixed(1)}G` : String(Math.ceil(a3 / 1024) || 1);
}
const duNQXEC3EF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  duCommand: H$7
});
var g$7 = { name: "env", summary: "run a program in a modified environment", usage: "env [OPTION]... [NAME=VALUE]... [COMMAND [ARG]...]", options: ["-i, --ignore-environment  start with an empty environment", "-u NAME, --unset=NAME     remove NAME from the environment", "    --help                display this help and exit"] }, C$5 = { name: "env", async execute(s3, i4) {
  if (o$3(s3)) return s$1(g$7);
  let u3 = false, o2 = [], c3 = {}, t4 = -1;
  for (let n3 = 0; n3 < s3.length; n3++) {
    let e5 = s3[n3];
    if (e5 === "-i" || e5 === "--ignore-environment") u3 = true;
    else if (e5 === "-u" && n3 + 1 < s3.length) o2.push(s3[++n3]);
    else if (e5.startsWith("-u")) o2.push(e5.slice(2));
    else if (e5.startsWith("--unset=")) o2.push(e5.slice(8));
    else {
      if (e5.startsWith("--") && e5 !== "--") return r$3("env", e5);
      if (e5.startsWith("-") && e5 !== "-") {
        for (let r2 of e5.slice(1)) if (r2 !== "i" && r2 !== "u") return r$3("env", `-${r2}`);
        e5.includes("i") && (u3 = true);
      } else if (e5.includes("=") && t4 === -1) {
        let r2 = e5.indexOf("="), O2 = e5.slice(0, r2), $5 = e5.slice(r2 + 1);
        c3[O2] = $5;
      } else {
        t4 = n3;
        break;
      }
    }
  }
  let l3;
  if (u3) l3 = { ...c3 };
  else {
    l3 = { ...i4.env };
    for (let n3 of o2) delete l3[n3];
    Object.assign(l3, c3);
  }
  if (t4 === -1) {
    let n3 = [];
    for (let [e5, r2] of Object.entries(l3)) n3.push(`${e5}=${r2}`);
    return { stdout: n3.join(`
`) + (n3.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
  }
  if (!i4.exec) return { stdout: "", stderr: `env: command execution not supported in this context
`, exitCode: 1 };
  let a3 = s3.slice(t4), h3 = a3[0], x4 = a3.slice(1).map((n3) => /[\s"'\\$`!*?[\]{}|&;<>()]/.test(n3) ? `'${n3.replace(/'/g, "'\\''")}'` : n3), p3 = ["command", h3, ...x4].join(" "), v2 = Object.entries(c3).map(([n3, e5]) => `${n3}="${e5}"`).join(" "), A2 = v2 ? `${v2} ${p3}` : p3;
  return i4.exec(A2, { cwd: i4.cwd });
} }, j$5 = { name: "printenv", summary: "print all or part of environment", usage: "printenv [OPTION]... [VARIABLE]...", options: ["    --help       display this help and exit"] }, E$6 = { name: "printenv", async execute(s3, i4) {
  if (o$3(s3)) return s$1(j$5);
  let u3 = s3.filter((t4) => !t4.startsWith("-"));
  if (u3.length === 0) {
    let t4 = [];
    for (let [l3, a3] of Object.entries(i4.env)) t4.push(`${l3}=${a3}`);
    return { stdout: t4.join(`
`) + (t4.length > 0 ? `
` : ""), stderr: "", exitCode: 0 };
  }
  let o2 = [], c3 = 0;
  for (let t4 of u3) t4 in i4.env ? o2.push(i4.env[t4]) : c3 = 1;
  return { stdout: o2.join(`
`) + (o2.length > 0 ? `
` : ""), stderr: "", exitCode: c3 };
} };
const env2UI6XINU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  envCommand: C$5,
  printenvCommand: E$6
});
var u$2 = { name: "alias", summary: "define or display aliases", usage: "alias [name[=value] ...]", options: ["    --help display this help and exit"] }, o$2 = "BASH_ALIAS_", m$3 = { name: "alias", async execute(e5, a3) {
  if (o$3(e5)) return s$1(u$2);
  if (e5.length === 0) {
    let t4 = "";
    for (let [i4, s3] of Object.entries(a3.env)) if (i4.startsWith(o$2)) {
      let n3 = i4.slice(o$2.length);
      t4 += `alias ${n3}='${s3}'
`;
    }
    return { stdout: t4, stderr: "", exitCode: 0 };
  }
  let l3 = e5[0] === "--" ? e5.slice(1) : e5;
  for (let t4 of l3) {
    let i4 = t4.indexOf("=");
    if (i4 === -1) {
      let s3 = o$2 + t4;
      return a3.env[s3] ? { stdout: `alias ${t4}='${a3.env[s3]}'
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: `alias: ${t4}: not found
`, exitCode: 1 };
    } else {
      let s3 = t4.slice(0, i4), n3 = t4.slice(i4 + 1);
      (n3.startsWith("'") && n3.endsWith("'") || n3.startsWith('"') && n3.endsWith('"')) && (n3 = n3.slice(1, -1)), a3.env[o$2 + s3] = n3;
    }
  }
  return { stdout: "", stderr: "", exitCode: 0 };
} }, c$2 = { name: "unalias", async execute(e5, a3) {
  if (o$3(e5)) return s$1({ name: "unalias", summary: "remove alias definitions", usage: "unalias name [name ...]", options: ["-a      remove all aliases", "    --help display this help and exit"] });
  if (e5.length === 0) return { stdout: "", stderr: `unalias: usage: unalias [-a] name [name ...]
`, exitCode: 1 };
  if (e5[0] === "-a") {
    for (let s3 of Object.keys(a3.env)) s3.startsWith(o$2) && delete a3.env[s3];
    return { stdout: "", stderr: "", exitCode: 0 };
  }
  let l3 = e5[0] === "--" ? e5.slice(1) : e5, t4 = false, i4 = "";
  for (let s3 of l3) {
    let n3 = o$2 + s3;
    a3.env[n3] ? delete a3.env[n3] : (i4 += `unalias: ${s3}: not found
`, t4 = true);
  }
  return { stdout: "", stderr: i4, exitCode: t4 ? 1 : 0 };
} };
const aliasATFBB6D2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  aliasCommand: m$3,
  unaliasCommand: c$2
});
var d$5 = { name: "history", summary: "display command history", usage: "history [n]", options: ["-c      clear the history list", "    --help display this help and exit"] }, l$4 = "BASH_HISTORY", m$2 = { name: "history", async execute(e5, n3) {
  if (o$3(e5)) return s$1(d$5);
  let a3 = n3.env[l$4] || "[]", t4;
  try {
    t4 = JSON.parse(a3);
  } catch {
    t4 = [];
  }
  if (e5[0] === "-c") return n3.env[l$4] = "[]", { stdout: "", stderr: "", exitCode: 0 };
  let s3 = t4.length;
  e5[0] && /^\d+$/.test(e5[0]) && (s3 = Math.min(parseInt(e5[0], 10), t4.length));
  let c3 = t4.length - s3, r2 = "";
  for (let o2 = c3; o2 < t4.length; o2++) {
    let y2 = (o2 + 1).toString().padStart(5, " ");
    r2 += `${y2}  ${t4[o2]}
`;
  }
  return { stdout: r2, stderr: "", exitCode: 0 };
} };
const historyMQDK2OPD = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  historyCommand: m$2
});
var E$5 = { name: "xargs", summary: "build and execute command lines from standard input", usage: "xargs [OPTION]... [COMMAND [INITIAL-ARGS]]", options: ["-I REPLACE   replace occurrences of REPLACE with input", "-d DELIM     use DELIM as input delimiter (e.g., -d '\\n' for newline)", "-n NUM       use at most NUM arguments per command line", "-P NUM       run at most NUM processes at a time", "-0, --null   items are separated by null, not whitespace", "-t, --verbose  print commands before executing", "-r, --no-run-if-empty  do not run command if input is empty", "    --help   display this help and exit"] }, P$5 = { name: "xargs", async execute(s3, i4) {
  if (o$3(s3)) return s$1(E$5);
  let p3 = null, h3 = null, c3 = null, o2 = null, g2 = false, x4 = false, C2 = false, l3 = 0;
  for (let e5 = 0; e5 < s3.length; e5++) {
    let t4 = s3[e5];
    if (t4 === "-I" && e5 + 1 < s3.length) p3 = s3[++e5], l3 = e5 + 1;
    else if (t4 === "-d" && e5 + 1 < s3.length) h3 = s3[++e5].replace(/\\n/g, `
`).replace(/\\t/g, "	").replace(/\\r/g, "\r").replace(/\\0/g, "\0").replace(/\\\\/g, "\\"), l3 = e5 + 1;
    else if (t4 === "-n" && e5 + 1 < s3.length) c3 = parseInt(s3[++e5], 10), l3 = e5 + 1;
    else if (t4 === "-P" && e5 + 1 < s3.length) o2 = parseInt(s3[++e5], 10), l3 = e5 + 1;
    else if (t4 === "-0" || t4 === "--null") g2 = true, l3 = e5 + 1;
    else if (t4 === "-t" || t4 === "--verbose") x4 = true, l3 = e5 + 1;
    else if (t4 === "-r" || t4 === "--no-run-if-empty") C2 = true, l3 = e5 + 1;
    else {
      if (t4.startsWith("--")) return r$3("xargs", t4);
      if (t4.startsWith("-") && t4.length > 1) {
        for (let n3 of t4.slice(1)) if (!"0tr".includes(n3)) return r$3("xargs", `-${n3}`);
        t4.includes("0") && (g2 = true), t4.includes("t") && (x4 = true), t4.includes("r") && (C2 = true), l3 = e5 + 1;
      } else if (!t4.startsWith("-")) {
        l3 = e5;
        break;
      }
    }
  }
  let a3 = s3.slice(l3);
  a3.length === 0 && a3.push("echo");
  let r2;
  if (g2 ? r2 = i4.stdin.split("\0").filter((e5) => e5.length > 0) : h3 !== null ? r2 = i4.stdin.replace(/\n$/, "").split(h3).filter((t4) => t4.length > 0) : r2 = i4.stdin.split(/\s+/).map((e5) => e5.trim()).filter((e5) => e5.length > 0), r2.length === 0) return C2 ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
  let d3 = "", u3 = "", f3 = 0, M4 = (e5) => /[\s"'\\$`!*?[\]{}();&|<>#]/.test(e5) ? `"${e5.replace(/([\\"`$])/g, "\\$1")}"` : e5, w4 = async (e5) => {
    let t4 = e5.map(M4).join(" ");
    return x4 && (u3 += `${t4}
`), i4.exec ? i4.exec(t4, { cwd: i4.cwd }) : { stdout: `${t4}
`, stderr: "", exitCode: 0 };
  }, I2 = async (e5) => {
    if (o2 !== null && o2 > 1) for (let t4 = 0; t4 < e5.length; t4 += o2) {
      let n3 = e5.slice(t4, t4 + o2), $5 = await Promise.all(n3.map(w4));
      for (let m3 of $5) d3 += m3.stdout, u3 += m3.stderr, m3.exitCode !== 0 && (f3 = m3.exitCode);
    }
    else for (let t4 of e5) {
      let n3 = await w4(t4);
      d3 += n3.stdout, u3 += n3.stderr, n3.exitCode !== 0 && (f3 = n3.exitCode);
    }
  };
  if (p3 !== null) {
    let e5 = r2.map((t4) => a3.map((n3) => n3.replaceAll(p3, t4)));
    await I2(e5);
  } else if (c3 !== null) {
    let e5 = [];
    for (let t4 = 0; t4 < r2.length; t4 += c3) {
      let n3 = r2.slice(t4, t4 + c3);
      e5.push([...a3, ...n3]);
    }
    await I2(e5);
  } else {
    let e5 = [...a3, ...r2], t4 = await w4(e5);
    d3 += t4.stdout, u3 += t4.stderr, f3 = t4.exitCode;
  }
  return { stdout: d3, stderr: u3, exitCode: f3 };
} };
const xargs4FRA6OJ7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  xargsCommand: P$5
});
var e$3 = { name: "true", async execute() {
  return { stdout: "", stderr: "", exitCode: 0 };
} }, t$2 = { name: "false", async execute() {
  return { stdout: "", stderr: "", exitCode: 1 };
} };
const trueCNJ54NE6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  falseCommand: t$2,
  trueCommand: e$3
});
var t$1 = { name: "clear", summary: "clear the terminal screen", usage: "clear [OPTIONS]", options: ["    --help display this help and exit"] }, s = { name: "clear", async execute(a3, c3) {
  return o$3(a3) ? s$1(t$1) : { stdout: "\x1B[2J\x1B[H", stderr: "", exitCode: 0 };
} };
const clearVT2LJIDX = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  clearCommand: s
});
var l$3 = { name: "bash", summary: "execute shell commands or scripts", usage: "bash [OPTIONS] [SCRIPT_FILE] [ARGUMENTS...]", options: ["-c COMMAND  execute COMMAND string", "    --help  display this help and exit"], notes: ["Without -c, reads and executes commands from SCRIPT_FILE.", "Arguments are passed as $1, $2, etc. to the script.", '$0 is set to the script name (or "bash" with -c).'] }, f$1 = { name: "bash", async execute(e5, t4) {
  if (o$3(e5)) return s$1(l$3);
  if (e5[0] === "-c" && e5.length >= 2) {
    let r2 = e5[1], s3 = e5[2] || "bash", c3 = e5.slice(3);
    return i$3(r2, s3, c3, t4);
  }
  if (e5.length === 0) return t4.stdin?.trim() ? i$3(t4.stdin, "bash", [], t4) : { stdout: "", stderr: "", exitCode: 0 };
  let n3 = e5[0], o2 = e5.slice(1);
  try {
    let r2 = t4.fs.resolvePath(t4.cwd, n3), s3 = await t4.fs.readFile(r2);
    return i$3(s3, n3, o2, t4);
  } catch {
    return { stdout: "", stderr: `bash: ${n3}: No such file or directory
`, exitCode: 127 };
  }
} }, p$4 = { name: "sh", async execute(e5, t4) {
  if (o$3(e5)) return s$1({ ...l$3, name: "sh", summary: "execute shell commands or scripts (POSIX shell)" });
  if (e5[0] === "-c" && e5.length >= 2) {
    let r2 = e5[1], s3 = e5[2] || "sh", c3 = e5.slice(3);
    return i$3(r2, s3, c3, t4);
  }
  if (e5.length === 0) return t4.stdin?.trim() ? i$3(t4.stdin, "sh", [], t4) : { stdout: "", stderr: "", exitCode: 0 };
  let n3 = e5[0], o2 = e5.slice(1);
  try {
    let r2 = t4.fs.resolvePath(t4.cwd, n3), s3 = await t4.fs.readFile(r2);
    return i$3(s3, n3, o2, t4);
  } catch {
    return { stdout: "", stderr: `sh: ${n3}: No such file or directory
`, exitCode: 127 };
  }
} };
async function i$3(e5, t4, n3, o2) {
  if (!o2.exec) return { stdout: "", stderr: `bash: internal error: exec function not available
`, exitCode: 1 };
  let r2 = { ...o2.exportedEnv || {}, 0: t4, "#": String(n3.length), "@": n3.join(" "), "*": n3.join(" ") };
  n3.forEach((a3, u3) => {
    r2[String(u3 + 1)] = a3;
  });
  let s3 = e5;
  if (s3.startsWith("#!")) {
    let a3 = s3.indexOf(`
`);
    a3 !== -1 && (s3 = s3.slice(a3 + 1));
  }
  return await o2.exec(s3, { env: r2, cwd: o2.cwd });
}
const bashOLRNM52U = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  bashCommand: f$1,
  shCommand: p$4
});
function K$2(t4, r2, e5, n3, p3, i4, u3, f3, s3, c3) {
  switch (r2) {
    case "sort":
      return Array.isArray(t4) ? [[...t4].sort(u3)] : [null];
    case "sort_by":
      return !Array.isArray(t4) || e5.length === 0 ? [null] : [[...t4].sort((h3, y2) => {
        let a3 = p3(h3, e5[0], n3)[0], l3 = p3(y2, e5[0], n3)[0];
        return u3(a3, l3);
      })];
    case "bsearch": {
      if (!Array.isArray(t4)) {
        let h3 = t4 === null ? "null" : typeof t4 == "object" ? "object" : typeof t4;
        throw new Error(`${h3} (${JSON.stringify(t4)}) cannot be searched from`);
      }
      return e5.length === 0 ? [null] : p3(t4, e5[0], n3).map((h3) => {
        let y2 = 0, a3 = t4.length;
        for (; y2 < a3; ) {
          let l3 = y2 + a3 >>> 1;
          u3(t4[l3], h3) < 0 ? y2 = l3 + 1 : a3 = l3;
        }
        return y2 < t4.length && u3(t4[y2], h3) === 0 ? y2 : -y2 - 1;
      });
    }
    case "unique_by": {
      if (!Array.isArray(t4) || e5.length === 0) return [null];
      let o2 = /* @__PURE__ */ new Map();
      for (let y2 of t4) {
        let a3 = p3(y2, e5[0], n3)[0], l3 = JSON.stringify(a3);
        o2.has(l3) || o2.set(l3, { item: y2, key: a3 });
      }
      let h3 = [...o2.values()];
      return h3.sort((y2, a3) => u3(y2.key, a3.key)), [h3.map((y2) => y2.item)];
    }
    case "group_by": {
      if (!Array.isArray(t4) || e5.length === 0) return [null];
      let o2 = /* @__PURE__ */ new Map();
      for (let h3 of t4) {
        let y2 = JSON.stringify(p3(h3, e5[0], n3)[0]);
        o2.has(y2) || o2.set(y2, []), o2.get(y2)?.push(h3);
      }
      return [[...o2.values()]];
    }
    case "max":
      return Array.isArray(t4) && t4.length > 0 ? [t4.reduce((o2, h3) => u3(o2, h3) > 0 ? o2 : h3)] : [null];
    case "max_by":
      return !Array.isArray(t4) || t4.length === 0 || e5.length === 0 ? [null] : [t4.reduce((o2, h3) => {
        let y2 = p3(o2, e5[0], n3)[0], a3 = p3(h3, e5[0], n3)[0];
        return u3(y2, a3) > 0 ? o2 : h3;
      })];
    case "min":
      return Array.isArray(t4) && t4.length > 0 ? [t4.reduce((o2, h3) => u3(o2, h3) < 0 ? o2 : h3)] : [null];
    case "min_by":
      return !Array.isArray(t4) || t4.length === 0 || e5.length === 0 ? [null] : [t4.reduce((o2, h3) => {
        let y2 = p3(o2, e5[0], n3)[0], a3 = p3(h3, e5[0], n3)[0];
        return u3(y2, a3) < 0 ? o2 : h3;
      })];
    case "add": {
      let o2 = (h3) => {
        let y2 = h3.filter((a3) => a3 !== null);
        return y2.length === 0 ? null : y2.every((a3) => typeof a3 == "number") ? y2.reduce((a3, l3) => a3 + l3, 0) : y2.every((a3) => typeof a3 == "string") ? y2.join("") : y2.every((a3) => Array.isArray(a3)) ? y2.flat() : y2.every((a3) => a3 && typeof a3 == "object" && !Array.isArray(a3)) ? Object.assign({}, ...y2) : null;
      };
      if (e5.length >= 1) {
        let h3 = p3(t4, e5[0], n3);
        return [o2(h3)];
      }
      return Array.isArray(t4) ? [o2(t4)] : [null];
    }
    case "any": {
      if (e5.length >= 2) {
        try {
          let o2 = i4(t4, e5[0], n3);
          for (let h3 of o2) if (p3(h3, e5[1], n3).some(f3)) return [true];
        } catch (o2) {
          if (o2 instanceof c3) throw o2;
        }
        return [false];
      }
      return e5.length === 1 ? Array.isArray(t4) ? [t4.some((o2) => f3(p3(o2, e5[0], n3)[0]))] : [false] : Array.isArray(t4) ? [t4.some(f3)] : [false];
    }
    case "all": {
      if (e5.length >= 2) {
        try {
          let o2 = i4(t4, e5[0], n3);
          for (let h3 of o2) if (!p3(h3, e5[1], n3).some(f3)) return [false];
        } catch (o2) {
          if (o2 instanceof c3) throw o2;
        }
        return [true];
      }
      return e5.length === 1 ? Array.isArray(t4) ? [t4.every((o2) => f3(p3(o2, e5[0], n3)[0]))] : [true] : Array.isArray(t4) ? [t4.every(f3)] : [true];
    }
    case "select":
      return e5.length === 0 ? [t4] : p3(t4, e5[0], n3).some(f3) ? [t4] : [];
    case "map":
      return e5.length === 0 || !Array.isArray(t4) ? [null] : [t4.flatMap((h3) => p3(h3, e5[0], n3))];
    case "map_values": {
      if (e5.length === 0) return [null];
      if (Array.isArray(t4)) return [t4.flatMap((o2) => p3(o2, e5[0], n3))];
      if (t4 && typeof t4 == "object") {
        let o2 = {};
        for (let [h3, y2] of Object.entries(t4)) {
          let a3 = p3(y2, e5[0], n3);
          a3.length > 0 && (o2[h3] = a3[0]);
        }
        return [o2];
      }
      return [null];
    }
    case "has": {
      if (e5.length === 0) return [false];
      let h3 = p3(t4, e5[0], n3)[0];
      return Array.isArray(t4) && typeof h3 == "number" ? [h3 >= 0 && h3 < t4.length] : t4 && typeof t4 == "object" && typeof h3 == "string" ? [h3 in t4] : [false];
    }
    case "in": {
      if (e5.length === 0) return [false];
      let h3 = p3(t4, e5[0], n3)[0];
      return Array.isArray(h3) && typeof t4 == "number" ? [t4 >= 0 && t4 < h3.length] : h3 && typeof h3 == "object" && typeof t4 == "string" ? [t4 in h3] : [false];
    }
    case "contains": {
      if (e5.length === 0) return [false];
      let o2 = p3(t4, e5[0], n3);
      return [s3(t4, o2[0])];
    }
    case "inside": {
      if (e5.length === 0) return [false];
      let o2 = p3(t4, e5[0], n3);
      return [s3(o2[0], t4)];
    }
    default:
      return null;
  }
}
function V$5(t4, r2, e5, n3, p3, i4, u3, f3) {
  switch (r2) {
    case "first":
      if (e5.length > 0) try {
        let s3 = i4(t4, e5[0], n3);
        return s3.length > 0 ? [s3[0]] : [];
      } catch (s3) {
        if (s3 instanceof f3) throw s3;
        return [];
      }
      return Array.isArray(t4) && t4.length > 0 ? [t4[0]] : [null];
    case "last":
      if (e5.length > 0) {
        let s3 = p3(t4, e5[0], n3);
        return s3.length > 0 ? [s3[s3.length - 1]] : [];
      }
      return Array.isArray(t4) && t4.length > 0 ? [t4[t4.length - 1]] : [null];
    case "nth": {
      if (e5.length < 1) return [null];
      let s3 = p3(t4, e5[0], n3);
      if (e5.length > 1) {
        for (let o2 of s3) if (o2 < 0) throw new Error("nth doesn't support negative indices");
        let c3;
        try {
          c3 = i4(t4, e5[1], n3);
        } catch (o2) {
          if (o2 instanceof f3) throw o2;
          c3 = [];
        }
        return s3.flatMap((o2) => {
          let h3 = o2;
          return h3 < c3.length ? [c3[h3]] : [];
        });
      }
      return Array.isArray(t4) ? s3.flatMap((c3) => {
        let o2 = c3;
        if (o2 < 0) throw new Error("nth doesn't support negative indices");
        return o2 < t4.length ? [t4[o2]] : [null];
      }) : [null];
    }
    case "range": {
      if (e5.length === 0) return [];
      let s3 = p3(t4, e5[0], n3);
      if (e5.length === 1) {
        let y2 = [];
        for (let a3 of s3) {
          let l3 = a3;
          for (let d3 = 0; d3 < l3; d3++) y2.push(d3);
        }
        return y2;
      }
      let c3 = p3(t4, e5[1], n3);
      if (e5.length === 2) {
        let y2 = [];
        for (let a3 of s3) for (let l3 of c3) {
          let d3 = a3, g2 = l3;
          for (let A2 = d3; A2 < g2; A2++) y2.push(A2);
        }
        return y2;
      }
      let o2 = p3(t4, e5[2], n3), h3 = [];
      for (let y2 of s3) for (let a3 of c3) for (let l3 of o2) {
        let d3 = y2, g2 = a3, A2 = l3;
        if (A2 !== 0) if (A2 > 0) for (let b4 = d3; b4 < g2; b4 += A2) h3.push(b4);
        else for (let b4 = d3; b4 > g2; b4 += A2) h3.push(b4);
      }
      return h3;
    }
    case "limit":
      return e5.length < 2 ? [] : p3(t4, e5[0], n3).flatMap((c3) => {
        let o2 = c3;
        if (o2 < 0) throw new Error("limit doesn't support negative count");
        if (o2 === 0) return [];
        let h3;
        try {
          h3 = i4(t4, e5[1], n3);
        } catch (y2) {
          if (y2 instanceof f3) throw y2;
          h3 = [];
        }
        return h3.slice(0, o2);
      });
    case "isempty": {
      if (e5.length < 1) return [true];
      try {
        return [i4(t4, e5[0], n3).length === 0];
      } catch (s3) {
        if (s3 instanceof f3) throw s3;
        return [true];
      }
    }
    case "isvalid": {
      if (e5.length < 1) return [true];
      try {
        return [p3(t4, e5[0], n3).length > 0];
      } catch (s3) {
        if (s3 instanceof f3) throw s3;
        return [false];
      }
    }
    case "skip":
      return e5.length < 2 ? [] : p3(t4, e5[0], n3).flatMap((c3) => {
        let o2 = c3;
        if (o2 < 0) throw new Error("skip doesn't support negative count");
        return p3(t4, e5[1], n3).slice(o2);
      });
    case "until": {
      if (e5.length < 2) return [t4];
      let s3 = t4, c3 = n3.limits.maxIterations;
      for (let o2 = 0; o2 < c3; o2++) {
        if (p3(s3, e5[0], n3).some(u3)) return [s3];
        let y2 = p3(s3, e5[1], n3);
        if (y2.length === 0) return [s3];
        s3 = y2[0];
      }
      throw new f3(`jq until: too many iterations (${c3}), increase executionLimits.maxJqIterations`, "iterations");
    }
    case "while": {
      if (e5.length < 2) return [t4];
      let s3 = [], c3 = t4, o2 = n3.limits.maxIterations;
      for (let h3 = 0; h3 < o2 && p3(c3, e5[0], n3).some(u3); h3++) {
        s3.push(c3);
        let a3 = p3(c3, e5[1], n3);
        if (a3.length === 0) break;
        c3 = a3[0];
      }
      if (s3.length >= o2) throw new f3(`jq while: too many iterations (${o2}), increase executionLimits.maxJqIterations`, "iterations");
      return s3;
    }
    case "repeat": {
      if (e5.length === 0) return [t4];
      let s3 = [], c3 = t4, o2 = n3.limits.maxIterations;
      for (let h3 = 0; h3 < o2; h3++) {
        s3.push(c3);
        let y2 = p3(c3, e5[0], n3);
        if (y2.length === 0) break;
        c3 = y2[0];
      }
      if (s3.length >= o2) throw new f3(`jq repeat: too many iterations (${o2}), increase executionLimits.maxJqIterations`, "iterations");
      return s3;
    }
    default:
      return null;
  }
}
function J$4(t4, r2, e5, n3, p3) {
  switch (r2) {
    case "now":
      return [Date.now() / 1e3];
    case "gmtime": {
      if (typeof t4 != "number") return [null];
      let i4 = new Date(t4 * 1e3), u3 = i4.getUTCFullYear(), f3 = i4.getUTCMonth(), s3 = i4.getUTCDate(), c3 = i4.getUTCHours(), o2 = i4.getUTCMinutes(), h3 = i4.getUTCSeconds(), y2 = i4.getUTCDay(), a3 = Date.UTC(u3, 0, 1), l3 = Math.floor((i4.getTime() - a3) / (1440 * 60 * 1e3));
      return [[u3, f3, s3, c3, o2, h3, y2, l3]];
    }
    case "mktime": {
      if (!Array.isArray(t4)) throw new Error("mktime requires parsed datetime inputs");
      let [i4, u3, f3, s3 = 0, c3 = 0, o2 = 0] = t4;
      if (typeof i4 != "number" || typeof u3 != "number") throw new Error("mktime requires parsed datetime inputs");
      let h3 = Date.UTC(i4, u3, f3 ?? 1, s3 ?? 0, c3 ?? 0, o2 ?? 0);
      return [Math.floor(h3 / 1e3)];
    }
    case "strftime": {
      if (e5.length === 0) return [null];
      let u3 = p3(t4, e5[0], n3)[0];
      if (typeof u3 != "string") throw new Error("strftime/1 requires a string format");
      let f3;
      if (typeof t4 == "number") f3 = new Date(t4 * 1e3);
      else if (Array.isArray(t4)) {
        let [y2, a3, l3, d3 = 0, g2 = 0, A2 = 0] = t4;
        if (typeof y2 != "number" || typeof a3 != "number") throw new Error("strftime/1 requires parsed datetime inputs");
        f3 = new Date(Date.UTC(y2, a3, l3 ?? 1, d3 ?? 0, g2 ?? 0, A2 ?? 0));
      } else throw new Error("strftime/1 requires parsed datetime inputs");
      let s3 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], c3 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], o2 = (y2, a3 = 2) => String(y2).padStart(a3, "0");
      return [u3.replace(/%Y/g, String(f3.getUTCFullYear())).replace(/%m/g, o2(f3.getUTCMonth() + 1)).replace(/%d/g, o2(f3.getUTCDate())).replace(/%H/g, o2(f3.getUTCHours())).replace(/%M/g, o2(f3.getUTCMinutes())).replace(/%S/g, o2(f3.getUTCSeconds())).replace(/%A/g, s3[f3.getUTCDay()]).replace(/%B/g, c3[f3.getUTCMonth()]).replace(/%Z/g, "UTC").replace(/%%/g, "%")];
    }
    case "strptime": {
      if (e5.length === 0) return [null];
      if (typeof t4 != "string") throw new Error("strptime/1 requires a string input");
      let u3 = p3(t4, e5[0], n3)[0];
      if (typeof u3 != "string") throw new Error("strptime/1 requires a string format");
      if (u3 === "%Y-%m-%dT%H:%M:%SZ") {
        let s3 = t4.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})Z$/);
        if (s3) {
          let [, c3, o2, h3, y2, a3, l3] = s3.map(Number), d3 = new Date(Date.UTC(c3, o2 - 1, h3, y2, a3, l3)), g2 = d3.getUTCDay(), A2 = Date.UTC(c3, 0, 1), b4 = Math.floor((d3.getTime() - A2) / (1440 * 60 * 1e3));
          return [[c3, o2 - 1, h3, y2, a3, l3, g2, b4]];
        }
      }
      let f3 = new Date(t4);
      if (!Number.isNaN(f3.getTime())) {
        let s3 = f3.getUTCFullYear(), c3 = f3.getUTCMonth(), o2 = f3.getUTCDate(), h3 = f3.getUTCHours(), y2 = f3.getUTCMinutes(), a3 = f3.getUTCSeconds(), l3 = f3.getUTCDay(), d3 = Date.UTC(s3, 0, 1), g2 = Math.floor((f3.getTime() - d3) / (1440 * 60 * 1e3));
        return [[s3, c3, o2, h3, y2, a3, l3, g2]];
      }
      throw new Error(`Cannot parse date: ${t4}`);
    }
    case "fromdate": {
      if (typeof t4 != "string") throw new Error("fromdate requires a string input");
      let i4 = new Date(t4);
      if (Number.isNaN(i4.getTime())) throw new Error(`date "${t4}" does not match format "%Y-%m-%dT%H:%M:%SZ"`);
      return [Math.floor(i4.getTime() / 1e3)];
    }
    case "todate": {
      if (typeof t4 != "number") throw new Error("todate requires a number input");
      return [new Date(t4 * 1e3).toISOString().replace(/\.\d{3}Z$/, "Z")];
    }
    default:
      return null;
  }
}
function E$4(t4) {
  return t4 !== false && t4 !== null;
}
function S$8(t4, r2) {
  return JSON.stringify(t4) === JSON.stringify(r2);
}
function M$5(t4, r2) {
  return typeof t4 == "number" && typeof r2 == "number" ? t4 - r2 : typeof t4 == "string" && typeof r2 == "string" ? t4.localeCompare(r2) : 0;
}
function H$6(t4, r2) {
  let e5 = { ...t4 };
  for (let n3 of Object.keys(r2)) n3 in e5 && e5[n3] && typeof e5[n3] == "object" && !Array.isArray(e5[n3]) && r2[n3] && typeof r2[n3] == "object" && !Array.isArray(r2[n3]) ? e5[n3] = H$6(e5[n3], r2[n3]) : e5[n3] = r2[n3];
  return e5;
}
function T$4(t4, r2 = 3e3) {
  let e5 = 0, n3 = t4;
  for (; e5 < r2; ) if (Array.isArray(n3)) {
    if (n3.length === 0) return e5 + 1;
    n3 = n3[0], e5++;
  } else if (n3 !== null && typeof n3 == "object") {
    let p3 = Object.keys(n3);
    if (p3.length === 0) return e5 + 1;
    n3 = n3[p3[0]], e5++;
  } else return e5;
  return e5;
}
function j$4(t4, r2) {
  let e5 = (i4) => i4 === null ? 0 : typeof i4 == "boolean" ? 1 : typeof i4 == "number" ? 2 : typeof i4 == "string" ? 3 : Array.isArray(i4) ? 4 : typeof i4 == "object" ? 5 : 6, n3 = e5(t4), p3 = e5(r2);
  if (n3 !== p3) return n3 - p3;
  if (typeof t4 == "number" && typeof r2 == "number") return t4 - r2;
  if (typeof t4 == "string" && typeof r2 == "string") return t4.localeCompare(r2);
  if (typeof t4 == "boolean" && typeof r2 == "boolean") return (t4 ? 1 : 0) - (r2 ? 1 : 0);
  if (Array.isArray(t4) && Array.isArray(r2)) {
    for (let i4 = 0; i4 < Math.min(t4.length, r2.length); i4++) {
      let u3 = j$4(t4[i4], r2[i4]);
      if (u3 !== 0) return u3;
    }
    return t4.length - r2.length;
  }
  if (t4 && r2 && typeof t4 == "object" && typeof r2 == "object") {
    let i4 = t4, u3 = r2, f3 = Object.keys(i4).sort(), s3 = Object.keys(u3).sort();
    for (let c3 = 0; c3 < Math.min(f3.length, s3.length); c3++) {
      let o2 = f3[c3].localeCompare(s3[c3]);
      if (o2 !== 0) return o2;
    }
    if (f3.length !== s3.length) return f3.length - s3.length;
    for (let c3 of f3) {
      let o2 = j$4(i4[c3], u3[c3]);
      if (o2 !== 0) return o2;
    }
  }
  return 0;
}
function P$4(t4, r2) {
  if (S$8(t4, r2)) return true;
  if (typeof t4 == "string" && typeof r2 == "string") return t4.includes(r2);
  if (Array.isArray(t4) && Array.isArray(r2)) return r2.every((e5) => t4.some((n3) => P$4(n3, e5)));
  if (t4 && r2 && typeof t4 == "object" && typeof r2 == "object" && !Array.isArray(t4) && !Array.isArray(r2)) {
    let e5 = t4, n3 = r2;
    return Object.keys(n3).every((p3) => p3 in e5 && P$4(e5[p3], n3[p3]));
  }
  return false;
}
var ut$1 = 2e3;
function Y$3(t4, r2, e5) {
  switch (r2) {
    case "@base64":
      return typeof t4 == "string" ? typeof Buffer < "u" ? [Buffer.from(t4, "utf-8").toString("base64")] : [btoa(t4)] : [null];
    case "@base64d":
      return typeof t4 == "string" ? typeof Buffer < "u" ? [Buffer.from(t4, "base64").toString("utf-8")] : [atob(t4)] : [null];
    case "@uri":
      return typeof t4 == "string" ? [encodeURIComponent(t4).replace(/!/g, "%21").replace(/'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A")] : [null];
    case "@urid":
      return typeof t4 == "string" ? [decodeURIComponent(t4)] : [null];
    case "@csv":
      return Array.isArray(t4) ? [t4.map((p3) => {
        if (p3 === null) return "";
        if (typeof p3 == "boolean") return p3 ? "true" : "false";
        if (typeof p3 == "number") return String(p3);
        let i4 = String(p3);
        return i4.includes(",") || i4.includes('"') || i4.includes(`
`) || i4.includes("\r") ? `"${i4.replace(/"/g, '""')}"` : i4;
      }).join(",")] : [null];
    case "@tsv":
      return Array.isArray(t4) ? [t4.map((n3) => String(n3 ?? "").replace(/\t/g, "\\t").replace(/\n/g, "\\n")).join("	")] : [null];
    case "@json": {
      let n3 = e5 ?? ut$1;
      return T$4(t4, n3 + 1) > n3 ? [null] : [JSON.stringify(t4)];
    }
    case "@html":
      return typeof t4 == "string" ? [t4.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&apos;").replace(/"/g, "&quot;")] : [null];
    case "@sh":
      return typeof t4 == "string" ? [`'${t4.replace(/'/g, "'\\''")}'`] : [null];
    case "@text":
      return typeof t4 == "string" ? [t4] : t4 == null ? [""] : [String(t4)];
    default:
      return null;
  }
}
function q$5(t4, r2, e5, n3, p3, i4) {
  switch (r2) {
    case "index":
      return e5.length === 0 ? [null] : p3(t4, e5[0], n3).map((f3) => {
        if (typeof t4 == "string" && typeof f3 == "string") {
          if (f3 === "" && t4 === "") return null;
          let s3 = t4.indexOf(f3);
          return s3 >= 0 ? s3 : null;
        }
        if (Array.isArray(t4)) {
          if (Array.isArray(f3)) {
            for (let c3 = 0; c3 <= t4.length - f3.length; c3++) {
              let o2 = true;
              for (let h3 = 0; h3 < f3.length; h3++) if (!i4(t4[c3 + h3], f3[h3])) {
                o2 = false;
                break;
              }
              if (o2) return c3;
            }
            return null;
          }
          let s3 = t4.findIndex((c3) => i4(c3, f3));
          return s3 >= 0 ? s3 : null;
        }
        return null;
      });
    case "rindex":
      return e5.length === 0 ? [null] : p3(t4, e5[0], n3).map((f3) => {
        if (typeof t4 == "string" && typeof f3 == "string") {
          let s3 = t4.lastIndexOf(f3);
          return s3 >= 0 ? s3 : null;
        }
        if (Array.isArray(t4)) {
          if (Array.isArray(f3)) {
            for (let s3 = t4.length - f3.length; s3 >= 0; s3--) {
              let c3 = true;
              for (let o2 = 0; o2 < f3.length; o2++) if (!i4(t4[s3 + o2], f3[o2])) {
                c3 = false;
                break;
              }
              if (c3) return s3;
            }
            return null;
          }
          for (let s3 = t4.length - 1; s3 >= 0; s3--) if (i4(t4[s3], f3)) return s3;
          return null;
        }
        return null;
      });
    case "indices":
      return e5.length === 0 ? [[]] : p3(t4, e5[0], n3).map((f3) => {
        let s3 = [];
        if (typeof t4 == "string" && typeof f3 == "string") {
          let c3 = t4.indexOf(f3);
          for (; c3 !== -1; ) s3.push(c3), c3 = t4.indexOf(f3, c3 + 1);
        } else if (Array.isArray(t4)) if (Array.isArray(f3)) {
          let c3 = f3.length;
          if (c3 === 0) for (let o2 = 0; o2 <= t4.length; o2++) s3.push(o2);
          else for (let o2 = 0; o2 <= t4.length - c3; o2++) {
            let h3 = true;
            for (let y2 = 0; y2 < c3; y2++) if (!i4(t4[o2 + y2], f3[y2])) {
              h3 = false;
              break;
            }
            h3 && s3.push(o2);
          }
        } else for (let c3 = 0; c3 < t4.length; c3++) i4(t4[c3], f3) && s3.push(c3);
        return s3;
      });
    default:
      return null;
  }
}
function G$2(t4, r2, e5, n3, p3) {
  switch (r2) {
    case "fabs":
    case "abs":
      return typeof t4 == "number" ? [Math.abs(t4)] : typeof t4 == "string" ? [t4] : [null];
    case "exp10":
      return typeof t4 == "number" ? [10 ** t4] : [null];
    case "exp2":
      return typeof t4 == "number" ? [2 ** t4] : [null];
    case "pow": {
      if (e5.length < 2) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = p3(t4, e5[1], n3), f3 = i4[0], s3 = u3[0];
      return typeof f3 != "number" || typeof s3 != "number" ? [null] : [f3 ** s3];
    }
    case "atan2": {
      if (e5.length < 2) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = p3(t4, e5[1], n3), f3 = i4[0], s3 = u3[0];
      return typeof f3 != "number" || typeof s3 != "number" ? [null] : [Math.atan2(f3, s3)];
    }
    case "hypot": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [Math.hypot(t4, i4)];
    }
    case "fma": {
      if (typeof t4 != "number" || e5.length < 2) return [null];
      let i4 = p3(t4, e5[0], n3)[0], u3 = p3(t4, e5[1], n3)[0];
      return [t4 * i4 + u3];
    }
    case "copysign": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [Math.sign(i4) * Math.abs(t4)];
    }
    case "drem":
    case "remainder": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [t4 - Math.round(t4 / i4) * i4];
    }
    case "fdim": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [Math.max(0, t4 - i4)];
    }
    case "fmax": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [Math.max(t4, i4)];
    }
    case "fmin": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [Math.min(t4, i4)];
    }
    case "ldexp": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [t4 * 2 ** i4];
    }
    case "scalbn":
    case "scalbln": {
      if (typeof t4 != "number" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3)[0];
      return [t4 * 2 ** i4];
    }
    case "nearbyint":
      return typeof t4 == "number" ? [Math.round(t4)] : [null];
    case "logb":
      return typeof t4 == "number" ? [Math.floor(Math.log2(Math.abs(t4)))] : [null];
    case "significand":
      if (typeof t4 == "number") {
        let i4 = Math.floor(Math.log2(Math.abs(t4)));
        return [t4 / 2 ** i4];
      }
      return [null];
    case "frexp":
      if (typeof t4 == "number") {
        if (t4 === 0) return [[0, 0]];
        let i4 = Math.floor(Math.log2(Math.abs(t4))) + 1;
        return [[t4 / 2 ** i4, i4]];
      }
      return [null];
    case "modf":
      if (typeof t4 == "number") {
        let i4 = Math.trunc(t4);
        return [[t4 - i4, i4]];
      }
      return [null];
    default:
      return null;
  }
}
function X$4(t4, r2, e5, n3, p3, i4, u3, f3) {
  switch (r2) {
    case "recurse": {
      if (e5.length === 0) {
        let a3 = [], l3 = (d3) => {
          if (a3.push(d3), Array.isArray(d3)) for (let g2 of d3) l3(g2);
          else if (d3 && typeof d3 == "object") for (let g2 of Object.keys(d3)) l3(d3[g2]);
        };
        return l3(t4), a3;
      }
      let s3 = [], c3 = e5.length >= 2 ? e5[1] : null, o2 = 1e4, h3 = 0, y2 = (a3) => {
        if (h3++ > o2 || c3 && !p3(a3, c3, n3).some(i4)) return;
        s3.push(a3);
        let l3 = p3(a3, e5[0], n3);
        for (let d3 of l3) d3 != null && y2(d3);
      };
      return y2(t4), s3;
    }
    case "recurse_down":
      return f3(t4, "recurse", e5, n3);
    case "walk": {
      if (e5.length === 0) return [t4];
      let s3 = /* @__PURE__ */ new WeakSet(), c3 = (o2) => {
        if (o2 && typeof o2 == "object") {
          if (s3.has(o2)) return o2;
          s3.add(o2);
        }
        let h3;
        if (Array.isArray(o2)) h3 = o2.map(c3);
        else if (o2 && typeof o2 == "object") {
          let a3 = {};
          for (let [l3, d3] of Object.entries(o2)) a3[l3] = c3(d3);
          h3 = a3;
        } else h3 = o2;
        return p3(h3, e5[0], n3)[0];
      };
      return [c3(t4)];
    }
    case "transpose": {
      if (!Array.isArray(t4)) return [null];
      if (t4.length === 0) return [[]];
      let s3 = Math.max(...t4.map((o2) => Array.isArray(o2) ? o2.length : 0)), c3 = [];
      for (let o2 = 0; o2 < s3; o2++) c3.push(t4.map((h3) => Array.isArray(h3) ? h3[o2] : null));
      return [c3];
    }
    case "combinations": {
      if (e5.length > 0) {
        let h3 = p3(t4, e5[0], n3)[0];
        if (!Array.isArray(t4) || h3 < 0) return [];
        if (h3 === 0) return [[]];
        let y2 = [], a3 = (l3, d3) => {
          if (d3 === h3) {
            y2.push([...l3]);
            return;
          }
          for (let g2 of t4) l3.push(g2), a3(l3, d3 + 1), l3.pop();
        };
        return a3([], 0), y2;
      }
      if (!Array.isArray(t4)) return [];
      if (t4.length === 0) return [[]];
      for (let o2 of t4) if (!Array.isArray(o2)) return [];
      let s3 = [], c3 = (o2, h3) => {
        if (o2 === t4.length) {
          s3.push([...h3]);
          return;
        }
        let y2 = t4[o2];
        for (let a3 of y2) h3.push(a3), c3(o2 + 1, h3), h3.pop();
      };
      return c3(0, []), s3;
    }
    case "parent": {
      if (n3.root === void 0 || n3.currentPath === void 0) return [];
      let s3 = n3.currentPath;
      if (s3.length === 0) return [];
      let c3 = e5.length > 0 ? p3(t4, e5[0], n3)[0] : 1;
      if (c3 >= 0) {
        if (c3 > s3.length) return [];
        let o2 = s3.slice(0, s3.length - c3);
        return [u3(n3.root, o2)];
      } else {
        let o2 = -c3 - 1;
        if (o2 >= s3.length) return [t4];
        let h3 = s3.slice(0, o2);
        return [u3(n3.root, h3)];
      }
    }
    case "parents": {
      if (n3.root === void 0 || n3.currentPath === void 0) return [[]];
      let s3 = n3.currentPath, c3 = [];
      for (let o2 = s3.length - 1; o2 >= 0; o2--) c3.push(u3(n3.root, s3.slice(0, o2)));
      return [c3];
    }
    case "root":
      return n3.root !== void 0 ? [n3.root] : [];
    default:
      return null;
  }
}
var ht$1 = 2e3;
function W$5(t4, r2, e5, n3, p3) {
  switch (r2) {
    case "keys":
      return Array.isArray(t4) ? [t4.map((i4, u3) => u3)] : t4 && typeof t4 == "object" ? [Object.keys(t4).sort()] : [null];
    case "keys_unsorted":
      return Array.isArray(t4) ? [t4.map((i4, u3) => u3)] : t4 && typeof t4 == "object" ? [Object.keys(t4)] : [null];
    case "length":
      return typeof t4 == "string" ? [t4.length] : Array.isArray(t4) ? [t4.length] : t4 && typeof t4 == "object" ? [Object.keys(t4).length] : t4 === null ? [0] : typeof t4 == "number" ? [Math.abs(t4)] : [null];
    case "utf8bytelength": {
      if (typeof t4 == "string") return [new TextEncoder().encode(t4).length];
      let i4 = t4 === null ? "null" : Array.isArray(t4) ? "array" : typeof t4, u3 = i4 === "array" || i4 === "object" ? JSON.stringify(t4) : String(t4);
      throw new Error(`${i4} (${u3}) only strings have UTF-8 byte length`);
    }
    case "to_entries":
      return t4 && typeof t4 == "object" && !Array.isArray(t4) ? [Object.entries(t4).map(([i4, u3]) => ({ key: i4, value: u3 }))] : [null];
    case "from_entries":
      if (Array.isArray(t4)) {
        let i4 = {};
        for (let u3 of t4) if (u3 && typeof u3 == "object") {
          let f3 = u3, s3 = f3.key ?? f3.Key ?? f3.name ?? f3.Name ?? f3.k, c3 = f3.value ?? f3.Value ?? f3.v;
          s3 !== void 0 && (i4[String(s3)] = c3);
        }
        return [i4];
      }
      return [null];
    case "with_entries": {
      if (e5.length === 0) return [t4];
      if (t4 && typeof t4 == "object" && !Array.isArray(t4)) {
        let u3 = Object.entries(t4).map(([s3, c3]) => ({ key: s3, value: c3 })).flatMap((s3) => p3(s3, e5[0], n3)), f3 = {};
        for (let s3 of u3) if (s3 && typeof s3 == "object") {
          let c3 = s3, o2 = c3.key ?? c3.name ?? c3.k, h3 = c3.value ?? c3.v;
          o2 !== void 0 && (f3[String(o2)] = h3);
        }
        return [f3];
      }
      return [null];
    }
    case "reverse":
      return Array.isArray(t4) ? [[...t4].reverse()] : typeof t4 == "string" ? [t4.split("").reverse().join("")] : [null];
    case "flatten":
      return Array.isArray(t4) ? (e5.length > 0 ? p3(t4, e5[0], n3) : [Number.POSITIVE_INFINITY]).map((u3) => {
        let f3 = u3;
        if (f3 < 0) throw new Error("flatten depth must not be negative");
        return t4.flat(f3);
      }) : [null];
    case "unique":
      if (Array.isArray(t4)) {
        let i4 = /* @__PURE__ */ new Set(), u3 = [];
        for (let f3 of t4) {
          let s3 = JSON.stringify(f3);
          i4.has(s3) || (i4.add(s3), u3.push(f3));
        }
        return [u3];
      }
      return [null];
    case "tojson":
    case "tojsonstream": {
      let i4 = n3.limits.maxDepth ?? ht$1;
      return T$4(t4, i4 + 1) > i4 ? [null] : [JSON.stringify(t4)];
    }
    case "fromjson": {
      if (typeof t4 == "string") {
        let i4 = t4.trim().toLowerCase();
        if (i4 === "nan") return [Number.NaN];
        if (i4 === "inf" || i4 === "infinity") return [Number.POSITIVE_INFINITY];
        if (i4 === "-inf" || i4 === "-infinity") return [Number.NEGATIVE_INFINITY];
        try {
          return [JSON.parse(t4)];
        } catch {
          throw new Error(`Invalid JSON: ${t4}`);
        }
      }
      return [t4];
    }
    case "tostring":
      return typeof t4 == "string" ? [t4] : [JSON.stringify(t4)];
    case "tonumber":
      if (typeof t4 == "number") return [t4];
      if (typeof t4 == "string") {
        let i4 = Number(t4);
        if (Number.isNaN(i4)) throw new Error(`${JSON.stringify(t4)} cannot be parsed as a number`);
        return [i4];
      }
      throw new Error(`${typeof t4} cannot be parsed as a number`);
    case "toboolean": {
      if (typeof t4 == "boolean") return [t4];
      if (typeof t4 == "string") {
        if (t4 === "true") return [true];
        if (t4 === "false") return [false];
        throw new Error(`string (${JSON.stringify(t4)}) cannot be parsed as a boolean`);
      }
      let i4 = t4 === null ? "null" : Array.isArray(t4) ? "array" : typeof t4, u3 = i4 === "array" || i4 === "object" ? JSON.stringify(t4) : String(t4);
      throw new Error(`${i4} (${u3}) cannot be parsed as a boolean`);
    }
    case "tostream": {
      let i4 = [], u3 = (f3, s3) => {
        if (f3 === null || typeof f3 != "object") i4.push([s3, f3]);
        else if (Array.isArray(f3)) if (f3.length === 0) i4.push([s3, []]);
        else for (let c3 = 0; c3 < f3.length; c3++) u3(f3[c3], [...s3, c3]);
        else {
          let c3 = Object.keys(f3);
          if (c3.length === 0) i4.push([s3, {}]);
          else for (let o2 of c3) u3(f3[o2], [...s3, o2]);
        }
      };
      return u3(t4, []), i4.push([[]]), i4;
    }
    case "fromstream": {
      if (e5.length === 0) return [t4];
      let i4 = p3(t4, e5[0], n3), u3 = null;
      for (let f3 of i4) {
        if (!Array.isArray(f3) || f3.length === 1 && Array.isArray(f3[0]) && f3[0].length === 0 || f3.length !== 2) continue;
        let [s3, c3] = f3;
        if (!Array.isArray(s3)) continue;
        if (s3.length === 0) {
          u3 = c3;
          continue;
        }
        u3 === null && (u3 = typeof s3[0] == "number" ? [] : {});
        let o2 = u3;
        for (let y2 = 0; y2 < s3.length - 1; y2++) {
          let a3 = s3[y2], l3 = s3[y2 + 1];
          if (Array.isArray(o2) && typeof a3 == "number") {
            for (; o2.length <= a3; ) o2.push(null);
            o2[a3] === null && (o2[a3] = typeof l3 == "number" ? [] : {}), o2 = o2[a3];
          } else if (o2 && typeof o2 == "object" && !Array.isArray(o2)) {
            let d3 = o2;
            (d3[String(a3)] === null || d3[String(a3)] === void 0) && (d3[String(a3)] = typeof l3 == "number" ? [] : {}), o2 = d3[String(a3)];
          }
        }
        let h3 = s3[s3.length - 1];
        if (Array.isArray(o2) && typeof h3 == "number") {
          for (; o2.length <= h3; ) o2.push(null);
          o2[h3] = c3;
        } else o2 && typeof o2 == "object" && !Array.isArray(o2) && (o2[String(h3)] = c3);
      }
      return [u3];
    }
    case "truncate_stream": {
      let i4 = typeof t4 == "number" ? Math.floor(t4) : 0;
      if (e5.length === 0) return [];
      let u3 = [], f3 = p3(t4, e5[0], n3);
      for (let s3 of f3) if (Array.isArray(s3)) {
        if (s3.length === 1 && Array.isArray(s3[0])) {
          let c3 = s3[0];
          c3.length > i4 && u3.push([c3.slice(i4)]);
          continue;
        }
        if (s3.length === 2 && Array.isArray(s3[0])) {
          let c3 = s3[0], o2 = s3[1];
          c3.length > i4 && u3.push([c3.slice(i4), o2]);
        }
      }
      return u3;
    }
    default:
      return null;
  }
}
function Q$4(t4, r2, e5, n3, p3, i4, u3, f3, s3, c3) {
  switch (r2) {
    case "getpath": {
      if (e5.length === 0) return [null];
      let o2 = p3(t4, e5[0], n3), h3 = [];
      for (let y2 of o2) {
        let a3 = y2, l3 = t4;
        for (let d3 of a3) {
          if (l3 == null) {
            l3 = null;
            break;
          }
          if (Array.isArray(l3) && typeof d3 == "number") l3 = l3[d3];
          else if (typeof l3 == "object" && typeof d3 == "string") l3 = l3[d3];
          else {
            l3 = null;
            break;
          }
        }
        h3.push(l3);
      }
      return h3;
    }
    case "setpath": {
      if (e5.length < 2) return [null];
      let h3 = p3(t4, e5[0], n3)[0], a3 = p3(t4, e5[1], n3)[0];
      return [u3(t4, h3, a3)];
    }
    case "delpaths": {
      if (e5.length === 0) return [t4];
      let h3 = p3(t4, e5[0], n3)[0], y2 = t4;
      for (let a3 of h3.sort((l3, d3) => d3.length - l3.length)) y2 = f3(y2, a3);
      return [y2];
    }
    case "path": {
      if (e5.length === 0) return [[]];
      let o2 = [];
      return c3(t4, e5[0], n3, [], o2), o2;
    }
    case "del":
      return e5.length === 0 ? [t4] : [s3(t4, e5[0], n3)];
    case "pick": {
      if (e5.length === 0) return [null];
      let o2 = [];
      for (let y2 of e5) c3(t4, y2, n3, [], o2);
      let h3 = null;
      for (let y2 of o2) {
        for (let l3 of y2) if (typeof l3 == "number" && l3 < 0) throw new Error("Out of bounds negative array index");
        let a3 = t4;
        for (let l3 of y2) {
          if (a3 == null) break;
          if (Array.isArray(a3) && typeof l3 == "number") a3 = a3[l3];
          else if (typeof a3 == "object" && typeof l3 == "string") a3 = a3[l3];
          else {
            a3 = null;
            break;
          }
        }
        h3 = u3(h3, y2, a3);
      }
      return [h3];
    }
    case "paths": {
      let o2 = [], h3 = (y2, a3) => {
        if (y2 && typeof y2 == "object") if (Array.isArray(y2)) for (let l3 = 0; l3 < y2.length; l3++) o2.push([...a3, l3]), h3(y2[l3], [...a3, l3]);
        else for (let l3 of Object.keys(y2)) o2.push([...a3, l3]), h3(y2[l3], [...a3, l3]);
      };
      return h3(t4, []), e5.length > 0 ? o2.filter((y2) => {
        let a3 = t4;
        for (let d3 of y2) if (Array.isArray(a3) && typeof d3 == "number") a3 = a3[d3];
        else if (a3 && typeof a3 == "object" && typeof d3 == "string") a3 = a3[d3];
        else return false;
        return p3(a3, e5[0], n3).some(i4);
      }) : o2;
    }
    case "leaf_paths": {
      let o2 = [], h3 = (y2, a3) => {
        if (y2 === null || typeof y2 != "object") o2.push(a3);
        else if (Array.isArray(y2)) for (let l3 = 0; l3 < y2.length; l3++) h3(y2[l3], [...a3, l3]);
        else for (let l3 of Object.keys(y2)) h3(y2[l3], [...a3, l3]);
      };
      return h3(t4, []), o2;
    }
    default:
      return null;
  }
}
function Z$2(t4, r2, e5, n3, p3, i4) {
  switch (r2) {
    case "IN": {
      if (e5.length === 0) return [false];
      if (e5.length === 1) {
        let c3 = p3(t4, e5[0], n3);
        for (let o2 of c3) if (i4(t4, o2)) return [true];
        return [false];
      }
      let u3 = p3(t4, e5[0], n3), f3 = p3(t4, e5[1], n3), s3 = new Set(f3.map((c3) => JSON.stringify(c3)));
      for (let c3 of u3) if (s3.has(JSON.stringify(c3))) return [true];
      return [false];
    }
    case "INDEX": {
      if (e5.length === 0) return [{}];
      if (e5.length === 1) {
        let s3 = p3(t4, e5[0], n3), c3 = {};
        for (let o2 of s3) {
          let h3 = String(o2);
          c3[h3] = o2;
        }
        return [c3];
      }
      if (e5.length === 2) {
        let s3 = p3(t4, e5[0], n3), c3 = {};
        for (let o2 of s3) {
          let h3 = p3(o2, e5[1], n3);
          if (h3.length > 0) {
            let y2 = String(h3[0]);
            c3[y2] = o2;
          }
        }
        return [c3];
      }
      let u3 = p3(t4, e5[0], n3), f3 = {};
      for (let s3 of u3) {
        let c3 = p3(s3, e5[1], n3), o2 = p3(s3, e5[2], n3);
        if (c3.length > 0 && o2.length > 0) {
          let h3 = String(c3[0]);
          f3[h3] = o2[0];
        }
      }
      return [f3];
    }
    case "JOIN": {
      if (e5.length < 2) return [null];
      let u3 = p3(t4, e5[0], n3)[0];
      if (!u3 || typeof u3 != "object" || Array.isArray(u3)) return [null];
      let f3 = u3;
      if (!Array.isArray(t4)) return [null];
      let s3 = [];
      for (let c3 of t4) {
        let o2 = p3(c3, e5[1], n3), h3 = o2.length > 0 ? String(o2[0]) : "", y2 = h3 in f3 ? f3[h3] : null;
        s3.push([c3, y2]);
      }
      return [s3];
    }
    default:
      return null;
  }
}
function z$2(t4, r2, e5, n3, p3) {
  switch (r2) {
    case "join": {
      if (!Array.isArray(t4)) return [null];
      let i4 = e5.length > 0 ? p3(t4, e5[0], n3) : [""];
      for (let u3 of t4) if (Array.isArray(u3) || u3 !== null && typeof u3 == "object") throw new Error("cannot join: contains arrays or objects");
      return i4.map((u3) => t4.map((f3) => f3 === null ? "" : typeof f3 == "string" ? f3 : String(f3)).join(String(u3)));
    }
    case "split": {
      if (typeof t4 != "string" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      return [t4.split(u3)];
    }
    case "splits": {
      if (typeof t4 != "string" || e5.length === 0) return [];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      try {
        let f3 = e5.length > 1 ? String(p3(t4, e5[1], n3)[0]) : "g", s3 = new RegExp(u3, f3.includes("g") ? f3 : `${f3}g`);
        return t4.split(s3);
      } catch {
        return [];
      }
    }
    case "scan": {
      if (typeof t4 != "string" || e5.length === 0) return [];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      try {
        let f3 = e5.length > 1 ? String(p3(t4, e5[1], n3)[0]) : "", s3 = new RegExp(u3, f3.includes("g") ? f3 : `${f3}g`);
        return [...t4.matchAll(s3)].map((o2) => o2.length > 1 ? o2.slice(1) : o2[0]);
      } catch {
        return [];
      }
    }
    case "test": {
      if (typeof t4 != "string" || e5.length === 0) return [false];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      try {
        let f3 = e5.length > 1 ? String(p3(t4, e5[1], n3)[0]) : "";
        return [new RegExp(u3, f3).test(t4)];
      } catch {
        return [false];
      }
    }
    case "match": {
      if (typeof t4 != "string" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      try {
        let f3 = e5.length > 1 ? String(p3(t4, e5[1], n3)[0]) : "", c3 = new RegExp(u3, `${f3}d`).exec(t4);
        if (!c3) return [];
        let o2 = c3.indices;
        return [{ offset: c3.index, length: c3[0].length, string: c3[0], captures: c3.slice(1).map((h3, y2) => ({ offset: o2?.[y2 + 1]?.[0] ?? null, length: h3?.length ?? 0, string: h3 ?? "", name: null })) }];
      } catch {
        return [null];
      }
    }
    case "capture": {
      if (typeof t4 != "string" || e5.length === 0) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      try {
        let f3 = e5.length > 1 ? String(p3(t4, e5[1], n3)[0]) : "", s3 = new RegExp(u3, f3), c3 = t4.match(s3);
        return !c3 || !c3.groups ? [{}] : [c3.groups];
      } catch {
        return [null];
      }
    }
    case "sub": {
      if (typeof t4 != "string" || e5.length < 2) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = p3(t4, e5[1], n3), f3 = String(i4[0]), s3 = String(u3[0]);
      try {
        let c3 = e5.length > 2 ? String(p3(t4, e5[2], n3)[0]) : "";
        return [t4.replace(new RegExp(f3, c3), s3)];
      } catch {
        return [t4];
      }
    }
    case "gsub": {
      if (typeof t4 != "string" || e5.length < 2) return [null];
      let i4 = p3(t4, e5[0], n3), u3 = p3(t4, e5[1], n3), f3 = String(i4[0]), s3 = String(u3[0]);
      try {
        let c3 = e5.length > 2 ? String(p3(t4, e5[2], n3)[0]) : "g", o2 = c3.includes("g") ? c3 : `${c3}g`;
        return [t4.replace(new RegExp(f3, o2), s3)];
      } catch {
        return [t4];
      }
    }
    case "ascii_downcase":
      return typeof t4 == "string" ? [t4.replace(/[A-Z]/g, (i4) => String.fromCharCode(i4.charCodeAt(0) + 32))] : [null];
    case "ascii_upcase":
      return typeof t4 == "string" ? [t4.replace(/[a-z]/g, (i4) => String.fromCharCode(i4.charCodeAt(0) - 32))] : [null];
    case "ltrimstr": {
      if (typeof t4 != "string" || e5.length === 0) return [t4];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      return [t4.startsWith(u3) ? t4.slice(u3.length) : t4];
    }
    case "rtrimstr": {
      if (typeof t4 != "string" || e5.length === 0) return [t4];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      return u3 === "" ? [t4] : [t4.endsWith(u3) ? t4.slice(0, -u3.length) : t4];
    }
    case "trimstr": {
      if (typeof t4 != "string" || e5.length === 0) return [t4];
      let i4 = p3(t4, e5[0], n3), u3 = String(i4[0]);
      if (u3 === "") return [t4];
      let f3 = t4;
      return f3.startsWith(u3) && (f3 = f3.slice(u3.length)), f3.endsWith(u3) && (f3 = f3.slice(0, -u3.length)), [f3];
    }
    case "trim":
      if (typeof t4 == "string") return [t4.trim()];
      throw new Error("trim input must be a string");
    case "ltrim":
      if (typeof t4 == "string") return [t4.trimStart()];
      throw new Error("trim input must be a string");
    case "rtrim":
      if (typeof t4 == "string") return [t4.trimEnd()];
      throw new Error("trim input must be a string");
    case "startswith": {
      if (typeof t4 != "string" || e5.length === 0) return [false];
      let i4 = p3(t4, e5[0], n3);
      return [t4.startsWith(String(i4[0]))];
    }
    case "endswith": {
      if (typeof t4 != "string" || e5.length === 0) return [false];
      let i4 = p3(t4, e5[0], n3);
      return [t4.endsWith(String(i4[0]))];
    }
    case "ascii":
      return typeof t4 == "string" && t4.length > 0 ? [t4.charCodeAt(0)] : [null];
    case "explode":
      return typeof t4 == "string" ? [Array.from(t4).map((i4) => i4.codePointAt(0))] : [null];
    case "implode":
      if (!Array.isArray(t4)) throw new Error("implode input must be an array");
      return [t4.map((f3) => {
        if (typeof f3 == "string") throw new Error(`string (${JSON.stringify(f3)}) can't be imploded, unicode codepoint needs to be numeric`);
        if (typeof f3 != "number" || Number.isNaN(f3)) throw new Error("number (null) can't be imploded, unicode codepoint needs to be numeric");
        let s3 = Math.trunc(f3);
        return s3 < 0 || s3 > 1114111 || s3 >= 55296 && s3 <= 57343 ? String.fromCodePoint(65533) : String.fromCodePoint(s3);
      }).join("")];
    default:
      return null;
  }
}
function v$3(t4, r2) {
  switch (r2) {
    case "type":
      return t4 === null ? ["null"] : Array.isArray(t4) ? ["array"] : typeof t4 == "boolean" ? ["boolean"] : typeof t4 == "number" ? ["number"] : typeof t4 == "string" ? ["string"] : typeof t4 == "object" ? ["object"] : ["null"];
    case "infinite":
      return [Number.POSITIVE_INFINITY];
    case "nan":
      return [Number.NaN];
    case "isinfinite":
      return [typeof t4 == "number" && !Number.isFinite(t4)];
    case "isnan":
      return [typeof t4 == "number" && Number.isNaN(t4)];
    case "isnormal":
      return [typeof t4 == "number" && Number.isFinite(t4) && t4 !== 0];
    case "isfinite":
      return [typeof t4 == "number" && Number.isFinite(t4)];
    case "numbers":
      return typeof t4 == "number" ? [t4] : [];
    case "strings":
      return typeof t4 == "string" ? [t4] : [];
    case "booleans":
      return typeof t4 == "boolean" ? [t4] : [];
    case "nulls":
      return t4 === null ? [t4] : [];
    case "arrays":
      return Array.isArray(t4) ? [t4] : [];
    case "objects":
      return t4 && typeof t4 == "object" && !Array.isArray(t4) ? [t4] : [];
    case "iterables":
      return Array.isArray(t4) || t4 && typeof t4 == "object" && !Array.isArray(t4) ? [t4] : [];
    case "scalars":
      return !Array.isArray(t4) && !(t4 && typeof t4 == "object") ? [t4] : [];
    case "values":
      return t4 === null ? [] : [t4];
    case "not":
      return t4 === false || t4 === null ? [true] : [false];
    case "null":
      return [null];
    case "true":
      return [true];
    case "false":
      return [false];
    case "empty":
      return [];
    default:
      return null;
  }
}
function D$5(t4, r2, e5) {
  if (r2.length === 0) return e5;
  let [n3, ...p3] = r2;
  if (typeof n3 == "number") {
    if (t4 && typeof t4 == "object" && !Array.isArray(t4)) throw new Error("Cannot index object with number");
    if (n3 > 536870911) throw new Error("Array index too large");
    if (n3 < 0) throw new Error("Out of bounds negative array index");
    let f3 = Array.isArray(t4) ? [...t4] : [];
    for (; f3.length <= n3; ) f3.push(null);
    return f3[n3] = D$5(f3[n3], p3, e5), f3;
  }
  if (Array.isArray(t4)) throw new Error("Cannot index array with string");
  let i4 = t4 && typeof t4 == "object" && !Array.isArray(t4) ? { ...t4 } : {};
  return i4[n3] = D$5(i4[n3], p3, e5), i4;
}
function B$6(t4, r2) {
  if (r2.length === 0) return null;
  if (r2.length === 1) {
    let p3 = r2[0];
    if (Array.isArray(t4) && typeof p3 == "number") {
      let i4 = [...t4];
      return i4.splice(p3, 1), i4;
    }
    if (t4 && typeof t4 == "object" && !Array.isArray(t4)) {
      let i4 = { ...t4 };
      return delete i4[String(p3)], i4;
    }
    return t4;
  }
  let [e5, ...n3] = r2;
  if (Array.isArray(t4) && typeof e5 == "number") {
    let p3 = [...t4];
    return p3[e5] = B$6(p3[e5], n3), p3;
  }
  if (t4 && typeof t4 == "object" && !Array.isArray(t4)) {
    let p3 = { ...t4 };
    return p3[String(e5)] = B$6(p3[String(e5)], n3), p3;
  }
  return t4;
}
var R$5 = class t extends Error {
  label;
  partialResults;
  constructor(r2, e5 = []) {
    super(`break ${r2}`), this.label = r2, this.partialResults = e5, this.name = "BreakError";
  }
  withPrependedResults(r2) {
    return new t(this.label, [...r2, ...this.partialResults]);
  }
}, L$6 = class L extends Error {
  value;
  constructor(r2) {
    super(typeof r2 == "string" ? r2 : JSON.stringify(r2)), this.value = r2, this.name = "JqError";
  }
}, yt$1 = 1e4, it$2 = 2e3, at$2 = { floor: Math.floor, ceil: Math.ceil, round: Math.round, sqrt: Math.sqrt, log: Math.log, log10: Math.log10, log2: Math.log2, exp: Math.exp, sin: Math.sin, cos: Math.cos, tan: Math.tan, asin: Math.asin, acos: Math.acos, atan: Math.atan, sinh: Math.sinh, cosh: Math.cosh, tanh: Math.tanh, asinh: Math.asinh, acosh: Math.acosh, atanh: Math.atanh, cbrt: Math.cbrt, expm1: Math.expm1, log1p: Math.log1p, trunc: Math.trunc };
function lt(t4) {
  return { vars: /* @__PURE__ */ new Map(), limits: { maxIterations: t4?.limits?.maxIterations ?? yt$1, maxDepth: t4?.limits?.maxDepth ?? it$2 }, env: t4?.env };
}
function _$5(t4, r2, e5) {
  let n3 = new Map(t4.vars);
  return n3.set(r2, e5), { vars: n3, limits: t4.limits, env: t4.env, root: t4.root, currentPath: t4.currentPath, funcs: t4.funcs, labels: t4.labels };
}
function I$6(t4, r2, e5) {
  switch (r2.type) {
    case "var":
      return _$5(t4, r2.name, e5);
    case "array": {
      if (!Array.isArray(e5)) return null;
      let n3 = t4;
      for (let p3 = 0; p3 < r2.elements.length; p3++) {
        let i4 = r2.elements[p3], u3 = p3 < e5.length ? e5[p3] : null, f3 = I$6(n3, i4, u3);
        if (f3 === null) return null;
        n3 = f3;
      }
      return n3;
    }
    case "object": {
      if (e5 === null || typeof e5 != "object" || Array.isArray(e5)) return null;
      let n3 = e5, p3 = t4;
      for (let i4 of r2.fields) {
        let u3;
        if (typeof i4.key == "string") u3 = i4.key;
        else {
          let c3 = m$1(e5, i4.key, t4);
          if (c3.length === 0) return null;
          u3 = String(c3[0]);
        }
        let f3 = u3 in n3 ? n3[u3] : null;
        i4.keyVar && (p3 = _$5(p3, i4.keyVar, f3));
        let s3 = I$6(p3, i4.pattern, f3);
        if (s3 === null) return null;
        p3 = s3;
      }
      return p3;
    }
  }
}
function mt(t4, r2) {
  let e5 = t4;
  for (let n3 of r2) if (e5 && typeof e5 == "object") e5 = e5[n3];
  else return;
  return e5;
}
function w$7(t4) {
  if (t4.type === "Identity") return [];
  if (t4.type === "Field") {
    let r2 = t4.base ? w$7(t4.base) : [];
    return r2 === null ? null : [...r2, t4.name];
  }
  if (t4.type === "Index" && t4.index.type === "Literal") {
    let r2 = t4.base ? w$7(t4.base) : [];
    if (r2 === null) return null;
    let e5 = t4.index.value;
    return typeof e5 == "number" || typeof e5 == "string" ? [...r2, e5] : null;
  }
  if (t4.type === "Pipe") {
    let r2 = w$7(t4.left);
    return r2 === null ? null : tt$3(r2, t4.right);
  }
  if (t4.type === "Call") {
    if (t4.name === "parent" || t4.name === "root") return null;
    if (t4.name === "first" && t4.args.length === 0) return [0];
    if (t4.name === "last" && t4.args.length === 0) return [-1];
  }
  return null;
}
function tt$3(t4, r2) {
  if (r2.type === "Call") {
    if (r2.name === "parent") {
      let e5 = 1;
      if (r2.args.length > 0 && r2.args[0].type === "Literal") {
        let n3 = r2.args[0].value;
        typeof n3 == "number" && (e5 = n3);
      }
      if (e5 >= 0) return t4.slice(0, Math.max(0, t4.length - e5));
      {
        let n3 = -e5 - 1;
        return t4.slice(0, Math.min(n3, t4.length));
      }
    }
    if (r2.name === "root") return [];
  }
  if (r2.type === "Field") {
    let e5 = w$7(r2);
    if (e5 !== null) return [...t4, ...e5];
  }
  if (r2.type === "Index" && r2.index.type === "Literal") {
    let e5 = w$7(r2);
    if (e5 !== null) return [...t4, ...e5];
  }
  if (r2.type === "Pipe") {
    let e5 = tt$3(t4, r2.left);
    return e5 === null ? null : tt$3(e5, r2.right);
  }
  return r2.type === "Identity" ? t4 : null;
}
function nt$2(t4, r2, e5) {
  if (r2.type === "Comma") {
    let n3 = [];
    try {
      n3.push(...m$1(t4, r2.left, e5));
    } catch (p3) {
      if (p3 instanceof b$i) throw p3;
      if (n3.length > 0) return n3;
      throw new Error("evaluation failed");
    }
    try {
      n3.push(...m$1(t4, r2.right, e5));
    } catch (p3) {
      if (p3 instanceof b$i) throw p3;
      return n3;
    }
    return n3;
  }
  return m$1(t4, r2, e5);
}
function m$1(t4, r2, e5) {
  let n3 = e5 && "vars" in e5 ? e5 : lt(e5);
  switch (n3.root === void 0 && (n3 = { ...n3, root: t4, currentPath: [] }), r2.type) {
    case "Identity":
      return [t4];
    case "Field":
      return (r2.base ? m$1(t4, r2.base, n3) : [t4]).flatMap((i4) => {
        if (i4 && typeof i4 == "object" && !Array.isArray(i4)) {
          let f3 = i4[r2.name];
          return [f3 === void 0 ? null : f3];
        }
        if (i4 === null) return [null];
        let u3 = Array.isArray(i4) ? "array" : typeof i4;
        throw new Error(`Cannot index ${u3} with string "${r2.name}"`);
      });
    case "Index":
      return (r2.base ? m$1(t4, r2.base, n3) : [t4]).flatMap((i4) => m$1(i4, r2.index, n3).flatMap((f3) => {
        if (typeof f3 == "number" && Array.isArray(i4)) {
          if (Number.isNaN(f3)) return [null];
          let s3 = Math.trunc(f3), c3 = s3 < 0 ? i4.length + s3 : s3;
          return c3 >= 0 && c3 < i4.length ? [i4[c3]] : [null];
        }
        return typeof f3 == "string" && i4 && typeof i4 == "object" && !Array.isArray(i4) ? [i4[f3]] : [null];
      }));
    case "Slice":
      return (r2.base ? m$1(t4, r2.base, n3) : [t4]).flatMap((i4) => {
        if (i4 === null) return [null];
        if (!Array.isArray(i4) && typeof i4 != "string") throw new Error(`Cannot slice ${typeof i4} (${JSON.stringify(i4)})`);
        let u3 = i4.length, f3 = r2.start ? m$1(t4, r2.start, n3) : [0], s3 = r2.end ? m$1(t4, r2.end, n3) : [u3];
        return f3.flatMap((c3) => s3.map((o2) => {
          let h3 = c3, y2 = o2, a3 = Number.isNaN(h3) ? 0 : Number.isInteger(h3) ? h3 : Math.floor(h3), l3 = Number.isNaN(y2) ? u3 : Number.isInteger(y2) ? y2 : Math.ceil(y2), d3 = st$3(a3, u3), g2 = st$3(l3, u3);
          return i4.slice(d3, g2);
        }));
      });
    case "Iterate":
      return (r2.base ? m$1(t4, r2.base, n3) : [t4]).flatMap((i4) => Array.isArray(i4) ? i4 : i4 && typeof i4 == "object" ? Object.values(i4) : []);
    case "Pipe": {
      let p3 = m$1(t4, r2.left, n3), i4 = w$7(r2.left), u3 = [];
      for (let f3 of p3) try {
        if (i4 !== null) {
          let s3 = { ...n3, currentPath: [...n3.currentPath ?? [], ...i4] };
          u3.push(...m$1(f3, r2.right, s3));
        } else u3.push(...m$1(f3, r2.right, n3));
      } catch (s3) {
        throw s3 instanceof R$5 ? s3.withPrependedResults(u3) : s3;
      }
      return u3;
    }
    case "Comma": {
      let p3 = m$1(t4, r2.left, n3), i4 = m$1(t4, r2.right, n3);
      return [...p3, ...i4];
    }
    case "Literal":
      return [r2.value];
    case "Array":
      return r2.elements ? [m$1(t4, r2.elements, n3)] : [[]];
    case "Object": {
      let p3 = [{}];
      for (let i4 of r2.entries) {
        let u3 = typeof i4.key == "string" ? [i4.key] : m$1(t4, i4.key, n3), f3 = m$1(t4, i4.value, n3), s3 = [];
        for (let c3 of p3) for (let o2 of u3) {
          if (typeof o2 != "string") {
            let h3 = o2 === null ? "null" : Array.isArray(o2) ? "array" : typeof o2;
            throw new Error(`Cannot use ${h3} (${JSON.stringify(o2)}) as object key`);
          }
          for (let h3 of f3) s3.push({ ...c3, [o2]: h3 });
        }
        p3.length = 0, p3.push(...s3);
      }
      return p3;
    }
    case "Paren":
      return m$1(t4, r2.expr, n3);
    case "BinaryOp":
      return gt$1(t4, r2.op, r2.left, r2.right, n3);
    case "UnaryOp":
      return m$1(t4, r2.operand, n3).map((i4) => {
        if (r2.op === "-") {
          if (typeof i4 == "number") return -i4;
          if (typeof i4 == "string") {
            let u3 = (f3) => f3.length > 5 ? `"${f3.slice(0, 3)}...` : JSON.stringify(f3);
            throw new Error(`string (${u3(i4)}) cannot be negated`);
          }
          return null;
        }
        return r2.op === "not" ? !E$4(i4) : null;
      });
    case "Cond":
      return m$1(t4, r2.cond, n3).flatMap((i4) => {
        if (E$4(i4)) return m$1(t4, r2.then, n3);
        for (let u3 of r2.elifs) if (m$1(t4, u3.cond, n3).some(E$4)) return m$1(t4, u3.then, n3);
        return r2.else ? m$1(t4, r2.else, n3) : [t4];
      });
    case "Try":
      try {
        return m$1(t4, r2.body, n3);
      } catch (p3) {
        if (r2.catch) {
          let i4 = p3 instanceof L$6 ? p3.value : p3 instanceof Error ? p3.message : String(p3);
          return m$1(i4, r2.catch, n3);
        }
        return [];
      }
    case "Call":
      return ot$1(t4, r2.name, r2.args, n3);
    case "VarBind":
      return m$1(t4, r2.value, n3).flatMap((i4) => {
        let u3 = null, f3 = [];
        r2.pattern ? f3.push(r2.pattern) : r2.name && f3.push({ type: "var", name: r2.name }), r2.alternatives && f3.push(...r2.alternatives);
        for (let s3 of f3) if (u3 = I$6(n3, s3, i4), u3 !== null) break;
        return u3 === null ? [] : m$1(t4, r2.body, u3);
      });
    case "VarRef": {
      if (r2.name === "$ENV") return [n3.env ?? {}];
      let p3 = n3.vars.get(r2.name);
      return p3 !== void 0 ? [p3] : [null];
    }
    case "Recurse": {
      let p3 = [], i4 = /* @__PURE__ */ new WeakSet(), u3 = (f3) => {
        if (f3 && typeof f3 == "object") {
          if (i4.has(f3)) return;
          i4.add(f3);
        }
        if (p3.push(f3), Array.isArray(f3)) for (let s3 of f3) u3(s3);
        else if (f3 && typeof f3 == "object") for (let s3 of Object.keys(f3)) u3(f3[s3]);
      };
      return u3(t4), p3;
    }
    case "Optional":
      try {
        return m$1(t4, r2.expr, n3);
      } catch {
        return [];
      }
    case "StringInterp":
      return [r2.parts.map((i4) => typeof i4 == "string" ? i4 : m$1(t4, i4, n3).map((f3) => typeof f3 == "string" ? f3 : JSON.stringify(f3)).join("")).join("")];
    case "UpdateOp":
      return [dt$1(t4, r2.path, r2.op, r2.value, n3)];
    case "Reduce": {
      let p3 = m$1(t4, r2.expr, n3), i4 = m$1(t4, r2.init, n3)[0], u3 = n3.limits.maxDepth ?? it$2;
      for (let f3 of p3) {
        let s3;
        if (r2.pattern) {
          if (s3 = I$6(n3, r2.pattern, f3), s3 === null) continue;
        } else s3 = _$5(n3, r2.varName, f3);
        if (i4 = m$1(i4, r2.update, s3)[0], T$4(i4, u3 + 1) > u3) return [null];
      }
      return [i4];
    }
    case "Foreach": {
      let p3 = m$1(t4, r2.expr, n3), i4 = m$1(t4, r2.init, n3)[0], u3 = [];
      for (let f3 of p3) try {
        let s3;
        if (r2.pattern) {
          if (s3 = I$6(n3, r2.pattern, f3), s3 === null) continue;
        } else s3 = _$5(n3, r2.varName, f3);
        if (i4 = m$1(i4, r2.update, s3)[0], r2.extract) {
          let c3 = m$1(i4, r2.extract, s3);
          u3.push(...c3);
        } else u3.push(i4);
      } catch (s3) {
        throw s3 instanceof R$5 ? s3.withPrependedResults(u3) : s3;
      }
      return u3;
    }
    case "Label":
      try {
        return m$1(t4, r2.body, { ...n3, labels: /* @__PURE__ */ new Set([...n3.labels ?? [], r2.name]) });
      } catch (p3) {
        if (p3 instanceof R$5 && p3.label === r2.name) return p3.partialResults;
        throw p3;
      }
    case "Break":
      throw new R$5(r2.name);
    case "Def": {
      let p3 = new Map(n3.funcs ?? []), i4 = `${r2.name}/${r2.params.length}`;
      p3.set(i4, { params: r2.params, body: r2.funcBody, closure: new Map(n3.funcs ?? []) });
      let u3 = { ...n3, funcs: p3 };
      return m$1(t4, r2.body, u3);
    }
    default: {
      let p3 = r2;
      throw new Error(`Unknown AST node type: ${p3.type}`);
    }
  }
}
function st$3(t4, r2) {
  return t4 < 0 ? Math.max(0, r2 + t4) : Math.min(t4, r2);
}
function dt$1(t4, r2, e5, n3, p3) {
  function i4(s3, c3) {
    switch (e5) {
      case "=":
        return c3;
      case "|=":
        return m$1(s3, n3, p3)[0] ?? null;
      case "+=":
        return typeof s3 == "number" && typeof c3 == "number" || typeof s3 == "string" && typeof c3 == "string" ? s3 + c3 : Array.isArray(s3) && Array.isArray(c3) ? [...s3, ...c3] : s3 && c3 && typeof s3 == "object" && typeof c3 == "object" ? { ...s3, ...c3 } : c3;
      case "-=":
        return typeof s3 == "number" && typeof c3 == "number" ? s3 - c3 : s3;
      case "*=":
        return typeof s3 == "number" && typeof c3 == "number" ? s3 * c3 : s3;
      case "/=":
        return typeof s3 == "number" && typeof c3 == "number" ? s3 / c3 : s3;
      case "%=":
        return typeof s3 == "number" && typeof c3 == "number" ? s3 % c3 : s3;
      case "//=":
        return s3 === null || s3 === false ? c3 : s3;
      default:
        return c3;
    }
  }
  function u3(s3, c3, o2) {
    switch (c3.type) {
      case "Identity":
        return o2(s3);
      case "Field": {
        if (c3.base) return u3(s3, c3.base, (h3) => {
          if (h3 && typeof h3 == "object" && !Array.isArray(h3)) {
            let y2 = { ...h3 };
            return y2[c3.name] = o2(y2[c3.name]), y2;
          }
          return h3;
        });
        if (s3 && typeof s3 == "object" && !Array.isArray(s3)) {
          let h3 = { ...s3 };
          return h3[c3.name] = o2(h3[c3.name]), h3;
        }
        return s3;
      }
      case "Index": {
        let y2 = m$1(t4, c3.index, p3)[0];
        if (typeof y2 == "number" && Number.isNaN(y2)) throw new Error("Cannot set array element at NaN index");
        if (typeof y2 == "number" && !Number.isInteger(y2) && (y2 = Math.trunc(y2)), c3.base) return u3(s3, c3.base, (a3) => {
          if (typeof y2 == "number" && Array.isArray(a3)) {
            let l3 = [...a3], d3 = y2 < 0 ? l3.length + y2 : y2;
            if (d3 >= 0) {
              for (; l3.length <= d3; ) l3.push(null);
              l3[d3] = o2(l3[d3]);
            }
            return l3;
          }
          if (typeof y2 == "string" && a3 && typeof a3 == "object" && !Array.isArray(a3)) {
            let l3 = { ...a3 };
            return l3[y2] = o2(l3[y2]), l3;
          }
          return a3;
        });
        if (typeof y2 == "number") {
          if (y2 > 536870911) throw new Error("Array index too large");
          if (y2 < 0 && (!s3 || !Array.isArray(s3))) throw new Error("Out of bounds negative array index");
          if (Array.isArray(s3)) {
            let l3 = [...s3], d3 = y2 < 0 ? l3.length + y2 : y2;
            if (d3 >= 0) {
              for (; l3.length <= d3; ) l3.push(null);
              l3[d3] = o2(l3[d3]);
            }
            return l3;
          }
          if (s3 == null) {
            let l3 = [];
            for (; l3.length <= y2; ) l3.push(null);
            return l3[y2] = o2(null), l3;
          }
          return s3;
        }
        if (typeof y2 == "string" && s3 && typeof s3 == "object" && !Array.isArray(s3)) {
          let a3 = { ...s3 };
          return a3[y2] = o2(a3[y2]), a3;
        }
        return s3;
      }
      case "Iterate": {
        let h3 = (y2) => {
          if (Array.isArray(y2)) return y2.map((a3) => o2(a3));
          if (y2 && typeof y2 == "object") {
            let a3 = {};
            for (let [l3, d3] of Object.entries(y2)) a3[l3] = o2(d3);
            return a3;
          }
          return y2;
        };
        return c3.base ? u3(s3, c3.base, h3) : h3(s3);
      }
      case "Pipe": {
        let h3 = u3(s3, c3.left, (y2) => y2);
        return u3(h3, c3.right, o2);
      }
      default:
        return o2(s3);
    }
  }
  return u3(t4, r2, (s3) => {
    if (e5 === "|=") return i4(s3, s3);
    let c3 = m$1(t4, n3, p3);
    return i4(s3, c3[0] ?? null);
  });
}
function At$1(t4, r2, e5) {
  function n3(i4, u3, f3) {
    switch (u3.type) {
      case "Identity":
        return f3;
      case "Field": {
        if (u3.base) {
          let s3 = m$1(i4, u3.base, e5)[0], c3 = n3(s3, { type: "Field", name: u3.name }, f3);
          return n3(i4, u3.base, c3);
        }
        return i4 && typeof i4 == "object" && !Array.isArray(i4) ? { ...i4, [u3.name]: f3 } : i4;
      }
      case "Index": {
        if (u3.base) {
          let o2 = m$1(i4, u3.base, e5)[0], h3 = n3(o2, { type: "Index", index: u3.index }, f3);
          return n3(i4, u3.base, h3);
        }
        let c3 = m$1(t4, u3.index, e5)[0];
        if (typeof c3 == "number" && Array.isArray(i4)) {
          let o2 = [...i4], h3 = c3 < 0 ? o2.length + c3 : c3;
          return h3 >= 0 && h3 < o2.length && (o2[h3] = f3), o2;
        }
        return typeof c3 == "string" && i4 && typeof i4 == "object" && !Array.isArray(i4) ? { ...i4, [c3]: f3 } : i4;
      }
      default:
        return i4;
    }
  }
  function p3(i4, u3) {
    switch (u3.type) {
      case "Identity":
        return null;
      case "Field": {
        if (u3.base) {
          let s3 = m$1(i4, u3.base, e5)[0];
          if (s3 == null) return i4;
          let c3 = p3(s3, { type: "Field", name: u3.name });
          return n3(i4, u3.base, c3);
        }
        if (i4 && typeof i4 == "object" && !Array.isArray(i4)) {
          let s3 = { ...i4 };
          return delete s3[u3.name], s3;
        }
        return i4;
      }
      case "Index": {
        if (u3.base) {
          let o2 = m$1(i4, u3.base, e5)[0];
          if (o2 == null) return i4;
          let h3 = p3(o2, { type: "Index", index: u3.index });
          return n3(i4, u3.base, h3);
        }
        let c3 = m$1(t4, u3.index, e5)[0];
        if (typeof c3 == "number" && Array.isArray(i4)) {
          let o2 = [...i4], h3 = c3 < 0 ? o2.length + c3 : c3;
          return h3 >= 0 && h3 < o2.length && o2.splice(h3, 1), o2;
        }
        if (typeof c3 == "string" && i4 && typeof i4 == "object" && !Array.isArray(i4)) {
          let o2 = { ...i4 };
          return delete o2[c3], o2;
        }
        return i4;
      }
      case "Iterate":
        return Array.isArray(i4) ? [] : i4 && typeof i4 == "object" ? {} : i4;
      case "Pipe": {
        let o2 = function(a3, l3, d3) {
          switch (l3.type) {
            case "Identity":
              return d3;
            case "Field":
              return a3 && typeof a3 == "object" && !Array.isArray(a3) ? { ...a3, [l3.name]: d3 } : a3;
            case "Index": {
              let A2 = m$1(t4, l3.index, e5)[0];
              if (typeof A2 == "number" && Array.isArray(a3)) {
                let b4 = [...a3], C2 = A2 < 0 ? b4.length + A2 : A2;
                return C2 >= 0 && C2 < b4.length && (b4[C2] = d3), b4;
              }
              return typeof A2 == "string" && a3 && typeof a3 == "object" && !Array.isArray(a3) ? { ...a3, [A2]: d3 } : a3;
            }
            case "Pipe": {
              let g2 = m$1(a3, l3.left, e5)[0], A2 = o2(g2, l3.right, d3);
              return o2(a3, l3.left, A2);
            }
            default:
              return a3;
          }
        };
        let s3 = u3.left, c3 = u3.right, h3 = m$1(i4, s3, e5)[0];
        if (h3 == null) return i4;
        let y2 = p3(h3, c3);
        return o2(i4, s3, y2);
      }
      default:
        return i4;
    }
  }
  return p3(t4, r2);
}
function gt$1(t4, r2, e5, n3, p3) {
  if (r2 === "and") return m$1(t4, e5, p3).flatMap((s3) => E$4(s3) ? m$1(t4, n3, p3).map((o2) => E$4(o2)) : [false]);
  if (r2 === "or") return m$1(t4, e5, p3).flatMap((s3) => E$4(s3) ? [true] : m$1(t4, n3, p3).map((o2) => E$4(o2)));
  if (r2 === "//") {
    let s3 = m$1(t4, e5, p3).filter((c3) => c3 != null && c3 !== false);
    return s3.length > 0 ? s3 : m$1(t4, n3, p3);
  }
  let i4 = m$1(t4, e5, p3), u3 = m$1(t4, n3, p3);
  return i4.flatMap((f3) => u3.map((s3) => {
    switch (r2) {
      case "+":
        return f3 === null ? s3 : s3 === null ? f3 : typeof f3 == "number" && typeof s3 == "number" || typeof f3 == "string" && typeof s3 == "string" ? f3 + s3 : Array.isArray(f3) && Array.isArray(s3) ? [...f3, ...s3] : f3 && s3 && typeof f3 == "object" && typeof s3 == "object" && !Array.isArray(f3) && !Array.isArray(s3) ? { ...f3, ...s3 } : null;
      case "-":
        if (typeof f3 == "number" && typeof s3 == "number") return f3 - s3;
        if (Array.isArray(f3) && Array.isArray(s3)) {
          let c3 = new Set(s3.map((o2) => JSON.stringify(o2)));
          return f3.filter((o2) => !c3.has(JSON.stringify(o2)));
        }
        if (typeof f3 == "string" && typeof s3 == "string") {
          let c3 = (o2) => o2.length > 10 ? `"${o2.slice(0, 10)}...` : JSON.stringify(o2);
          throw new Error(`string (${c3(f3)}) and string (${c3(s3)}) cannot be subtracted`);
        }
        return null;
      case "*":
        return typeof f3 == "number" && typeof s3 == "number" ? f3 * s3 : typeof f3 == "string" && typeof s3 == "number" ? f3.repeat(s3) : f3 && s3 && typeof f3 == "object" && typeof s3 == "object" && !Array.isArray(f3) && !Array.isArray(s3) ? H$6(f3, s3) : null;
      case "/":
        if (typeof f3 == "number" && typeof s3 == "number") {
          if (s3 === 0) throw new Error(`number (${f3}) and number (${s3}) cannot be divided because the divisor is zero`);
          return f3 / s3;
        }
        return typeof f3 == "string" && typeof s3 == "string" ? f3.split(s3) : null;
      case "%":
        if (typeof f3 == "number" && typeof s3 == "number") {
          if (s3 === 0) throw new Error(`number (${f3}) and number (${s3}) cannot be divided (remainder) because the divisor is zero`);
          return !Number.isFinite(f3) && !Number.isNaN(f3) ? !Number.isFinite(s3) && !Number.isNaN(s3) && f3 < 0 && s3 > 0 ? -1 : 0 : f3 % s3;
        }
        return null;
      case "==":
        return S$8(f3, s3);
      case "!=":
        return !S$8(f3, s3);
      case "<":
        return M$5(f3, s3) < 0;
      case "<=":
        return M$5(f3, s3) <= 0;
      case ">":
        return M$5(f3, s3) > 0;
      case ">=":
        return M$5(f3, s3) >= 0;
      default:
        return null;
    }
  }));
}
function ot$1(t4, r2, e5, n3) {
  let p3 = at$2[r2];
  if (p3) return typeof t4 == "number" ? [p3(t4)] : [null];
  let i4 = G$2(t4, r2, e5, n3, m$1);
  if (i4 !== null) return i4;
  let u3 = z$2(t4, r2, e5, n3, m$1);
  if (u3 !== null) return u3;
  let f3 = J$4(t4, r2, e5, n3, m$1);
  if (f3 !== null) return f3;
  let s3 = Y$3(t4, r2, n3.limits.maxDepth);
  if (s3 !== null) return s3;
  let c3 = v$3(t4, r2);
  if (c3 !== null) return c3;
  let o2 = W$5(t4, r2, e5, n3, m$1);
  if (o2 !== null) return o2;
  let h3 = K$2(t4, r2, e5, n3, m$1, nt$2, j$4, E$4, P$4, b$i);
  if (h3 !== null) return h3;
  let y2 = Q$4(t4, r2, e5, n3, m$1, E$4, D$5, B$6, At$1, U$4);
  if (y2 !== null) return y2;
  let a3 = q$5(t4, r2, e5, n3, m$1, S$8);
  if (a3 !== null) return a3;
  let l3 = V$5(t4, r2, e5, n3, m$1, nt$2, E$4, b$i);
  if (l3 !== null) return l3;
  let d3 = X$4(t4, r2, e5, n3, m$1, E$4, mt, ot$1);
  if (d3 !== null) return d3;
  let g2 = Z$2(t4, r2, e5, n3, m$1, S$8);
  if (g2 !== null) return g2;
  switch (r2) {
    case "builtins":
      return [["add/0", "all/0", "all/1", "all/2", "any/0", "any/1", "any/2", "arrays/0", "ascii/0", "ascii_downcase/0", "ascii_upcase/0", "booleans/0", "bsearch/1", "builtins/0", "combinations/0", "combinations/1", "contains/1", "debug/0", "del/1", "delpaths/1", "empty/0", "env/0", "error/0", "error/1", "explode/0", "first/0", "first/1", "flatten/0", "flatten/1", "floor/0", "from_entries/0", "fromdate/0", "fromjson/0", "getpath/1", "gmtime/0", "group_by/1", "gsub/2", "gsub/3", "has/1", "implode/0", "IN/1", "IN/2", "INDEX/1", "INDEX/2", "index/1", "indices/1", "infinite/0", "inside/1", "isempty/1", "isnan/0", "isnormal/0", "isvalid/1", "iterables/0", "join/1", "keys/0", "keys_unsorted/0", "last/0", "last/1", "length/0", "limit/2", "ltrimstr/1", "map/1", "map_values/1", "match/1", "match/2", "max/0", "max_by/1", "min/0", "min_by/1", "mktime/0", "modulemeta/1", "nan/0", "not/0", "nth/1", "nth/2", "null/0", "nulls/0", "numbers/0", "objects/0", "path/1", "paths/0", "paths/1", "pick/1", "range/1", "range/2", "range/3", "recurse/0", "recurse/1", "recurse_down/0", "repeat/1", "reverse/0", "rindex/1", "rtrimstr/1", "scalars/0", "scan/1", "scan/2", "select/1", "setpath/2", "skip/2", "sort/0", "sort_by/1", "split/1", "splits/1", "splits/2", "sqrt/0", "startswith/1", "strftime/1", "strings/0", "strptime/1", "sub/2", "sub/3", "test/1", "test/2", "to_entries/0", "toboolean/0", "todate/0", "tojson/0", "tostream/0", "fromstream/1", "truncate_stream/1", "tonumber/0", "tostring/0", "transpose/0", "trim/0", "ltrim/0", "rtrim/0", "type/0", "unique/0", "unique_by/1", "until/2", "utf8bytelength/0", "values/0", "walk/1", "while/2", "with_entries/1"]];
    case "error": {
      let A2 = e5.length > 0 ? m$1(t4, e5[0], n3)[0] : t4;
      throw new L$6(A2);
    }
    case "env":
      return [n3.env ?? {}];
    case "debug":
      return [t4];
    case "input_line_number":
      return [1];
    default: {
      let A2 = `${r2}/${e5.length}`, b4 = n3.funcs?.get(A2);
      if (b4) {
        let C2 = b4.closure ?? n3.funcs ?? /* @__PURE__ */ new Map(), $5 = new Map(C2);
        $5.set(A2, b4);
        for (let x4 = 0; x4 < b4.params.length; x4++) {
          let pt2 = b4.params[x4], rt2 = e5[x4];
          if (rt2) {
            let k3 = m$1(t4, rt2, n3), N2;
            if (k3.length === 0) N2 = { type: "Call", name: "empty", args: [] };
            else if (k3.length === 1) N2 = { type: "Literal", value: k3[0] };
            else {
              N2 = { type: "Literal", value: k3[k3.length - 1] };
              for (let F2 = k3.length - 2; F2 >= 0; F2--) N2 = { type: "Comma", left: { type: "Literal", value: k3[F2] }, right: N2 };
            }
            $5.set(`${pt2}/0`, { params: [], body: N2 });
          }
        }
        let ct2 = { ...n3, funcs: $5 };
        return m$1(t4, b4.body, ct2);
      }
      throw new Error(`Unknown function: ${r2}`);
    }
  }
}
function U$4(t4, r2, e5, n3, p3) {
  if (r2.type === "Comma") {
    let f3 = r2;
    U$4(t4, f3.left, e5, n3, p3), U$4(t4, f3.right, e5, n3, p3);
    return;
  }
  let i4 = w$7(r2);
  if (i4 !== null) {
    p3.push([...n3, ...i4]);
    return;
  }
  if (r2.type === "Iterate") {
    if (Array.isArray(t4)) for (let f3 = 0; f3 < t4.length; f3++) p3.push([...n3, f3]);
    else if (t4 && typeof t4 == "object") for (let f3 of Object.keys(t4)) p3.push([...n3, f3]);
    return;
  }
  if (r2.type === "Recurse") {
    let f3 = (s3, c3) => {
      if (p3.push([...n3, ...c3]), s3 && typeof s3 == "object") if (Array.isArray(s3)) for (let o2 = 0; o2 < s3.length; o2++) f3(s3[o2], [...c3, o2]);
      else for (let o2 of Object.keys(s3)) f3(s3[o2], [...c3, o2]);
    };
    f3(t4, []);
    return;
  }
  if (r2.type === "Pipe") {
    let f3 = w$7(r2.left);
    if (f3 !== null) {
      let s3 = m$1(t4, r2.left, e5);
      for (let c3 of s3) U$4(c3, r2.right, e5, [...n3, ...f3], p3);
      return;
    }
  }
  m$1(t4, r2, e5).length > 0 && p3.push(n3);
}
var bt = { and: "AND", or: "OR", not: "NOT", if: "IF", then: "THEN", elif: "ELIF", else: "ELSE", end: "END", as: "AS", try: "TRY", catch: "CATCH", true: "TRUE", false: "FALSE", null: "NULL", reduce: "REDUCE", foreach: "FOREACH", label: "LABEL", break: "BREAK", def: "DEF" };
function ft$1(t4) {
  let r2 = [], e5 = 0, n3 = (c3 = 0) => t4[e5 + c3], p3 = () => t4[e5++], i4 = () => e5 >= t4.length, u3 = (c3) => c3 >= "0" && c3 <= "9", f3 = (c3) => c3 >= "a" && c3 <= "z" || c3 >= "A" && c3 <= "Z" || c3 === "_", s3 = (c3) => f3(c3) || u3(c3);
  for (; !i4(); ) {
    let c3 = e5, o2 = p3();
    if (!(o2 === " " || o2 === "	" || o2 === `
` || o2 === "\r")) {
      if (o2 === "#") {
        for (; !i4() && n3() !== `
`; ) p3();
        continue;
      }
      if (o2 === "." && n3() === ".") {
        p3(), r2.push({ type: "DOTDOT", pos: c3 });
        continue;
      }
      if (o2 === "=" && n3() === "=") {
        p3(), r2.push({ type: "EQ", pos: c3 });
        continue;
      }
      if (o2 === "!" && n3() === "=") {
        p3(), r2.push({ type: "NE", pos: c3 });
        continue;
      }
      if (o2 === "<" && n3() === "=") {
        p3(), r2.push({ type: "LE", pos: c3 });
        continue;
      }
      if (o2 === ">" && n3() === "=") {
        p3(), r2.push({ type: "GE", pos: c3 });
        continue;
      }
      if (o2 === "/" && n3() === "/") {
        p3(), n3() === "=" ? (p3(), r2.push({ type: "UPDATE_ALT", pos: c3 })) : r2.push({ type: "ALT", pos: c3 });
        continue;
      }
      if (o2 === "+" && n3() === "=") {
        p3(), r2.push({ type: "UPDATE_ADD", pos: c3 });
        continue;
      }
      if (o2 === "-" && n3() === "=") {
        p3(), r2.push({ type: "UPDATE_SUB", pos: c3 });
        continue;
      }
      if (o2 === "*" && n3() === "=") {
        p3(), r2.push({ type: "UPDATE_MUL", pos: c3 });
        continue;
      }
      if (o2 === "/" && n3() === "=") {
        p3(), r2.push({ type: "UPDATE_DIV", pos: c3 });
        continue;
      }
      if (o2 === "%" && n3() === "=") {
        p3(), r2.push({ type: "UPDATE_MOD", pos: c3 });
        continue;
      }
      if (o2 === "=" && n3() !== "=") {
        r2.push({ type: "ASSIGN", pos: c3 });
        continue;
      }
      if (o2 === ".") {
        r2.push({ type: "DOT", pos: c3 });
        continue;
      }
      if (o2 === "|") {
        n3() === "=" ? (p3(), r2.push({ type: "UPDATE_PIPE", pos: c3 })) : r2.push({ type: "PIPE", pos: c3 });
        continue;
      }
      if (o2 === ",") {
        r2.push({ type: "COMMA", pos: c3 });
        continue;
      }
      if (o2 === ":") {
        r2.push({ type: "COLON", pos: c3 });
        continue;
      }
      if (o2 === ";") {
        r2.push({ type: "SEMICOLON", pos: c3 });
        continue;
      }
      if (o2 === "(") {
        r2.push({ type: "LPAREN", pos: c3 });
        continue;
      }
      if (o2 === ")") {
        r2.push({ type: "RPAREN", pos: c3 });
        continue;
      }
      if (o2 === "[") {
        r2.push({ type: "LBRACKET", pos: c3 });
        continue;
      }
      if (o2 === "]") {
        r2.push({ type: "RBRACKET", pos: c3 });
        continue;
      }
      if (o2 === "{") {
        r2.push({ type: "LBRACE", pos: c3 });
        continue;
      }
      if (o2 === "}") {
        r2.push({ type: "RBRACE", pos: c3 });
        continue;
      }
      if (o2 === "?") {
        r2.push({ type: "QUESTION", pos: c3 });
        continue;
      }
      if (o2 === "+") {
        r2.push({ type: "PLUS", pos: c3 });
        continue;
      }
      if (o2 === "-") {
        r2.push({ type: "MINUS", pos: c3 });
        continue;
      }
      if (o2 === "*") {
        r2.push({ type: "STAR", pos: c3 });
        continue;
      }
      if (o2 === "/") {
        r2.push({ type: "SLASH", pos: c3 });
        continue;
      }
      if (o2 === "%") {
        r2.push({ type: "PERCENT", pos: c3 });
        continue;
      }
      if (o2 === "<") {
        r2.push({ type: "LT", pos: c3 });
        continue;
      }
      if (o2 === ">") {
        r2.push({ type: "GT", pos: c3 });
        continue;
      }
      if (u3(o2)) {
        let h3 = o2;
        for (; !i4() && (u3(n3()) || n3() === "." || n3() === "e" || n3() === "E"); ) (n3() === "e" || n3() === "E") && (t4[e5 + 1] === "+" || t4[e5 + 1] === "-") && (h3 += p3()), h3 += p3();
        r2.push({ type: "NUMBER", value: Number(h3), pos: c3 });
        continue;
      }
      if (o2 === '"') {
        let h3 = "";
        for (; !i4() && n3() !== '"'; ) if (n3() === "\\") {
          if (p3(), i4()) break;
          let y2 = p3();
          switch (y2) {
            case "n":
              h3 += `
`;
              break;
            case "r":
              h3 += "\r";
              break;
            case "t":
              h3 += "	";
              break;
            case "\\":
              h3 += "\\";
              break;
            case '"':
              h3 += '"';
              break;
            case "(":
              h3 += "\\(";
              break;
            default:
              h3 += y2;
          }
        } else h3 += p3();
        i4() || p3(), r2.push({ type: "STRING", value: h3, pos: c3 });
        continue;
      }
      if (f3(o2) || o2 === "$" || o2 === "@") {
        let h3 = o2;
        for (; !i4() && s3(n3()); ) h3 += p3();
        let y2 = bt[h3];
        y2 ? r2.push({ type: y2, pos: c3 }) : r2.push({ type: "IDENT", value: h3, pos: c3 });
        continue;
      }
      throw new Error(`Unexpected character '${o2}' at position ${c3}`);
    }
  }
  return r2.push({ type: "EOF", pos: e5 }), r2;
}
var et$4 = class t2 {
  tokens;
  pos = 0;
  constructor(r2) {
    this.tokens = r2;
  }
  peek(r2 = 0) {
    return this.tokens[this.pos + r2] ?? { type: "EOF", pos: -1 };
  }
  advance() {
    return this.tokens[this.pos++];
  }
  check(r2) {
    return this.peek().type === r2;
  }
  match(...r2) {
    for (let e5 of r2) if (this.check(e5)) return this.advance();
    return null;
  }
  expect(r2, e5) {
    if (!this.check(r2)) throw new Error(`${e5} at position ${this.peek().pos}, got ${this.peek().type}`);
    return this.advance();
  }
  parse() {
    let r2 = this.parseExpr();
    if (!this.check("EOF")) throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
    return r2;
  }
  parseExpr() {
    return this.parsePipe();
  }
  parsePattern() {
    if (this.match("LBRACKET")) {
      let n3 = [];
      if (!this.check("RBRACKET")) for (n3.push(this.parsePattern()); this.match("COMMA") && !this.check("RBRACKET"); ) n3.push(this.parsePattern());
      return this.expect("RBRACKET", "Expected ']' after array pattern"), { type: "array", elements: n3 };
    }
    if (this.match("LBRACE")) {
      let n3 = [];
      if (!this.check("RBRACE")) for (n3.push(this.parsePatternField()); this.match("COMMA") && !this.check("RBRACE"); ) n3.push(this.parsePatternField());
      return this.expect("RBRACE", "Expected '}' after object pattern"), { type: "object", fields: n3 };
    }
    let r2 = this.expect("IDENT", "Expected variable name in pattern"), e5 = r2.value;
    if (!e5.startsWith("$")) throw new Error(`Variable name must start with $ at position ${r2.pos}`);
    return { type: "var", name: e5 };
  }
  parsePatternField() {
    if (this.match("LPAREN")) {
      let e5 = this.parseExpr();
      this.expect("RPAREN", "Expected ')' after computed key"), this.expect("COLON", "Expected ':' after computed key");
      let n3 = this.parsePattern();
      return { key: e5, pattern: n3 };
    }
    let r2 = this.peek();
    if (r2.type === "IDENT") {
      let e5 = r2.value;
      if (e5.startsWith("$")) {
        if (this.advance(), this.match("COLON")) {
          let n3 = this.parsePattern();
          return { key: e5.slice(1), pattern: n3, keyVar: e5 };
        }
        return { key: e5.slice(1), pattern: { type: "var", name: e5 } };
      }
      if (this.advance(), this.match("COLON")) {
        let n3 = this.parsePattern();
        return { key: e5, pattern: n3 };
      }
      return { key: e5, pattern: { type: "var", name: `$${e5}` } };
    }
    throw new Error(`Expected field name in object pattern at position ${r2.pos}`);
  }
  parsePipe() {
    let r2 = this.parseComma();
    for (; this.match("PIPE"); ) {
      let e5 = this.parseComma();
      r2 = { type: "Pipe", left: r2, right: e5 };
    }
    return r2;
  }
  parseComma() {
    let r2 = this.parseVarBind();
    for (; this.match("COMMA"); ) {
      let e5 = this.parseVarBind();
      r2 = { type: "Comma", left: r2, right: e5 };
    }
    return r2;
  }
  parseVarBind() {
    let r2 = this.parseUpdate();
    if (this.match("AS")) {
      let e5 = this.parsePattern(), n3 = [];
      for (; this.check("QUESTION") && this.peekAhead(1)?.type === "ALT"; ) this.advance(), this.advance(), n3.push(this.parsePattern());
      this.expect("PIPE", "Expected '|' after variable binding");
      let p3 = this.parseExpr();
      return e5.type === "var" && n3.length === 0 ? { type: "VarBind", name: e5.name, value: r2, body: p3 } : { type: "VarBind", name: e5.type === "var" ? e5.name : "", value: r2, body: p3, pattern: e5.type !== "var" ? e5 : void 0, alternatives: n3.length > 0 ? n3 : void 0 };
    }
    return r2;
  }
  peekAhead(r2) {
    let e5 = this.pos + r2;
    return e5 < this.tokens.length ? this.tokens[e5] : void 0;
  }
  parseUpdate() {
    let r2 = this.parseAlt(), e5 = { ASSIGN: "=", UPDATE_ADD: "+=", UPDATE_SUB: "-=", UPDATE_MUL: "*=", UPDATE_DIV: "/=", UPDATE_MOD: "%=", UPDATE_ALT: "//=", UPDATE_PIPE: "|=" }, n3 = this.match("ASSIGN", "UPDATE_ADD", "UPDATE_SUB", "UPDATE_MUL", "UPDATE_DIV", "UPDATE_MOD", "UPDATE_ALT", "UPDATE_PIPE");
    if (n3) {
      let p3 = this.parseVarBind();
      return { type: "UpdateOp", op: e5[n3.type], path: r2, value: p3 };
    }
    return r2;
  }
  parseAlt() {
    let r2 = this.parseOr();
    for (; this.match("ALT"); ) {
      let e5 = this.parseOr();
      r2 = { type: "BinaryOp", op: "//", left: r2, right: e5 };
    }
    return r2;
  }
  parseOr() {
    let r2 = this.parseAnd();
    for (; this.match("OR"); ) {
      let e5 = this.parseAnd();
      r2 = { type: "BinaryOp", op: "or", left: r2, right: e5 };
    }
    return r2;
  }
  parseAnd() {
    let r2 = this.parseNot();
    for (; this.match("AND"); ) {
      let e5 = this.parseNot();
      r2 = { type: "BinaryOp", op: "and", left: r2, right: e5 };
    }
    return r2;
  }
  parseNot() {
    return this.parseComparison();
  }
  parseComparison() {
    let r2 = this.parseAddSub(), e5 = { EQ: "==", NE: "!=", LT: "<", LE: "<=", GT: ">", GE: ">=" }, n3 = this.match("EQ", "NE", "LT", "LE", "GT", "GE");
    if (n3) {
      let p3 = this.parseAddSub();
      r2 = { type: "BinaryOp", op: e5[n3.type], left: r2, right: p3 };
    }
    return r2;
  }
  parseAddSub() {
    let r2 = this.parseMulDiv();
    for (; ; ) if (this.match("PLUS")) {
      let e5 = this.parseMulDiv();
      r2 = { type: "BinaryOp", op: "+", left: r2, right: e5 };
    } else if (this.match("MINUS")) {
      let e5 = this.parseMulDiv();
      r2 = { type: "BinaryOp", op: "-", left: r2, right: e5 };
    } else break;
    return r2;
  }
  parseMulDiv() {
    let r2 = this.parseUnary();
    for (; ; ) if (this.match("STAR")) {
      let e5 = this.parseUnary();
      r2 = { type: "BinaryOp", op: "*", left: r2, right: e5 };
    } else if (this.match("SLASH")) {
      let e5 = this.parseUnary();
      r2 = { type: "BinaryOp", op: "/", left: r2, right: e5 };
    } else if (this.match("PERCENT")) {
      let e5 = this.parseUnary();
      r2 = { type: "BinaryOp", op: "%", left: r2, right: e5 };
    } else break;
    return r2;
  }
  parseUnary() {
    return this.match("MINUS") ? { type: "UnaryOp", op: "-", operand: this.parseUnary() } : this.parsePostfix();
  }
  parsePostfix() {
    let r2 = this.parsePrimary();
    for (; ; ) if (this.match("QUESTION")) r2 = { type: "Optional", expr: r2 };
    else if (this.check("DOT") && (this.peek(1).type === "IDENT" || this.peek(1).type === "STRING")) this.advance(), r2 = { type: "Field", name: this.advance().value, base: r2 };
    else if (this.check("LBRACKET")) if (this.advance(), this.match("RBRACKET")) r2 = { type: "Iterate", base: r2 };
    else if (this.check("COLON")) {
      this.advance();
      let e5 = this.check("RBRACKET") ? void 0 : this.parseExpr();
      this.expect("RBRACKET", "Expected ']'"), r2 = { type: "Slice", end: e5, base: r2 };
    } else {
      let e5 = this.parseExpr();
      if (this.match("COLON")) {
        let n3 = this.check("RBRACKET") ? void 0 : this.parseExpr();
        this.expect("RBRACKET", "Expected ']'"), r2 = { type: "Slice", start: e5, end: n3, base: r2 };
      } else this.expect("RBRACKET", "Expected ']'"), r2 = { type: "Index", index: e5, base: r2 };
    }
    else break;
    return r2;
  }
  parsePrimary() {
    if (this.match("DOTDOT")) return { type: "Recurse" };
    if (this.match("DOT")) {
      if (this.check("LBRACKET")) {
        if (this.advance(), this.match("RBRACKET")) return { type: "Iterate" };
        if (this.check("COLON")) {
          this.advance();
          let e5 = this.check("RBRACKET") ? void 0 : this.parseExpr();
          return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", end: e5 };
        }
        let r2 = this.parseExpr();
        if (this.match("COLON")) {
          let e5 = this.check("RBRACKET") ? void 0 : this.parseExpr();
          return this.expect("RBRACKET", "Expected ']'"), { type: "Slice", start: r2, end: e5 };
        }
        return this.expect("RBRACKET", "Expected ']'"), { type: "Index", index: r2 };
      }
      return this.check("IDENT") || this.check("STRING") ? { type: "Field", name: this.advance().value } : { type: "Identity" };
    }
    if (this.match("TRUE")) return { type: "Literal", value: true };
    if (this.match("FALSE")) return { type: "Literal", value: false };
    if (this.match("NULL")) return { type: "Literal", value: null };
    if (this.check("NUMBER")) return { type: "Literal", value: this.advance().value };
    if (this.check("STRING")) {
      let e5 = this.advance().value;
      return e5.includes("\\(") ? this.parseStringInterpolation(e5) : { type: "Literal", value: e5 };
    }
    if (this.match("LBRACKET")) {
      if (this.match("RBRACKET")) return { type: "Array" };
      let r2 = this.parseExpr();
      return this.expect("RBRACKET", "Expected ']'"), { type: "Array", elements: r2 };
    }
    if (this.match("LBRACE")) return this.parseObjectConstruction();
    if (this.match("LPAREN")) {
      let r2 = this.parseExpr();
      return this.expect("RPAREN", "Expected ')'"), { type: "Paren", expr: r2 };
    }
    if (this.match("IF")) return this.parseIf();
    if (this.match("TRY")) {
      let r2 = this.parsePostfix(), e5;
      return this.match("CATCH") && (e5 = this.parsePostfix()), { type: "Try", body: r2, catch: e5 };
    }
    if (this.match("REDUCE")) {
      let r2 = this.parseAddSub();
      this.expect("AS", "Expected 'as' after reduce expression");
      let e5 = this.parsePattern();
      this.expect("LPAREN", "Expected '(' after variable");
      let n3 = this.parseExpr();
      this.expect("SEMICOLON", "Expected ';' after init expression");
      let p3 = this.parseExpr();
      this.expect("RPAREN", "Expected ')' after update expression");
      let i4 = e5.type === "var" ? e5.name : "";
      return { type: "Reduce", expr: r2, varName: i4, init: n3, update: p3, pattern: e5.type !== "var" ? e5 : void 0 };
    }
    if (this.match("FOREACH")) {
      let r2 = this.parseAddSub();
      this.expect("AS", "Expected 'as' after foreach expression");
      let e5 = this.parsePattern();
      this.expect("LPAREN", "Expected '(' after variable");
      let n3 = this.parseExpr();
      this.expect("SEMICOLON", "Expected ';' after init expression");
      let p3 = this.parseExpr(), i4;
      this.match("SEMICOLON") && (i4 = this.parseExpr()), this.expect("RPAREN", "Expected ')' after expressions");
      let u3 = e5.type === "var" ? e5.name : "";
      return { type: "Foreach", expr: r2, varName: u3, init: n3, update: p3, extract: i4, pattern: e5.type !== "var" ? e5 : void 0 };
    }
    if (this.match("LABEL")) {
      let r2 = this.expect("IDENT", "Expected label name (e.g., $out)"), e5 = r2.value;
      if (!e5.startsWith("$")) throw new Error(`Label name must start with $ at position ${r2.pos}`);
      this.expect("PIPE", "Expected '|' after label name");
      let n3 = this.parseExpr();
      return { type: "Label", name: e5, body: n3 };
    }
    if (this.match("BREAK")) {
      let r2 = this.expect("IDENT", "Expected label name to break to"), e5 = r2.value;
      if (!e5.startsWith("$")) throw new Error(`Break label must start with $ at position ${r2.pos}`);
      return { type: "Break", name: e5 };
    }
    if (this.match("DEF")) {
      let e5 = this.expect("IDENT", "Expected function name after def").value, n3 = [];
      if (this.match("LPAREN")) {
        if (!this.check("RPAREN")) {
          let u3 = this.expect("IDENT", "Expected parameter name");
          for (n3.push(u3.value); this.match("SEMICOLON"); ) {
            let f3 = this.expect("IDENT", "Expected parameter name");
            n3.push(f3.value);
          }
        }
        this.expect("RPAREN", "Expected ')' after parameters");
      }
      this.expect("COLON", "Expected ':' after function name");
      let p3 = this.parseExpr();
      this.expect("SEMICOLON", "Expected ';' after function body");
      let i4 = this.parseExpr();
      return { type: "Def", name: e5, params: n3, funcBody: p3, body: i4 };
    }
    if (this.match("NOT")) return { type: "Call", name: "not", args: [] };
    if (this.check("IDENT")) {
      let e5 = this.advance().value;
      if (e5.startsWith("$")) return { type: "VarRef", name: e5 };
      if (this.match("LPAREN")) {
        let n3 = [];
        if (!this.check("RPAREN")) for (n3.push(this.parseExpr()); this.match("SEMICOLON"); ) n3.push(this.parseExpr());
        return this.expect("RPAREN", "Expected ')'"), { type: "Call", name: e5, args: n3 };
      }
      return { type: "Call", name: e5, args: [] };
    }
    throw new Error(`Unexpected token ${this.peek().type} at position ${this.peek().pos}`);
  }
  parseObjectConstruction() {
    let r2 = [];
    if (!this.check("RBRACE")) do {
      let e5, n3;
      if (this.match("LPAREN")) e5 = this.parseExpr(), this.expect("RPAREN", "Expected ')'"), this.expect("COLON", "Expected ':'"), n3 = this.parseObjectValue();
      else if (this.check("IDENT")) {
        let p3 = this.advance().value;
        this.match("COLON") ? (e5 = p3, n3 = this.parseObjectValue()) : (e5 = p3, n3 = { type: "Field", name: p3 });
      } else if (this.check("STRING")) e5 = this.advance().value, this.expect("COLON", "Expected ':'"), n3 = this.parseObjectValue();
      else throw new Error(`Expected object key at position ${this.peek().pos}`);
      r2.push({ key: e5, value: n3 });
    } while (this.match("COMMA"));
    return this.expect("RBRACE", "Expected '}'"), { type: "Object", entries: r2 };
  }
  parseObjectValue() {
    let r2 = this.parseVarBind();
    for (; this.match("PIPE"); ) {
      let e5 = this.parseVarBind();
      r2 = { type: "Pipe", left: r2, right: e5 };
    }
    return r2;
  }
  parseIf() {
    let r2 = this.parseExpr();
    this.expect("THEN", "Expected 'then'");
    let e5 = this.parseExpr(), n3 = [];
    for (; this.match("ELIF"); ) {
      let i4 = this.parseExpr();
      this.expect("THEN", "Expected 'then' after elif");
      let u3 = this.parseExpr();
      n3.push({ cond: i4, then: u3 });
    }
    let p3;
    return this.match("ELSE") && (p3 = this.parseExpr()), this.expect("END", "Expected 'end'"), { type: "Cond", cond: r2, then: e5, elifs: n3, else: p3 };
  }
  parseStringInterpolation(r2) {
    let e5 = [], n3 = "", p3 = 0;
    for (; p3 < r2.length; ) if (r2[p3] === "\\" && r2[p3 + 1] === "(") {
      n3 && (e5.push(n3), n3 = ""), p3 += 2;
      let i4 = 1, u3 = "";
      for (; p3 < r2.length && i4 > 0; ) r2[p3] === "(" ? i4++ : r2[p3] === ")" && i4--, i4 > 0 && (u3 += r2[p3]), p3++;
      let f3 = ft$1(u3), s3 = new t2(f3);
      e5.push(s3.parse());
    } else n3 += r2[p3], p3++;
    return n3 && e5.push(n3), { type: "StringInterp", parts: e5 };
  }
};
function te$3(t4) {
  let r2 = ft$1(t4);
  return new et$4(r2).parse();
}
function I$5(s3) {
  let i4 = [], t4 = 0, o2 = s3.length;
  for (; t4 < o2; ) {
    for (; t4 < o2 && /\s/.test(s3[t4]); ) t4++;
    if (t4 >= o2) break;
    let a3 = t4, r2 = s3[t4];
    if (r2 === "{" || r2 === "[") {
      let n3 = r2, l3 = r2 === "{" ? "}" : "]", c3 = 1, p3 = false, d3 = false;
      for (t4++; t4 < o2 && c3 > 0; ) {
        let h3 = s3[t4];
        d3 ? d3 = false : h3 === "\\" ? d3 = true : h3 === '"' ? p3 = !p3 : p3 || (h3 === n3 ? c3++ : h3 === l3 && c3--), t4++;
      }
      if (c3 !== 0) throw new Error(`Unexpected end of JSON input at position ${t4} (unclosed ${n3})`);
      i4.push(JSON.parse(s3.slice(a3, t4)));
    } else if (r2 === '"') {
      let n3 = false;
      for (t4++; t4 < o2; ) {
        let l3 = s3[t4];
        if (n3) n3 = false;
        else if (l3 === "\\") n3 = true;
        else if (l3 === '"') {
          t4++;
          break;
        }
        t4++;
      }
      i4.push(JSON.parse(s3.slice(a3, t4)));
    } else if (r2 === "-" || r2 >= "0" && r2 <= "9") {
      for (; t4 < o2 && /[\d.eE+-]/.test(s3[t4]); ) t4++;
      i4.push(JSON.parse(s3.slice(a3, t4)));
    } else if (s3.slice(t4, t4 + 4) === "true") i4.push(true), t4 += 4;
    else if (s3.slice(t4, t4 + 5) === "false") i4.push(false), t4 += 5;
    else if (s3.slice(t4, t4 + 4) === "null") i4.push(null), t4 += 4;
    else {
      let n3 = s3.slice(t4, t4 + 10);
      throw new Error(`Invalid JSON at position ${a3}: unexpected '${n3.split(/\s/)[0]}'`);
    }
  }
  return i4;
}
var H$5 = { name: "jq", summary: "command-line JSON processor", usage: "jq [OPTIONS] FILTER [FILE]", options: ["-r, --raw-output  output strings without quotes", "-c, --compact     compact output (no pretty printing)", "-e, --exit-status set exit status based on output", "-s, --slurp       read entire input into array", "-n, --null-input  don't read any input", "-j, --join-output don't print newlines after each output", "-a, --ascii       force ASCII output", "-S, --sort-keys   sort object keys", "-C, --color       colorize output (ignored)", "-M, --monochrome  monochrome output (ignored)", "    --tab         use tabs for indentation", "    --help        display this help and exit"] };
function g$6(s3, i4, t4, o2, a3, r2 = 0) {
  if (s3 === null || s3 === void 0) return "null";
  if (typeof s3 == "boolean") return String(s3);
  if (typeof s3 == "number") return Number.isFinite(s3) ? String(s3) : "null";
  if (typeof s3 == "string") return t4 ? s3 : JSON.stringify(s3);
  let n3 = a3 ? "	" : "  ";
  if (Array.isArray(s3)) return s3.length === 0 ? "[]" : i4 ? `[${s3.map((c3) => g$6(c3, true, false, o2, a3)).join(",")}]` : `[
${s3.map((c3) => n3.repeat(r2 + 1) + g$6(c3, false, false, o2, a3, r2 + 1)).join(`,
`)}
${n3.repeat(r2)}]`;
  if (typeof s3 == "object") {
    let l3 = Object.keys(s3);
    return o2 && (l3 = l3.sort()), l3.length === 0 ? "{}" : i4 ? `{${l3.map((p3) => `${JSON.stringify(p3)}:${g$6(s3[p3], true, false, o2, a3)}`).join(",")}}` : `{
${l3.map((p3) => {
      let d3 = g$6(s3[p3], false, false, o2, a3, r2 + 1);
      return `${n3.repeat(r2 + 1)}${JSON.stringify(p3)}: ${d3}`;
    }).join(`,
`)}
${n3.repeat(r2)}}`;
  }
  return String(s3);
}
var P$3 = { name: "jq", async execute(s3, i4) {
  if (o$3(s3)) return s$1(H$5);
  let t4 = false, o2 = false, a3 = false, r2 = false, n3 = false, l3 = false, c3 = false, p3 = false, d3 = ".", h3 = false, j2 = [];
  for (let u3 = 0; u3 < s3.length; u3++) {
    let e5 = s3[u3];
    if (e5 === "-r" || e5 === "--raw-output") t4 = true;
    else if (e5 === "-c" || e5 === "--compact-output") o2 = true;
    else if (e5 === "-e" || e5 === "--exit-status") a3 = true;
    else if (e5 === "-s" || e5 === "--slurp") r2 = true;
    else if (e5 === "-n" || e5 === "--null-input") n3 = true;
    else if (e5 === "-j" || e5 === "--join-output") l3 = true;
    else if (!(e5 === "-a" || e5 === "--ascii")) {
      if (e5 === "-S" || e5 === "--sort-keys") c3 = true;
      else if (!(e5 === "-C" || e5 === "--color")) {
        if (!(e5 === "-M" || e5 === "--monochrome")) if (e5 === "--tab") p3 = true;
        else if (e5 === "-") j2.push("-");
        else {
          if (e5.startsWith("--")) return r$3("jq", e5);
          if (e5.startsWith("-")) {
            for (let f3 of e5.slice(1)) if (f3 === "r") t4 = true;
            else if (f3 === "c") o2 = true;
            else if (f3 === "e") a3 = true;
            else if (f3 === "s") r2 = true;
            else if (f3 === "n") n3 = true;
            else if (f3 === "j") l3 = true;
            else if (f3 !== "a") {
              if (f3 === "S") c3 = true;
              else if (f3 !== "C") {
                if (f3 !== "M") return r$3("jq", `-${f3}`);
              }
            }
          } else h3 ? j2.push(e5) : (d3 = e5, h3 = true);
        }
      }
    }
  }
  let S3 = [];
  if (!n3) if (j2.length === 0 || j2.length === 1 && j2[0] === "-") S3.push({ source: "stdin", content: i4.stdin });
  else {
    let u3 = await y$e(i4, j2, { cmdName: "jq", stopOnError: true });
    if (u3.exitCode !== 0) return { stdout: "", stderr: u3.stderr, exitCode: 2 };
    S3 = u3.files.map((e5) => ({ source: e5.filename || "stdin", content: e5.content }));
  }
  try {
    let u3 = te$3(d3), e5 = [], f3 = { limits: i4.limits ? { maxIterations: i4.limits.maxJqIterations } : void 0, env: i4.env };
    if (n3) e5 = m$1(null, u3, f3);
    else if (r2) {
      let m3 = [];
      for (let { content: $5 } of S3) {
        let y2 = $5.trim();
        y2 && m3.push(...I$5(y2));
      }
      e5 = m$1(m3, u3, f3);
    } else for (let { content: m3 } of S3) {
      let $5 = m3.trim();
      if (!$5) continue;
      let y2 = I$5($5);
      for (let A2 of y2) e5.push(...m$1(A2, u3, f3));
    }
    let b4 = e5.map((m3) => g$6(m3, o2, t4, c3, p3)), k3 = l3 ? "" : `
`, O2 = b4.join(k3), F2 = a3 && (e5.length === 0 || e5.every((m3) => m3 == null || m3 === false)) ? 1 : 0;
    return { stdout: O2 ? l3 ? O2 : `${O2}
` : "", stderr: "", exitCode: F2 };
  } catch (u3) {
    if (u3 instanceof b$i) return { stdout: "", stderr: `jq: ${u3.message}
`, exitCode: b$i.EXIT_CODE };
    let e5 = u3.message;
    return e5.includes("Unknown function") ? { stdout: "", stderr: `jq: error: ${e5}
`, exitCode: 3 } : { stdout: "", stderr: `jq: parse error: ${e5}
`, exitCode: 5 };
  }
} };
const jqRLRYRPOJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  jqCommand: P$3
});
var g$5 = { name: "base64", summary: "base64 encode/decode data and print to standard output", usage: "base64 [OPTION]... [FILE]", options: ["-d, --decode    decode data", "-w, --wrap=COLS wrap encoded lines after COLS character (default 76, 0 to disable)", "    --help      display this help and exit"] }, b$4 = { decode: { short: "d", long: "decode", type: "boolean" }, wrap: { short: "w", long: "wrap", type: "number", default: 76 } };
async function p$3(r2, o2, a3) {
  if (o2.length === 0 || o2.length === 1 && o2[0] === "-") return { ok: true, data: Uint8Array.from(r2.stdin, (e5) => e5.charCodeAt(0)) };
  let s3 = [];
  for (let e5 of o2) {
    if (e5 === "-") {
      s3.push(Uint8Array.from(r2.stdin, (t4) => t4.charCodeAt(0)));
      continue;
    }
    try {
      let t4 = r2.fs.resolvePath(r2.cwd, e5), n3 = await r2.fs.readFileBuffer(t4);
      s3.push(n3);
    } catch {
      return { ok: false, error: { stdout: "", stderr: `${a3}: ${e5}: No such file or directory
`, exitCode: 1 } };
    }
  }
  let c3 = s3.reduce((e5, t4) => e5 + t4.length, 0), i4 = new Uint8Array(c3), d3 = 0;
  for (let e5 of s3) i4.set(e5, d3), d3 += e5.length;
  return { ok: true, data: i4 };
}
var y$5 = { name: "base64", async execute(r2, o2) {
  if (o$3(r2)) return s$1(g$5);
  let a3 = x$g("base64", r2, b$4);
  if (!a3.ok) return a3.error;
  let s3 = a3.result.flags.decode, c3 = a3.result.flags.wrap, i4 = a3.result.positional;
  try {
    if (s3) {
      let t4 = await p$3(o2, i4, "base64");
      if (!t4.ok) return t4.error;
      let h3 = String.fromCharCode(...t4.data).replace(/\s/g, "");
      return { stdout: atob(h3), stderr: "", exitCode: 0 };
    }
    let d3 = await p$3(o2, i4, "base64");
    if (!d3.ok) return d3.error;
    let e5 = btoa(String.fromCharCode(...d3.data));
    if (c3 > 0) {
      let t4 = [];
      for (let n3 = 0; n3 < e5.length; n3 += c3) t4.push(e5.slice(n3, n3 + c3));
      e5 = t4.join(`
`) + (e5.length > 0 ? `
` : "");
    }
    return { stdout: e5, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: "", stderr: `base64: invalid input
`, exitCode: 1 };
  }
} };
const base643BME25ON = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  base64Command: y$5
});
var y$4 = { name: "diff", summary: "compare files line by line", usage: "diff [OPTION]... FILE1 FILE2", options: ["-u, --unified     output unified diff format (default)", "-q, --brief       report only whether files differ", "-s, --report-identical-files  report when files are the same", "-i, --ignore-case  ignore case differences", "    --help        display this help and exit"] }, C$4 = { unified: { short: "u", long: "unified", type: "boolean" }, brief: { short: "q", long: "brief", type: "boolean" }, reportSame: { short: "s", long: "report-identical-files", type: "boolean" }, ignoreCase: { short: "i", long: "ignore-case", type: "boolean" } }, $$3 = { name: "diff", async execute(d3, e5) {
  if (o$3(d3)) return s$1(y$4);
  let t4 = x$g("diff", d3, C$4);
  if (!t4.ok) return t4.error;
  let h3 = t4.result.flags.brief, g2 = t4.result.flags.reportSame, m3 = t4.result.flags.ignoreCase, a3 = t4.result.positional;
  if (t4.result.flags.unified, a3.length < 2) return { stdout: "", stderr: `diff: missing operand
`, exitCode: 2 };
  let o2, s3, [r2, i4] = a3;
  try {
    o2 = r2 === "-" ? e5.stdin : await e5.fs.readFile(e5.fs.resolvePath(e5.cwd, r2));
  } catch {
    return { stdout: "", stderr: `diff: ${r2}: No such file or directory
`, exitCode: 2 };
  }
  try {
    s3 = i4 === "-" ? e5.stdin : await e5.fs.readFile(e5.fs.resolvePath(e5.cwd, i4));
  } catch {
    return { stdout: "", stderr: `diff: ${i4}: No such file or directory
`, exitCode: 2 };
  }
  let f3 = o2, n3 = s3;
  return m3 && (f3 = f3.toLowerCase(), n3 = n3.toLowerCase()), f3 === n3 ? g2 ? { stdout: `Files ${r2} and ${i4} are identical
`, stderr: "", exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 } : h3 ? { stdout: `Files ${r2} and ${i4} differ
`, stderr: "", exitCode: 1 } : { stdout: createTwoFilesPatch(r2, i4, o2, s3, "", "", { context: 3 }), stderr: "", exitCode: 1 };
} };
const diffZLJYSBRK = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  diffCommand: $$3
});
var p$2 = { name: "date", summary: "display the current time in the given FORMAT", usage: "date [OPTION]... [+FORMAT]", options: ["-d, --date=STRING   display time described by STRING", "-u, --utc           print Coordinated Universal Time (UTC)", "-I, --iso-8601      output date/time in ISO 8601 format", "-R, --rfc-email     output RFC 5322 date format", "    --help          display this help and exit"] }, M$4 = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], h$4 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
function n$2(t4, i4 = 2) {
  return String(t4).padStart(i4, "0");
}
function T$3(t4) {
  let i4 = -t4.getTimezoneOffset();
  return `${i4 >= 0 ? "+" : "-"}${n$2(Math.floor(Math.abs(i4) / 60))}${n$2(Math.abs(i4) % 60)}`;
}
function d$4(t4, i4, r2) {
  let a3 = r2 ? { Y: t4.getUTCFullYear(), m: t4.getUTCMonth(), D: t4.getUTCDate(), H: t4.getUTCHours(), M: t4.getUTCMinutes(), S: t4.getUTCSeconds(), w: t4.getUTCDay() } : { Y: t4.getFullYear(), m: t4.getMonth(), D: t4.getDate(), H: t4.getHours(), M: t4.getMinutes(), S: t4.getSeconds(), w: t4.getDay() }, e5 = "", o2 = 0;
  for (; o2 < i4.length; ) {
    if (i4[o2] === "%" && o2 + 1 < i4.length) {
      let c3 = i4[++o2];
      switch (c3) {
        case "%":
          e5 += "%";
          break;
        case "a":
          e5 += M$4[a3.w];
          break;
        case "b":
        case "h":
          e5 += h$4[a3.m];
          break;
        case "d":
          e5 += n$2(a3.D);
          break;
        case "e":
          e5 += String(a3.D).padStart(2, " ");
          break;
        case "F":
          e5 += `${a3.Y}-${n$2(a3.m + 1)}-${n$2(a3.D)}`;
          break;
        case "H":
          e5 += n$2(a3.H);
          break;
        case "I":
          e5 += n$2(a3.H % 12 || 12);
          break;
        case "m":
          e5 += n$2(a3.m + 1);
          break;
        case "M":
          e5 += n$2(a3.M);
          break;
        case "n":
          e5 += `
`;
          break;
        case "p":
          e5 += a3.H < 12 ? "AM" : "PM";
          break;
        case "P":
          e5 += a3.H < 12 ? "am" : "pm";
          break;
        case "R":
          e5 += `${n$2(a3.H)}:${n$2(a3.M)}`;
          break;
        case "s":
          e5 += Math.floor(t4.getTime() / 1e3);
          break;
        case "S":
          e5 += n$2(a3.S);
          break;
        case "t":
          e5 += "	";
          break;
        case "T":
          e5 += `${n$2(a3.H)}:${n$2(a3.M)}:${n$2(a3.S)}`;
          break;
        case "u":
          e5 += a3.w || 7;
          break;
        case "w":
          e5 += a3.w;
          break;
        case "y":
          e5 += n$2(a3.Y % 100);
          break;
        case "Y":
          e5 += a3.Y;
          break;
        case "z":
          e5 += r2 ? "+0000" : T$3(t4);
          break;
        case "Z":
          e5 += r2 ? "UTC" : Intl.DateTimeFormat().resolvedOptions().timeZone;
          break;
        default:
          e5 += `%${c3}`;
      }
    } else e5 += i4[o2];
    o2++;
  }
  return e5;
}
function S$7(t4) {
  let i4 = new Date(t4);
  if (!Number.isNaN(i4.getTime())) return i4;
  if (/^\d+$/.test(t4)) return new Date(Number.parseInt(t4, 10) * 1e3);
  let r2 = t4.toLowerCase();
  return r2 === "now" || r2 === "today" ? /* @__PURE__ */ new Date() : r2 === "yesterday" ? new Date(Date.now() - 864e5) : r2 === "tomorrow" ? new Date(Date.now() + 864e5) : null;
}
var w$6 = { name: "date", async execute(t4, i4) {
  if (o$3(t4)) return s$1(p$2);
  let r2 = false, a3 = null, e5 = null, o2 = false, c3 = false;
  for (let f3 = 0; f3 < t4.length; f3++) {
    let s3 = t4[f3];
    if (s3 === "-u" || s3 === "--utc") r2 = true;
    else if (s3 === "-d" || s3 === "--date") a3 = t4[++f3] ?? "";
    else if (s3.startsWith("--date=")) a3 = s3.slice(7);
    else if (s3 === "-I" || s3 === "--iso-8601") o2 = true;
    else if (s3 === "-R" || s3 === "--rfc-email") c3 = true;
    else if (s3.startsWith("+")) e5 = s3.slice(1);
    else {
      if (s3.startsWith("--")) return r$3("date", s3);
      if (s3.startsWith("-")) for (let b4 of s3.slice(1)) if (b4 === "u") r2 = true;
      else if (b4 === "I") o2 = true;
      else if (b4 === "R") c3 = true;
      else return r$3("date", `-${b4}`);
    }
  }
  let l3 = a3 !== null ? S$7(a3) : /* @__PURE__ */ new Date();
  if (!l3) return { stdout: "", stderr: `date: invalid date '${a3}'
`, exitCode: 1 };
  let u3;
  return e5 ? u3 = d$4(l3, e5, r2) : o2 ? u3 = d$4(l3, "%Y-%m-%dT%H:%M:%S%z", r2) : c3 ? u3 = d$4(l3, "%a, %d %b %Y %H:%M:%S %z", r2) : u3 = d$4(l3, "%a %b %e %H:%M:%S %Z %Y", r2), { stdout: `${u3}
`, stderr: "", exitCode: 0 };
} };
const datePN3CMG7K = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  dateCommand: w$6
});
var i$2 = { name: "sleep", summary: "delay for a specified amount of time", usage: "sleep NUMBER[SUFFIX]", description: `Pause for NUMBER seconds. SUFFIX may be:
  s - seconds (default)
  m - minutes
  h - hours
  d - days

NUMBER may be a decimal number.`, options: ["    --help display this help and exit"] };
function l$2(t4) {
  let s3 = t4.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!s3) return null;
  let e5 = parseFloat(s3[1]);
  switch (s3[2] || "s") {
    case "s":
      return e5 * 1e3;
    case "m":
      return e5 * 60 * 1e3;
    case "h":
      return e5 * 60 * 60 * 1e3;
    case "d":
      return e5 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var d$3 = { name: "sleep", async execute(t4, s3) {
  if (o$3(t4)) return s$1(i$2);
  if (t4.length === 0) return { stdout: "", stderr: `sleep: missing operand
`, exitCode: 1 };
  let e5 = 0;
  for (let n3 of t4) {
    let r2 = l$2(n3);
    if (r2 === null) return { stdout: "", stderr: `sleep: invalid time interval '${n3}'
`, exitCode: 1 };
    e5 += r2;
  }
  return s3.sleep ? await s3.sleep(e5) : await new Promise((n3) => setTimeout(n3, e5)), { stdout: "", stderr: "", exitCode: 0 };
} };
const sleepAK4QE4WR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sleepCommand: d$3
});
var x$5 = { name: "timeout", summary: "run a command with a time limit", usage: "timeout [OPTION] DURATION COMMAND [ARG]...", description: `Start COMMAND, and kill it if still running after DURATION.

DURATION is a number with optional suffix:
  s - seconds (default)
  m - minutes
  h - hours
  d - days`, options: ["-k, --kill-after=DURATION  send KILL signal after DURATION if still running", "-s, --signal=SIGNAL        specify signal to send (default: TERM)", "    --preserve-status      exit with same status as COMMAND, even on timeout", "    --foreground           run command in foreground", "    --help                 display this help and exit"] };
function O$7(r2) {
  let i4 = r2.match(/^(\d+\.?\d*)(s|m|h|d)?$/);
  if (!i4) return null;
  let n3 = parseFloat(i4[1]);
  switch (i4[2] || "s") {
    case "s":
      return n3 * 1e3;
    case "m":
      return n3 * 60 * 1e3;
    case "h":
      return n3 * 60 * 60 * 1e3;
    case "d":
      return n3 * 24 * 60 * 60 * 1e3;
    default:
      return null;
  }
}
var w$5 = { name: "timeout", async execute(r2, i4) {
  if (o$3(r2)) return s$1(x$5);
  let s3 = 0;
  for (let t4 = 0; t4 < r2.length; t4++) {
    let e5 = r2[t4];
    if (e5 === "--preserve-status") s3 = t4 + 1;
    else if (e5 === "--foreground") s3 = t4 + 1;
    else if (e5 === "-k" || e5 === "--kill-after") t4++, s3 = t4 + 1;
    else if (e5.startsWith("--kill-after=")) s3 = t4 + 1;
    else if (e5 === "-s" || e5 === "--signal") t4++, s3 = t4 + 1;
    else if (e5.startsWith("--signal=")) s3 = t4 + 1;
    else {
      if (e5.startsWith("--") && e5 !== "--") return r$3("timeout", e5);
      if (e5.startsWith("-") && e5.length > 1 && e5 !== "--") if (e5.startsWith("-k")) s3 = t4 + 1;
      else if (e5.startsWith("-s")) s3 = t4 + 1;
      else return r$3("timeout", e5);
      else {
        s3 = t4;
        break;
      }
    }
  }
  let o2 = r2.slice(s3);
  if (o2.length === 0) return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
  let a3 = o2[0], l3 = O$7(a3);
  if (l3 === null) return { stdout: "", stderr: `timeout: invalid time interval '${a3}'
`, exitCode: 1 };
  let m3 = o2.slice(1);
  if (m3.length === 0) return { stdout: "", stderr: `timeout: missing operand
`, exitCode: 1 };
  if (!i4.exec) return { stdout: "", stderr: `timeout: exec not available
`, exitCode: 1 };
  let h3 = m3.map((t4) => t4.includes(" ") || t4.includes("	") ? `'${t4.replace(/'/g, "'\\''")}'` : t4).join(" "), p3 = new Promise((t4) => {
    setTimeout(() => t4({ timedOut: true }), l3);
  }), g2 = i4.exec(h3, { cwd: i4.cwd }).then((t4) => ({ timedOut: false, result: t4 })), d3 = await Promise.race([p3, g2]);
  return d3.timedOut ? { stdout: "", stderr: "", exitCode: 124 } : d3.result;
} };
const timeoutX3X3N6IE = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  timeoutCommand: w$5
});
var h$3 = { name: "time", async execute(i4, r2) {
  let a3 = "%e %M", n3 = null, d3 = false, m3 = false, t4 = 0;
  for (; t4 < i4.length; ) {
    let e5 = i4[t4];
    if (e5 === "-f" || e5 === "--format") {
      if (t4++, t4 >= i4.length) return { stdout: "", stderr: `time: missing argument to '-f'
`, exitCode: 1 };
      a3 = i4[t4], t4++;
    } else if (e5 === "-o" || e5 === "--output") {
      if (t4++, t4 >= i4.length) return { stdout: "", stderr: `time: missing argument to '-o'
`, exitCode: 1 };
      n3 = i4[t4], t4++;
    } else if (e5 === "-a" || e5 === "--append") d3 = true, t4++;
    else if (e5 === "-v" || e5 === "--verbose") a3 = `Command being timed: %C
Elapsed (wall clock) time: %e seconds
Maximum resident set size (kbytes): %M`, t4++;
    else if (e5 === "-p" || e5 === "--portability") m3 = true, t4++;
    else if (e5 === "--") {
      t4++;
      break;
    } else if (e5.startsWith("-")) t4++;
    else break;
  }
  let f3 = i4.slice(t4);
  if (f3.length === 0) return { stdout: "", stderr: "", exitCode: 0 };
  let c3 = performance.now(), u3 = f3.join(" "), s3;
  try {
    if (!r2.exec) return { stdout: "", stderr: `time: exec not available
`, exitCode: 1 };
    s3 = await r2.exec(u3, { env: r2.env, cwd: r2.cwd });
  } catch (e5) {
    s3 = { stdout: "", stderr: `time: ${e5.message}
`, exitCode: 127 };
  }
  let l3 = (performance.now() - c3) / 1e3, o2;
  if (m3 ? o2 = `real ${l3.toFixed(2)}
user 0.00
sys 0.00
` : (o2 = a3.replace(/%e/g, l3.toFixed(2)).replace(/%E/g, g$4(l3)).replace(/%M/g, "0").replace(/%S/g, "0.00").replace(/%U/g, "0.00").replace(/%P/g, "0%").replace(/%C/g, u3), o2.endsWith(`
`) || (o2 += `
`)), n3) try {
    let e5 = r2.fs.resolvePath(r2.cwd, n3);
    if (d3 && await r2.fs.exists(e5)) {
      let p3 = await r2.fs.readFile(e5);
      await r2.fs.writeFile(e5, p3 + o2);
    } else await r2.fs.writeFile(e5, o2);
  } catch (e5) {
    return { stdout: s3.stdout, stderr: s3.stderr + `time: cannot write to '${n3}': ${e5.message}
`, exitCode: s3.exitCode };
  }
  else s3 = { ...s3, stderr: s3.stderr + o2 };
  return s3;
} };
function g$4(i4) {
  let r2 = Math.floor(i4 / 3600), a3 = Math.floor(i4 % 3600 / 60), n3 = i4 % 60;
  return r2 > 0 ? `${r2}:${a3.toString().padStart(2, "0")}:${n3.toFixed(2).padStart(5, "0")}` : `${a3}:${n3.toFixed(2).padStart(5, "0")}`;
}
const timeUWXBG6CS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  timeCommand: h$3
});
var F$6 = { name: "seq", async execute(r2) {
  let d3 = `
`, h3 = false, i4 = [], e5 = 0;
  for (; e5 < r2.length; ) {
    let t4 = r2[e5];
    if (t4 === "-s" && e5 + 1 < r2.length) {
      d3 = r2[e5 + 1], e5 += 2;
      continue;
    }
    if (t4 === "-w") {
      h3 = true, e5++;
      continue;
    }
    if (t4 === "--") {
      e5++;
      break;
    }
    if (t4.startsWith("-") && t4 !== "-") {
      if (t4.startsWith("-s") && t4.length > 2) {
        d3 = t4.slice(2), e5++;
        continue;
      }
      if ((t4 === "-ws" || t4 === "-sw") && (h3 = true, e5 + 1 < r2.length)) {
        d3 = r2[e5 + 1], e5 += 2;
        continue;
      }
    }
    i4.push(t4), e5++;
  }
  for (; e5 < r2.length; ) i4.push(r2[e5]), e5++;
  if (i4.length === 0) return { stdout: "", stderr: `seq: missing operand
`, exitCode: 1 };
  let l3 = 1, o2 = 1, a3;
  if (i4.length === 1 ? a3 = parseFloat(i4[0]) : i4.length === 2 ? (l3 = parseFloat(i4[0]), a3 = parseFloat(i4[1])) : (l3 = parseFloat(i4[0]), o2 = parseFloat(i4[1]), a3 = parseFloat(i4[2])), Number.isNaN(l3) || Number.isNaN(o2) || Number.isNaN(a3)) return { stdout: "", stderr: `seq: invalid floating point argument: '${i4.find((n3) => Number.isNaN(parseFloat(n3)))}'
`, exitCode: 1 };
  if (o2 === 0) return { stdout: "", stderr: `seq: invalid Zero increment value: '0'
`, exitCode: 1 };
  let s3 = [], f3 = (t4) => {
    let n3 = String(t4), u3 = n3.indexOf(".");
    return u3 === -1 ? 0 : n3.length - u3 - 1;
  }, c3 = Math.max(f3(l3), f3(o2), f3(a3)), p3 = 1e5, m3 = 0;
  if (o2 > 0) for (let t4 = l3; t4 <= a3 + 1e-10 && !(m3++ > p3); t4 += o2) s3.push(c3 > 0 ? t4.toFixed(c3) : String(Math.round(t4)));
  else for (let t4 = l3; t4 >= a3 - 1e-10 && !(m3++ > p3); t4 += o2) s3.push(c3 > 0 ? t4.toFixed(c3) : String(Math.round(t4)));
  if (h3 && s3.length > 0) {
    let t4 = Math.max(...s3.map((n3) => n3.replace("-", "").length));
    for (let n3 = 0; n3 < s3.length; n3++) {
      let u3 = s3[n3].startsWith("-"), x4 = (u3 ? s3[n3].slice(1) : s3[n3]).padStart(t4, "0");
      s3[n3] = u3 ? `-${x4}` : x4;
    }
  }
  let g2 = s3.join(d3);
  return { stdout: g2 ? `${g2}
` : "", stderr: "", exitCode: 0 };
} };
const seq5VRIVQYP = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  seqCommand: F$6
});
var d$2 = { name: "expr", async execute(s3, r2) {
  if (s3.length === 0) return { stdout: "", stderr: `expr: missing operand
`, exitCode: 2 };
  try {
    let l3 = g$3(s3), h3 = l3 === "0" || l3 === "" ? 1 : 0;
    return { stdout: `${l3}
`, stderr: "", exitCode: h3 };
  } catch (l3) {
    return { stdout: "", stderr: `expr: ${l3.message}
`, exitCode: 2 };
  }
} };
function g$3(s3) {
  if (s3.length === 1) return s3[0];
  let r2 = 0;
  function l3() {
    let e5 = h3();
    for (; r2 < s3.length && s3[r2] === "|"; ) {
      r2++;
      let t4 = h3();
      if (e5 !== "0" && e5 !== "") return e5;
      e5 = t4;
    }
    return e5;
  }
  function h3() {
    let e5 = a3();
    for (; r2 < s3.length && s3[r2] === "&"; ) {
      r2++;
      let t4 = a3();
      (e5 === "0" || e5 === "" || t4 === "0" || t4 === "") && (e5 = "0");
    }
    return e5;
  }
  function a3() {
    let e5 = p3();
    for (; r2 < s3.length; ) {
      let t4 = s3[r2];
      if (["=", "!=", "<", ">", "<=", ">="].includes(t4)) {
        r2++;
        let o2 = p3(), n3 = parseInt(e5, 10), i4 = parseInt(o2, 10), f3 = !Number.isNaN(n3) && !Number.isNaN(i4), c3;
        t4 === "=" ? c3 = f3 ? n3 === i4 : e5 === o2 : t4 === "!=" ? c3 = f3 ? n3 !== i4 : e5 !== o2 : t4 === "<" ? c3 = f3 ? n3 < i4 : e5 < o2 : t4 === ">" ? c3 = f3 ? n3 > i4 : e5 > o2 : t4 === "<=" ? c3 = f3 ? n3 <= i4 : e5 <= o2 : c3 = f3 ? n3 >= i4 : e5 >= o2, e5 = c3 ? "1" : "0";
      } else break;
    }
    return e5;
  }
  function p3() {
    let e5 = N2();
    for (; r2 < s3.length; ) {
      let t4 = s3[r2];
      if (t4 === "+" || t4 === "-") {
        r2++;
        let o2 = N2(), n3 = parseInt(e5, 10), i4 = parseInt(o2, 10);
        if (Number.isNaN(n3) || Number.isNaN(i4)) throw new Error("non-integer argument");
        e5 = String(t4 === "+" ? n3 + i4 : n3 - i4);
      } else break;
    }
    return e5;
  }
  function N2() {
    let e5 = m3();
    for (; r2 < s3.length; ) {
      let t4 = s3[r2];
      if (t4 === "*" || t4 === "/" || t4 === "%") {
        r2++;
        let o2 = m3(), n3 = parseInt(e5, 10), i4 = parseInt(o2, 10);
        if (Number.isNaN(n3) || Number.isNaN(i4)) throw new Error("non-integer argument");
        if ((t4 === "/" || t4 === "%") && i4 === 0) throw new Error("division by zero");
        t4 === "*" ? e5 = String(n3 * i4) : t4 === "/" ? e5 = String(Math.trunc(n3 / i4)) : e5 = String(n3 % i4);
      } else break;
    }
    return e5;
  }
  function m3() {
    let e5 = u3();
    for (; r2 < s3.length && s3[r2] === ":"; ) {
      r2++;
      let t4 = u3(), o2 = new RegExp(`^${t4}`), n3 = e5.match(o2);
      n3 ? e5 = n3[1] !== void 0 ? n3[1] : String(n3[0].length) : e5 = "0";
    }
    return e5;
  }
  function u3() {
    if (r2 >= s3.length) throw new Error("syntax error");
    let e5 = s3[r2];
    if (e5 === "match") {
      r2++;
      let t4 = u3(), o2 = u3(), n3 = new RegExp(o2), i4 = t4.match(n3);
      return i4 ? i4[1] !== void 0 ? i4[1] : String(i4[0].length) : "0";
    }
    if (e5 === "substr") {
      r2++;
      let t4 = u3(), o2 = parseInt(u3(), 10), n3 = parseInt(u3(), 10);
      if (Number.isNaN(o2) || Number.isNaN(n3)) throw new Error("non-integer argument");
      return t4.substring(o2 - 1, o2 - 1 + n3);
    }
    if (e5 === "index") {
      r2++;
      let t4 = u3(), o2 = u3();
      for (let n3 = 0; n3 < t4.length; n3++) if (o2.includes(t4[n3])) return String(n3 + 1);
      return "0";
    }
    if (e5 === "length") {
      r2++;
      let t4 = u3();
      return String(t4.length);
    }
    if (e5 === "(") {
      r2++;
      let t4 = l3();
      if (r2 >= s3.length || s3[r2] !== ")") throw new Error("syntax error");
      return r2++, t4;
    }
    return r2++, e5;
  }
  return l3();
}
const exprDG4E7SIS = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  exprCommand: d$2
});
var k$4 = { sha1: "SHA-1", sha256: "SHA-256" };
function L$5(n3) {
  function h3(a3, u3) {
    return a3 << u3 | a3 >>> 32 - u3;
  }
  let p3 = new Uint32Array([3614090360, 3905402710, 606105819, 3250441966, 4118548399, 1200080426, 2821735955, 4249261313, 1770035416, 2336552879, 4294925233, 2304563134, 1804603682, 4254626195, 2792965006, 1236535329, 4129170786, 3225465664, 643717713, 3921069994, 3593408605, 38016083, 3634488961, 3889429448, 568446438, 3275163606, 4107603335, 1163531501, 2850285829, 4243563512, 1735328473, 2368359562, 4294588738, 2272392833, 1839030562, 4259657740, 2763975236, 1272893353, 4139469664, 3200236656, 681279174, 3936430074, 3572445317, 76029189, 3654602809, 3873151461, 530742520, 3299628645, 4096336452, 1126891415, 2878612391, 4237533241, 1700485571, 2399980690, 4293915773, 2240044497, 1873313359, 4264355552, 2734768916, 1309151649, 4149444226, 3174756917, 718787259, 3951481745]), A2 = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21], g2 = n3.length * 8, o2 = (n3.length % 64 < 56 ? 56 : 120) - n3.length % 64, s3 = new Uint8Array(n3.length + o2 + 8);
  s3.set(n3), s3[n3.length] = 128;
  let d3 = new DataView(s3.buffer);
  d3.setUint32(s3.length - 8, g2 >>> 0, true), d3.setUint32(s3.length - 4, Math.floor(g2 / 4294967296), true);
  let b4 = 1732584193, l3 = 4023233417, w4 = 2562383102, e5 = 271733878;
  for (let a3 = 0; a3 < s3.length; a3 += 64) {
    let u3 = new Uint32Array(16);
    for (let t4 = 0; t4 < 16; t4++) u3[t4] = d3.getUint32(a3 + t4 * 4, true);
    let y2 = b4, r2 = l3, x4 = w4, c3 = e5;
    for (let t4 = 0; t4 < 64; t4++) {
      let i4, U2;
      t4 < 16 ? (i4 = r2 & x4 | ~r2 & c3, U2 = t4) : t4 < 32 ? (i4 = c3 & r2 | ~c3 & x4, U2 = (5 * t4 + 1) % 16) : t4 < 48 ? (i4 = r2 ^ x4 ^ c3, U2 = (3 * t4 + 5) % 16) : (i4 = x4 ^ (r2 | ~c3), U2 = 7 * t4 % 16), i4 = i4 + y2 + p3[t4] + u3[U2] >>> 0, y2 = c3, c3 = x4, x4 = r2, r2 = r2 + h3(i4, A2[t4]) >>> 0;
    }
    b4 = b4 + y2 >>> 0, l3 = l3 + r2 >>> 0, w4 = w4 + x4 >>> 0, e5 = e5 + c3 >>> 0;
  }
  let f3 = new Uint8Array(16);
  return new DataView(f3.buffer).setUint32(0, b4, true), new DataView(f3.buffer).setUint32(4, l3, true), new DataView(f3.buffer).setUint32(8, w4, true), new DataView(f3.buffer).setUint32(12, e5, true), Array.from(f3).map((a3) => a3.toString(16).padStart(2, "0")).join("");
}
async function F$5(n3, h3) {
  if (n3 === "md5") return L$5(h3);
  let p3 = await globalThis.crypto.subtle.digest(k$4[n3], new Uint8Array(h3).buffer);
  return Array.from(new Uint8Array(p3)).map((A2) => A2.toString(16).padStart(2, "0")).join("");
}
function S$6(n3, h3, p3) {
  let A2 = { name: n3, summary: p3, usage: `${n3} [OPTION]... [FILE]...`, options: ["-c, --check    read checksums from FILEs and check them", "    --help     display this help and exit"] };
  return { name: n3, async execute(g2, o2) {
    if (o$3(g2)) return s$1(A2);
    let s3 = false, d3 = [];
    for (let e5 of g2) if (e5 === "-c" || e5 === "--check") s3 = true;
    else if (!(e5 === "-b" || e5 === "-t" || e5 === "--binary" || e5 === "--text")) {
      if (e5.startsWith("-") && e5 !== "-") return r$3(n3, e5);
      d3.push(e5);
    }
    d3.length === 0 && d3.push("-");
    let b4 = async (e5) => {
      if (e5 === "-") return Uint8Array.from(o2.stdin, (f3) => f3.charCodeAt(0));
      try {
        return await o2.fs.readFileBuffer(o2.fs.resolvePath(o2.cwd, e5));
      } catch {
        return null;
      }
    };
    if (s3) {
      let e5 = 0, f3 = "";
      for (let a3 of d3) {
        let u3 = a3 === "-" ? o2.stdin : await o2.fs.readFile(o2.fs.resolvePath(o2.cwd, a3)).catch(() => null);
        if (u3 === null) return { stdout: "", stderr: `${n3}: ${a3}: No such file or directory
`, exitCode: 1 };
        for (let y2 of u3.split(`
`)) {
          let r2 = y2.match(/^([a-fA-F0-9]+)\s+[* ]?(.+)$/);
          if (!r2) continue;
          let [, x4, c3] = r2, t4 = await b4(c3);
          if (t4 === null) {
            f3 += `${c3}: FAILED open or read
`, e5++;
            continue;
          }
          let i4 = await F$5(h3, t4) === x4.toLowerCase();
          f3 += `${c3}: ${i4 ? "OK" : "FAILED"}
`, i4 || e5++;
        }
      }
      return e5 > 0 && (f3 += `${n3}: WARNING: ${e5} computed checksum${e5 > 1 ? "s" : ""} did NOT match
`), { stdout: f3, stderr: "", exitCode: e5 > 0 ? 1 : 0 };
    }
    let l3 = "", w4 = 0;
    for (let e5 of d3) {
      let f3 = await b4(e5);
      if (f3 === null) {
        l3 += `${n3}: ${e5}: No such file or directory
`, w4 = 1;
        continue;
      }
      l3 += `${await F$5(h3, f3)}  ${e5}
`;
    }
    return { stdout: l3, stderr: "", exitCode: w4 };
  } };
}
var o$1 = S$6("md5sum", "md5", "compute MD5 message digest");
const md5sumKLHZSRUA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  md5sumCommand: o$1
});
var e$2 = S$6("sha1sum", "sha1", "compute SHA1 message digest");
const sha1sumWKWTIZGQ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sha1sumCommand: e$2
});
var e$1 = S$6("sha256sum", "sha256", "compute SHA256 message digest");
const sha256sumIUVNMBTA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sha256sumCommand: e$1
});
var Te$2 = o$4((ae2) => {
  ae2.read = function(i4, e5, t4, r2, n3) {
    var o2, s3, f3 = n3 * 8 - r2 - 1, a3 = (1 << f3) - 1, m3 = a3 >> 1, c3 = -7, p3 = t4 ? n3 - 1 : 0, l3 = t4 ? -1 : 1, u3 = i4[e5 + p3];
    for (p3 += l3, o2 = u3 & (1 << -c3) - 1, u3 >>= -c3, c3 += f3; c3 > 0; o2 = o2 * 256 + i4[e5 + p3], p3 += l3, c3 -= 8) ;
    for (s3 = o2 & (1 << -c3) - 1, o2 >>= -c3, c3 += r2; c3 > 0; s3 = s3 * 256 + i4[e5 + p3], p3 += l3, c3 -= 8) ;
    if (o2 === 0) o2 = 1 - m3;
    else {
      if (o2 === a3) return s3 ? NaN : (u3 ? -1 : 1) * (1 / 0);
      s3 = s3 + Math.pow(2, r2), o2 = o2 - m3;
    }
    return (u3 ? -1 : 1) * s3 * Math.pow(2, o2 - r2);
  };
  ae2.write = function(i4, e5, t4, r2, n3, o2) {
    var s3, f3, a3, m3 = o2 * 8 - n3 - 1, c3 = (1 << m3) - 1, p3 = c3 >> 1, l3 = n3 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, u3 = r2 ? 0 : o2 - 1, T3 = r2 ? 1 : -1, k3 = e5 < 0 || e5 === 0 && 1 / e5 < 0 ? 1 : 0;
    for (e5 = Math.abs(e5), isNaN(e5) || e5 === 1 / 0 ? (f3 = isNaN(e5) ? 1 : 0, s3 = c3) : (s3 = Math.floor(Math.log(e5) / Math.LN2), e5 * (a3 = Math.pow(2, -s3)) < 1 && (s3--, a3 *= 2), s3 + p3 >= 1 ? e5 += l3 / a3 : e5 += l3 * Math.pow(2, 1 - p3), e5 * a3 >= 2 && (s3++, a3 /= 2), s3 + p3 >= c3 ? (f3 = 0, s3 = c3) : s3 + p3 >= 1 ? (f3 = (e5 * a3 - 1) * Math.pow(2, n3), s3 = s3 + p3) : (f3 = e5 * Math.pow(2, p3 - 1) * Math.pow(2, n3), s3 = 0)); n3 >= 8; i4[t4 + u3] = f3 & 255, u3 += T3, f3 /= 256, n3 -= 8) ;
    for (s3 = s3 << n3 | f3, m3 += n3; m3 > 0; i4[t4 + u3] = s3 & 255, u3 += T3, s3 /= 256, m3 -= 8) ;
    i4[t4 + u3 - T3] |= k3 * 128;
  };
});
var ze$1 = o$4((Ki2, Me2) => {
  var j2 = 1e3, P2 = j2 * 60, N2 = P2 * 60, z2 = N2 * 24, yt2 = z2 * 7, bt2 = z2 * 365.25;
  Me2.exports = function(i4, e5) {
    e5 = e5 || {};
    var t4 = typeof i4;
    if (t4 === "string" && i4.length > 0) return Ct2(i4);
    if (t4 === "number" && isFinite(i4)) return e5.long ? vt2(i4) : Ft2(i4);
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(i4));
  };
  function Ct2(i4) {
    if (i4 = String(i4), !(i4.length > 100)) {
      var e5 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(i4);
      if (e5) {
        var t4 = parseFloat(e5[1]), r2 = (e5[2] || "ms").toLowerCase();
        switch (r2) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return t4 * bt2;
          case "weeks":
          case "week":
          case "w":
            return t4 * yt2;
          case "days":
          case "day":
          case "d":
            return t4 * z2;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return t4 * N2;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return t4 * P2;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return t4 * j2;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return t4;
          default:
            return;
        }
      }
    }
  }
  function Ft2(i4) {
    var e5 = Math.abs(i4);
    return e5 >= z2 ? Math.round(i4 / z2) + "d" : e5 >= N2 ? Math.round(i4 / N2) + "h" : e5 >= P2 ? Math.round(i4 / P2) + "m" : e5 >= j2 ? Math.round(i4 / j2) + "s" : i4 + "ms";
  }
  function vt2(i4) {
    var e5 = Math.abs(i4);
    return e5 >= z2 ? Y2(i4, e5, z2, "day") : e5 >= N2 ? Y2(i4, e5, N2, "hour") : e5 >= P2 ? Y2(i4, e5, P2, "minute") : e5 >= j2 ? Y2(i4, e5, j2, "second") : i4 + " ms";
  }
  function Y2(i4, e5, t4, r2) {
    var n3 = e5 >= t4 * 1.5;
    return Math.round(i4 / t4) + " " + r2 + (n3 ? "s" : "");
  }
});
var fe$2 = o$4((er2, Ue2) => {
  function St2(i4) {
    t4.debug = t4, t4.default = t4, t4.coerce = a3, t4.disable = s3, t4.enable = n3, t4.enabled = f3, t4.humanize = ze$1(), t4.destroy = m3, Object.keys(i4).forEach((c3) => {
      t4[c3] = i4[c3];
    }), t4.names = [], t4.skips = [], t4.formatters = {};
    function e5(c3) {
      let p3 = 0;
      for (let l3 = 0; l3 < c3.length; l3++) p3 = (p3 << 5) - p3 + c3.charCodeAt(l3), p3 |= 0;
      return t4.colors[Math.abs(p3) % t4.colors.length];
    }
    t4.selectColor = e5;
    function t4(c3) {
      let p3, l3 = null, u3, T3;
      function k3(...F2) {
        if (!k3.enabled) return;
        let O2 = k3, V4 = Number(/* @__PURE__ */ new Date()), rt2 = V4 - (p3 || V4);
        O2.diff = rt2, O2.prev = p3, O2.curr = V4, p3 = V4, F2[0] = t4.coerce(F2[0]), typeof F2[0] != "string" && F2.unshift("%O");
        let q2 = 0;
        F2[0] = F2[0].replace(/%([a-zA-Z%])/g, (re2, nt3) => {
          if (re2 === "%%") return "%";
          q2++;
          let ye2 = t4.formatters[nt3];
          if (typeof ye2 == "function") {
            let ot2 = F2[q2];
            re2 = ye2.call(O2, ot2), F2.splice(q2, 1), q2--;
          }
          return re2;
        }), t4.formatArgs.call(O2, F2), (O2.log || t4.log).apply(O2, F2);
      }
      return k3.namespace = c3, k3.useColors = t4.useColors(), k3.color = t4.selectColor(c3), k3.extend = r2, k3.destroy = t4.destroy, Object.defineProperty(k3, "enabled", { enumerable: true, configurable: false, get: () => l3 !== null ? l3 : (u3 !== t4.namespaces && (u3 = t4.namespaces, T3 = t4.enabled(c3)), T3), set: (F2) => {
        l3 = F2;
      } }), typeof t4.init == "function" && t4.init(k3), k3;
    }
    function r2(c3, p3) {
      let l3 = t4(this.namespace + (typeof p3 > "u" ? ":" : p3) + c3);
      return l3.log = this.log, l3;
    }
    function n3(c3) {
      t4.save(c3), t4.namespaces = c3, t4.names = [], t4.skips = [];
      let p3 = (typeof c3 == "string" ? c3 : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
      for (let l3 of p3) l3[0] === "-" ? t4.skips.push(l3.slice(1)) : t4.names.push(l3);
    }
    function o2(c3, p3) {
      let l3 = 0, u3 = 0, T3 = -1, k3 = 0;
      for (; l3 < c3.length; ) if (u3 < p3.length && (p3[u3] === c3[l3] || p3[u3] === "*")) p3[u3] === "*" ? (T3 = u3, k3 = l3, u3++) : (l3++, u3++);
      else if (T3 !== -1) u3 = T3 + 1, k3++, l3 = k3;
      else return false;
      for (; u3 < p3.length && p3[u3] === "*"; ) u3++;
      return u3 === p3.length;
    }
    function s3() {
      let c3 = [...t4.names, ...t4.skips.map((p3) => "-" + p3)].join(",");
      return t4.enable(""), c3;
    }
    function f3(c3) {
      for (let p3 of t4.skips) if (o2(c3, p3)) return false;
      for (let p3 of t4.names) if (o2(c3, p3)) return true;
      return false;
    }
    function a3(c3) {
      return c3 instanceof Error ? c3.stack || c3.message : c3;
    }
    function m3() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    return t4.enable(t4.load()), t4;
  }
  Ue2.exports = St2;
});
var Le$2 = o$4((C2, K2) => {
  C2.formatArgs = Et2;
  C2.save = At2;
  C2.load = Bt2;
  C2.useColors = Tt2;
  C2.storage = It2();
  C2.destroy = /* @__PURE__ */ (() => {
    let i4 = false;
    return () => {
      i4 || (i4 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
    };
  })();
  C2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
  function Tt2() {
    if (typeof window < "u" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) return true;
    if (typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) return false;
    let i4;
    return typeof document < "u" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window < "u" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator < "u" && navigator.userAgent && (i4 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(i4[1], 10) >= 31 || typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function Et2(i4) {
    if (i4[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + i4[0] + (this.useColors ? "%c " : " ") + "+" + K2.exports.humanize(this.diff), !this.useColors) return;
    let e5 = "color: " + this.color;
    i4.splice(1, 0, e5, "color: inherit");
    let t4 = 0, r2 = 0;
    i4[0].replace(/%[a-zA-Z%]/g, (n3) => {
      n3 !== "%%" && (t4++, n3 === "%c" && (r2 = t4));
    }), i4.splice(r2, 0, e5);
  }
  C2.log = console.debug || console.log || (() => {
  });
  function At2(i4) {
    try {
      i4 ? C2.storage.setItem("debug", i4) : C2.storage.removeItem("debug");
    } catch {
    }
  }
  function Bt2() {
    let i4;
    try {
      i4 = C2.storage.getItem("debug") || C2.storage.getItem("DEBUG");
    } catch {
    }
    return !i4 && typeof process < "u" && "env" in process && (i4 = process.env.DEBUG), i4;
  }
  function It2() {
    try {
      return localStorage;
    } catch {
    }
  }
  K2.exports = fe$2()(C2);
  var { formatters: Ot2 } = K2.exports;
  Ot2.j = function(i4) {
    try {
      return JSON.stringify(i4);
    } catch (e5) {
      return "[UnexpectedJSONParseError]: " + e5.message;
    }
  };
});
var je$3 = o$4((tr2, Re3) => {
  Re3.exports = (i4, e5 = process.argv) => {
    let t4 = i4.startsWith("-") ? "" : i4.length === 1 ? "-" : "--", r2 = e5.indexOf(t4 + i4), n3 = e5.indexOf("--");
    return r2 !== -1 && (n3 === -1 || r2 < n3);
  };
});
var _e$3 = o$4((ir2, Ne2) => {
  var Dt2 = m$d("os"), Pe2 = m$d("tty"), v2 = je$3(), { env: g2 } = process, I2;
  v2("no-color") || v2("no-colors") || v2("color=false") || v2("color=never") ? I2 = 0 : (v2("color") || v2("colors") || v2("color=true") || v2("color=always")) && (I2 = 1);
  "FORCE_COLOR" in g2 && (g2.FORCE_COLOR === "true" ? I2 = 1 : g2.FORCE_COLOR === "false" ? I2 = 0 : I2 = g2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(g2.FORCE_COLOR, 10), 3));
  function pe2(i4) {
    return i4 === 0 ? false : { level: i4, hasBasic: true, has256: i4 >= 2, has16m: i4 >= 3 };
  }
  function me2(i4, e5) {
    if (I2 === 0) return 0;
    if (v2("color=16m") || v2("color=full") || v2("color=truecolor")) return 3;
    if (v2("color=256")) return 2;
    if (i4 && !e5 && I2 === void 0) return 0;
    let t4 = I2 || 0;
    if (g2.TERM === "dumb") return t4;
    if (process.platform === "win32") {
      let r2 = Dt2.release().split(".");
      return Number(r2[0]) >= 10 && Number(r2[2]) >= 10586 ? Number(r2[2]) >= 14931 ? 3 : 2 : 1;
    }
    if ("CI" in g2) return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((r2) => r2 in g2) || g2.CI_NAME === "codeship" ? 1 : t4;
    if ("TEAMCITY_VERSION" in g2) return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(g2.TEAMCITY_VERSION) ? 1 : 0;
    if (g2.COLORTERM === "truecolor") return 3;
    if ("TERM_PROGRAM" in g2) {
      let r2 = parseInt((g2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (g2.TERM_PROGRAM) {
        case "iTerm.app":
          return r2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    return /-256(color)?$/i.test(g2.TERM) ? 2 : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(g2.TERM) || "COLORTERM" in g2 ? 1 : t4;
  }
  function Mt2(i4) {
    let e5 = me2(i4, i4 && i4.isTTY);
    return pe2(e5);
  }
  Ne2.exports = { supportsColor: Mt2, stdout: pe2(me2(true, Pe2.isatty(1))), stderr: pe2(me2(true, Pe2.isatty(2))) };
});
var He$3 = o$4((w4, te2) => {
  var zt2 = m$d("tty"), ee2 = m$d("util");
  w4.init = _t2;
  w4.log = jt2;
  w4.formatArgs = Lt2;
  w4.save = Pt2;
  w4.load = Nt2;
  w4.useColors = Ut2;
  w4.destroy = ee2.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  w4.colors = [6, 2, 3, 4, 5, 1];
  try {
    let i4 = _e$3();
    i4 && (i4.stderr || i4).level >= 2 && (w4.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221]);
  } catch {
  }
  w4.inspectOpts = Object.keys(process.env).filter((i4) => /^debug_/i.test(i4)).reduce((i4, e5) => {
    let t4 = e5.substring(6).toLowerCase().replace(/_([a-z])/g, (n3, o2) => o2.toUpperCase()), r2 = process.env[e5];
    return /^(yes|on|true|enabled)$/i.test(r2) ? r2 = true : /^(no|off|false|disabled)$/i.test(r2) ? r2 = false : r2 === "null" ? r2 = null : r2 = Number(r2), i4[t4] = r2, i4;
  }, {});
  function Ut2() {
    return "colors" in w4.inspectOpts ? !!w4.inspectOpts.colors : zt2.isatty(process.stderr.fd);
  }
  function Lt2(i4) {
    let { namespace: e5, useColors: t4 } = this;
    if (t4) {
      let r2 = this.color, n3 = "\x1B[3" + (r2 < 8 ? r2 : "8;5;" + r2), o2 = `  ${n3};1m${e5} \x1B[0m`;
      i4[0] = o2 + i4[0].split(`
`).join(`
` + o2), i4.push(n3 + "m+" + te2.exports.humanize(this.diff) + "\x1B[0m");
    } else i4[0] = Rt2() + e5 + " " + i4[0];
  }
  function Rt2() {
    return w4.inspectOpts.hideDate ? "" : (/* @__PURE__ */ new Date()).toISOString() + " ";
  }
  function jt2(...i4) {
    return process.stderr.write(ee2.formatWithOptions(w4.inspectOpts, ...i4) + `
`);
  }
  function Pt2(i4) {
    i4 ? process.env.DEBUG = i4 : delete process.env.DEBUG;
  }
  function Nt2() {
    return process.env.DEBUG;
  }
  function _t2(i4) {
    i4.inspectOpts = {};
    let e5 = Object.keys(w4.inspectOpts);
    for (let t4 = 0; t4 < e5.length; t4++) i4.inspectOpts[e5[t4]] = w4.inspectOpts[e5[t4]];
  }
  te2.exports = fe$2()(w4);
  var { formatters: $e2 } = te2.exports;
  $e2.o = function(i4) {
    return this.inspectOpts.colors = this.useColors, ee2.inspect(i4, this.inspectOpts).split(`
`).map((e5) => e5.trim()).join(" ");
  };
  $e2.O = function(i4) {
    return this.inspectOpts.colors = this.useColors, ee2.inspect(i4, this.inspectOpts);
  };
});
var We$3 = o$4((rr2, le2) => {
  typeof process > "u" || process.type === "renderer" || process.browser === true || process.__nwjs ? le2.exports = Le$2() : le2.exports = He$3();
});
var st$2 = "End-Of-Stream", x$4 = class x2 extends Error {
  constructor() {
    super(st$2), this.name = "EndOfStreamError";
  }
}, D$4 = class D extends Error {
  constructor(e5 = "The operation was aborted") {
    super(e5), this.name = "AbortError";
  }
};
var M$3 = class M2 {
  constructor() {
    this.endOfStream = false, this.interrupted = false, this.peekQueue = [];
  }
  async peek(e5, t4 = false) {
    let r2 = await this.read(e5, t4);
    return this.peekQueue.push(e5.subarray(0, r2)), r2;
  }
  async read(e5, t4 = false) {
    if (e5.length === 0) return 0;
    let r2 = this.readFromPeekBuffer(e5);
    if (this.endOfStream || (r2 += await this.readRemainderFromStream(e5.subarray(r2), t4)), r2 === 0 && !t4) throw new x$4();
    return r2;
  }
  readFromPeekBuffer(e5) {
    let t4 = e5.length, r2 = 0;
    for (; this.peekQueue.length > 0 && t4 > 0; ) {
      let n3 = this.peekQueue.pop();
      if (!n3) throw new Error("peekData should be defined");
      let o2 = Math.min(n3.length, t4);
      e5.set(n3.subarray(0, o2), r2), r2 += o2, t4 -= o2, o2 < n3.length && this.peekQueue.push(n3.subarray(o2));
    }
    return r2;
  }
  async readRemainderFromStream(e5, t4) {
    let r2 = 0;
    for (; r2 < e5.length && !this.endOfStream; ) {
      if (this.interrupted) throw new D$4();
      let n3 = await this.readFromStream(e5.subarray(r2), t4);
      if (n3 === 0) break;
      r2 += n3;
    }
    if (!t4 && r2 < e5.length) throw new x$4();
    return r2;
  }
};
var J$3 = class J extends M$3 {
  constructor(e5) {
    super(), this.reader = e5;
  }
  async abort() {
    return this.close();
  }
  async close() {
    this.reader.releaseLock();
  }
};
var _$4 = class _2 extends J$3 {
  async readFromStream(e5, t4) {
    if (e5.length === 0) return 0;
    let r2 = await this.reader.read(new Uint8Array(e5.length), { min: t4 ? void 0 : e5.length });
    return r2.done && (this.endOfStream = r2.done), r2.value ? (e5.set(r2.value), r2.value.length) : 0;
  }
};
var L$4 = class L2 extends M$3 {
  constructor(e5) {
    super(), this.reader = e5, this.buffer = null;
  }
  writeChunk(e5, t4) {
    let r2 = Math.min(t4.length, e5.length);
    return e5.set(t4.subarray(0, r2)), r2 < t4.length ? this.buffer = t4.subarray(r2) : this.buffer = null, r2;
  }
  async readFromStream(e5, t4) {
    if (e5.length === 0) return 0;
    let r2 = 0;
    for (this.buffer && (r2 += this.writeChunk(e5, this.buffer)); r2 < e5.length && !this.endOfStream; ) {
      let n3 = await this.reader.read();
      if (n3.done) {
        this.endOfStream = true;
        break;
      }
      n3.value && (r2 += this.writeChunk(e5.subarray(r2), n3.value));
    }
    if (!t4 && r2 === 0 && this.endOfStream) throw new x$4();
    return r2;
  }
  abort() {
    return this.interrupted = true, this.reader.cancel();
  }
  async close() {
    await this.abort(), this.reader.releaseLock();
  }
};
function oe$2(i4) {
  try {
    let e5 = i4.getReader({ mode: "byob" });
    return e5 instanceof ReadableStreamDefaultReader ? new L$4(e5) : new _$4(e5);
  } catch (e5) {
    if (e5 instanceof TypeError) return new L$4(i4.getReader());
    throw e5;
  }
}
var S$5 = class S {
  constructor(e5) {
    this.numBuffer = new Uint8Array(8), this.position = 0, this.onClose = e5?.onClose, e5?.abortSignal && e5.abortSignal.addEventListener("abort", () => {
      this.abort();
    });
  }
  async readToken(e5, t4 = this.position) {
    let r2 = new Uint8Array(e5.len);
    if (await this.readBuffer(r2, { position: t4 }) < e5.len) throw new x$4();
    return e5.get(r2, 0);
  }
  async peekToken(e5, t4 = this.position) {
    let r2 = new Uint8Array(e5.len);
    if (await this.peekBuffer(r2, { position: t4 }) < e5.len) throw new x$4();
    return e5.get(r2, 0);
  }
  async readNumber(e5) {
    if (await this.readBuffer(this.numBuffer, { length: e5.len }) < e5.len) throw new x$4();
    return e5.get(this.numBuffer, 0);
  }
  async peekNumber(e5) {
    if (await this.peekBuffer(this.numBuffer, { length: e5.len }) < e5.len) throw new x$4();
    return e5.get(this.numBuffer, 0);
  }
  async ignore(e5) {
    if (this.fileInfo.size !== void 0) {
      let t4 = this.fileInfo.size - this.position;
      if (e5 > t4) return this.position += t4, t4;
    }
    return this.position += e5, e5;
  }
  async close() {
    await this.abort(), await this.onClose?.();
  }
  normalizeOptions(e5, t4) {
    if (!this.supportsRandomAccess() && t4 && t4.position !== void 0 && t4.position < this.position) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    return { mayBeLess: false, offset: 0, length: e5.length, position: this.position, ...t4 };
  }
  abort() {
    return Promise.resolve();
  }
};
var ct = 256e3, X$3 = class X extends S$5 {
  constructor(e5, t4) {
    super(t4), this.streamReader = e5, this.fileInfo = t4?.fileInfo ?? {};
  }
  async readBuffer(e5, t4) {
    let r2 = this.normalizeOptions(e5, t4), n3 = r2.position - this.position;
    if (n3 > 0) return await this.ignore(n3), this.readBuffer(e5, t4);
    if (n3 < 0) throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
    if (r2.length === 0) return 0;
    let o2 = await this.streamReader.read(e5.subarray(0, r2.length), r2.mayBeLess);
    if (this.position += o2, (!t4 || !t4.mayBeLess) && o2 < r2.length) throw new x$4();
    return o2;
  }
  async peekBuffer(e5, t4) {
    let r2 = this.normalizeOptions(e5, t4), n3 = 0;
    if (r2.position) {
      let o2 = r2.position - this.position;
      if (o2 > 0) {
        let s3 = new Uint8Array(r2.length + o2);
        return n3 = await this.peekBuffer(s3, { mayBeLess: r2.mayBeLess }), e5.set(s3.subarray(o2)), n3 - o2;
      }
      if (o2 < 0) throw new Error("Cannot peek from a negative offset in a stream");
    }
    if (r2.length > 0) {
      try {
        n3 = await this.streamReader.peek(e5.subarray(0, r2.length), r2.mayBeLess);
      } catch (o2) {
        if (t4?.mayBeLess && o2 instanceof x$4) return 0;
        throw o2;
      }
      if (!r2.mayBeLess && n3 < r2.length) throw new x$4();
    }
    return n3;
  }
  async ignore(e5) {
    let t4 = Math.min(ct, e5), r2 = new Uint8Array(t4), n3 = 0;
    for (; n3 < e5; ) {
      let o2 = e5 - n3, s3 = await this.readBuffer(r2, { length: Math.min(t4, o2) });
      if (s3 < 0) return s3;
      n3 += s3;
    }
    return n3;
  }
  abort() {
    return this.streamReader.abort();
  }
  async close() {
    return this.streamReader.close();
  }
  supportsRandomAccess() {
    return false;
  }
};
var Z$1 = class Z extends S$5 {
  constructor(e5, t4) {
    super(t4), this.uint8Array = e5, this.fileInfo = { ...t4?.fileInfo ?? {}, size: e5.length };
  }
  async readBuffer(e5, t4) {
    t4?.position && (this.position = t4.position);
    let r2 = await this.peekBuffer(e5, t4);
    return this.position += r2, r2;
  }
  async peekBuffer(e5, t4) {
    let r2 = this.normalizeOptions(e5, t4), n3 = Math.min(this.uint8Array.length - r2.position, r2.length);
    if (!r2.mayBeLess && n3 < r2.length) throw new x$4();
    return e5.set(this.uint8Array.subarray(r2.position, r2.position + n3)), n3;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(e5) {
    this.position = e5;
  }
};
var Q$3 = class Q2 extends S$5 {
  constructor(e5, t4) {
    super(t4), this.blob = e5, this.fileInfo = { ...t4?.fileInfo ?? {}, size: e5.size, mimeType: e5.type };
  }
  async readBuffer(e5, t4) {
    t4?.position && (this.position = t4.position);
    let r2 = await this.peekBuffer(e5, t4);
    return this.position += r2, r2;
  }
  async peekBuffer(e5, t4) {
    let r2 = this.normalizeOptions(e5, t4), n3 = Math.min(this.blob.size - r2.position, r2.length);
    if (!r2.mayBeLess && n3 < r2.length) throw new x$4();
    let o2 = await this.blob.slice(r2.position, r2.position + n3).arrayBuffer();
    return e5.set(new Uint8Array(o2)), n3;
  }
  close() {
    return super.close();
  }
  supportsRandomAccess() {
    return true;
  }
  setPosition(e5) {
    this.position = e5;
  }
};
function se$2(i4, e5) {
  let t4 = oe$2(i4), r2 = e5 ?? {}, n3 = r2.onClose;
  return r2.onClose = async () => {
    if (await t4.close(), n3) return n3();
  }, new X$3(t4, r2);
}
function ve$2(i4, e5) {
  return new Z$1(i4, e5);
}
function Se$2(i4, e5) {
  return new Q$3(i4, e5);
}
q$d(Te$2());
var ce$3 = { 128: "", 130: "", 131: "", 132: "", 133: "", 134: "", 135: "", 136: "", 137: "", 138: "", 139: "", 140: "", 142: "", 145: "", 146: "", 147: "", 148: "", 149: "", 150: "", 151: "", 152: "", 153: "", 154: "", 155: "", 156: "", 158: "", 159: "" };
for (let [i4, e5] of Object.entries(ce$3)) Number.parseInt(i4);
function Ee$2(i4, e5 = "utf-8") {
  switch (e5.toLowerCase()) {
    case "utf-8":
    case "utf8":
      return typeof globalThis.TextDecoder < "u" ? new globalThis.TextDecoder("utf-8").decode(i4) : xt2(i4);
    case "utf-16le":
      return dt(i4);
    case "ascii":
      return ht(i4);
    case "latin1":
    case "iso-8859-1":
      return gt(i4);
    case "windows-1252":
      return wt$2(i4);
    default:
      throw new RangeError(`Encoding '${e5}' not supported`);
  }
}
function xt2(i4) {
  let e5 = "", t4 = 0;
  for (; t4 < i4.length; ) {
    let r2 = i4[t4++];
    if (r2 < 128) e5 += String.fromCharCode(r2);
    else if (r2 < 224) {
      let n3 = i4[t4++] & 63;
      e5 += String.fromCharCode((r2 & 31) << 6 | n3);
    } else if (r2 < 240) {
      let n3 = i4[t4++] & 63, o2 = i4[t4++] & 63;
      e5 += String.fromCharCode((r2 & 15) << 12 | n3 << 6 | o2);
    } else {
      let n3 = i4[t4++] & 63, o2 = i4[t4++] & 63, s3 = i4[t4++] & 63, f3 = (r2 & 7) << 18 | n3 << 12 | o2 << 6 | s3;
      f3 -= 65536, e5 += String.fromCharCode(55296 + (f3 >> 10 & 1023), 56320 + (f3 & 1023));
    }
  }
  return e5;
}
function dt(i4) {
  let e5 = "";
  for (let t4 = 0; t4 < i4.length; t4 += 2) e5 += String.fromCharCode(i4[t4] | i4[t4 + 1] << 8);
  return e5;
}
function ht(i4) {
  return String.fromCharCode(...i4.map((e5) => e5 & 127));
}
function gt(i4) {
  return String.fromCharCode(...i4);
}
function wt$2(i4) {
  let e5 = "";
  for (let t4 of i4) t4 >= 128 && t4 <= 159 && ce$3[t4] ? e5 += ce$3[t4] : e5 += String.fromCharCode(t4);
  return e5;
}
function y$3(i4) {
  return new DataView(i4.buffer, i4.byteOffset);
}
var Be$3 = { len: 1, get(i4, e5) {
  return y$3(i4).getUint8(e5);
}, put(i4, e5, t4) {
  return y$3(i4).setUint8(e5, t4), e5 + 1;
} }, d$1 = { len: 2, get(i4, e5) {
  return y$3(i4).getUint16(e5, true);
}, put(i4, e5, t4) {
  return y$3(i4).setUint16(e5, t4, true), e5 + 2;
} }, R$4 = { len: 2, get(i4, e5) {
  return y$3(i4).getUint16(e5);
}, put(i4, e5, t4) {
  return y$3(i4).setUint16(e5, t4), e5 + 2;
} };
var h$2 = { len: 4, get(i4, e5) {
  return y$3(i4).getUint32(e5, true);
}, put(i4, e5, t4) {
  return y$3(i4).setUint32(e5, t4, true), e5 + 4;
} }, Ie$2 = { len: 4, get(i4, e5) {
  return y$3(i4).getUint32(e5);
}, put(i4, e5, t4) {
  return y$3(i4).setUint32(e5, t4), e5 + 4;
} };
var Oe$3 = { len: 4, get(i4, e5) {
  return y$3(i4).getInt32(e5);
}, put(i4, e5, t4) {
  return y$3(i4).setInt32(e5, t4), e5 + 4;
} };
var De$2 = { len: 8, get(i4, e5) {
  return y$3(i4).getBigUint64(e5, true);
}, put(i4, e5, t4) {
  return y$3(i4).setBigUint64(e5, t4, true), e5 + 8;
} };
var b$3 = class b2 {
  constructor(e5, t4) {
    this.len = e5, this.encoding = t4;
  }
  get(e5, t4 = 0) {
    let r2 = e5.subarray(t4, t4 + this.len);
    return Ee$2(r2, this.encoding);
  }
};
var Je$3 = q$d(We$3());
var U$3 = { LocalFileHeader: 67324752, DataDescriptor: 134695760, CentralFileHeader: 33639248, EndOfCentralDirectory: 101010256 }, ue$2 = { get(i4) {
  return { signature: h$2.get(i4, 0), compressedSize: h$2.get(i4, 8), uncompressedSize: h$2.get(i4, 12) };
}, len: 16 }, Ve$3 = { get(i4) {
  let e5 = d$1.get(i4, 6);
  return { signature: h$2.get(i4, 0), minVersion: d$1.get(i4, 4), dataDescriptor: !!(e5 & 8), compressedMethod: d$1.get(i4, 8), compressedSize: h$2.get(i4, 18), uncompressedSize: h$2.get(i4, 22), filenameLength: d$1.get(i4, 26), extraFieldLength: d$1.get(i4, 28), filename: null };
}, len: 30 }, qe$3 = { get(i4) {
  return { signature: h$2.get(i4, 0), nrOfThisDisk: d$1.get(i4, 4), nrOfThisDiskWithTheStart: d$1.get(i4, 6), nrOfEntriesOnThisDisk: d$1.get(i4, 8), nrOfEntriesOfSize: d$1.get(i4, 10), sizeOfCd: h$2.get(i4, 12), offsetOfStartOfCd: h$2.get(i4, 16), zipFileCommentLength: d$1.get(i4, 20) };
}, len: 22 }, Ge$1 = { get(i4) {
  let e5 = d$1.get(i4, 8);
  return { signature: h$2.get(i4, 0), minVersion: d$1.get(i4, 6), dataDescriptor: !!(e5 & 8), compressedMethod: d$1.get(i4, 10), compressedSize: h$2.get(i4, 20), uncompressedSize: h$2.get(i4, 24), filenameLength: d$1.get(i4, 28), extraFieldLength: d$1.get(i4, 30), fileCommentLength: d$1.get(i4, 32), relativeOffsetOfLocalHeader: h$2.get(i4, 42), filename: null };
}, len: 46 };
function Xe$1(i4) {
  let e5 = new Uint8Array(h$2.len);
  return h$2.put(e5, 0, i4), e5;
}
var E$3 = (0, Je$3.default)("tokenizer:inflate"), xe$4 = 256 * 1024, $t = Xe$1(U$3.DataDescriptor), ie$3 = Xe$1(U$3.EndOfCentralDirectory), H$4 = class i2 {
  constructor(e5) {
    this.tokenizer = e5, this.syncBuffer = new Uint8Array(xe$4);
  }
  async isZip() {
    return await this.peekSignature() === U$3.LocalFileHeader;
  }
  peekSignature() {
    return this.tokenizer.peekToken(h$2);
  }
  async findEndOfCentralDirectoryLocator() {
    let e5 = this.tokenizer, t4 = Math.min(16 * 1024, e5.fileInfo.size), r2 = this.syncBuffer.subarray(0, t4);
    await this.tokenizer.readBuffer(r2, { position: e5.fileInfo.size - t4 });
    for (let n3 = r2.length - 4; n3 >= 0; n3--) if (r2[n3] === ie$3[0] && r2[n3 + 1] === ie$3[1] && r2[n3 + 2] === ie$3[2] && r2[n3 + 3] === ie$3[3]) return e5.fileInfo.size - t4 + n3;
    return -1;
  }
  async readCentralDirectory() {
    if (!this.tokenizer.supportsRandomAccess()) {
      E$3("Cannot reading central-directory without random-read support");
      return;
    }
    E$3("Reading central-directory...");
    let e5 = this.tokenizer.position, t4 = await this.findEndOfCentralDirectoryLocator();
    if (t4 > 0) {
      E$3("Central-directory 32-bit signature found");
      let r2 = await this.tokenizer.readToken(qe$3, t4), n3 = [];
      this.tokenizer.setPosition(r2.offsetOfStartOfCd);
      for (let o2 = 0; o2 < r2.nrOfEntriesOfSize; ++o2) {
        let s3 = await this.tokenizer.readToken(Ge$1);
        if (s3.signature !== U$3.CentralFileHeader) throw new Error("Expected Central-File-Header signature");
        s3.filename = await this.tokenizer.readToken(new b$3(s3.filenameLength, "utf-8")), await this.tokenizer.ignore(s3.extraFieldLength), await this.tokenizer.ignore(s3.fileCommentLength), n3.push(s3), E$3(`Add central-directory file-entry: n=${o2 + 1}/${n3.length}: filename=${n3[o2].filename}`);
      }
      return this.tokenizer.setPosition(e5), n3;
    }
    this.tokenizer.setPosition(e5);
  }
  async unzip(e5) {
    let t4 = await this.readCentralDirectory();
    if (t4) return this.iterateOverCentralDirectory(t4, e5);
    let r2 = false;
    do {
      let n3 = await this.readLocalFileHeader();
      if (!n3) break;
      let o2 = e5(n3);
      r2 = !!o2.stop;
      let s3;
      if (await this.tokenizer.ignore(n3.extraFieldLength), n3.dataDescriptor && n3.compressedSize === 0) {
        let f3 = [], a3 = xe$4;
        E$3("Compressed-file-size unknown, scanning for next data-descriptor-signature....");
        let m3 = -1;
        for (; m3 < 0 && a3 === xe$4; ) {
          a3 = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true }), m3 = Ht(this.syncBuffer.subarray(0, a3), $t);
          let c3 = m3 >= 0 ? m3 : a3;
          if (o2.handler) {
            let p3 = new Uint8Array(c3);
            await this.tokenizer.readBuffer(p3), f3.push(p3);
          } else await this.tokenizer.ignore(c3);
        }
        E$3(`Found data-descriptor-signature at pos=${this.tokenizer.position}`), o2.handler && await this.inflate(n3, Wt(f3), o2.handler);
      } else o2.handler ? (E$3(`Reading compressed-file-data: ${n3.compressedSize} bytes`), s3 = new Uint8Array(n3.compressedSize), await this.tokenizer.readBuffer(s3), await this.inflate(n3, s3, o2.handler)) : (E$3(`Ignoring compressed-file-data: ${n3.compressedSize} bytes`), await this.tokenizer.ignore(n3.compressedSize));
      if (E$3(`Reading data-descriptor at pos=${this.tokenizer.position}`), n3.dataDescriptor && (await this.tokenizer.readToken(ue$2)).signature !== 134695760) throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - ue$2.len}`);
    } while (!r2);
  }
  async iterateOverCentralDirectory(e5, t4) {
    for (let r2 of e5) {
      let n3 = t4(r2);
      if (n3.handler) {
        this.tokenizer.setPosition(r2.relativeOffsetOfLocalHeader);
        let o2 = await this.readLocalFileHeader();
        if (o2) {
          await this.tokenizer.ignore(o2.extraFieldLength);
          let s3 = new Uint8Array(r2.compressedSize);
          await this.tokenizer.readBuffer(s3), await this.inflate(o2, s3, n3.handler);
        }
      }
      if (n3.stop) break;
    }
  }
  async inflate(e5, t4, r2) {
    if (e5.compressedMethod === 0) return r2(t4);
    if (e5.compressedMethod !== 8) throw new Error(`Unsupported ZIP compression method: ${e5.compressedMethod}`);
    E$3(`Decompress filename=${e5.filename}, compressed-size=${t4.length}`);
    let n3 = await i2.decompressDeflateRaw(t4);
    return r2(n3);
  }
  static async decompressDeflateRaw(e5) {
    let t4 = new ReadableStream({ start(o2) {
      o2.enqueue(e5), o2.close();
    } }), r2 = new DecompressionStream("deflate-raw"), n3 = t4.pipeThrough(r2);
    try {
      let s3 = await new Response(n3).arrayBuffer();
      return new Uint8Array(s3);
    } catch (o2) {
      let s3 = o2 instanceof Error ? `Failed to deflate ZIP entry: ${o2.message}` : "Unknown decompression error in ZIP entry";
      throw new TypeError(s3);
    }
  }
  async readLocalFileHeader() {
    let e5 = await this.tokenizer.peekToken(h$2);
    if (e5 === U$3.LocalFileHeader) {
      let t4 = await this.tokenizer.readToken(Ve$3);
      return t4.filename = await this.tokenizer.readToken(new b$3(t4.filenameLength, "utf-8")), t4;
    }
    if (e5 === U$3.CentralFileHeader) return false;
    throw e5 === 3759263696 ? new Error("Encrypted ZIP") : new Error("Unexpected signature");
  }
};
function Ht(i4, e5) {
  let t4 = i4.length, r2 = e5.length;
  if (r2 > t4) return -1;
  for (let n3 = 0; n3 <= t4 - r2; n3++) {
    let o2 = true;
    for (let s3 = 0; s3 < r2; s3++) if (i4[n3 + s3] !== e5[s3]) {
      o2 = false;
      break;
    }
    if (o2) return n3;
  }
  return -1;
}
function Wt(i4) {
  let e5 = i4.reduce((n3, o2) => n3 + o2.length, 0), t4 = new Uint8Array(e5), r2 = 0;
  for (let n3 of i4) t4.set(n3, r2), r2 += n3.length;
  return t4;
}
var W$4 = class W2 {
  constructor(e5) {
    this.tokenizer = e5;
  }
  inflate() {
    let e5 = this.tokenizer;
    return new ReadableStream({ async pull(t4) {
      let r2 = new Uint8Array(1024), n3 = await e5.readBuffer(r2, { mayBeLess: true });
      if (n3 === 0) {
        t4.close();
        return;
      }
      t4.enqueue(r2.subarray(0, n3));
    } }).pipeThrough(new DecompressionStream("gzip"));
  }
};
({ utf8: new globalThis.TextDecoder("utf8") });
new globalThis.TextEncoder();
Array.from({ length: 256 }, (i4, e5) => e5.toString(16).padStart(2, "0"));
function de$2(i4) {
  let { byteLength: e5 } = i4;
  if (e5 === 6) return i4.getUint16(0) * 2 ** 32 + i4.getUint32(2);
  if (e5 === 5) return i4.getUint8(0) * 2 ** 32 + i4.getUint32(1);
  if (e5 === 4) return i4.getUint32(0);
  if (e5 === 3) return i4.getUint8(0) * 2 ** 16 + i4.getUint16(1);
  if (e5 === 2) return i4.getUint16(0);
  if (e5 === 1) return i4.getUint8(0);
}
function Ze$2(i4, e5) {
  if (e5 === "utf-16le") {
    let t4 = [];
    for (let r2 = 0; r2 < i4.length; r2++) {
      let n3 = i4.charCodeAt(r2);
      t4.push(n3 & 255, n3 >> 8 & 255);
    }
    return t4;
  }
  if (e5 === "utf-16be") {
    let t4 = [];
    for (let r2 = 0; r2 < i4.length; r2++) {
      let n3 = i4.charCodeAt(r2);
      t4.push(n3 >> 8 & 255, n3 & 255);
    }
    return t4;
  }
  return [...i4].map((t4) => t4.charCodeAt(0));
}
function Qe$3(i4, e5 = 0) {
  let t4 = Number.parseInt(new b$3(6).get(i4, 148).replace(/\0.*$/, "").trim(), 8);
  if (Number.isNaN(t4)) return false;
  let r2 = 256;
  for (let n3 = e5; n3 < e5 + 148; n3++) r2 += i4[n3];
  for (let n3 = e5 + 156; n3 < e5 + 512; n3++) r2 += i4[n3];
  return t4 === r2;
}
var Ye$2 = { get: (i4, e5) => i4[e5 + 3] & 127 | i4[e5 + 2] << 7 | i4[e5 + 1] << 14 | i4[e5] << 21, len: 4 };
var Ke$1 = ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "elf", "macho", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ttc", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "j2c", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf", "jls", "pst", "dwg", "parquet", "class", "arj", "cpio", "ace", "avro", "icc", "fbx", "vsdx", "vtt", "apk", "drc", "lz4", "potx", "xltx", "dotx", "xltm", "ott", "ots", "otp", "odg", "otg", "xlsm", "docm", "dotm", "potm", "pptm", "jar", "jmp", "rm", "sav", "ppsm", "ppsx", "tar.gz", "reg", "dat"], et$3 = ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.ms-powerpoint.slideshow.macroenabled.12", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/vnd.openxmlformats-officedocument.presentationml.slideshow", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/vnd.apache.arrow.file", "video/mp4", "audio/midi", "video/matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/wav", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "video/ogg", "audio/ogg", "audio/ogg; codecs=opus", "application/ogg", "audio/flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-elf", "application/x-mach-binary", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "font/collection", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/j2c", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "text/vtt", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd", "image/jls", "application/vnd.ms-outlook", "image/vnd.dwg", "application/vnd.apache.parquet", "application/java-vm", "application/x-arj", "application/x-cpio", "application/x-ace-compressed", "application/avro", "application/vnd.iccprofile", "application/x.autodesk.fbx", "application/vnd.visio", "application/vnd.android.package-archive", "application/vnd.google.draco", "application/x-lz4", "application/vnd.openxmlformats-officedocument.presentationml.template", "application/vnd.openxmlformats-officedocument.spreadsheetml.template", "application/vnd.openxmlformats-officedocument.wordprocessingml.template", "application/vnd.ms-excel.template.macroenabled.12", "application/vnd.oasis.opendocument.text-template", "application/vnd.oasis.opendocument.spreadsheet-template", "application/vnd.oasis.opendocument.presentation-template", "application/vnd.oasis.opendocument.graphics", "application/vnd.oasis.opendocument.graphics-template", "application/vnd.ms-excel.sheet.macroenabled.12", "application/vnd.ms-word.document.macroenabled.12", "application/vnd.ms-word.template.macroenabled.12", "application/vnd.ms-powerpoint.template.macroenabled.12", "application/vnd.ms-powerpoint.presentation.macroenabled.12", "application/java-archive", "application/vnd.rn-realmedia", "application/x-spss-sav", "application/x-ms-regedit", "application/x-ft-windows-registry-hive", "application/x-jmp-data"];
var he$2 = 4100;
async function ke$2(i4, e5) {
  return new we$3(e5).fromBuffer(i4);
}
function ge$2(i4) {
  switch (i4 = i4.toLowerCase(), i4) {
    case "application/epub+zip":
      return { ext: "epub", mime: i4 };
    case "application/vnd.oasis.opendocument.text":
      return { ext: "odt", mime: i4 };
    case "application/vnd.oasis.opendocument.text-template":
      return { ext: "ott", mime: i4 };
    case "application/vnd.oasis.opendocument.spreadsheet":
      return { ext: "ods", mime: i4 };
    case "application/vnd.oasis.opendocument.spreadsheet-template":
      return { ext: "ots", mime: i4 };
    case "application/vnd.oasis.opendocument.presentation":
      return { ext: "odp", mime: i4 };
    case "application/vnd.oasis.opendocument.presentation-template":
      return { ext: "otp", mime: i4 };
    case "application/vnd.oasis.opendocument.graphics":
      return { ext: "odg", mime: i4 };
    case "application/vnd.oasis.opendocument.graphics-template":
      return { ext: "otg", mime: i4 };
    case "application/vnd.openxmlformats-officedocument.presentationml.slideshow":
      return { ext: "ppsx", mime: i4 };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":
      return { ext: "xlsx", mime: i4 };
    case "application/vnd.ms-excel.sheet.macroenabled":
      return { ext: "xlsm", mime: "application/vnd.ms-excel.sheet.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.spreadsheetml.template":
      return { ext: "xltx", mime: i4 };
    case "application/vnd.ms-excel.template.macroenabled":
      return { ext: "xltm", mime: "application/vnd.ms-excel.template.macroenabled.12" };
    case "application/vnd.ms-powerpoint.slideshow.macroenabled":
      return { ext: "ppsm", mime: "application/vnd.ms-powerpoint.slideshow.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.document":
      return { ext: "docx", mime: i4 };
    case "application/vnd.ms-word.document.macroenabled":
      return { ext: "docm", mime: "application/vnd.ms-word.document.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.wordprocessingml.template":
      return { ext: "dotx", mime: i4 };
    case "application/vnd.ms-word.template.macroenabledtemplate":
      return { ext: "dotm", mime: "application/vnd.ms-word.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.template":
      return { ext: "potx", mime: i4 };
    case "application/vnd.ms-powerpoint.template.macroenabled":
      return { ext: "potm", mime: "application/vnd.ms-powerpoint.template.macroenabled.12" };
    case "application/vnd.openxmlformats-officedocument.presentationml.presentation":
      return { ext: "pptx", mime: i4 };
    case "application/vnd.ms-powerpoint.presentation.macroenabled":
      return { ext: "pptm", mime: "application/vnd.ms-powerpoint.presentation.macroenabled.12" };
    case "application/vnd.ms-visio.drawing":
      return { ext: "vsdx", mime: "application/vnd.visio" };
    case "application/vnd.ms-package.3dmanufacturing-3dmodel+xml":
      return { ext: "3mf", mime: "model/3mf" };
  }
}
function A$5(i4, e5, t4) {
  t4 = { offset: 0, ...t4 };
  for (let [r2, n3] of e5.entries()) if (t4.mask) {
    if (n3 !== (t4.mask[r2] & i4[r2 + t4.offset])) return false;
  } else if (n3 !== i4[r2 + t4.offset]) return false;
  return true;
}
var we$3 = class we {
  constructor(e5) {
    this.options = { mpegOffsetTolerance: 0, ...e5 }, this.detectors = [...e5?.customDetectors ?? [], { id: "core", detect: this.detectConfident }, { id: "core.imprecise", detect: this.detectImprecise }], this.tokenizerOptions = { abortSignal: e5?.signal };
  }
  async fromTokenizer(e5) {
    let t4 = e5.position;
    for (let r2 of this.detectors) {
      let n3 = await r2.detect(e5);
      if (n3) return n3;
      if (t4 !== e5.position) return;
    }
  }
  async fromBuffer(e5) {
    if (!(e5 instanceof Uint8Array || e5 instanceof ArrayBuffer)) throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`ArrayBuffer\`, got \`${typeof e5}\``);
    let t4 = e5 instanceof Uint8Array ? e5 : new Uint8Array(e5);
    if (t4?.length > 1) return this.fromTokenizer(ve$2(t4, this.tokenizerOptions));
  }
  async fromBlob(e5) {
    let t4 = Se$2(e5, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(t4);
    } finally {
      await t4.close();
    }
  }
  async fromStream(e5) {
    let t4 = se$2(e5, this.tokenizerOptions);
    try {
      return await this.fromTokenizer(t4);
    } finally {
      await t4.close();
    }
  }
  async toDetectionStream(e5, t4) {
    let { sampleSize: r2 = he$2 } = t4, n3, o2, s3 = e5.getReader({ mode: "byob" });
    try {
      let { value: m3, done: c3 } = await s3.read(new Uint8Array(r2));
      if (o2 = m3, !c3 && m3) try {
        n3 = await this.fromBuffer(m3.subarray(0, r2));
      } catch (p3) {
        if (!(p3 instanceof x$4)) throw p3;
        n3 = void 0;
      }
      o2 = m3;
    } finally {
      s3.releaseLock();
    }
    let f3 = new TransformStream({ async start(m3) {
      m3.enqueue(o2);
    }, transform(m3, c3) {
      c3.enqueue(m3);
    } }), a3 = e5.pipeThrough(f3);
    return a3.fileType = n3, a3;
  }
  check(e5, t4) {
    return A$5(this.buffer, e5, t4);
  }
  checkString(e5, t4) {
    return this.check(Ze$2(e5, t4?.encoding), t4);
  }
  detectConfident = async (e5) => {
    if (this.buffer = new Uint8Array(he$2), e5.fileInfo.size === void 0 && (e5.fileInfo.size = Number.MAX_SAFE_INTEGER), this.tokenizer = e5, await e5.peekBuffer(this.buffer, { length: 32, mayBeLess: true }), this.check([66, 77])) return { ext: "bmp", mime: "image/bmp" };
    if (this.check([11, 119])) return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
    if (this.check([120, 1])) return { ext: "dmg", mime: "application/x-apple-diskimage" };
    if (this.check([77, 90])) return { ext: "exe", mime: "application/x-msdownload" };
    if (this.check([37, 33])) return await e5.peekBuffer(this.buffer, { length: 24, mayBeLess: true }), this.checkString("PS-Adobe-", { offset: 2 }) && this.checkString(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
    if (this.check([31, 160]) || this.check([31, 157])) return { ext: "Z", mime: "application/x-compress" };
    if (this.check([199, 113])) return { ext: "cpio", mime: "application/x-cpio" };
    if (this.check([96, 234])) return { ext: "arj", mime: "application/x-arj" };
    if (this.check([239, 187, 191])) return this.tokenizer.ignore(3), this.detectConfident(e5);
    if (this.check([71, 73, 70])) return { ext: "gif", mime: "image/gif" };
    if (this.check([73, 73, 188])) return { ext: "jxr", mime: "image/vnd.ms-photo" };
    if (this.check([31, 139, 8])) {
      let r2 = new W$4(e5).inflate(), n3 = true;
      try {
        let o2;
        try {
          o2 = await this.fromStream(r2);
        } catch {
          n3 = false;
        }
        if (o2 && o2.ext === "tar") return { ext: "tar.gz", mime: "application/gzip" };
      } finally {
        n3 && await r2.cancel();
      }
      return { ext: "gz", mime: "application/gzip" };
    }
    if (this.check([66, 90, 104])) return { ext: "bz2", mime: "application/x-bzip2" };
    if (this.checkString("ID3")) {
      await e5.ignore(6);
      let t4 = await e5.readToken(Ye$2);
      return e5.position + t4 > e5.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await e5.ignore(t4), this.fromTokenizer(e5));
    }
    if (this.checkString("MP+")) return { ext: "mpc", mime: "audio/x-musepack" };
    if ((this.buffer[0] === 67 || this.buffer[0] === 70) && this.check([87, 83], { offset: 1 })) return { ext: "swf", mime: "application/x-shockwave-flash" };
    if (this.check([255, 216, 255])) return this.check([247], { offset: 3 }) ? { ext: "jls", mime: "image/jls" } : { ext: "jpg", mime: "image/jpeg" };
    if (this.check([79, 98, 106, 1])) return { ext: "avro", mime: "application/avro" };
    if (this.checkString("FLIF")) return { ext: "flif", mime: "image/flif" };
    if (this.checkString("8BPS")) return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
    if (this.checkString("MPCK")) return { ext: "mpc", mime: "audio/x-musepack" };
    if (this.checkString("FORM")) return { ext: "aif", mime: "audio/aiff" };
    if (this.checkString("icns", { offset: 0 })) return { ext: "icns", mime: "image/icns" };
    if (this.check([80, 75, 3, 4])) {
      let t4;
      return await new H$4(e5).unzip((r2) => {
        switch (r2.filename) {
          case "META-INF/mozilla.rsa":
            return t4 = { ext: "xpi", mime: "application/x-xpinstall" }, { stop: true };
          case "META-INF/MANIFEST.MF":
            return t4 = { ext: "jar", mime: "application/java-archive" }, { stop: true };
          case "mimetype":
            return { async handler(n3) {
              let o2 = new TextDecoder("utf-8").decode(n3).trim();
              t4 = ge$2(o2);
            }, stop: true };
          case "[Content_Types].xml":
            return { async handler(n3) {
              let o2 = new TextDecoder("utf-8").decode(n3), s3 = o2.indexOf('.main+xml"');
              if (s3 === -1) {
                let f3 = "application/vnd.ms-package.3dmanufacturing-3dmodel+xml";
                o2.includes(`ContentType="${f3}"`) && (t4 = ge$2(f3));
              } else {
                o2 = o2.slice(0, Math.max(0, s3));
                let f3 = o2.lastIndexOf('"'), a3 = o2.slice(Math.max(0, f3 + 1));
                t4 = ge$2(a3);
              }
            }, stop: true };
          default:
            return /classes\d*\.dex/.test(r2.filename) ? (t4 = { ext: "apk", mime: "application/vnd.android.package-archive" }, { stop: true }) : {};
        }
      }).catch((r2) => {
        if (!(r2 instanceof x$4)) throw r2;
      }), t4 ?? { ext: "zip", mime: "application/zip" };
    }
    if (this.checkString("OggS")) {
      await e5.ignore(28);
      let t4 = new Uint8Array(8);
      return await e5.readBuffer(t4), A$5(t4, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/ogg; codecs=opus" } : A$5(t4, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : A$5(t4, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : A$5(t4, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : A$5(t4, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : A$5(t4, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
    }
    if (this.check([80, 75]) && (this.buffer[2] === 3 || this.buffer[2] === 5 || this.buffer[2] === 7) && (this.buffer[3] === 4 || this.buffer[3] === 6 || this.buffer[3] === 8)) return { ext: "zip", mime: "application/zip" };
    if (this.checkString("MThd")) return { ext: "mid", mime: "audio/midi" };
    if (this.checkString("wOFF") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) return { ext: "woff", mime: "font/woff" };
    if (this.checkString("wOF2") && (this.check([0, 1, 0, 0], { offset: 4 }) || this.checkString("OTTO", { offset: 4 }))) return { ext: "woff2", mime: "font/woff2" };
    if (this.check([212, 195, 178, 161]) || this.check([161, 178, 195, 212])) return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
    if (this.checkString("DSD ")) return { ext: "dsf", mime: "audio/x-dsf" };
    if (this.checkString("LZIP")) return { ext: "lz", mime: "application/x-lzip" };
    if (this.checkString("fLaC")) return { ext: "flac", mime: "audio/flac" };
    if (this.check([66, 80, 71, 251])) return { ext: "bpg", mime: "image/bpg" };
    if (this.checkString("wvpk")) return { ext: "wv", mime: "audio/wavpack" };
    if (this.checkString("%PDF")) return { ext: "pdf", mime: "application/pdf" };
    if (this.check([0, 97, 115, 109])) return { ext: "wasm", mime: "application/wasm" };
    if (this.check([73, 73])) {
      let t4 = await this.readTiffHeader(false);
      if (t4) return t4;
    }
    if (this.check([77, 77])) {
      let t4 = await this.readTiffHeader(true);
      if (t4) return t4;
    }
    if (this.checkString("MAC ")) return { ext: "ape", mime: "audio/ape" };
    if (this.check([26, 69, 223, 163])) {
      async function t4() {
        let f3 = await e5.peekNumber(Be$3), a3 = 128, m3 = 0;
        for (; (f3 & a3) === 0 && a3 !== 0; ) ++m3, a3 >>= 1;
        let c3 = new Uint8Array(m3 + 1);
        return await e5.readBuffer(c3), c3;
      }
      async function r2() {
        let f3 = await t4(), a3 = await t4();
        a3[0] ^= 128 >> a3.length - 1;
        let m3 = Math.min(6, a3.length), c3 = new DataView(f3.buffer), p3 = new DataView(a3.buffer, a3.length - m3, m3);
        return { id: de$2(c3), len: de$2(p3) };
      }
      async function n3(f3) {
        for (; f3 > 0; ) {
          let a3 = await r2();
          if (a3.id === 17026) return (await e5.readToken(new b$3(a3.len))).replaceAll(/\00.*$/g, "");
          await e5.ignore(a3.len), --f3;
        }
      }
      let o2 = await r2();
      switch (await n3(o2.len)) {
        case "webm":
          return { ext: "webm", mime: "video/webm" };
        case "matroska":
          return { ext: "mkv", mime: "video/matroska" };
        default:
          return;
      }
    }
    if (this.checkString("SQLi")) return { ext: "sqlite", mime: "application/x-sqlite3" };
    if (this.check([78, 69, 83, 26])) return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
    if (this.checkString("Cr24")) return { ext: "crx", mime: "application/x-google-chrome-extension" };
    if (this.checkString("MSCF") || this.checkString("ISc(")) return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
    if (this.check([237, 171, 238, 219])) return { ext: "rpm", mime: "application/x-rpm" };
    if (this.check([197, 208, 211, 198])) return { ext: "eps", mime: "application/eps" };
    if (this.check([40, 181, 47, 253])) return { ext: "zst", mime: "application/zstd" };
    if (this.check([127, 69, 76, 70])) return { ext: "elf", mime: "application/x-elf" };
    if (this.check([33, 66, 68, 78])) return { ext: "pst", mime: "application/vnd.ms-outlook" };
    if (this.checkString("PAR1") || this.checkString("PARE")) return { ext: "parquet", mime: "application/vnd.apache.parquet" };
    if (this.checkString("ttcf")) return { ext: "ttc", mime: "font/collection" };
    if (this.check([207, 250, 237, 254])) return { ext: "macho", mime: "application/x-mach-binary" };
    if (this.check([4, 34, 77, 24])) return { ext: "lz4", mime: "application/x-lz4" };
    if (this.checkString("regf")) return { ext: "dat", mime: "application/x-ft-windows-registry-hive" };
    if (this.checkString("$FL2") || this.checkString("$FL3")) return { ext: "sav", mime: "application/x-spss-sav" };
    if (this.check([79, 84, 84, 79, 0])) return { ext: "otf", mime: "font/otf" };
    if (this.checkString("#!AMR")) return { ext: "amr", mime: "audio/amr" };
    if (this.checkString("{\\rtf")) return { ext: "rtf", mime: "application/rtf" };
    if (this.check([70, 76, 86, 1])) return { ext: "flv", mime: "video/x-flv" };
    if (this.checkString("IMPM")) return { ext: "it", mime: "audio/x-it" };
    if (this.checkString("-lh0-", { offset: 2 }) || this.checkString("-lh1-", { offset: 2 }) || this.checkString("-lh2-", { offset: 2 }) || this.checkString("-lh3-", { offset: 2 }) || this.checkString("-lh4-", { offset: 2 }) || this.checkString("-lh5-", { offset: 2 }) || this.checkString("-lh6-", { offset: 2 }) || this.checkString("-lh7-", { offset: 2 }) || this.checkString("-lzs-", { offset: 2 }) || this.checkString("-lz4-", { offset: 2 }) || this.checkString("-lz5-", { offset: 2 }) || this.checkString("-lhd-", { offset: 2 })) return { ext: "lzh", mime: "application/x-lzh-compressed" };
    if (this.check([0, 0, 1, 186])) {
      if (this.check([33], { offset: 4, mask: [241] })) return { ext: "mpg", mime: "video/MP1S" };
      if (this.check([68], { offset: 4, mask: [196] })) return { ext: "mpg", mime: "video/MP2P" };
    }
    if (this.checkString("ITSF")) return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
    if (this.check([202, 254, 186, 190])) return { ext: "class", mime: "application/java-vm" };
    if (this.checkString(".RMF")) return { ext: "rm", mime: "application/vnd.rn-realmedia" };
    if (this.checkString("DRACO")) return { ext: "drc", mime: "application/vnd.google.draco" };
    if (this.check([253, 55, 122, 88, 90, 0])) return { ext: "xz", mime: "application/x-xz" };
    if (this.checkString("<?xml ")) return { ext: "xml", mime: "application/xml" };
    if (this.check([55, 122, 188, 175, 39, 28])) return { ext: "7z", mime: "application/x-7z-compressed" };
    if (this.check([82, 97, 114, 33, 26, 7]) && (this.buffer[6] === 0 || this.buffer[6] === 1)) return { ext: "rar", mime: "application/x-rar-compressed" };
    if (this.checkString("solid ")) return { ext: "stl", mime: "model/stl" };
    if (this.checkString("AC")) {
      let t4 = new b$3(4, "latin1").get(this.buffer, 2);
      if (t4.match("^d*") && t4 >= 1e3 && t4 <= 1050) return { ext: "dwg", mime: "image/vnd.dwg" };
    }
    if (this.checkString("070707")) return { ext: "cpio", mime: "application/x-cpio" };
    if (this.checkString("BLENDER")) return { ext: "blend", mime: "application/x-blender" };
    if (this.checkString("!<arch>")) return await e5.ignore(8), await e5.readToken(new b$3(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
    if (this.checkString("WEBVTT") && [`
`, "\r", "	", " ", "\0"].some((t4) => this.checkString(t4, { offset: 6 }))) return { ext: "vtt", mime: "text/vtt" };
    if (this.check([137, 80, 78, 71, 13, 10, 26, 10])) {
      await e5.ignore(8);
      async function t4() {
        return { length: await e5.readToken(Oe$3), type: await e5.readToken(new b$3(4, "latin1")) };
      }
      do {
        let r2 = await t4();
        if (r2.length < 0) return;
        switch (r2.type) {
          case "IDAT":
            return { ext: "png", mime: "image/png" };
          case "acTL":
            return { ext: "apng", mime: "image/apng" };
          default:
            await e5.ignore(r2.length + 4);
        }
      } while (e5.position + 8 < e5.fileInfo.size);
      return { ext: "png", mime: "image/png" };
    }
    if (this.check([65, 82, 82, 79, 87, 49, 0, 0])) return { ext: "arrow", mime: "application/vnd.apache.arrow.file" };
    if (this.check([103, 108, 84, 70, 2, 0, 0, 0])) return { ext: "glb", mime: "model/gltf-binary" };
    if (this.check([102, 114, 101, 101], { offset: 4 }) || this.check([109, 100, 97, 116], { offset: 4 }) || this.check([109, 111, 111, 118], { offset: 4 }) || this.check([119, 105, 100, 101], { offset: 4 })) return { ext: "mov", mime: "video/quicktime" };
    if (this.check([73, 73, 82, 79, 8, 0, 0, 0, 24])) return { ext: "orf", mime: "image/x-olympus-orf" };
    if (this.checkString("gimp xcf ")) return { ext: "xcf", mime: "image/x-xcf" };
    if (this.checkString("ftyp", { offset: 4 }) && (this.buffer[8] & 96) !== 0) {
      let t4 = new b$3(4, "latin1").get(this.buffer, 8).replace("\0", " ").trim();
      switch (t4) {
        case "avif":
        case "avis":
          return { ext: "avif", mime: "image/avif" };
        case "mif1":
          return { ext: "heic", mime: "image/heif" };
        case "msf1":
          return { ext: "heic", mime: "image/heif-sequence" };
        case "heic":
        case "heix":
          return { ext: "heic", mime: "image/heic" };
        case "hevc":
        case "hevx":
          return { ext: "heic", mime: "image/heic-sequence" };
        case "qt":
          return { ext: "mov", mime: "video/quicktime" };
        case "M4V":
        case "M4VH":
        case "M4VP":
          return { ext: "m4v", mime: "video/x-m4v" };
        case "M4P":
          return { ext: "m4p", mime: "video/mp4" };
        case "M4B":
          return { ext: "m4b", mime: "audio/mp4" };
        case "M4A":
          return { ext: "m4a", mime: "audio/x-m4a" };
        case "F4V":
          return { ext: "f4v", mime: "video/mp4" };
        case "F4P":
          return { ext: "f4p", mime: "video/mp4" };
        case "F4A":
          return { ext: "f4a", mime: "audio/mp4" };
        case "F4B":
          return { ext: "f4b", mime: "audio/mp4" };
        case "crx":
          return { ext: "cr3", mime: "image/x-canon-cr3" };
        default:
          return t4.startsWith("3g") ? t4.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
      }
    }
    if (this.checkString(`REGEDIT4\r
`)) return { ext: "reg", mime: "application/x-ms-regedit" };
    if (this.check([82, 73, 70, 70])) {
      if (this.checkString("WEBP", { offset: 8 })) return { ext: "webp", mime: "image/webp" };
      if (this.check([65, 86, 73], { offset: 8 })) return { ext: "avi", mime: "video/vnd.avi" };
      if (this.check([87, 65, 86, 69], { offset: 8 })) return { ext: "wav", mime: "audio/wav" };
      if (this.check([81, 76, 67, 77], { offset: 8 })) return { ext: "qcp", mime: "audio/qcelp" };
    }
    if (this.check([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216])) return { ext: "rw2", mime: "image/x-panasonic-rw2" };
    if (this.check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
      async function t4() {
        let r2 = new Uint8Array(16);
        return await e5.readBuffer(r2), { id: r2, size: Number(await e5.readToken(De$2)) };
      }
      for (await e5.ignore(30); e5.position + 24 < e5.fileInfo.size; ) {
        let r2 = await t4(), n3 = r2.size - 24;
        if (A$5(r2.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
          let o2 = new Uint8Array(16);
          if (n3 -= await e5.readBuffer(o2), A$5(o2, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "audio/x-ms-asf" };
          if (A$5(o2, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43])) return { ext: "asf", mime: "video/x-ms-asf" };
          break;
        }
        await e5.ignore(n3);
      }
      return { ext: "asf", mime: "application/vnd.ms-asf" };
    }
    if (this.check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) return { ext: "ktx", mime: "image/ktx" };
    if ((this.check([126, 16, 4]) || this.check([126, 24, 4])) && this.check([48, 77, 73, 69], { offset: 4 })) return { ext: "mie", mime: "application/x-mie" };
    if (this.check([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 })) return { ext: "shp", mime: "application/x-esri-shape" };
    if (this.check([255, 79, 255, 81])) return { ext: "j2c", mime: "image/j2c" };
    if (this.check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) switch (await e5.ignore(20), await e5.readToken(new b$3(4, "ascii"))) {
      case "jp2 ":
        return { ext: "jp2", mime: "image/jp2" };
      case "jpx ":
        return { ext: "jpx", mime: "image/jpx" };
      case "jpm ":
        return { ext: "jpm", mime: "image/jpm" };
      case "mjp2":
        return { ext: "mj2", mime: "image/mj2" };
      default:
        return;
    }
    if (this.check([255, 10]) || this.check([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10])) return { ext: "jxl", mime: "image/jxl" };
    if (this.check([254, 255])) return this.checkString("<?xml ", { offset: 2, encoding: "utf-16be" }) ? { ext: "xml", mime: "application/xml" } : void 0;
    if (this.check([208, 207, 17, 224, 161, 177, 26, 225])) return { ext: "cfb", mime: "application/x-cfb" };
    if (await e5.peekBuffer(this.buffer, { length: Math.min(256, e5.fileInfo.size), mayBeLess: true }), this.check([97, 99, 115, 112], { offset: 36 })) return { ext: "icc", mime: "application/vnd.iccprofile" };
    if (this.checkString("**ACE", { offset: 7 }) && this.checkString("**", { offset: 12 })) return { ext: "ace", mime: "application/x-ace-compressed" };
    if (this.checkString("BEGIN:")) {
      if (this.checkString("VCARD", { offset: 6 })) return { ext: "vcf", mime: "text/vcard" };
      if (this.checkString("VCALENDAR", { offset: 6 })) return { ext: "ics", mime: "text/calendar" };
    }
    if (this.checkString("FUJIFILMCCD-RAW")) return { ext: "raf", mime: "image/x-fujifilm-raf" };
    if (this.checkString("Extended Module:")) return { ext: "xm", mime: "audio/x-xm" };
    if (this.checkString("Creative Voice File")) return { ext: "voc", mime: "audio/x-voc" };
    if (this.check([4, 0, 0, 0]) && this.buffer.length >= 16) {
      let t4 = new DataView(this.buffer.buffer).getUint32(12, true);
      if (t4 > 12 && this.buffer.length >= t4 + 16) try {
        let r2 = new TextDecoder().decode(this.buffer.subarray(16, t4 + 16));
        if (JSON.parse(r2).files) return { ext: "asar", mime: "application/x-asar" };
      } catch {
      }
    }
    if (this.check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) return { ext: "mxf", mime: "application/mxf" };
    if (this.checkString("SCRM", { offset: 44 })) return { ext: "s3m", mime: "audio/x-s3m" };
    if (this.check([71]) && this.check([71], { offset: 188 })) return { ext: "mts", mime: "video/mp2t" };
    if (this.check([71], { offset: 4 }) && this.check([71], { offset: 196 })) return { ext: "mts", mime: "video/mp2t" };
    if (this.check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
    if (this.check([68, 73, 67, 77], { offset: 128 })) return { ext: "dcm", mime: "application/dicom" };
    if (this.check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) return { ext: "lnk", mime: "application/x.ms.shortcut" };
    if (this.check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) return { ext: "alias", mime: "application/x.apple.alias" };
    if (this.checkString("Kaydara FBX Binary  \0")) return { ext: "fbx", mime: "application/x.autodesk.fbx" };
    if (this.check([76, 80], { offset: 34 }) && (this.check([0, 0, 1], { offset: 8 }) || this.check([1, 0, 2], { offset: 8 }) || this.check([2, 0, 2], { offset: 8 }))) return { ext: "eot", mime: "application/vnd.ms-fontobject" };
    if (this.check([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29])) return { ext: "indd", mime: "application/x-indesign" };
    if (this.check([255, 255, 0, 0, 7, 0, 0, 0, 4, 0, 0, 0, 1, 0, 1, 0]) || this.check([0, 0, 255, 255, 0, 0, 0, 7, 0, 0, 0, 4, 0, 1, 0, 1])) return { ext: "jmp", mime: "application/x-jmp-data" };
    if (await e5.peekBuffer(this.buffer, { length: Math.min(512, e5.fileInfo.size), mayBeLess: true }), this.checkString("ustar", { offset: 257 }) && (this.checkString("\0", { offset: 262 }) || this.checkString(" ", { offset: 262 })) || this.check([0, 0, 0, 0, 0, 0], { offset: 257 }) && Qe$3(this.buffer)) return { ext: "tar", mime: "application/x-tar" };
    if (this.check([255, 254])) {
      let t4 = "utf-16le";
      return this.checkString("<?xml ", { offset: 2, encoding: t4 }) ? { ext: "xml", mime: "application/xml" } : this.check([255, 14], { offset: 2 }) && this.checkString("SketchUp Model", { offset: 4, encoding: t4 }) ? { ext: "skp", mime: "application/vnd.sketchup.skp" } : this.checkString(`Windows Registry Editor Version 5.00\r
`, { offset: 2, encoding: t4 }) ? { ext: "reg", mime: "application/x-ms-regedit" } : void 0;
    }
    if (this.checkString("-----BEGIN PGP MESSAGE-----")) return { ext: "pgp", mime: "application/pgp-encrypted" };
  };
  detectImprecise = async (e5) => {
    if (this.buffer = new Uint8Array(he$2), await e5.peekBuffer(this.buffer, { length: Math.min(8, e5.fileInfo.size), mayBeLess: true }), this.check([0, 0, 1, 186]) || this.check([0, 0, 1, 179])) return { ext: "mpg", mime: "video/mpeg" };
    if (this.check([0, 1, 0, 0, 0])) return { ext: "ttf", mime: "font/ttf" };
    if (this.check([0, 0, 1, 0])) return { ext: "ico", mime: "image/x-icon" };
    if (this.check([0, 0, 2, 0])) return { ext: "cur", mime: "image/x-icon" };
    if (await e5.peekBuffer(this.buffer, { length: Math.min(2 + this.options.mpegOffsetTolerance, e5.fileInfo.size), mayBeLess: true }), this.buffer.length >= 2 + this.options.mpegOffsetTolerance) for (let t4 = 0; t4 <= this.options.mpegOffsetTolerance; ++t4) {
      let r2 = this.scanMpeg(t4);
      if (r2) return r2;
    }
  };
  async readTiffTag(e5) {
    let t4 = await this.tokenizer.readToken(e5 ? R$4 : d$1);
    switch (this.tokenizer.ignore(10), t4) {
      case 50341:
        return { ext: "arw", mime: "image/x-sony-arw" };
      case 50706:
        return { ext: "dng", mime: "image/x-adobe-dng" };
    }
  }
  async readTiffIFD(e5) {
    let t4 = await this.tokenizer.readToken(e5 ? R$4 : d$1);
    for (let r2 = 0; r2 < t4; ++r2) {
      let n3 = await this.readTiffTag(e5);
      if (n3) return n3;
    }
  }
  async readTiffHeader(e5) {
    let t4 = (e5 ? R$4 : d$1).get(this.buffer, 2), r2 = (e5 ? Ie$2 : h$2).get(this.buffer, 4);
    if (t4 === 42) {
      if (r2 >= 6) {
        if (this.checkString("CR", { offset: 8 })) return { ext: "cr2", mime: "image/x-canon-cr2" };
        if (r2 >= 8) {
          let o2 = (e5 ? R$4 : d$1).get(this.buffer, 8), s3 = (e5 ? R$4 : d$1).get(this.buffer, 10);
          if (o2 === 28 && s3 === 254 || o2 === 31 && s3 === 11) return { ext: "nef", mime: "image/x-nikon-nef" };
        }
      }
      return await this.tokenizer.ignore(r2), await this.readTiffIFD(e5) ?? { ext: "tif", mime: "image/tiff" };
    }
    if (t4 === 43) return { ext: "tif", mime: "image/tiff" };
  }
  scanMpeg(e5) {
    if (this.check([255, 224], { offset: e5, mask: [255, 224] })) {
      if (this.check([16], { offset: e5 + 1, mask: [22] })) return this.check([8], { offset: e5 + 1, mask: [8] }) ? { ext: "aac", mime: "audio/aac" } : { ext: "aac", mime: "audio/aac" };
      if (this.check([2], { offset: e5 + 1, mask: [6] })) return { ext: "mp3", mime: "audio/mpeg" };
      if (this.check([4], { offset: e5 + 1, mask: [6] })) return { ext: "mp2", mime: "audio/mpeg" };
      if (this.check([6], { offset: e5 + 1, mask: [6] })) return { ext: "mp1", mime: "audio/mpeg" };
    }
  }
};
new Set(Ke$1);
new Set(et$3);
var Gt = { name: "file", summary: "determine file type", usage: "file [OPTION]... FILE...", options: ["-b, --brief          do not prepend filenames to output", "-i, --mime           output MIME type strings", "-L, --dereference    follow symlinks", "    --help           display this help and exit"] }, tt$2 = { ".js": { description: "JavaScript source", mime: "text/javascript" }, ".mjs": { description: "JavaScript module", mime: "text/javascript" }, ".cjs": { description: "CommonJS module", mime: "text/javascript" }, ".ts": { description: "TypeScript source", mime: "text/typescript" }, ".tsx": { description: "TypeScript JSX source", mime: "text/typescript" }, ".jsx": { description: "JavaScript JSX source", mime: "text/javascript" }, ".py": { description: "Python script", mime: "text/x-python" }, ".rb": { description: "Ruby script", mime: "text/x-ruby" }, ".go": { description: "Go source", mime: "text/x-go" }, ".rs": { description: "Rust source", mime: "text/x-rust" }, ".c": { description: "C source", mime: "text/x-c" }, ".h": { description: "C header", mime: "text/x-c" }, ".cpp": { description: "C++ source", mime: "text/x-c++" }, ".hpp": { description: "C++ header", mime: "text/x-c++" }, ".java": { description: "Java source", mime: "text/x-java" }, ".sh": { description: "Bourne-Again shell script", mime: "text/x-shellscript" }, ".bash": { description: "Bourne-Again shell script", mime: "text/x-shellscript" }, ".zsh": { description: "Zsh shell script", mime: "text/x-shellscript" }, ".json": { description: "JSON data", mime: "application/json" }, ".yaml": { description: "YAML data", mime: "text/yaml" }, ".yml": { description: "YAML data", mime: "text/yaml" }, ".xml": { description: "XML document", mime: "application/xml" }, ".csv": { description: "CSV text", mime: "text/csv" }, ".toml": { description: "TOML data", mime: "text/toml" }, ".html": { description: "HTML document", mime: "text/html" }, ".htm": { description: "HTML document", mime: "text/html" }, ".css": { description: "CSS stylesheet", mime: "text/css" }, ".svg": { description: "SVG image", mime: "image/svg+xml" }, ".md": { description: "Markdown document", mime: "text/markdown" }, ".markdown": { description: "Markdown document", mime: "text/markdown" }, ".txt": { description: "ASCII text", mime: "text/plain" }, ".rst": { description: "reStructuredText", mime: "text/x-rst" }, ".env": { description: "ASCII text", mime: "text/plain" }, ".gitignore": { description: "ASCII text", mime: "text/plain" }, ".dockerignore": { description: "ASCII text", mime: "text/plain" } }, it$1 = { jpg: "JPEG image data", jpeg: "JPEG image data", png: "PNG image data", gif: "GIF image data", webp: "WebP image data", bmp: "PC bitmap", ico: "MS Windows icon resource", tif: "TIFF image data", tiff: "TIFF image data", psd: "Adobe Photoshop Document", avif: "AVIF image", heic: "HEIC image", heif: "HEIF image", jxl: "JPEG XL image", icns: "Mac OS X icon", svg: "SVG Scalable Vector Graphics image", pdf: "PDF document", epub: "EPUB document", mobi: "Mobipocket E-book", djvu: "DjVu document", zip: "Zip archive data", gz: "gzip compressed data", gzip: "gzip compressed data", bz2: "bzip2 compressed data", xz: "XZ compressed data", tar: "POSIX tar archive", rar: "RAR archive data", "7z": "7-zip archive data", lz: "lzip compressed data", lzma: "LZMA compressed data", zst: "Zstandard compressed data", cab: "Microsoft Cabinet archive", ar: "Unix ar archive", rpm: "RPM package", deb: "Debian binary package", apk: "Android Package", dmg: "Apple disk image", iso: "ISO 9660 CD-ROM filesystem data", vhd: "Microsoft Virtual Hard Disk", vhdx: "Microsoft Virtual Hard Disk (new format)", qcow2: "QEMU QCOW Image", mp3: "Audio file with ID3", m4a: "MPEG-4 audio", aac: "AAC audio", wav: "RIFF (little-endian) data, WAVE audio", flac: "FLAC audio bitstream data", ogg: "Ogg data", oga: "Ogg audio", opus: "Ogg Opus audio", aiff: "AIFF audio", wma: "Windows Media Audio", amr: "AMR audio", mid: "MIDI audio", midi: "MIDI audio", ape: "Monkey's Audio", mp4: "ISO Media, MPEG-4", m4v: "MPEG-4 video", webm: "WebM", avi: "RIFF (little-endian) data, AVI", mov: "ISO Media, Apple QuickTime movie", mkv: "Matroska data", wmv: "Windows Media Video", flv: "Flash Video", "3gp": "3GPP multimedia", "3g2": "3GPP2 multimedia", ogv: "Ogg video", mts: "MPEG transport stream", m2ts: "MPEG transport stream", ts: "MPEG transport stream", mpg: "MPEG video", mpeg: "MPEG video", exe: "PE32 executable", dll: "PE32 DLL", elf: "ELF executable", mach: "Mach-O executable", wasm: "WebAssembly (wasm) binary module", dex: "Android Dalvik executable", class: "Java class file", swf: "Adobe Flash", doc: "Microsoft Word Document", docx: "Microsoft Word 2007+ Document", xls: "Microsoft Excel Spreadsheet", xlsx: "Microsoft Excel 2007+ Spreadsheet", ppt: "Microsoft PowerPoint Presentation", pptx: "Microsoft PowerPoint 2007+ Presentation", odt: "OpenDocument Text", ods: "OpenDocument Spreadsheet", odp: "OpenDocument Presentation", ttf: "TrueType Font", otf: "OpenType Font", woff: "Web Open Font Format", woff2: "Web Open Font Format 2", eot: "Embedded OpenType font", stl: "Stereolithography CAD", obj: "Wavefront 3D Object", gltf: "GL Transmission Format", glb: "GL Transmission Format (binary)", sqlite: "SQLite 3.x database", mdb: "Microsoft Access Database", xml: "XML document", json: "JSON data", macho: "Mach-O binary", ics: "iCalendar data", vcf: "vCard data", msi: "Microsoft Installer", ps: "PostScript", ai: "Adobe Illustrator", indd: "Adobe InDesign", sketch: "Sketch design file", fig: "Figma design file", xd: "Adobe XD", blend: "Blender", fbx: "Autodesk FBX", lnk: "MS Windows shortcut", alias: "Mac OS alias", torrent: "BitTorrent file", pcap: "pcap capture file", arrow: "Apache Arrow", parquet: "Apache Parquet" };
function Jt(i4, e5) {
  if (it$1[i4]) return it$1[i4];
  let [t4, r2] = e5.split("/"), n3 = r2?.split("+")[0]?.replace(/-/g, " ") || i4;
  switch (t4) {
    case "image":
      return `${n3.toUpperCase()} image data`;
    case "audio":
      return `${n3.toUpperCase()} audio`;
    case "video":
      return `${n3.toUpperCase()} video`;
    case "font":
      return `${n3} font`;
    case "model":
      return `${n3} 3D model`;
    case "application":
      return r2?.includes("zip") || r2?.includes("compressed") ? `${n3} archive data` : r2?.includes("executable") ? `${n3} executable` : `${i4.toUpperCase()} data`;
    default:
      return `${i4.toUpperCase()} data`;
  }
}
function Xt(i4) {
  let e5 = i4.split("/").pop() || i4;
  if (e5.startsWith(".") && !e5.includes(".", 1)) return e5;
  let t4 = e5.lastIndexOf(".");
  return t4 === -1 || t4 === 0 ? "" : e5.slice(t4).toLowerCase();
}
function Zt$1(i4, e5) {
  if (i4.startsWith("#!")) {
    let a3 = i4.split(`
`)[0];
    return a3.includes("python") ? { description: "Python script, ASCII text executable", mime: "text/x-python" } : a3.includes("node") || a3.includes("bun") || a3.includes("deno") ? { description: "JavaScript script, ASCII text executable", mime: "text/javascript" } : a3.includes("bash") ? { description: "Bourne-Again shell script, ASCII text executable", mime: "text/x-shellscript" } : a3.includes("sh") ? { description: "POSIX shell script, ASCII text executable", mime: "text/x-shellscript" } : a3.includes("ruby") ? { description: "Ruby script, ASCII text executable", mime: "text/x-ruby" } : a3.includes("perl") ? { description: "Perl script, ASCII text executable", mime: "text/x-perl" } : { description: "script, ASCII text executable", mime: "text/plain" };
  }
  let t4 = i4.trimStart();
  if (t4.startsWith("<?xml")) return { description: "XML document", mime: "application/xml" };
  if (t4.startsWith("<!DOCTYPE html") || t4.toLowerCase().startsWith("<html")) return { description: "HTML document", mime: "text/html" };
  let r2 = i4.includes(`\r
`), n3 = i4.includes("\r") && !r2, o2 = "";
  r2 ? o2 = ", with CRLF line terminators" : n3 && (o2 = ", with CR line terminators");
  let s3 = Xt(e5);
  if (s3 && tt$2[s3]) {
    let a3 = tt$2[s3];
    return a3.mime.startsWith("text/") && o2 ? { description: `${a3.description}${o2}`, mime: a3.mime } : a3;
  }
  let f3 = false;
  for (let a3 = 0; a3 < Math.min(i4.length, 8192); a3++) if (i4.charCodeAt(a3) > 127) {
    f3 = true;
    break;
  }
  return f3 ? { description: `UTF-8 Unicode text${o2}`, mime: "text/plain; charset=utf-8" } : { description: `ASCII text${o2}`, mime: "text/plain" };
}
async function Qt(i4, e5) {
  if (e5.length === 0) return { description: "empty", mime: "inode/x-empty" };
  let t4 = await ke$2(e5);
  if (t4) return { description: Jt(t4.ext, t4.mime), mime: t4.mime };
  let r2 = new TextDecoder("utf-8", { fatal: false }).decode(e5);
  return Zt$1(r2, i4);
}
var Dr = { name: "file", async execute(i4, e5) {
  if (o$3(i4)) return s$1(Gt);
  let t4 = false, r2 = false, n3 = [];
  for (let f3 of i4) if (f3.startsWith("--")) {
    if (f3 === "--brief") t4 = true;
    else if (f3 === "--mime" || f3 === "--mime-type") r2 = true;
    else if (f3 !== "--dereference") return r$3("file", f3);
  } else if (f3.startsWith("-") && f3 !== "-") {
    for (let a3 of f3.slice(1)) if (a3 === "b") t4 = true;
    else if (a3 === "i") r2 = true;
    else if (a3 !== "L") return r$3("file", `-${a3}`);
  } else n3.push(f3);
  if (n3.length === 0) return { stdout: "", stderr: `Usage: file [-bLi] FILE...
`, exitCode: 1 };
  let o2 = "", s3 = 0;
  for (let f3 of n3) try {
    let a3 = e5.fs.resolvePath(e5.cwd, f3);
    if ((await e5.fs.stat(a3)).isDirectory) {
      let u3 = r2 ? "inode/directory" : "directory";
      o2 += t4 ? `${u3}
` : `${f3}: ${u3}
`;
      continue;
    }
    let c3 = await e5.fs.readFileBuffer(a3), p3 = await Qt(f3, c3), l3 = r2 ? p3.mime : p3.description;
    o2 += t4 ? `${l3}
` : `${f3}: ${l3}
`;
  } catch {
    o2 += t4 ? `cannot open
` : `${f3}: cannot open (No such file or directory)
`, s3 = 1;
  }
  return { stdout: o2, stderr: "", exitCode: s3 };
} };
const fileNQP3CKRV = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  fileCommand: Dr
});
var p$1 = { name: "html-to-markdown", summary: "convert HTML to Markdown (BashEnv extension)", usage: "html-to-markdown [OPTION]... [FILE]", description: ["Convert HTML content to Markdown format using the turndown library.", "This is a non-standard BashEnv extension command, not available in regular bash.", "", "Read HTML from FILE or standard input and output Markdown to standard output.", "Commonly used with curl to convert web pages:", "  curl -s https://example.com | html-to-markdown", "", "Supported HTML elements:", "  - Headings (h1-h6)  # Markdown headings", "  - Paragraphs (p)  Plain text with blank lines", "  - Links (a)  [text](url)", "  - Images (img)  ![alt](src)", "  - Bold/Strong  **text**", "  - Italic/Em  _text_", "  - Code (code, pre)  `inline` or fenced blocks", "  - Lists (ul, ol, li)  - or 1. items", "  - Blockquotes  > quoted text", "  - Horizontal rules (hr)  ---"], options: ["-b, --bullet=CHAR     bullet character for unordered lists (-, +, or *)", "-c, --code=FENCE      fence style for code blocks (``` or ~~~)", "-r, --hr=STRING       string for horizontal rules (default: ---)", "    --heading-style=STYLE", "                      heading style: 'atx' for # headings (default),", "                      'setext' for underlined headings (h1/h2 only)", "    --help            display this help and exit"], examples: ["echo '<h1>Hello</h1><p>World</p>' | html-to-markdown", "html-to-markdown page.html", "curl -s https://example.com | html-to-markdown > page.md"] }, g$2 = { name: "html-to-markdown", async execute(r2, n3) {
  if (o$3(r2)) return s$1(p$1);
  let s3 = "-", a3 = "```", i4 = "---", m3 = "atx", o2 = [];
  for (let t4 = 0; t4 < r2.length; t4++) {
    let e5 = r2[t4];
    if (e5 === "-b" || e5 === "--bullet") s3 = r2[++t4] ?? "-";
    else if (e5.startsWith("--bullet=")) s3 = e5.slice(9);
    else if (e5 === "-c" || e5 === "--code") a3 = r2[++t4] ?? "```";
    else if (e5.startsWith("--code=")) a3 = e5.slice(7);
    else if (e5 === "-r" || e5 === "--hr") i4 = r2[++t4] ?? "---";
    else if (e5.startsWith("--hr=")) i4 = e5.slice(5);
    else if (e5.startsWith("--heading-style=")) {
      let d3 = e5.slice(16);
      (d3 === "setext" || d3 === "atx") && (m3 = d3);
    } else if (e5 === "-") o2.push("-");
    else {
      if (e5.startsWith("--")) return r$3("html-to-markdown", e5);
      if (e5.startsWith("-")) return r$3("html-to-markdown", e5);
      o2.push(e5);
    }
  }
  let l3;
  if (o2.length === 0 || o2.length === 1 && o2[0] === "-") l3 = n3.stdin;
  else try {
    let t4 = n3.fs.resolvePath(n3.cwd, o2[0]);
    l3 = await n3.fs.readFile(t4);
  } catch {
    return { stdout: "", stderr: `html-to-markdown: ${o2[0]}: No such file or directory
`, exitCode: 1 };
  }
  if (!l3.trim()) return { stdout: "", stderr: "", exitCode: 0 };
  try {
    let t4 = new TurndownService({ bulletListMarker: s3, codeBlockStyle: "fenced", fence: a3, hr: i4, headingStyle: m3 });
    return t4.remove(["script", "style", "footer"]), { stdout: `${t4.turndown(l3).trim()}
`, stderr: "", exitCode: 0 };
  } catch (t4) {
    return { stdout: "", stderr: `html-to-markdown: conversion error: ${t4.message}
`, exitCode: 1 };
  }
} };
const htmlToMarkdownZK6GQVSL = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  htmlToMarkdownCommand: g$2
});
var r = { "File operations": ["ls", "cat", "head", "tail", "wc", "touch", "mkdir", "rm", "cp", "mv", "ln", "chmod", "stat", "readlink"], "Text processing": ["grep", "sed", "awk", "sort", "uniq", "cut", "tr", "tee", "diff"], Search: ["find"], "Navigation & paths": ["pwd", "basename", "dirname", "tree", "du"], "Environment & shell": ["echo", "printf", "env", "printenv", "export", "alias", "unalias", "history", "clear", "true", "false", "bash", "sh"], "Data processing": ["xargs", "jq", "base64", "date"], Network: ["curl", "html-to-markdown"] };
function l$1(t4) {
  let e5 = [], n3 = new Set(t4);
  e5.push(`Available commands:
`);
  let s3 = [];
  for (let [o2, c3] of Object.entries(r)) {
    let a3 = c3.filter((i4) => n3.has(i4));
    if (a3.length > 0) {
      e5.push(`  ${o2}:`), e5.push(`    ${a3.join(", ")}
`);
      for (let i4 of a3) n3.delete(i4);
    }
  }
  for (let o2 of n3) s3.push(o2);
  return s3.length > 0 && (e5.push("  Other:"), e5.push(`    ${s3.sort().join(", ")}
`)), e5.push("Use '<command> --help' for details on a specific command."), `${e5.join(`
`)}
`;
}
var d2 = { name: "help", async execute(t4, e5) {
  if (t4.includes("--help") || t4.includes("-h")) return { stdout: `help - display available commands

Usage: help [command]

Options:
  -h, --help    Show this help message

If a command name is provided, shows help for that command.
Otherwise, lists all available commands.
`, stderr: "", exitCode: 0 };
  if (t4.length > 0 && e5.exec) {
    let s3 = t4[0];
    return e5.exec(`${s3} --help`, { cwd: e5.cwd });
  }
  let n3 = e5.getRegisteredCommands?.() ?? [];
  return { stdout: l$1(n3), stderr: "", exitCode: 0 };
} };
const help75YOGKM4 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  helpCommand: d2
});
var w$4 = { name: "which", summary: "locate a command", usage: "which [-as] program ...", options: ["-a         List all instances of executables found", "-s         No output, just return 0 if found, 1 if not", "--help     display this help and exit"] }, g$1 = { showAll: { short: "a", type: "boolean" }, silent: { short: "s", type: "boolean" } }, A$4 = { name: "which", async execute(s3, e5) {
  if (o$3(s3)) return s$1(w$4);
  let t4 = x$g("which", s3, g$1);
  if (!t4.ok) return t4.error;
  let c3 = t4.result.flags.showAll, p3 = t4.result.flags.silent, o2 = t4.result.positional;
  if (o2.length === 0) return { stdout: "", stderr: "", exitCode: 1 };
  let d3 = (e5.env.PATH || "/usr/bin:/bin").split(":"), n3 = "", r2 = true;
  for (let m3 of o2) {
    let a3 = false;
    for (let i4 of d3) {
      if (!i4) continue;
      let l3 = `${i4}/${m3}`;
      if (await e5.fs.exists(l3) && (a3 = true, p3 || (n3 += `${l3}
`), !c3)) break;
    }
    a3 || (r2 = false);
  }
  return { stdout: n3, stderr: "", exitCode: r2 ? 0 : 1 };
} };
const whichUBLRBDHN = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  whichCommand: A$4
});
async function i$1(t4, o2) {
  if (t4.length > 0 && t4[0] !== "-") {
    let c3 = t4[0].startsWith("/") ? t4[0] : `${o2.cwd}/${t4[0]}`;
    try {
      let n3 = (await o2.fs.readFile(c3)).split(`
`);
      n3[n3.length - 1] === "" && n3.pop();
      let s3 = n3.reverse();
      return { stdout: s3.length > 0 ? `${s3.join(`
`)}
` : "", stderr: "", exitCode: 0 };
    } catch {
      return { stdout: "", stderr: `tac: ${t4[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let e5 = o2.stdin.split(`
`);
  e5[e5.length - 1] === "" && e5.pop();
  let r2 = e5.reverse();
  return { stdout: r2.length > 0 ? `${r2.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var l2 = { name: "tac", execute: i$1 };
const tac2X4JLF4W = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  tac: l2
});
async function t3(e5, n3) {
  return { stdout: `localhost
`, stderr: "", exitCode: 0 };
}
var o = { name: "hostname", execute: t3 };
const hostnameNWR32CGF = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hostname: o
});
async function e4(t4, o2) {
  return { stdout: `user
`, stderr: "", exitCode: 0 };
}
var n$1 = { name: "whoami", execute: e4 };
const whoamiYUDAIS32 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  whoami: n$1
});
async function x$3(o2, h3) {
  let s3 = "octal", e5 = [], i4 = [];
  for (let t4 = 0; t4 < o2.length; t4++) {
    let r2 = o2[t4];
    if (r2 === "-c") e5.push("char");
    else if (r2 === "-An" || r2 === "-A" && o2[t4 + 1] === "n") s3 = "none", r2 === "-A" && t4++;
    else if (r2 === "-t" && o2[t4 + 1]) {
      let n3 = o2[++t4];
      n3 === "x1" ? e5.push("hex") : n3 === "c" ? e5.push("char") : n3.startsWith("o") && e5.push("octal");
    } else (!r2.startsWith("-") || r2 === "-") && i4.push(r2);
  }
  e5.length === 0 && e5.push("octal");
  let c3 = h3.stdin;
  if (i4.length > 0 && i4[0] !== "-") {
    let t4 = i4[0].startsWith("/") ? i4[0] : `${h3.cwd}/${i4[0]}`;
    try {
      c3 = await h3.fs.readFile(t4);
    } catch {
      return { stdout: "", stderr: `od: ${i4[0]}: No such file or directory
`, exitCode: 1 };
    }
  }
  let m3 = e5.includes("char");
  function g2(t4) {
    return t4 === 0 ? "  \\0" : t4 === 7 ? "  \\a" : t4 === 8 ? "  \\b" : t4 === 9 ? "  \\t" : t4 === 10 ? "  \\n" : t4 === 11 ? "  \\v" : t4 === 12 ? "  \\f" : t4 === 13 ? "  \\r" : t4 >= 32 && t4 < 127 ? `   ${String.fromCharCode(t4)}` : ` ${t4.toString(8).padStart(3, "0")}`;
  }
  function S3(t4) {
    return m3 ? `  ${t4.toString(16).padStart(2, "0")}` : ` ${t4.toString(16).padStart(2, "0")}`;
  }
  function $5(t4) {
    return ` ${t4.toString(8).padStart(3, "0")}`;
  }
  let f3 = [];
  for (let t4 of c3) f3.push(t4.charCodeAt(0));
  let p3 = 16, a3 = [];
  for (let t4 = 0; t4 < f3.length; t4 += p3) {
    let r2 = f3.slice(t4, t4 + p3);
    for (let n3 = 0; n3 < e5.length; n3++) {
      let d3 = e5[n3], u3;
      d3 === "char" ? u3 = r2.map(g2) : d3 === "hex" ? u3 = r2.map(S3) : u3 = r2.map($5);
      let l3 = "";
      n3 === 0 && s3 !== "none" ? l3 = `${t4.toString(8).padStart(7, "0")} ` : (n3 > 0 || s3 === "none") && (l3 = s3 === "none" ? "" : "        "), a3.push(l3 + u3.join(""));
    }
  }
  return s3 !== "none" && f3.length > 0 && a3.push(f3.length.toString(8).padStart(7, "0")), { stdout: a3.length > 0 ? `${a3.join(`
`)}
` : "", stderr: "", exitCode: 0 };
}
var y$2 = { name: "od", execute: x$3 };
const od3FPDPLWJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  od: y$2
});
var I$4 = { name: "gzip", summary: "compress or expand files", usage: "gzip [OPTION]... [FILE]...", description: `Compress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.

With -d, decompress instead.`, options: ["-c, --stdout      write to standard output, keep original files", "-d, --decompress  decompress", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not save or restore the original name and timestamp", "-N, --name        save or restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "-1, --fast        compress faster", "-9, --best        compress better", "    --help        display this help and exit"] }, q$4 = { name: "gunzip", summary: "decompress files", usage: "gunzip [OPTION]... [FILE]...", description: `Decompress FILEs (by default, in-place).

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-c, --stdout      write to standard output, keep original files", "-f, --force       force overwrite of output file", "-k, --keep        keep (don't delete) input files", "-l, --list        list compressed file contents", "-n, --no-name     do not restore the original name and timestamp", "-N, --name        restore the original file name and timestamp", "-q, --quiet       suppress all warnings", "-r, --recursive   operate recursively on directories", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, P$2 = { name: "zcat", summary: "decompress files to stdout", usage: "zcat [OPTION]... [FILE]...", description: `Decompress FILEs to standard output.

When no FILE is given, or when FILE is -, read from standard input.`, options: ["-f, --force       force; read compressed data even from a terminal", "-l, --list        list compressed file contents", "-q, --quiet       suppress all warnings", "-S, --suffix=SUF  use suffix SUF on compressed files (default: .gz)", "-t, --test        test compressed file integrity", "-v, --verbose     verbose mode", "    --help        display this help and exit"] }, L$3 = { stdout: { short: "c", long: "stdout", type: "boolean" }, toStdout: { long: "to-stdout", type: "boolean" }, decompress: { short: "d", long: "decompress", type: "boolean" }, uncompress: { long: "uncompress", type: "boolean" }, force: { short: "f", long: "force", type: "boolean" }, keep: { short: "k", long: "keep", type: "boolean" }, list: { short: "l", long: "list", type: "boolean" }, noName: { short: "n", long: "no-name", type: "boolean" }, name: { short: "N", long: "name", type: "boolean" }, quiet: { short: "q", long: "quiet", type: "boolean" }, recursive: { short: "r", long: "recursive", type: "boolean" }, suffix: { short: "S", long: "suffix", type: "string", default: ".gz" }, test: { short: "t", long: "test", type: "boolean" }, verbose: { short: "v", long: "verbose", type: "boolean" }, fast: { short: "1", long: "fast", type: "boolean" }, level2: { short: "2", type: "boolean" }, level3: { short: "3", type: "boolean" }, level4: { short: "4", type: "boolean" }, level5: { short: "5", type: "boolean" }, level6: { short: "6", type: "boolean" }, level7: { short: "7", type: "boolean" }, level8: { short: "8", type: "boolean" }, best: { short: "9", long: "best", type: "boolean" } };
function F$4(e5) {
  return e5.best ? constants.Z_BEST_COMPRESSION : e5.level8 ? 8 : e5.level7 ? 7 : e5.level6 ? 6 : e5.level5 ? 5 : e5.level4 ? 4 : e5.level3 ? 3 : e5.level2 ? 2 : e5.fast ? constants.Z_BEST_SPEED : constants.Z_DEFAULT_COMPRESSION;
}
function S$4(e5) {
  if (e5.length < 10) return { originalName: null, mtime: null, headerSize: 0 };
  if (e5[0] !== 31 || e5[1] !== 139) return { originalName: null, mtime: null, headerSize: 0 };
  let t4 = e5[3], o2 = e5[4] | e5[5] << 8 | e5[6] << 16 | e5[7] << 24, r2 = 10;
  if (t4 & 4) {
    if (r2 + 2 > e5.length) return { originalName: null, mtime: null, headerSize: 0 };
    let s3 = e5[r2] | e5[r2 + 1] << 8;
    r2 += 2 + s3;
  }
  let n3 = null;
  if (t4 & 8) {
    let s3 = r2;
    for (; r2 < e5.length && e5[r2] !== 0; ) r2++;
    r2 < e5.length && (n3 = new TextDecoder().decode(e5.slice(s3, r2)), r2++);
  }
  if (t4 & 16) {
    for (; r2 < e5.length && e5[r2] !== 0; ) r2++;
    r2++;
  }
  return t4 & 2 && (r2 += 2), { originalName: n3, mtime: o2 > 0 ? new Date(o2 * 1e3) : null, headerSize: r2 };
}
function D$3(e5) {
  if (e5.length < 4) return 0;
  let t4 = e5.length;
  return e5[t4 - 4] | e5[t4 - 3] << 8 | e5[t4 - 2] << 16 | e5[t4 - 1] << 24;
}
function y$1(e5) {
  return e5.length >= 2 && e5[0] === 31 && e5[1] === 139;
}
async function E$2(e5, t4, o2, r2, n3, s3) {
  let u3 = o2.suffix, f3, p3, l3;
  if (t4 === "-" || t4 === "") if (l3 = Uint8Array.from(e5.stdin, (d3) => d3.charCodeAt(0)), n3) {
    if (!y$1(l3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: stdin: not in gzip format
`, exitCode: 1 };
    try {
      let d3 = gunzipSync(l3);
      return { stdout: String.fromCharCode(...d3), stderr: "", exitCode: 0 };
    } catch (d3) {
      let i4 = d3 instanceof Error ? d3.message : "unknown error";
      return { stdout: "", stderr: `${r2}: stdin: ${i4}
`, exitCode: 1 };
    }
  } else {
    let d3 = F$4(o2), i4 = gzipSync(l3, { level: d3 });
    return { stdout: String.fromCharCode(...i4), stderr: "", exitCode: 0 };
  }
  f3 = e5.fs.resolvePath(e5.cwd, t4);
  try {
    if ((await e5.fs.stat(f3)).isDirectory) return o2.recursive ? await k$3(e5, f3, o2, r2, n3, s3) : o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4}: is a directory -- ignored
`, exitCode: 1 };
  } catch {
    return { stdout: "", stderr: `${r2}: ${t4}: No such file or directory
`, exitCode: 1 };
  }
  try {
    l3 = await e5.fs.readFileBuffer(f3);
  } catch {
    return { stdout: "", stderr: `${r2}: ${t4}: No such file or directory
`, exitCode: 1 };
  }
  if (n3) {
    if (!t4.endsWith(u3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4}: unknown suffix -- ignored
`, exitCode: 1 };
    if (!y$1(l3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4}: not in gzip format
`, exitCode: 1 };
    let d3;
    try {
      d3 = gunzipSync(l3);
    } catch (i4) {
      let c3 = i4 instanceof Error ? i4.message : "unknown error";
      return { stdout: "", stderr: `${r2}: ${t4}: ${c3}
`, exitCode: 1 };
    }
    if (s3) return { stdout: String.fromCharCode(...d3), stderr: "", exitCode: 0 };
    if (o2.name) {
      let i4 = S$4(l3);
      i4.originalName ? p3 = e5.fs.resolvePath(e5.cwd, i4.originalName) : p3 = f3.slice(0, -u3.length);
    } else p3 = f3.slice(0, -u3.length);
    if (!o2.force) try {
      return await e5.fs.stat(p3), { stdout: "", stderr: `${r2}: ${p3} already exists; not overwritten
`, exitCode: 1 };
    } catch {
    }
    if (await e5.fs.writeFile(p3, d3), !o2.keep && !s3 && await e5.fs.rm(f3), o2.verbose) {
      let i4 = l3.length > 0 ? ((1 - l3.length / d3.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t4}:	${i4}% -- replaced with ${p3.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  } else {
    if (t4.endsWith(u3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4} already has ${u3} suffix -- unchanged
`, exitCode: 1 };
    let d3 = F$4(o2), i4;
    try {
      i4 = gzipSync(l3, { level: d3 });
    } catch (c3) {
      let a3 = c3 instanceof Error ? c3.message : "unknown error";
      return { stdout: "", stderr: `${r2}: ${t4}: ${a3}
`, exitCode: 1 };
    }
    if (s3) return { stdout: String.fromCharCode(...i4), stderr: "", exitCode: 0 };
    if (p3 = f3 + u3, !o2.force) try {
      return await e5.fs.stat(p3), { stdout: "", stderr: `${r2}: ${p3} already exists; not overwritten
`, exitCode: 1 };
    } catch {
    }
    if (await e5.fs.writeFile(p3, i4), !o2.keep && !s3 && await e5.fs.rm(f3), o2.verbose) {
      let c3 = l3.length > 0 ? ((1 - i4.length / l3.length) * 100).toFixed(1) : "0.0";
      return { stdout: "", stderr: `${t4}:	${c3}% -- replaced with ${p3.split("/").pop()}
`, exitCode: 0 };
    }
    return { stdout: "", stderr: "", exitCode: 0 };
  }
}
async function k$3(e5, t4, o2, r2, n3, s3) {
  let u3 = await e5.fs.readdir(t4), f3 = "", p3 = "", l3 = 0;
  for (let d3 of u3) {
    let i4 = e5.fs.resolvePath(t4, d3), c3 = await e5.fs.stat(i4);
    if (c3.isDirectory) {
      let a3 = await k$3(e5, i4, o2, r2, n3, s3);
      f3 += a3.stdout, p3 += a3.stderr, a3.exitCode !== 0 && (l3 = a3.exitCode);
    } else if (c3.isFile) {
      let a3 = o2.suffix;
      if (n3 && !d3.endsWith(a3) || !n3 && d3.endsWith(a3)) continue;
      let m3 = i4.startsWith(`${e5.cwd}/`) ? i4.slice(e5.cwd.length + 1) : i4, g2 = await E$2(e5, m3, o2, r2, n3, s3);
      f3 += g2.stdout, p3 += g2.stderr, g2.exitCode !== 0 && (l3 = g2.exitCode);
    }
  }
  return { stdout: f3, stderr: p3, exitCode: l3 };
}
async function O$6(e5, t4, o2, r2) {
  let n3;
  if (t4 === "-" || t4 === "") n3 = Uint8Array.from(e5.stdin, (i4) => i4.charCodeAt(0));
  else {
    let i4 = e5.fs.resolvePath(e5.cwd, t4);
    try {
      n3 = await e5.fs.readFileBuffer(i4);
    } catch {
      return { stdout: "", stderr: `${r2}: ${t4}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!y$1(n3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4}: not in gzip format
`, exitCode: 1 };
  let s3 = n3.length, u3 = D$3(n3), f3 = u3 > 0 ? ((1 - s3 / u3) * 100).toFixed(1) : "0.0", l3 = S$4(n3).originalName || (t4 === "-" ? "" : t4.replace(/\.gz$/, ""));
  return { stdout: `${s3.toString().padStart(10)} ${u3.toString().padStart(10)} ${f3.padStart(5)}% ${l3}
`, stderr: "", exitCode: 0 };
}
async function U$2(e5, t4, o2, r2) {
  let n3;
  if (t4 === "-" || t4 === "") n3 = Uint8Array.from(e5.stdin, (s3) => s3.charCodeAt(0));
  else {
    let s3 = e5.fs.resolvePath(e5.cwd, t4);
    try {
      n3 = await e5.fs.readFileBuffer(s3);
    } catch {
      return { stdout: "", stderr: `${r2}: ${t4}: No such file or directory
`, exitCode: 1 };
    }
  }
  if (!y$1(n3)) return o2.quiet ? { stdout: "", stderr: "", exitCode: 1 } : { stdout: "", stderr: `${r2}: ${t4}: not in gzip format
`, exitCode: 1 };
  try {
    return gunzipSync(n3), o2.verbose ? { stdout: "", stderr: `${t4}:	OK
`, exitCode: 0 } : { stdout: "", stderr: "", exitCode: 0 };
  } catch (s3) {
    let u3 = s3 instanceof Error ? s3.message : "invalid";
    return { stdout: "", stderr: `${r2}: ${t4}: ${u3}
`, exitCode: 1 };
  }
}
async function v$2(e5, t4, o2) {
  let r2 = o2 === "zcat" ? P$2 : o2 === "gunzip" ? q$4 : I$4;
  if (o$3(e5)) return s$1(r2);
  let n3 = x$g(o2, e5, L$3);
  if (!n3.ok) return n3.error.stderr.includes("unrecognized option"), n3.error;
  let s3 = n3.result.flags, u3 = n3.result.positional, f3 = o2 === "gunzip" || o2 === "zcat" || s3.decompress || s3.uncompress, p3 = o2 === "zcat" || s3.stdout || s3.toStdout;
  if (s3.list) {
    u3.length === 0 && (u3 = ["-"]);
    let c3 = `  compressed uncompressed  ratio uncompressed_name
`, a3 = "", m3 = 0;
    for (let g2 of u3) {
      let h3 = await O$6(t4, g2, s3, o2);
      c3 += h3.stdout, a3 += h3.stderr, h3.exitCode !== 0 && (m3 = h3.exitCode);
    }
    return { stdout: c3, stderr: a3, exitCode: m3 };
  }
  if (s3.test) {
    u3.length === 0 && (u3 = ["-"]);
    let c3 = "", a3 = "", m3 = 0;
    for (let g2 of u3) {
      let h3 = await U$2(t4, g2, s3, o2);
      c3 += h3.stdout, a3 += h3.stderr, h3.exitCode !== 0 && (m3 = h3.exitCode);
    }
    return { stdout: c3, stderr: a3, exitCode: m3 };
  }
  u3.length === 0 && (u3 = ["-"]);
  let l3 = "", d3 = "", i4 = 0;
  for (let c3 of u3) {
    let a3 = await E$2(t4, c3, s3, o2, f3, p3);
    l3 += a3.stdout, d3 += a3.stderr, a3.exitCode !== 0 && (i4 = a3.exitCode);
  }
  return { stdout: l3, stderr: d3, exitCode: i4 };
}
var _$3 = { name: "gzip", async execute(e5, t4) {
  return v$2(e5, t4, "gzip");
} }, H$3 = { name: "gunzip", async execute(e5, t4) {
  return v$2(e5, t4, "gunzip");
} }, B$5 = { name: "zcat", async execute(e5, t4) {
  return v$2(e5, t4, "zcat");
} };
const gzipL3NDJG3F = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  gunzipCommand: H$3,
  gzipCommand: _$3,
  zcatCommand: B$5
});
var P$1 = "file", se$1 = "link", ae$1 = "symlink", b$2 = "directory", ve$1 = { file: "0", link: "1", symlink: "2", "character-device": "3", "block-device": "4", directory: "5", fifo: "6", "pax-header": "x", "pax-global-header": "g", "gnu-long-name": "L", "gnu-long-link-name": "K" }, ze = { 0: P$1, 1: se$1, 2: ae$1, 3: "character-device", 4: "block-device", 5: b$2, 6: "fifo", x: "pax-header", g: "pax-global-header", L: "gnu-long-name", K: "gnu-long-link-name" }, Oe$2 = new Uint8Array(512), O$5 = new Uint8Array(0), x$2 = new TextEncoder(), oe$1 = new TextDecoder();
function T$2(e5, t4, i4, r2) {
  r2 && x$2.encodeInto(r2, e5.subarray(t4, t4 + i4));
}
function I$3(e5, t4, i4, r2) {
  if (r2 === void 0) return;
  let n3 = r2.toString(8).padStart(i4 - 1, "0");
  x$2.encodeInto(n3, e5.subarray(t4, t4 + i4 - 1));
}
function A$3(e5, t4, i4) {
  let r2 = e5.indexOf(0, t4), n3 = r2 === -1 || r2 > t4 + i4 ? t4 + i4 : r2;
  return oe$1.decode(e5.subarray(t4, n3));
}
function G$1(e5, t4, i4) {
  let r2 = 0, n3 = t4 + i4;
  for (let s3 = t4; s3 < n3; s3++) {
    let o2 = e5[s3];
    if (o2 === 0) break;
    o2 !== 32 && (r2 = r2 * 8 + (o2 - 48));
  }
  return r2;
}
function R$3(e5, t4, i4) {
  if (e5[t4] & 128) {
    let r2 = 0;
    r2 = e5[t4] & 127;
    for (let n3 = 1; n3 < i4; n3++) r2 = r2 * 256 + e5[t4 + n3];
    if (!Number.isSafeInteger(r2)) throw new Error("TAR number too large");
    return r2;
  }
  return G$1(e5, t4, i4);
}
var k$2 = (e5) => e5.type === b$2 || e5.type === ae$1 || e5.type === se$1;
async function ce$2(e5) {
  if (e5 == null) return O$5;
  if (e5 instanceof Uint8Array) return e5;
  if (typeof e5 == "string") return x$2.encode(e5);
  if (e5 instanceof ArrayBuffer) return new Uint8Array(e5);
  if (e5 instanceof Blob) return new Uint8Array(await e5.arrayBuffer());
  throw new TypeError("Unsupported content type for entry body.");
}
function le$2(e5, t4) {
  let { strip: i4, filter: r2, map: n3 } = t4;
  if (!i4 && !r2 && !n3) return e5;
  let s3 = { ...e5 };
  if (i4 && i4 > 0) {
    let a3 = s3.name.split("/").filter(Boolean);
    if (i4 >= a3.length) return null;
    let c3 = a3.slice(i4).join("/");
    if (s3.name = s3.type === b$2 && !c3.endsWith("/") ? `${c3}/` : c3, s3.linkname?.startsWith("/")) {
      let l3 = s3.linkname.split("/").filter(Boolean);
      s3.linkname = i4 >= l3.length ? "/" : `/${l3.slice(i4).join("/")}`;
    }
  }
  if (r2?.(s3) === false) return null;
  let o2 = n3 ? n3(s3) : s3;
  return o2 && (!o2.name || !o2.name.trim() || o2.name === "." || o2.name === "/") ? null : o2;
}
var K$1 = 32, be$2 = 48;
function Me$2(e5) {
  let t4 = G$1(e5, 148, 8), i4 = 0;
  for (let r2 = 0; r2 < e5.length; r2++) r2 >= 148 && r2 < 156 ? i4 += K$1 : i4 += e5[r2];
  return t4 === i4;
}
function $e$1(e5) {
  e5.fill(K$1, 148, 156);
  let t4 = 0;
  for (let i4 of e5) t4 += i4;
  for (let i4 = 153; i4 >= 148; i4--) e5[i4] = (t4 & 7) + be$2, t4 >>= 3;
  e5[154] = 0, e5[155] = K$1;
}
function Ze$1(e5) {
  let t4 = {};
  e5.name.length > 100 && ue$1(e5.name) === null && (t4.path = e5.name), e5.linkname && e5.linkname.length > 100 && (t4.linkpath = e5.linkname), e5.uname && e5.uname.length > 32 && (t4.uname = e5.uname), e5.gname && e5.gname.length > 32 && (t4.gname = e5.gname), e5.uid != null && e5.uid > 2097151 && (t4.uid = String(e5.uid)), e5.gid != null && e5.gid > 2097151 && (t4.gid = String(e5.gid)), e5.size != null && e5.size > 8589934591 && (t4.size = String(e5.size)), e5.pax && Object.assign(t4, e5.pax);
  let i4 = Object.entries(t4);
  if (i4.length === 0) return null;
  let r2 = x$2.encode(i4.map(([n3, s3]) => {
    let o2 = `${n3}=${s3}
`, a3 = x$2.encode(o2).length + 1, c3 = a3 + String(a3).length;
    return c3 = a3 + String(c3).length, `${c3} ${o2}`;
  }).join(""));
  return { paxHeader: fe$1({ name: oe$1.decode(x$2.encode(`PaxHeader/${e5.name}`).slice(0, 100)), size: r2.length, type: "pax-header", mode: 420, mtime: e5.mtime, uname: e5.uname, gname: e5.gname, uid: e5.uid, gid: e5.gid }), paxBody: r2 };
}
function ue$1(e5) {
  if (e5.length <= 100) return null;
  let t4 = e5.length - 100 - 1, i4 = e5.lastIndexOf("/", 155);
  return i4 > 0 && i4 >= t4 ? { prefix: e5.slice(0, i4), name: e5.slice(i4 + 1) } : null;
}
function fe$1(e5) {
  let t4 = new Uint8Array(512), i4 = k$2(e5) ? 0 : e5.size ?? 0, r2 = e5.name, n3 = "";
  if (!e5.pax?.path) {
    let s3 = ue$1(r2);
    s3 && (r2 = s3.name, n3 = s3.prefix);
  }
  return T$2(t4, 0, 100, r2), I$3(t4, 100, 8, e5.mode ?? (e5.type === b$2 ? 493 : 420)), I$3(t4, 108, 8, e5.uid ?? 0), I$3(t4, 116, 8, e5.gid ?? 0), I$3(t4, 124, 12, i4), I$3(t4, 136, 12, Math.floor((e5.mtime?.getTime() ?? Date.now()) / 1e3)), T$2(t4, 156, 1, ve$1[e5.type ?? P$1]), T$2(t4, 157, 100, e5.linkname), T$2(t4, 257, 6, "ustar\0"), T$2(t4, 263, 2, "00"), T$2(t4, 265, 32, e5.uname), T$2(t4, 297, 32, e5.gname), T$2(t4, 345, 155, n3), $e$1(t4), t4;
}
function Be$2(e5, t4) {
  if (t4 && !Me$2(e5)) throw new Error("Invalid tar header checksum.");
  let i4 = A$3(e5, 156, 1), r2 = { name: A$3(e5, 0, 100), mode: G$1(e5, 100, 8), uid: R$3(e5, 108, 8), gid: R$3(e5, 116, 8), size: R$3(e5, 124, 12), mtime: new Date(R$3(e5, 136, 12) * 1e3), type: ze[i4] || P$1, linkname: A$3(e5, 157, 100) }, n3 = A$3(e5, 257, 6);
  return n3.trim() === "ustar" && (r2.uname = A$3(e5, 265, 32), r2.gname = A$3(e5, 297, 32)), n3 === "ustar" && (r2.prefix = A$3(e5, 345, 155)), r2;
}
var De$1 = { path: ["name", (e5) => e5], linkpath: ["linkname", (e5) => e5], size: ["size", (e5) => parseInt(e5, 10)], mtime: ["mtime", parseFloat], uid: ["uid", (e5) => parseInt(e5, 10)], gid: ["gid", (e5) => parseInt(e5, 10)], uname: ["uname", (e5) => e5], gname: ["gname", (e5) => e5] };
function Ne$1(e5) {
  let t4 = new TextDecoder("utf-8"), i4 = {}, r2 = {}, n3 = 0;
  for (; n3 < e5.length; ) {
    let s3 = e5.indexOf(32, n3);
    if (s3 === -1) break;
    let o2 = parseInt(t4.decode(e5.subarray(n3, s3)), 10);
    if (Number.isNaN(o2) || o2 === 0) break;
    let a3 = n3 + o2, [c3, l3] = t4.decode(e5.subarray(s3 + 1, a3 - 1)).split("=", 2);
    if (c3 && l3 !== void 0) {
      r2[c3] = l3;
      let d3 = De$1[c3];
      if (d3) {
        let [u3, g2] = d3, p3 = g2(l3);
        (typeof p3 == "string" || !Number.isNaN(p3)) && (i4[u3] = p3);
      }
    }
    n3 = a3;
  }
  return Object.keys(r2).length > 0 && (i4.pax = r2), i4;
}
function ne$2(e5, t4) {
  t4.name !== void 0 && (e5.name = t4.name), t4.linkname !== void 0 && (e5.linkname = t4.linkname), t4.size !== void 0 && (e5.size = t4.size), t4.mtime !== void 0 && (e5.mtime = new Date(t4.mtime * 1e3)), t4.uid !== void 0 && (e5.uid = t4.uid), t4.gid !== void 0 && (e5.gid = t4.gid), t4.uname !== void 0 && (e5.uname = t4.uname), t4.gname !== void 0 && (e5.gname = t4.gname), t4.pax && (e5.pax = Object.assign({}, e5.pax ?? {}, t4.pax));
}
function Le$1(e5) {
  switch (e5) {
    case "pax-global-header":
    case "pax-header":
      return Ne$1;
    case "gnu-long-name":
      return (t4) => ({ name: A$3(t4, 0, t4.length) });
    case "gnu-long-link-name":
      return (t4) => ({ linkname: A$3(t4, 0, t4.length) });
    default:
      return;
  }
}
function Ke(e5) {
  let t4 = fe$1(e5), i4 = Ze$1(e5);
  if (!i4) return [t4];
  let r2 = -i4.paxBody.length & 511, n3 = r2 > 0 ? [Oe$2.subarray(0, r2)] : [];
  return [i4.paxHeader, i4.paxBody, ...n3, t4];
}
var Pe$2 = new Uint8Array(512 * 2);
function de$1(e5, t4, i4) {
  let r2 = null, n3 = 0, s3 = false;
  return { add(o2) {
    if (s3) {
      let a3 = new Error("No new tar entries after finalize.");
      throw t4(a3), a3;
    }
    if (r2 !== null) {
      let a3 = new Error("Previous entry must be completed before adding a new one");
      throw t4(a3), a3;
    }
    try {
      let a3 = k$2(o2) ? 0 : o2.size ?? 0, c3 = Ke({ ...o2, size: a3 });
      for (let l3 of c3) e5(l3);
      r2 = { ...o2, size: a3 }, n3 = 0;
    } catch (a3) {
      t4(a3);
    }
  }, write(o2) {
    if (!r2) {
      let c3 = new Error("No active tar entry.");
      throw t4(c3), c3;
    }
    if (s3) {
      let c3 = new Error("Cannot write data after finalize.");
      throw t4(c3), c3;
    }
    let a3 = n3 + o2.length;
    if (a3 > r2.size) {
      let c3 = new Error(`"${r2.name}" exceeds given size of ${r2.size} bytes.`);
      throw t4(c3), c3;
    }
    try {
      n3 = a3, e5(o2);
    } catch (c3) {
      t4(c3);
    }
  }, endEntry() {
    if (!r2) {
      let o2 = new Error("No active entry to end.");
      throw t4(o2), o2;
    }
    if (s3) {
      let o2 = new Error("Cannot end entry after finalize.");
      throw t4(o2), o2;
    }
    try {
      if (n3 !== r2.size) {
        let a3 = new Error(`Size mismatch for "${r2.name}".`);
        throw t4(a3), a3;
      }
      let o2 = -r2.size & 511;
      o2 > 0 && e5(new Uint8Array(o2)), r2 = null, n3 = 0;
    } catch (o2) {
      throw t4(o2), o2;
    }
  }, finalize() {
    if (s3) {
      let o2 = new Error("Archive has already been finalized");
      throw t4(o2), o2;
    }
    if (r2 !== null) {
      let o2 = new Error("Cannot finalize while an entry is still active");
      throw t4(o2), o2;
    }
    try {
      e5(Pe$2), s3 = true, i4 && i4();
    } catch (o2) {
      t4(o2);
    }
  } };
}
var v$1 = 256;
function Ge() {
  let e5 = new Array(v$1), t4 = e5.length - 1, i4 = 0, r2 = 0, n3 = 0, s3 = (a3) => {
    let c3 = e5[i4];
    a3 === c3.length ? (e5[i4] = O$5, i4 = i4 + 1 & t4) : e5[i4] = c3.subarray(a3), n3 -= a3, n3 === 0 && e5.length > v$1 && (e5 = new Array(v$1), t4 = v$1 - 1, i4 = 0, r2 = 0);
  };
  function o2(a3, c3) {
    if (c3) {
      let p3 = 0, f3 = Math.min(a3, n3);
      for (; f3 > 0; ) {
        let h3 = e5[i4], m3 = Math.min(f3, h3.length), S3 = m3 === h3.length ? h3 : h3.subarray(0, m3);
        if (s3(m3), f3 -= m3, p3 += m3, !c3(S3)) break;
      }
      return p3;
    }
    if (n3 < a3) return null;
    if (a3 === 0) return O$5;
    let l3 = e5[i4];
    if (l3.length >= a3) {
      let p3 = l3.length === a3 ? l3 : l3.subarray(0, a3);
      return s3(a3), p3;
    }
    let d3 = new Uint8Array(a3), u3 = 0, g2 = a3;
    for (; g2 > 0; ) {
      let p3 = e5[i4], f3 = Math.min(g2, p3.length);
      d3.set(f3 === p3.length ? p3 : p3.subarray(0, f3), u3), u3 += f3, g2 -= f3, s3(f3);
    }
    return d3;
  }
  return { push: (a3) => {
    if (a3.length === 0) return;
    let c3 = r2 + 1 & t4;
    if (c3 === i4) {
      let l3 = e5.length, d3 = l3 * 2, u3 = new Array(d3), g2 = r2 - i4 + l3 & l3 - 1;
      if (i4 < r2) for (let p3 = 0; p3 < g2; p3++) u3[p3] = e5[i4 + p3];
      else if (g2 > 0) {
        let p3 = l3 - i4;
        for (let f3 = 0; f3 < p3; f3++) u3[f3] = e5[i4 + f3];
        for (let f3 = 0; f3 < r2; f3++) u3[p3 + f3] = e5[f3];
      }
      e5 = u3, t4 = d3 - 1, i4 = 0, r2 = g2, c3 = r2 + 1 & t4;
    }
    e5[r2] = a3, r2 = c3, n3 += a3.length;
  }, available: () => n3, peek: (a3) => {
    if (n3 < a3) return null;
    if (a3 === 0) return O$5;
    let c3 = e5[i4];
    if (c3.length >= a3) return c3.length === a3 ? c3 : c3.subarray(0, a3);
    let l3 = new Uint8Array(a3), d3 = 0, u3 = i4;
    for (; d3 < a3; ) {
      let g2 = e5[u3], p3 = Math.min(a3 - d3, g2.length);
      p3 === g2.length ? l3.set(g2, d3) : l3.set(g2.subarray(0, p3), d3), d3 += p3, u3 = u3 + 1 & t4;
    }
    return l3;
  }, discard: (a3) => {
    if (a3 > n3) throw new Error("Too many bytes consumed");
    if (a3 === 0) return;
    let c3 = a3;
    for (; c3 > 0; ) {
      let l3 = e5[i4], d3 = Math.min(c3, l3.length);
      s3(d3), c3 -= d3;
    }
  }, pull: o2 };
}
var L$2 = 0, F$3 = 1, z$1 = new Error("Tar archive is truncated.");
function me$1(e5 = {}) {
  let t4 = e5.strict ?? false, { available: i4, peek: r2, push: n3, discard: s3, pull: o2 } = Ge(), a3 = L$2, c3 = false, l3 = false, d3 = false, u3 = null, g2 = {}, p3 = {}, f3 = { isEntryActive: () => a3 === F$3, isBodyComplete: () => !u3 || u3.remaining === 0, write(h3) {
    if (c3) throw new Error("Archive already ended.");
    n3(h3);
  }, end() {
    c3 = true;
  }, readHeader() {
    if (a3 !== L$2) throw new Error("Cannot read header while an entry is active");
    if (!l3) for (; !l3; ) {
      if (i4() < 512) {
        if (c3) {
          if (i4() > 0 && t4) throw z$1;
          l3 = true;
          return;
        }
        return null;
      }
      let h3 = r2(512);
      if (ie$2(h3)) {
        if (i4() < 512 * 2) {
          if (c3) {
            if (t4) throw z$1;
            l3 = true;
            return;
          }
          return null;
        }
        if (ie$2(r2(512 * 2).subarray(512))) {
          s3(512 * 2), l3 = true, d3 = true;
          return;
        }
        if (t4) throw new Error("Invalid tar header.");
        s3(512);
        continue;
      }
      let m3;
      try {
        m3 = Be$2(h3, t4);
      } catch (w4) {
        if (t4) throw w4;
        s3(512);
        continue;
      }
      let S3 = Le$1(m3.type);
      if (S3) {
        let w4 = m3.size + 511 & -512;
        if (i4() < 512 + w4) {
          if (c3 && t4) throw z$1;
          return null;
        }
        s3(512);
        let U2 = S3(o2(w4).subarray(0, m3.size)), Re3 = m3.type === "pax-global-header" ? g2 : p3;
        for (let ee2 in U2) Re3[ee2] = U2[ee2];
        continue;
      }
      s3(512);
      let E2 = m3;
      return m3.prefix && (E2.name = `${m3.prefix}/${E2.name}`), ne$2(E2, g2), ne$2(E2, p3), p3 = {}, u3 = { header: E2, remaining: E2.size, padding: -E2.size & 511 }, a3 = F$3, E2;
    }
  }, streamBody(h3) {
    if (a3 !== F$3 || !u3 || u3.remaining === 0) return 0;
    let m3 = Math.min(u3.remaining, i4());
    if (m3 === 0) return 0;
    let S3 = o2(m3, h3);
    return u3.remaining -= S3, S3;
  }, skipPadding() {
    if (a3 !== F$3 || !u3) return true;
    if (u3.remaining > 0) throw new Error("Body not fully consumed");
    return i4() < u3.padding ? false : (s3(u3.padding), u3 = null, a3 = L$2, true);
  }, skipEntry() {
    if (a3 !== F$3 || !u3) return true;
    let h3 = Math.min(u3.remaining, i4());
    return h3 > 0 && (s3(h3), u3.remaining -= h3), u3.remaining > 0 ? false : f3.skipPadding();
  }, validateEOF() {
    if (t4) {
      if (!d3) throw z$1;
      if (i4() > 0 && o2(i4()).some((h3) => h3 !== 0)) throw new Error("Invalid EOF.");
    }
  } };
  return f3;
}
function ie$2(e5) {
  if (e5.byteOffset % 8 === 0) {
    let t4 = new BigUint64Array(e5.buffer, e5.byteOffset, e5.length / 8);
    for (let i4 = 0; i4 < t4.length; i4++) if (t4[i4] !== 0n) return false;
    return true;
  }
  for (let t4 = 0; t4 < e5.length; t4++) if (e5[t4] !== 0) return false;
  return true;
}
function he$1() {
  return new CompressionStream("gzip");
}
function ge$1() {
  return new DecompressionStream("gzip");
}
function He$2() {
  let e5, t4;
  return { readable: new ReadableStream({ start(i4) {
    e5 = i4, t4 = de$1(i4.enqueue.bind(i4), i4.error.bind(i4), i4.close.bind(i4));
  } }), controller: { add(i4) {
    let r2 = k$2(i4), n3 = { ...i4 };
    return r2 && (n3.size = 0), t4.add(n3), r2 && t4.endEntry(), new WritableStream({ write(s3) {
      t4.write(s3);
    }, close() {
      r2 || t4.endEntry();
    }, abort(s3) {
      e5.error(s3);
    } });
  }, finalize() {
    t4.finalize();
  }, error(i4) {
    e5.error(i4);
  } } };
}
async function Se$1(e5) {
  let t4 = [], i4 = e5.getReader(), r2 = 0;
  try {
    for (; ; ) {
      let { done: o2, value: a3 } = await i4.read();
      if (o2) break;
      t4.push(a3), r2 += a3.length;
    }
    let n3 = new Uint8Array(r2), s3 = 0;
    for (let o2 of t4) n3.set(o2, s3), s3 += o2.length;
    return n3;
  } finally {
    i4.releaseLock();
  }
}
var pe$1 = (e5) => e5.pipeTo(new WritableStream());
function We$2(e5 = {}) {
  let t4 = me$1(e5), i4 = null, r2 = false, n3 = (s3) => {
    if (!r2) {
      r2 = true;
      try {
        for (; ; ) if (t4.isEntryActive()) {
          if (i4) {
            if (t4.streamBody((o2) => (i4.enqueue(o2), true)) === 0 && !t4.isBodyComplete()) break;
          } else if (!t4.skipEntry()) break;
          if (t4.isBodyComplete()) {
            try {
              i4?.close();
            } catch {
            }
            if (i4 = null, !t4.skipPadding()) break;
          }
        } else {
          let o2 = t4.readHeader();
          if (o2 == null) break;
          s3.enqueue({ header: o2, body: new ReadableStream({ start(a3) {
            o2.size === 0 ? a3.close() : i4 = a3;
          }, pull: () => n3(s3), cancel() {
            i4 = null, n3(s3);
          } }) });
        }
      } catch (o2) {
        try {
          i4?.error(o2);
        } catch {
        }
        throw i4 = null, o2;
      } finally {
        r2 = false;
      }
    }
  };
  return new TransformStream({ transform(s3, o2) {
    try {
      t4.write(s3), n3(o2);
    } catch (a3) {
      try {
        i4?.error(a3);
      } catch {
      }
      throw a3;
    }
  }, flush(s3) {
    try {
      if (t4.end(), n3(s3), t4.validateEOF(), t4.isEntryActive() && !t4.isBodyComplete()) try {
        i4?.close();
      } catch {
      }
    } catch (o2) {
      try {
        i4?.error(o2);
      } catch {
      }
      throw o2;
    }
  } }, void 0, { highWaterMark: 1 });
}
async function Ee$1(e5) {
  let { readable: t4, controller: i4 } = He$2();
  return await (async () => {
    for (let r2 of e5) {
      let n3 = i4.add(r2.header), s3 = "body" in r2 ? r2.body : r2.data;
      if (!s3) {
        await n3.close();
        continue;
      }
      if (s3 instanceof ReadableStream) await s3.pipeTo(n3);
      else if (s3 instanceof Blob) await s3.stream().pipeTo(n3);
      else try {
        let o2 = await ce$2(s3);
        if (o2.length > 0) {
          let a3 = n3.getWriter();
          await a3.write(o2), await a3.close();
        } else await n3.close();
      } catch {
        throw new TypeError(`Unsupported content type for entry "${r2.header.name}".`);
      }
    }
  })().then(() => i4.finalize()).catch((r2) => i4.error(r2)), new Uint8Array(await Se$1(t4));
}
async function we$2(e5, t4 = {}) {
  let i4 = e5 instanceof ReadableStream ? e5 : new ReadableStream({ start(s3) {
    s3.enqueue(e5 instanceof Uint8Array ? e5 : new Uint8Array(e5)), s3.close();
  } }), r2 = [], n3 = i4.pipeThrough(We$2(t4));
  for await (let s3 of n3) {
    let o2;
    try {
      o2 = le$2(s3.header, t4);
    } catch (a3) {
      throw await s3.body.cancel(), a3;
    }
    if (o2 === null) {
      await pe$1(s3.body);
      continue;
    }
    k$2(o2) ? (await pe$1(s3.body), r2.push({ header: o2 })) : r2.push({ header: o2, data: await Se$1(s3.body) });
  }
  return r2;
}
var M$2 = null, $$2 = null;
async function _e$2() {
  if (M$2) return M$2;
  if ($$2) throw $$2;
  try {
    return M$2 = await import("./node-liblzma.mjs"), M$2;
  } catch {
    throw $$2 = new Error("xz compression requires node-liblzma which failed to load. Install liblzma-dev (apt) or xz (brew) and reinstall dependencies."), $$2;
  }
}
var y = 100 * 1024 * 1024, ye$2 = 1e4;
function Xe(e5) {
  let t4 = "file";
  e5.isDirectory ? t4 = "directory" : e5.isSymlink && (t4 = "symlink");
  let i4 = e5.name;
  e5.isDirectory && !i4.endsWith("/") && (i4 += "/");
  let r2;
  e5.content !== void 0 && (typeof e5.content == "string" ? r2 = new TextEncoder().encode(e5.content) : r2 = e5.content);
  let n3 = e5.isDirectory || e5.isSymlink ? 0 : r2?.length ?? 0;
  return { header: { name: i4, mode: e5.mode ?? (e5.isDirectory ? 493 : 420), uid: e5.uid ?? 0, gid: e5.gid ?? 0, size: n3, mtime: e5.mtime ?? /* @__PURE__ */ new Date(), type: t4, linkname: e5.linkTarget ?? "", uname: "user", gname: "user" }, body: r2 };
}
async function C$3(e5) {
  let t4 = e5.map(Xe);
  return Ee$1(t4);
}
async function Te$1(e5) {
  let t4 = await C$3(e5), n3 = new ReadableStream({ start(l3) {
    l3.enqueue(t4), l3.close();
  } }).pipeThrough(he$1()).getReader(), s3 = [];
  for (; ; ) {
    let { done: l3, value: d3 } = await n3.read();
    if (l3) break;
    s3.push(d3);
  }
  let o2 = s3.reduce((l3, d3) => l3 + d3.length, 0), a3 = new Uint8Array(o2), c3 = 0;
  for (let l3 of s3) a3.set(l3, c3), c3 += l3.length;
  return a3;
}
async function _$2(e5) {
  if (e5.length > y) return { entries: [], error: `Archive too large (max ${y} bytes)` };
  try {
    let t4 = await we$2(e5), i4 = [];
    for (let r2 of t4) {
      if (i4.length >= ye$2) return { entries: i4, error: `Too many entries (max ${ye$2})` };
      let n3 = "file";
      switch (r2.header.type) {
        case "directory":
          n3 = "directory";
          break;
        case "symlink":
          n3 = "symlink";
          break;
        case "link":
          n3 = "hardlink";
          break;
        case "file":
          n3 = "file";
          break;
        default:
          n3 = "other";
      }
      i4.push({ name: r2.header.name, mode: r2.header.mode ?? 420, uid: r2.header.uid ?? 0, gid: r2.header.gid ?? 0, size: r2.header.size, mtime: r2.header.mtime ?? /* @__PURE__ */ new Date(), type: n3, linkTarget: r2.header.linkname || void 0, content: r2.data ?? new Uint8Array(0) });
    }
    return { entries: i4 };
  } catch (t4) {
    let i4 = t4 instanceof Error ? t4.message : "Unknown error";
    return { entries: [], error: i4 };
  }
}
async function H$2(e5) {
  if (e5.length > y) return { entries: [], error: `Archive too large (max ${y} bytes)` };
  try {
    let r2 = new ReadableStream({ start(c3) {
      c3.enqueue(e5), c3.close();
    } }).pipeThrough(ge$1()).getReader(), n3 = [];
    for (; ; ) {
      let { done: c3, value: l3 } = await r2.read();
      if (c3) break;
      n3.push(l3);
    }
    let s3 = n3.reduce((c3, l3) => c3 + l3.length, 0), o2 = new Uint8Array(s3), a3 = 0;
    for (let c3 of n3) o2.set(c3, a3), a3 += c3.length;
    return _$2(o2);
  } catch (t4) {
    let i4 = t4 instanceof Error ? t4.message : "Unknown error";
    return { entries: [], error: `Decompression failed: ${i4}` };
  }
}
function W$3(e5) {
  return e5.length >= 2 && e5[0] === 31 && e5[1] === 139;
}
function X$2(e5) {
  return e5.length >= 3 && e5[0] === 66 && e5[1] === 90 && e5[2] === 104;
}
function j$3(e5) {
  return e5.length >= 6 && e5[0] === 253 && e5[1] === 55 && e5[2] === 122 && e5[3] === 88 && e5[4] === 90 && e5[5] === 0;
}
async function je$2(e5) {
  let i4 = Ae$4.Bzip2.decompressFile(Array.from(e5));
  return new Uint8Array(i4);
}
async function qe$2(e5) {
  let t4 = Ae$4.Bzip2, i4 = [];
  return t4.compressFile(Array.from(e5), i4, 9), new Uint8Array(i4);
}
async function Ye$1(e5) {
  let i4 = (await _e$2()).unxzSync(Buffer.from(e5));
  return new Uint8Array(i4);
}
async function Ve$2(e5) {
  let i4 = (await _e$2()).xzSync(Buffer.from(e5));
  return new Uint8Array(i4);
}
async function Ce$1(e5) {
  let t4 = await C$3(e5);
  return qe$2(t4);
}
async function xe$3(e5) {
  let t4 = await C$3(e5);
  return Ve$2(t4);
}
async function q$3(e5) {
  if (e5.length > y) return { entries: [], error: `Archive too large (max ${y} bytes)` };
  try {
    let t4 = await je$2(e5);
    return _$2(t4);
  } catch (t4) {
    let i4 = t4 instanceof Error ? t4.message : "Unknown error";
    return { entries: [], error: i4 };
  }
}
async function Y$2(e5) {
  if (e5.length > y) return { entries: [], error: `Archive too large (max ${y} bytes)` };
  try {
    let t4 = await Ye$1(e5);
    return _$2(t4);
  } catch (t4) {
    let i4 = t4 instanceof Error ? t4.message : "Unknown error";
    return { entries: [], error: i4 };
  }
}
function V$4(e5) {
  return e5.length >= 4 && e5[0] === 40 && e5[1] === 181 && e5[2] === 47 && e5[3] === 253;
}
async function Je$2(e5) {
  let t4 = await libExports.compress(Buffer.from(e5), 3);
  return new Uint8Array(t4);
}
async function Qe$2(e5) {
  let t4 = await libExports.decompress(Buffer.from(e5));
  return new Uint8Array(t4);
}
async function Ue$2(e5) {
  let t4 = await C$3(e5);
  return Je$2(t4);
}
async function J$2(e5) {
  if (e5.length > y) return { entries: [], error: `Archive too large (max ${y} bytes)` };
  try {
    let t4 = await Qe$2(e5);
    return _$2(t4);
  } catch (t4) {
    let i4 = t4 instanceof Error ? t4.message : "Unknown error";
    return { entries: [], error: i4 };
  }
}
function Ie$1(e5) {
  let t4 = { create: false, append: false, update: false, extract: false, list: false, file: "", autoCompress: false, gzip: false, bzip2: false, xz: false, zstd: false, verbose: false, toStdout: false, keepOldFiles: false, touch: false, directory: "", preserve: false, strip: 0, exclude: [], filesFrom: "", excludeFrom: "", wildcards: false }, i4 = [], r2 = 0;
  for (; r2 < e5.length; ) {
    let n3 = e5[r2];
    if (n3.startsWith("-") && !n3.startsWith("--") && n3.length > 2) {
      if (/^-\d+$/.test(n3)) {
        i4.push(n3), r2++;
        continue;
      }
      for (let s3 = 1; s3 < n3.length; s3++) {
        let o2 = n3[s3];
        switch (o2) {
          case "c":
            t4.create = true;
            break;
          case "r":
            t4.append = true;
            break;
          case "u":
            t4.update = true;
            break;
          case "x":
            t4.extract = true;
            break;
          case "t":
            t4.list = true;
            break;
          case "a":
            t4.autoCompress = true;
            break;
          case "z":
            t4.gzip = true;
            break;
          case "j":
            t4.bzip2 = true;
            break;
          case "J":
            t4.xz = true;
            break;
          case "v":
            t4.verbose = true;
            break;
          case "O":
            t4.toStdout = true;
            break;
          case "k":
            t4.keepOldFiles = true;
            break;
          case "m":
            t4.touch = true;
            break;
          case "p":
            t4.preserve = true;
            break;
          case "f":
            if (s3 < n3.length - 1) t4.file = n3.substring(s3 + 1), s3 = n3.length;
            else {
              if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'f'
`, exitCode: 2 } };
              t4.file = e5[r2];
            }
            break;
          case "C":
            if (s3 < n3.length - 1) t4.directory = n3.substring(s3 + 1), s3 = n3.length;
            else {
              if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'C'
`, exitCode: 2 } };
              t4.directory = e5[r2];
            }
            break;
          case "T":
            if (s3 < n3.length - 1) t4.filesFrom = n3.substring(s3 + 1), s3 = n3.length;
            else {
              if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'T'
`, exitCode: 2 } };
              t4.filesFrom = e5[r2];
            }
            break;
          case "X":
            if (s3 < n3.length - 1) t4.excludeFrom = n3.substring(s3 + 1), s3 = n3.length;
            else {
              if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'X'
`, exitCode: 2 } };
              t4.excludeFrom = e5[r2];
            }
            break;
          default:
            return { ok: false, error: r$3("tar", `-${o2}`) };
        }
      }
      r2++;
      continue;
    }
    if (n3 === "-c" || n3 === "--create") t4.create = true;
    else if (n3 === "-r" || n3 === "--append") t4.append = true;
    else if (n3 === "-u" || n3 === "--update") t4.update = true;
    else if (n3 === "-x" || n3 === "--extract" || n3 === "--get") t4.extract = true;
    else if (n3 === "-t" || n3 === "--list") t4.list = true;
    else if (n3 === "-a" || n3 === "--auto-compress") t4.autoCompress = true;
    else if (n3 === "-z" || n3 === "--gzip" || n3 === "--gunzip") t4.gzip = true;
    else if (n3 === "-j" || n3 === "--bzip2") t4.bzip2 = true;
    else if (n3 === "-J" || n3 === "--xz") t4.xz = true;
    else if (n3 === "--zstd") t4.zstd = true;
    else if (n3 === "-v" || n3 === "--verbose") t4.verbose = true;
    else if (n3 === "-O" || n3 === "--to-stdout") t4.toStdout = true;
    else if (n3 === "-k" || n3 === "--keep-old-files") t4.keepOldFiles = true;
    else if (n3 === "-m" || n3 === "--touch") t4.touch = true;
    else if (n3 === "--wildcards") t4.wildcards = true;
    else if (n3 === "-p" || n3 === "--preserve" || n3 === "--preserve-permissions") t4.preserve = true;
    else if (n3 === "-f" || n3 === "--file") {
      if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'f'
`, exitCode: 2 } };
      t4.file = e5[r2];
    } else if (n3.startsWith("--file=")) t4.file = n3.substring(7);
    else if (n3 === "-C" || n3 === "--directory") {
      if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'C'
`, exitCode: 2 } };
      t4.directory = e5[r2];
    } else if (n3.startsWith("--directory=")) t4.directory = n3.substring(12);
    else if (n3.startsWith("--strip-components=") || n3.startsWith("--strip=")) {
      let s3 = n3.includes("--strip-components=") ? n3.substring(19) : n3.substring(8), o2 = parseInt(s3, 10);
      if (Number.isNaN(o2) || o2 < 0) return { ok: false, error: { stdout: "", stderr: `tar: invalid number for --strip: '${s3}'
`, exitCode: 2 } };
      t4.strip = o2;
    } else if (n3.startsWith("--exclude=")) t4.exclude.push(n3.substring(10));
    else if (n3 === "--exclude") {
      if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option '--exclude' requires an argument
`, exitCode: 2 } };
      t4.exclude.push(e5[r2]);
    } else if (n3 === "-T" || n3 === "--files-from") {
      if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'T'
`, exitCode: 2 } };
      t4.filesFrom = e5[r2];
    } else if (n3.startsWith("--files-from=")) t4.filesFrom = n3.substring(13);
    else if (n3 === "-X" || n3 === "--exclude-from") {
      if (r2++, r2 >= e5.length) return { ok: false, error: { stdout: "", stderr: `tar: option requires an argument -- 'X'
`, exitCode: 2 } };
      t4.excludeFrom = e5[r2];
    } else if (n3.startsWith("--exclude-from=")) t4.excludeFrom = n3.substring(15);
    else if (n3 === "--") {
      i4.push(...e5.slice(r2 + 1));
      break;
    } else {
      if (n3.startsWith("-")) return { ok: false, error: r$3("tar", n3) };
      i4.push(n3);
    }
    r2++;
  }
  return { ok: true, options: t4, files: i4 };
}
var Fe$2 = 100, et$2 = { name: "tar", summary: "manipulate tape archives", usage: "tar [options] [file...]", description: ["Create, extract, or list contents of tar archives.", "", "One of -c, -r, -u, -x, or -t is required to specify the operation."], options: ["-c, --create           create a new archive", "-r, --append           append files to the end of an archive", "-u, --update           only append files newer than copy in archive", "-x, --extract          extract files from an archive", "-t, --list             list contents of an archive", "-f, --file=ARCHIVE     use archive file ARCHIVE", "-a, --auto-compress    use archive suffix to determine compression", "-z, --gzip             filter archive through gzip", "-j, --bzip2            filter archive through bzip2", "-J, --xz               filter archive through xz", "--zstd                 filter archive through zstd", "-v, --verbose          verbosely list files processed", "-O, --to-stdout        extract files to standard output", "-k, --keep-old-files   don't replace existing files when extracting", "-m, --touch            don't extract file modified time", "-C, --directory=DIR    change to directory DIR before performing operations", "-p, --preserve         preserve permissions", "-T, --files-from=FILE  read files to extract/create from FILE", "-X, --exclude-from=FILE read exclude patterns from FILE", "--strip=N              strip N leading path components on extraction", "--exclude=PATTERN      exclude files matching PATTERN", "--wildcards            use wildcards for pattern matching", "    --help             display this help and exit"], examples: ["tar -cvf archive.tar file1 file2     Create archive from files", "tar -czvf archive.tar.gz dir/        Create gzip-compressed archive", "tar -cjvf archive.tar.bz2 dir/       Create bzip2-compressed archive", "tar -rf archive.tar newfile.txt      Append file to archive", "tar -uf archive.tar dir/             Update archive with newer files", "tar -xvf archive.tar                 Extract archive", "tar -xvf archive.tar -C /tmp         Extract to /tmp", "tar -tvf archive.tar                 List archive contents", "tar -xzf archive.tar.gz              Extract gzip archive", "tar -xf archive.tar file1.txt        Extract specific file", "tar -xOf archive.tar file.txt        Extract file to stdout", "tar -xf archive.tar --wildcards '*.txt'  Extract matching files"] };
function Q$2(e5, t4) {
  let i4 = e5.includes("/") ? e5.substring(e5.lastIndexOf("/") + 1) : e5;
  for (let r2 of t4) {
    let n3 = r2.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*\*/g, "<<<GLOBSTAR>>>").replace(/\*/g, "[^/]*").replace(/<<<GLOBSTAR>>>/g, ".*").replace(/\?/g, ".");
    if (new RegExp(`^${n3}$`).test(e5) || new RegExp(`^${n3}/`).test(e5) || !r2.includes("/") && new RegExp(`^${n3}$`).test(i4)) return true;
  }
  return false;
}
function B$4(e5, t4) {
  let i4 = t4.replace(/[.+^${}()|[\]\\]/g, "\\$&").replace(/\*\*/g, "<<<GLOBSTAR>>>").replace(/\*/g, "[^/]*").replace(/<<<GLOBSTAR>>>/g, ".*").replace(/\?/g, "."), r2 = e5.includes("/") ? e5.substring(e5.lastIndexOf("/") + 1) : e5;
  return new RegExp(`^${i4}$`).test(e5) || new RegExp(`^${i4}$`).test(r2);
}
function ke$1(e5, t4) {
  if (t4 <= 0) return e5;
  let i4 = e5.split("/").filter((r2) => r2 !== "");
  return i4.length <= t4 ? "" : i4.slice(t4).join("/");
}
function tt$1(e5, t4) {
  let i4 = t4 ? "d" : "-", r2 = [e5 & 256 ? "r" : "-", e5 & 128 ? "w" : "-", e5 & 64 ? "x" : "-", e5 & 32 ? "r" : "-", e5 & 16 ? "w" : "-", e5 & 8 ? "x" : "-", e5 & 4 ? "r" : "-", e5 & 2 ? "w" : "-", e5 & 1 ? "x" : "-"].join("");
  return i4 + r2;
}
function rt(e5) {
  let i4 = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"][e5.getMonth()], r2 = e5.getDate().toString().padStart(2, " "), n3 = e5.getHours().toString().padStart(2, "0"), s3 = e5.getMinutes().toString().padStart(2, "0");
  return `${i4} ${r2} ${n3}:${s3}`;
}
async function D$2(e5, t4, i4, r2) {
  let n3 = [], s3 = [], o2 = e5.fs.resolvePath(t4, i4);
  try {
    let a3 = await e5.fs.stat(o2);
    if (Q$2(i4, r2)) return { entries: n3, errors: s3 };
    if (a3.isDirectory) {
      n3.push({ name: i4, isDirectory: true, mode: a3.mode, mtime: a3.mtime });
      let c3 = await e5.fs.readdir(o2);
      for (let l3 = 0; l3 < c3.length; l3 += Fe$2) {
        let d3 = c3.slice(l3, l3 + Fe$2), u3 = await Promise.all(d3.map((g2) => D$2(e5, t4, i4 ? `${i4}/${g2}` : g2, r2)));
        for (let g2 of u3) n3.push(...g2.entries), s3.push(...g2.errors);
      }
    } else if (a3.isFile) {
      let c3 = await e5.fs.readFileBuffer(o2);
      n3.push({ name: i4, content: c3, mode: a3.mode, mtime: a3.mtime });
    } else if (a3.isSymbolicLink) {
      let c3 = await e5.fs.readlink(o2);
      n3.push({ name: i4, isSymlink: true, linkTarget: c3, mode: a3.mode, mtime: a3.mtime });
    }
  } catch (a3) {
    let c3 = a3 instanceof Error ? a3.message : "unknown error";
    s3.push(`tar: ${i4}: ${c3}`);
  }
  return { entries: n3, errors: s3 };
}
async function nt$1(e5, t4, i4) {
  if (i4.length === 0) return { stdout: "", stderr: `tar: Cowardly refusing to create an empty archive
`, exitCode: 2 };
  let r2 = t4.directory ? e5.fs.resolvePath(e5.cwd, t4.directory) : e5.cwd, n3 = [], s3 = [], o2 = "";
  for (let d3 of i4) {
    let { entries: u3, errors: g2 } = await D$2(e5, r2, d3, t4.exclude);
    if (n3.push(...u3), s3.push(...g2), t4.verbose) for (let p3 of u3) o2 += `${p3.name}${p3.isDirectory ? "/" : ""}
`;
  }
  if (n3.length === 0 && s3.length > 0) return { stdout: "", stderr: `${s3.join(`
`)}
`, exitCode: 2 };
  let a3;
  try {
    t4.gzip ? a3 = await Te$1(n3) : t4.bzip2 ? a3 = await Ce$1(n3) : t4.xz ? a3 = await xe$3(n3) : t4.zstd ? a3 = await Ue$2(n3) : a3 = await C$3(n3);
  } catch (d3) {
    return { stdout: "", stderr: `tar: error creating archive: ${d3 instanceof Error ? d3.message : "unknown error"}
`, exitCode: 2 };
  }
  let c3 = "";
  if (t4.file && t4.file !== "-") {
    let d3 = e5.fs.resolvePath(e5.cwd, t4.file);
    try {
      await e5.fs.writeFile(d3, a3);
    } catch (u3) {
      let g2 = u3 instanceof Error ? u3.message : "unknown error";
      return { stdout: "", stderr: `tar: ${t4.file}: ${g2}
`, exitCode: 2 };
    }
  } else c3 = String.fromCharCode(...a3);
  let l3 = o2;
  return s3.length > 0 && (l3 += `${s3.join(`
`)}
`), { stdout: c3, stderr: l3, exitCode: s3.length > 0 ? 2 : 0 };
}
async function it(e5, t4, i4) {
  if (!t4.file || t4.file === "-") return { stdout: "", stderr: `tar: Cannot append to stdin/stdout
`, exitCode: 2 };
  if (i4.length === 0) return { stdout: "", stderr: `tar: Cowardly refusing to append nothing to archive
`, exitCode: 2 };
  let r2 = e5.fs.resolvePath(e5.cwd, t4.file), n3;
  try {
    n3 = await e5.fs.readFileBuffer(r2);
  } catch {
    return { stdout: "", stderr: `tar: ${t4.file}: Cannot open: No such file or directory
`, exitCode: 2 };
  }
  let s3 = await _$2(n3);
  if (s3.error) return { stdout: "", stderr: `tar: ${s3.error}
`, exitCode: 2 };
  let o2 = s3.entries.map((f3) => ({ name: f3.name, content: f3.content, mode: f3.mode, mtime: f3.mtime, isDirectory: f3.type === "directory", isSymlink: f3.type === "symlink", linkTarget: f3.linkTarget, uid: f3.uid, gid: f3.gid })), a3 = t4.directory ? e5.fs.resolvePath(e5.cwd, t4.directory) : e5.cwd, c3 = [], l3 = [], d3 = "";
  for (let f3 of i4) {
    let { entries: h3, errors: m3 } = await D$2(e5, a3, f3, t4.exclude);
    if (c3.push(...h3), l3.push(...m3), t4.verbose) for (let S3 of h3) d3 += `${S3.name}${S3.isDirectory ? "/" : ""}
`;
  }
  let u3 = [...o2, ...c3], g2;
  try {
    g2 = await C$3(u3);
  } catch (f3) {
    return { stdout: "", stderr: `tar: error creating archive: ${f3 instanceof Error ? f3.message : "unknown error"}
`, exitCode: 2 };
  }
  try {
    await e5.fs.writeFile(r2, g2);
  } catch (f3) {
    let h3 = f3 instanceof Error ? f3.message : "unknown error";
    return { stdout: "", stderr: `tar: ${t4.file}: ${h3}
`, exitCode: 2 };
  }
  let p3 = d3;
  return l3.length > 0 && (p3 += `${l3.join(`
`)}
`), { stdout: "", stderr: p3, exitCode: l3.length > 0 ? 2 : 0 };
}
async function st$1(e5, t4, i4) {
  if (!t4.file || t4.file === "-") return { stdout: "", stderr: `tar: Cannot update stdin/stdout
`, exitCode: 2 };
  if (i4.length === 0) return { stdout: "", stderr: `tar: Cowardly refusing to update with nothing
`, exitCode: 2 };
  let r2 = e5.fs.resolvePath(e5.cwd, t4.file), n3;
  try {
    n3 = await e5.fs.readFileBuffer(r2);
  } catch {
    return { stdout: "", stderr: `tar: ${t4.file}: Cannot open: No such file or directory
`, exitCode: 2 };
  }
  let s3 = await _$2(n3);
  if (s3.error) return { stdout: "", stderr: `tar: ${s3.error}
`, exitCode: 2 };
  let o2 = /* @__PURE__ */ new Map();
  for (let m3 of s3.entries) o2.set(m3.name, m3.mtime);
  let a3 = t4.directory ? e5.fs.resolvePath(e5.cwd, t4.directory) : e5.cwd, c3 = [], l3 = [], d3 = "";
  for (let m3 of i4) {
    let { entries: S3, errors: E2 } = await D$2(e5, a3, m3, t4.exclude);
    l3.push(...E2);
    for (let w4 of S3) {
      let U2 = o2.get(w4.name);
      (!U2 || w4.mtime && w4.mtime.getTime() > U2.getTime()) && (c3.push(w4), t4.verbose && (d3 += `${w4.name}${w4.isDirectory ? "/" : ""}
`));
    }
  }
  if (c3.length === 0) {
    let m3 = "";
    return l3.length > 0 && (m3 = `${l3.join(`
`)}
`), { stdout: "", stderr: m3, exitCode: l3.length > 0 ? 2 : 0 };
  }
  let u3 = new Set(c3.map((m3) => m3.name)), p3 = [...s3.entries.filter((m3) => !u3.has(m3.name)).map((m3) => ({ name: m3.name, content: m3.content, mode: m3.mode, mtime: m3.mtime, isDirectory: m3.type === "directory", isSymlink: m3.type === "symlink", linkTarget: m3.linkTarget, uid: m3.uid, gid: m3.gid })), ...c3], f3;
  try {
    f3 = await C$3(p3);
  } catch (m3) {
    return { stdout: "", stderr: `tar: error creating archive: ${m3 instanceof Error ? m3.message : "unknown error"}
`, exitCode: 2 };
  }
  try {
    await e5.fs.writeFile(r2, f3);
  } catch (m3) {
    let S3 = m3 instanceof Error ? m3.message : "unknown error";
    return { stdout: "", stderr: `tar: ${t4.file}: ${S3}
`, exitCode: 2 };
  }
  let h3 = d3;
  return l3.length > 0 && (h3 += `${l3.join(`
`)}
`), { stdout: "", stderr: h3, exitCode: l3.length > 0 ? 2 : 0 };
}
async function at$1(e5, t4, i4) {
  let r2;
  if (t4.file && t4.file !== "-") {
    let f3 = e5.fs.resolvePath(e5.cwd, t4.file);
    try {
      r2 = await e5.fs.readFileBuffer(f3);
    } catch {
      return { stdout: "", stderr: `tar: ${t4.file}: Cannot open: No such file or directory
`, exitCode: 2 };
    }
  } else r2 = Uint8Array.from(e5.stdin, (f3) => f3.charCodeAt(0));
  let n3, s3 = t4.gzip || W$3(r2), o2 = t4.bzip2 || X$2(r2), a3 = t4.xz || j$3(r2), c3 = t4.zstd || V$4(r2);
  if (s3 ? n3 = await H$2(r2) : o2 ? n3 = await q$3(r2) : a3 ? n3 = await Y$2(r2) : c3 ? n3 = await J$2(r2) : n3 = await _$2(r2), n3.error) return { stdout: "", stderr: `tar: ${n3.error}
`, exitCode: 2 };
  let l3 = t4.directory ? e5.fs.resolvePath(e5.cwd, t4.directory) : e5.cwd, d3 = "", u3 = "", g2 = [];
  if (t4.directory && !t4.toStdout) try {
    await e5.fs.mkdir(l3, { recursive: true });
  } catch {
  }
  for (let f3 of n3.entries) {
    let h3 = ke$1(f3.name, t4.strip);
    if (!h3) continue;
    let m3 = h3.endsWith("/") ? h3.slice(0, -1) : h3;
    if (i4.length > 0) {
      let E2;
      if (t4.wildcards ? E2 = i4.some((w4) => B$4(h3, w4) || B$4(m3, w4) || h3.startsWith(`${w4}/`)) : E2 = i4.some((w4) => h3 === w4 || h3.startsWith(`${w4}/`) || m3 === w4), !E2) continue;
    }
    if (Q$2(h3, t4.exclude)) continue;
    let S3 = e5.fs.resolvePath(l3, h3);
    try {
      if (f3.type === "directory") {
        if (t4.toStdout) continue;
        await e5.fs.mkdir(S3, { recursive: true }), t4.verbose && (d3 += `${h3}
`);
      } else if (f3.type === "file") {
        if (t4.toStdout) {
          u3 += new TextDecoder().decode(f3.content), t4.verbose && (d3 += `${h3}
`);
          continue;
        }
        if (t4.keepOldFiles) try {
          await e5.fs.stat(S3), t4.verbose && (d3 += `${h3}: not overwritten, file exists
`);
          continue;
        } catch {
        }
        let E2 = S3.substring(0, S3.lastIndexOf("/"));
        if (E2) try {
          await e5.fs.mkdir(E2, { recursive: true });
        } catch {
        }
        if (await e5.fs.writeFile(S3, f3.content), t4.preserve && f3.mode) try {
          await e5.fs.chmod(S3, f3.mode);
        } catch {
        }
        t4.verbose && (d3 += `${h3}
`);
      } else if (f3.type === "symlink" && f3.linkTarget) {
        if (t4.toStdout) continue;
        if (t4.keepOldFiles) try {
          await e5.fs.stat(S3), t4.verbose && (d3 += `${h3}: not overwritten, file exists
`);
          continue;
        } catch {
        }
        let E2 = S3.substring(0, S3.lastIndexOf("/"));
        if (E2) try {
          await e5.fs.mkdir(E2, { recursive: true });
        } catch {
        }
        try {
          await e5.fs.symlink(f3.linkTarget, S3);
        } catch {
        }
        t4.verbose && (d3 += `${h3}
`);
      }
    } catch (E2) {
      let w4 = E2 instanceof Error ? E2.message : "unknown error";
      g2.push(`tar: ${h3}: ${w4}`);
    }
  }
  let p3 = d3;
  return g2.length > 0 && (p3 += `${g2.join(`
`)}
`), { stdout: u3, stderr: p3, exitCode: g2.length > 0 ? 2 : 0 };
}
async function ot(e5, t4, i4) {
  let r2;
  if (t4.file && t4.file !== "-") {
    let d3 = e5.fs.resolvePath(e5.cwd, t4.file);
    try {
      r2 = await e5.fs.readFileBuffer(d3);
    } catch {
      return { stdout: "", stderr: `tar: ${t4.file}: Cannot open: No such file or directory
`, exitCode: 2 };
    }
  } else r2 = Uint8Array.from(e5.stdin, (d3) => d3.charCodeAt(0));
  let n3, s3 = t4.gzip || W$3(r2), o2 = t4.bzip2 || X$2(r2), a3 = t4.xz || j$3(r2), c3 = t4.zstd || V$4(r2);
  if (s3 ? n3 = await H$2(r2) : o2 ? n3 = await q$3(r2) : a3 ? n3 = await Y$2(r2) : c3 ? n3 = await J$2(r2) : n3 = await _$2(r2), n3.error) return { stdout: "", stderr: `tar: ${n3.error}
`, exitCode: 2 };
  let l3 = "";
  for (let d3 of n3.entries) {
    let u3 = ke$1(d3.name, t4.strip);
    if (!u3) continue;
    let g2 = u3.endsWith("/") ? u3.slice(0, -1) : u3;
    if (i4.length > 0) {
      let p3;
      if (t4.wildcards ? p3 = i4.some((f3) => B$4(u3, f3) || B$4(g2, f3) || u3.startsWith(`${f3}/`)) : p3 = i4.some((f3) => u3 === f3 || u3.startsWith(`${f3}/`) || g2 === f3), !p3) continue;
    }
    if (!Q$2(u3, t4.exclude)) if (t4.verbose) {
      let p3 = d3.type === "directory", f3 = tt$1(d3.mode, p3), h3 = `${d3.uid}/${d3.gid}`, m3 = d3.size.toString().padStart(8, " "), S3 = rt(d3.mtime), E2 = `${f3} ${h3.padEnd(10)} ${m3} ${S3} ${u3}`;
      d3.type === "symlink" && d3.linkTarget && (E2 += ` -> ${d3.linkTarget}`), l3 += `${E2}
`;
    } else l3 += `${u3}
`;
  }
  return { stdout: l3, stderr: "", exitCode: 0 };
}
var wt$1 = { name: "tar", async execute(e5, t4) {
  if (o$3(e5)) return s$1(et$2);
  let i4 = Ie$1(e5);
  if (!i4.ok) return i4.error;
  let { options: r2, files: n3 } = i4, s3 = [r2.create, r2.append, r2.update, r2.extract, r2.list].filter(Boolean).length;
  if (s3 === 0) return { stdout: "", stderr: `tar: You must specify one of -c, -r, -u, -x, or -t
`, exitCode: 2 };
  if (s3 > 1) return { stdout: "", stderr: `tar: You may not specify more than one of -c, -r, -u, -x, or -t
`, exitCode: 2 };
  if (r2.autoCompress && r2.file && r2.create) {
    let c3 = r2.file.toLowerCase();
    c3.endsWith(".tar.gz") || c3.endsWith(".tgz") ? r2.gzip = true : c3.endsWith(".tar.bz2") || c3.endsWith(".tbz2") ? r2.bzip2 = true : c3.endsWith(".tar.xz") || c3.endsWith(".txz") ? r2.xz = true : (c3.endsWith(".tar.zst") || c3.endsWith(".tzst")) && (r2.zstd = true);
  }
  let o2 = [r2.gzip, r2.bzip2, r2.xz, r2.zstd].filter(Boolean).length;
  if (o2 > 1) return { stdout: "", stderr: `tar: You may not specify more than one compression option
`, exitCode: 2 };
  if ((r2.append || r2.update) && o2 > 0) return { stdout: "", stderr: `tar: Cannot append/update compressed archives - decompress first
`, exitCode: 2 };
  let a3 = n3;
  if (r2.filesFrom) {
    let c3 = t4.fs.resolvePath(t4.cwd, r2.filesFrom);
    try {
      let d3 = (await t4.fs.readFile(c3)).split(`
`).map((u3) => u3.trim()).filter((u3) => u3.length > 0 && !u3.startsWith("#"));
      a3 = [...n3, ...d3];
    } catch {
      return { stdout: "", stderr: `tar: ${r2.filesFrom}: Cannot open: No such file or directory
`, exitCode: 2 };
    }
  }
  if (r2.excludeFrom) {
    let c3 = t4.fs.resolvePath(t4.cwd, r2.excludeFrom);
    try {
      let d3 = (await t4.fs.readFile(c3)).split(`
`).map((u3) => u3.trim()).filter((u3) => u3.length > 0 && !u3.startsWith("#"));
      r2.exclude.push(...d3);
    } catch {
      return { stdout: "", stderr: `tar: ${r2.excludeFrom}: Cannot open: No such file or directory
`, exitCode: 2 };
    }
  }
  return r2.create ? nt$1(t4, r2, a3) : r2.append ? it(t4, r2, a3) : r2.update ? st$1(t4, r2, a3) : r2.extract ? at$1(t4, r2, a3) : ot(t4, r2, a3);
} };
const tarLWIHPMT6 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  tarCommand: wt$1
});
var xe$2 = o$4((de2, pe2) => {
  (function(oe2, R2) {
    typeof define == "function" && define.amd ? define([], R2) : typeof pe2 == "object" && typeof de2 < "u" ? pe2.exports = R2() : oe2.Papa = R2();
  })(de2, function oe2() {
    var R2 = /* @__PURE__ */ (function() {
      return typeof self < "u" ? self : typeof window < "u" ? window : typeof R2 < "u" ? R2 : {};
    })();
    function _e2() {
      var e5 = R2.URL || R2.webkitURL || null, t4 = oe2.toString();
      return l3.BLOB_URL || (l3.BLOB_URL = e5.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", t4, ")();"], { type: "text/javascript" })));
    }
    var Y2 = !R2.document && !!R2.postMessage, ue2 = R2.IS_PAPA_WORKER || false, ae2 = {}, ge2 = 0, l3 = {};
    if (l3.parse = Ce2, l3.unparse = Re3, l3.RECORD_SEP = "", l3.UNIT_SEP = "", l3.BYTE_ORDER_MARK = "\uFEFF", l3.BAD_DELIMITERS = ["\r", `
`, '"', l3.BYTE_ORDER_MARK], l3.WORKERS_SUPPORTED = !Y2 && !!R2.Worker, l3.NODE_STREAM_INPUT = 1, l3.LocalChunkSize = 1024 * 1024 * 10, l3.RemoteChunkSize = 1024 * 1024 * 5, l3.DefaultDelimiter = ",", l3.Parser = fe2, l3.ParserHandle = ce2, l3.NetworkStreamer = G2, l3.FileStreamer = ee2, l3.StringStreamer = Z3, l3.ReadableStreamStreamer = te2, typeof PAPA_BROWSER_CONTEXT > "u" && (l3.DuplexStreamStreamer = re2), R2.jQuery) {
      var V4 = R2.jQuery;
      V4.fn.parse = function(e5) {
        var t4 = e5.config || {}, r2 = [];
        return this.each(function(h3) {
          var i4 = V4(this).prop("tagName").toUpperCase() === "INPUT" && V4(this).attr("type").toLowerCase() === "file" && R2.FileReader;
          if (!i4 || !this.files || this.files.length === 0) return true;
          for (var y2 = 0; y2 < this.files.length; y2++) r2.push({ file: this.files[y2], inputElem: this, instanceConfig: V4.extend({}, t4) });
        }), s3(), this;
        function s3() {
          if (r2.length === 0) {
            g2(e5.complete) && e5.complete();
            return;
          }
          var h3 = r2[0];
          if (g2(e5.before)) {
            var i4 = e5.before(h3.file, h3.inputElem);
            if (typeof i4 == "object") if (i4.action === "abort") {
              n3("AbortError", h3.file, h3.inputElem, i4.reason);
              return;
            } else if (i4.action === "skip") {
              p3();
              return;
            } else typeof i4.config == "object" && (h3.instanceConfig = V4.extend(h3.instanceConfig, i4.config));
            else if (i4 === "skip") {
              p3();
              return;
            }
          }
          var y2 = h3.instanceConfig.complete;
          h3.instanceConfig.complete = function(E2) {
            g2(y2) && y2(E2, h3.file, h3.inputElem), p3();
          }, l3.parse(h3.file, h3.instanceConfig);
        }
        function n3(h3, i4, y2, E2) {
          g2(e5.error) && e5.error({ name: h3 }, i4, y2, E2);
        }
        function p3() {
          r2.splice(0, 1), s3();
        }
      };
    }
    ue2 && (R2.onmessage = Se2);
    function Ce2(e5, t4) {
      t4 = t4 || {};
      var r2 = t4.dynamicTyping || false;
      if (g2(r2) && (t4.dynamicTypingFunction = r2, r2 = {}), t4.dynamicTyping = r2, t4.transform = g2(t4.transform) ? t4.transform : false, t4.worker && l3.WORKERS_SUPPORTED) {
        var s3 = Ee2();
        s3.userStep = t4.step, s3.userChunk = t4.chunk, s3.userComplete = t4.complete, s3.userError = t4.error, t4.step = g2(t4.step), t4.chunk = g2(t4.chunk), t4.complete = g2(t4.complete), t4.error = g2(t4.error), delete t4.worker, s3.postMessage({ input: e5, config: t4, workerId: s3.id });
        return;
      }
      var n3 = null;
      if (e5 === l3.NODE_STREAM_INPUT && typeof PAPA_BROWSER_CONTEXT > "u") return n3 = new re2(t4), n3.getStream();
      return typeof e5 == "string" ? (e5 = p3(e5), t4.download ? n3 = new G2(t4) : n3 = new Z3(t4)) : e5.readable === true && g2(e5.read) && g2(e5.on) ? n3 = new te2(t4) : (R2.File && e5 instanceof File || e5 instanceof Object) && (n3 = new ee2(t4)), n3.stream(e5);
      function p3(h3) {
        return h3.charCodeAt(0) === 65279 ? h3.slice(1) : h3;
      }
    }
    function Re3(e5, t4) {
      var r2 = false, s3 = true, n3 = ",", p3 = `\r
`, h3 = '"', i4 = h3 + h3, y2 = false, E2 = null, O2 = false;
      L4();
      var d3 = new RegExp(se3(h3), "g");
      if (typeof e5 == "string" && (e5 = JSON.parse(e5)), Array.isArray(e5)) {
        if (!e5.length || Array.isArray(e5[0])) return u3(null, e5, y2);
        if (typeof e5[0] == "object") return u3(E2 || Object.keys(e5[0]), e5, y2);
      } else if (typeof e5 == "object") return typeof e5.data == "string" && (e5.data = JSON.parse(e5.data)), Array.isArray(e5.data) && (e5.fields || (e5.fields = e5.meta && e5.meta.fields || E2), e5.fields || (e5.fields = Array.isArray(e5.data[0]) ? e5.fields : typeof e5.data[0] == "object" ? Object.keys(e5.data[0]) : []), !Array.isArray(e5.data[0]) && typeof e5.data[0] != "object" && (e5.data = [e5.data])), u3(e5.fields || [], e5.data || [], y2);
      throw new Error("Unable to serialize unrecognized input");
      function L4() {
        if (typeof t4 == "object") {
          if (typeof t4.delimiter == "string" && !l3.BAD_DELIMITERS.filter(function(v2) {
            return t4.delimiter.indexOf(v2) !== -1;
          }).length && (n3 = t4.delimiter), (typeof t4.quotes == "boolean" || typeof t4.quotes == "function" || Array.isArray(t4.quotes)) && (r2 = t4.quotes), (typeof t4.skipEmptyLines == "boolean" || typeof t4.skipEmptyLines == "string") && (y2 = t4.skipEmptyLines), typeof t4.newline == "string" && (p3 = t4.newline), typeof t4.quoteChar == "string" && (h3 = t4.quoteChar), typeof t4.header == "boolean" && (s3 = t4.header), Array.isArray(t4.columns)) {
            if (t4.columns.length === 0) throw new Error("Option columns is empty");
            E2 = t4.columns;
          }
          t4.escapeChar !== void 0 && (i4 = t4.escapeChar + h3), t4.escapeFormulae instanceof RegExp ? O2 = t4.escapeFormulae : typeof t4.escapeFormulae == "boolean" && t4.escapeFormulae && (O2 = /^[=+\-@\t\r].*$/);
        }
      }
      function u3(v2, k3, S3) {
        var w4 = "";
        typeof v2 == "string" && (v2 = JSON.parse(v2)), typeof k3 == "string" && (k3 = JSON.parse(k3));
        var M4 = Array.isArray(v2) && v2.length > 0, T3 = !Array.isArray(k3[0]);
        if (M4 && s3) {
          for (var q2 = 0; q2 < v2.length; q2++) q2 > 0 && (w4 += n3), w4 += c3(v2[q2], q2);
          k3.length > 0 && (w4 += p3);
        }
        for (var _4 = 0; _4 < k3.length; _4++) {
          var j2 = M4 ? v2.length : k3[_4].length, W4 = false, o2 = M4 ? Object.keys(k3[_4]).length === 0 : k3[_4].length === 0;
          if (S3 && !M4 && (W4 = S3 === "greedy" ? k3[_4].join("").trim() === "" : k3[_4].length === 1 && k3[_4][0].length === 0), S3 === "greedy" && M4) {
            for (var f3 = [], m3 = 0; m3 < j2; m3++) {
              var b4 = T3 ? v2[m3] : m3;
              f3.push(k3[_4][b4]);
            }
            W4 = f3.join("").trim() === "";
          }
          if (!W4) {
            for (var a3 = 0; a3 < j2; a3++) {
              a3 > 0 && !o2 && (w4 += n3);
              var C2 = M4 && T3 ? v2[a3] : a3;
              w4 += c3(k3[_4][C2], a3);
            }
            _4 < k3.length - 1 && (!S3 || j2 > 0 && !o2) && (w4 += p3);
          }
        }
        return w4;
      }
      function c3(v2, k3) {
        if (typeof v2 > "u" || v2 === null) return "";
        if (v2.constructor === Date) return JSON.stringify(v2).slice(1, 25);
        var S3 = false;
        O2 && typeof v2 == "string" && O2.test(v2) && (v2 = "'" + v2, S3 = true);
        var w4 = v2.toString().replace(d3, i4);
        return S3 = S3 || r2 === true || typeof r2 == "function" && r2(v2, k3) || Array.isArray(r2) && r2[k3] || Q4(w4, l3.BAD_DELIMITERS) || w4.indexOf(n3) > -1 || w4.charAt(0) === " " || w4.charAt(w4.length - 1) === " ", S3 ? h3 + w4 + h3 : w4;
      }
      function Q4(v2, k3) {
        for (var S3 = 0; S3 < k3.length; S3++) if (v2.indexOf(k3[S3]) > -1) return true;
        return false;
      }
    }
    function z2(e5) {
      this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, t4.call(this, e5), this.parseChunk = function(r2, s3) {
        let n3 = parseInt(this._config.skipFirstNLines) || 0;
        if (this.isFirstChunk && n3 > 0) {
          let O2 = this._config.newline;
          if (!O2) {
            let L4 = this._config.quoteChar || '"';
            O2 = this._handle.guessLineEndings(r2, L4);
          }
          r2 = [...r2.split(O2).slice(n3)].join(O2);
        }
        if (this.isFirstChunk && g2(this._config.beforeFirstChunk)) {
          var p3 = this._config.beforeFirstChunk(r2);
          p3 !== void 0 && (r2 = p3);
        }
        this.isFirstChunk = false, this._halted = false;
        var h3 = this._partialLine + r2;
        this._partialLine = "";
        var i4 = this._handle.parse(h3, this._baseIndex, !this._finished);
        if (this._handle.paused() || this._handle.aborted()) {
          this._halted = true;
          return;
        }
        var y2 = i4.meta.cursor;
        this._finished || (this._partialLine = h3.substring(y2 - this._baseIndex), this._baseIndex = y2), i4 && i4.data && (this._rowCount += i4.data.length);
        var E2 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
        if (ue2) R2.postMessage({ results: i4, workerId: l3.WORKER_ID, finished: E2 });
        else if (g2(this._config.chunk) && !s3) {
          if (this._config.chunk(i4, this._handle), this._handle.paused() || this._handle.aborted()) {
            this._halted = true;
            return;
          }
          i4 = void 0, this._completeResults = void 0;
        }
        return !this._config.step && !this._config.chunk && (this._completeResults.data = this._completeResults.data.concat(i4.data), this._completeResults.errors = this._completeResults.errors.concat(i4.errors), this._completeResults.meta = i4.meta), !this._completed && E2 && g2(this._config.complete) && (!i4 || !i4.meta.aborted) && (this._config.complete(this._completeResults, this._input), this._completed = true), !E2 && (!i4 || !i4.meta.paused) && this._nextChunk(), i4;
      }, this._sendError = function(r2) {
        g2(this._config.error) ? this._config.error(r2) : ue2 && this._config.error && R2.postMessage({ workerId: l3.WORKER_ID, error: r2, finished: false });
      };
      function t4(r2) {
        var s3 = he3(r2);
        s3.chunkSize = parseInt(s3.chunkSize), !r2.step && !r2.chunk && (s3.chunkSize = null), this._handle = new ce2(s3), this._handle.streamer = this, this._config = s3;
      }
    }
    function G2(e5) {
      e5 = e5 || {}, e5.chunkSize || (e5.chunkSize = l3.RemoteChunkSize), z2.call(this, e5);
      var t4;
      Y2 ? this._nextChunk = function() {
        this._readChunk(), this._chunkLoaded();
      } : this._nextChunk = function() {
        this._readChunk();
      }, this.stream = function(s3) {
        this._input = s3, this._nextChunk();
      }, this._readChunk = function() {
        if (this._finished) {
          this._chunkLoaded();
          return;
        }
        if (t4 = new XMLHttpRequest(), this._config.withCredentials && (t4.withCredentials = this._config.withCredentials), Y2 || (t4.onload = F2(this._chunkLoaded, this), t4.onerror = F2(this._chunkError, this)), t4.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !Y2), this._config.downloadRequestHeaders) {
          var s3 = this._config.downloadRequestHeaders;
          for (var n3 in s3) t4.setRequestHeader(n3, s3[n3]);
        }
        if (this._config.chunkSize) {
          var p3 = this._start + this._config.chunkSize - 1;
          t4.setRequestHeader("Range", "bytes=" + this._start + "-" + p3);
        }
        try {
          t4.send(this._config.downloadRequestBody);
        } catch (h3) {
          this._chunkError(h3.message);
        }
        Y2 && t4.status === 0 && this._chunkError();
      }, this._chunkLoaded = function() {
        if (t4.readyState === 4) {
          if (t4.status < 200 || t4.status >= 400) {
            this._chunkError();
            return;
          }
          this._start += this._config.chunkSize ? this._config.chunkSize : t4.responseText.length, this._finished = !this._config.chunkSize || this._start >= r2(t4), this.parseChunk(t4.responseText);
        }
      }, this._chunkError = function(s3) {
        var n3 = t4.statusText || s3;
        this._sendError(new Error(n3));
      };
      function r2(s3) {
        var n3 = s3.getResponseHeader("Content-Range");
        return n3 === null ? -1 : parseInt(n3.substring(n3.lastIndexOf("/") + 1));
      }
    }
    G2.prototype = Object.create(z2.prototype), G2.prototype.constructor = G2;
    function ee2(e5) {
      e5 = e5 || {}, e5.chunkSize || (e5.chunkSize = l3.LocalChunkSize), z2.call(this, e5);
      var t4, r2, s3 = typeof FileReader < "u";
      this.stream = function(n3) {
        this._input = n3, r2 = n3.slice || n3.webkitSlice || n3.mozSlice, s3 ? (t4 = new FileReader(), t4.onload = F2(this._chunkLoaded, this), t4.onerror = F2(this._chunkError, this)) : t4 = new FileReaderSync(), this._nextChunk();
      }, this._nextChunk = function() {
        !this._finished && (!this._config.preview || this._rowCount < this._config.preview) && this._readChunk();
      }, this._readChunk = function() {
        var n3 = this._input;
        if (this._config.chunkSize) {
          var p3 = Math.min(this._start + this._config.chunkSize, this._input.size);
          n3 = r2.call(n3, this._start, p3);
        }
        var h3 = t4.readAsText(n3, this._config.encoding);
        s3 || this._chunkLoaded({ target: { result: h3 } });
      }, this._chunkLoaded = function(n3) {
        this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(n3.target.result);
      }, this._chunkError = function() {
        this._sendError(t4.error);
      };
    }
    ee2.prototype = Object.create(z2.prototype), ee2.prototype.constructor = ee2;
    function Z3(e5) {
      e5 = e5 || {}, z2.call(this, e5);
      var t4;
      this.stream = function(r2) {
        return t4 = r2, this._nextChunk();
      }, this._nextChunk = function() {
        if (!this._finished) {
          var r2 = this._config.chunkSize, s3;
          return r2 ? (s3 = t4.substring(0, r2), t4 = t4.substring(r2)) : (s3 = t4, t4 = ""), this._finished = !t4, this.parseChunk(s3);
        }
      };
    }
    Z3.prototype = Object.create(Z3.prototype), Z3.prototype.constructor = Z3;
    function te2(e5) {
      e5 = e5 || {}, z2.call(this, e5);
      var t4 = [], r2 = true, s3 = false;
      this.pause = function() {
        z2.prototype.pause.apply(this, arguments), this._input.pause();
      }, this.resume = function() {
        z2.prototype.resume.apply(this, arguments), this._input.resume();
      }, this.stream = function(n3) {
        this._input = n3, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
      }, this._checkIsFinished = function() {
        s3 && t4.length === 1 && (this._finished = true);
      }, this._nextChunk = function() {
        this._checkIsFinished(), t4.length ? this.parseChunk(t4.shift()) : r2 = true;
      }, this._streamData = F2(function(n3) {
        try {
          t4.push(typeof n3 == "string" ? n3 : n3.toString(this._config.encoding)), r2 && (r2 = false, this._checkIsFinished(), this.parseChunk(t4.shift()));
        } catch (p3) {
          this._streamError(p3);
        }
      }, this), this._streamError = F2(function(n3) {
        this._streamCleanUp(), this._sendError(n3);
      }, this), this._streamEnd = F2(function() {
        this._streamCleanUp(), s3 = true, this._streamData("");
      }, this), this._streamCleanUp = F2(function() {
        this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
      }, this);
    }
    te2.prototype = Object.create(z2.prototype), te2.prototype.constructor = te2;
    function re2(e5) {
      var t4 = m$d("stream").Duplex, r2 = he3(e5), s3 = true, n3 = false, p3 = [], h3 = null;
      this._onCsvData = function(i4) {
        var y2 = i4.data;
        !h3.push(y2) && !this._handle.paused() && this._handle.pause();
      }, this._onCsvComplete = function() {
        h3.push(null);
      }, r2.step = F2(this._onCsvData, this), r2.complete = F2(this._onCsvComplete, this), z2.call(this, r2), this._nextChunk = function() {
        n3 && p3.length === 1 && (this._finished = true), p3.length ? p3.shift()() : s3 = true;
      }, this._addToParseQueue = function(i4, y2) {
        p3.push(F2(function() {
          if (this.parseChunk(typeof i4 == "string" ? i4 : i4.toString(r2.encoding)), g2(y2)) return y2();
        }, this)), s3 && (s3 = false, this._nextChunk());
      }, this._onRead = function() {
        this._handle.paused() && this._handle.resume();
      }, this._onWrite = function(i4, y2, E2) {
        this._addToParseQueue(i4, E2);
      }, this._onWriteComplete = function() {
        n3 = true, this._addToParseQueue("");
      }, this.getStream = function() {
        return h3;
      }, h3 = new t4({ readableObjectMode: true, decodeStrings: false, read: F2(this._onRead, this), write: F2(this._onWrite, this) }), h3.once("finish", F2(this._onWriteComplete, this));
    }
    typeof PAPA_BROWSER_CONTEXT > "u" && (re2.prototype = Object.create(z2.prototype), re2.prototype.constructor = re2);
    function ce2(e5) {
      var t4 = Math.pow(2, 53), r2 = -t4, s3 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, n3 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, p3 = this, h3 = 0, i4 = 0, y2, E2, O2 = false, d3 = false, L4, u3 = [], c3 = { data: [], errors: [], meta: {} };
      if (g2(e5.step)) {
        var Q4 = e5.step;
        e5.step = function(o2) {
          if (c3 = o2, w4()) S3();
          else {
            if (S3(), c3.data.length === 0) return;
            h3 += o2.data.length, e5.preview && h3 > e5.preview ? E2.abort() : (c3.data = c3.data[0], Q4(c3, p3));
          }
        };
      }
      this.parse = function(o2, f3, m3) {
        var b4 = e5.quoteChar || '"';
        if (e5.newline || (e5.newline = this.guessLineEndings(o2, b4)), L4 = false, e5.delimiter) g2(e5.delimiter) && (e5.delimiter = e5.delimiter(o2), c3.meta.delimiter = e5.delimiter);
        else {
          var a3 = j2(o2, e5.newline, e5.skipEmptyLines, e5.comments, e5.delimitersToGuess);
          a3.successful ? e5.delimiter = a3.bestDelimiter : (L4 = true, e5.delimiter = l3.DefaultDelimiter), c3.meta.delimiter = e5.delimiter;
        }
        var C2 = he3(e5);
        return e5.preview && e5.header && C2.preview++, y2 = o2, E2 = new fe2(C2), c3 = E2.parse(y2, f3, m3), S3(), O2 ? { meta: { paused: true } } : c3 || { meta: { paused: false } };
      }, this.paused = function() {
        return O2;
      }, this.pause = function() {
        O2 = true, E2.abort(), y2 = g2(e5.chunk) ? "" : y2.substring(E2.getCharIndex());
      }, this.resume = function() {
        p3.streamer._halted ? (O2 = false, p3.streamer.parseChunk(y2, true)) : setTimeout(p3.resume, 3);
      }, this.aborted = function() {
        return d3;
      }, this.abort = function() {
        d3 = true, E2.abort(), c3.meta.aborted = true, g2(e5.complete) && e5.complete(c3), y2 = "";
      }, this.guessLineEndings = function(o2, f3) {
        o2 = o2.substring(0, 1024 * 1024);
        var m3 = new RegExp(se3(f3) + "([^]*?)" + se3(f3), "gm");
        o2 = o2.replace(m3, "");
        var b4 = o2.split("\r"), a3 = o2.split(`
`), C2 = a3.length > 1 && a3[0].length < b4[0].length;
        if (b4.length === 1 || C2) return `
`;
        for (var A2 = 0, x4 = 0; x4 < b4.length; x4++) b4[x4][0] === `
` && A2++;
        return A2 >= b4.length / 2 ? `\r
` : "\r";
      };
      function v2(o2) {
        return e5.skipEmptyLines === "greedy" ? o2.join("").trim() === "" : o2.length === 1 && o2[0].length === 0;
      }
      function k3(o2) {
        if (s3.test(o2)) {
          var f3 = parseFloat(o2);
          if (f3 > r2 && f3 < t4) return true;
        }
        return false;
      }
      function S3() {
        return c3 && L4 && (W4("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + l3.DefaultDelimiter + "'"), L4 = false), e5.skipEmptyLines && (c3.data = c3.data.filter(function(o2) {
          return !v2(o2);
        })), w4() && M4(), _4();
      }
      function w4() {
        return e5.header && u3.length === 0;
      }
      function M4() {
        if (!c3) return;
        function o2(m3, b4) {
          g2(e5.transformHeader) && (m3 = e5.transformHeader(m3, b4)), u3.push(m3);
        }
        if (Array.isArray(c3.data[0])) {
          for (var f3 = 0; w4() && f3 < c3.data.length; f3++) c3.data[f3].forEach(o2);
          c3.data.splice(0, 1);
        } else c3.data.forEach(o2);
      }
      function T3(o2) {
        return e5.dynamicTypingFunction && e5.dynamicTyping[o2] === void 0 && (e5.dynamicTyping[o2] = e5.dynamicTypingFunction(o2)), (e5.dynamicTyping[o2] || e5.dynamicTyping) === true;
      }
      function q2(o2, f3) {
        return T3(o2) ? f3 === "true" || f3 === "TRUE" ? true : f3 === "false" || f3 === "FALSE" ? false : k3(f3) ? parseFloat(f3) : n3.test(f3) ? new Date(f3) : f3 === "" ? null : f3 : f3;
      }
      function _4() {
        if (!c3 || !e5.header && !e5.dynamicTyping && !e5.transform) return c3;
        function o2(m3, b4) {
          var a3 = e5.header ? {} : [], C2;
          for (C2 = 0; C2 < m3.length; C2++) {
            var A2 = C2, x4 = m3[C2];
            e5.header && (A2 = C2 >= u3.length ? "__parsed_extra" : u3[C2]), e5.transform && (x4 = e5.transform(x4, A2)), x4 = q2(A2, x4), A2 === "__parsed_extra" ? (a3[A2] = a3[A2] || [], a3[A2].push(x4)) : a3[A2] = x4;
          }
          return e5.header && (C2 > u3.length ? W4("FieldMismatch", "TooManyFields", "Too many fields: expected " + u3.length + " fields but parsed " + C2, i4 + b4) : C2 < u3.length && W4("FieldMismatch", "TooFewFields", "Too few fields: expected " + u3.length + " fields but parsed " + C2, i4 + b4)), a3;
        }
        var f3 = 1;
        return !c3.data.length || Array.isArray(c3.data[0]) ? (c3.data = c3.data.map(o2), f3 = c3.data.length) : c3.data = o2(c3.data, 0), e5.header && c3.meta && (c3.meta.fields = u3), i4 += f3, c3;
      }
      function j2(o2, f3, m3, b4, a3) {
        var C2, A2, x4, J3;
        a3 = a3 || [",", "	", "|", ";", l3.RECORD_SEP, l3.UNIT_SEP];
        for (var N2 = 0; N2 < a3.length; N2++) {
          var ie2 = a3[N2], X3 = 0, K2 = 0, I2 = 0;
          x4 = void 0;
          for (var H2 = new fe2({ comments: b4, delimiter: ie2, newline: f3, preview: 10 }).parse(o2), D3 = 0; D3 < H2.data.length; D3++) {
            if (m3 && v2(H2.data[D3])) {
              I2++;
              continue;
            }
            var P2 = H2.data[D3].length;
            if (K2 += P2, typeof x4 > "u") {
              x4 = P2;
              continue;
            } else P2 > 0 && (X3 += Math.abs(P2 - x4), x4 = P2);
          }
          H2.data.length > 0 && (K2 /= H2.data.length - I2), (typeof A2 > "u" || X3 <= A2) && (typeof J3 > "u" || K2 > J3) && K2 > 1.99 && (A2 = X3, C2 = ie2, J3 = K2);
        }
        return e5.delimiter = C2, { successful: !!C2, bestDelimiter: C2 };
      }
      function W4(o2, f3, m3, b4) {
        var a3 = { type: o2, code: f3, message: m3 };
        b4 !== void 0 && (a3.row = b4), c3.errors.push(a3);
      }
    }
    function se3(e5) {
      return e5.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function fe2(e5) {
      e5 = e5 || {};
      var t4 = e5.delimiter, r2 = e5.newline, s3 = e5.comments, n3 = e5.step, p3 = e5.preview, h3 = e5.fastMode, i4, y2 = null, E2 = false;
      e5.quoteChar === void 0 || e5.quoteChar === null ? i4 = '"' : i4 = e5.quoteChar;
      var O2 = i4;
      if (e5.escapeChar !== void 0 && (O2 = e5.escapeChar), (typeof t4 != "string" || l3.BAD_DELIMITERS.indexOf(t4) > -1) && (t4 = ","), s3 === t4) throw new Error("Comment character same as delimiter");
      s3 === true ? s3 = "#" : (typeof s3 != "string" || l3.BAD_DELIMITERS.indexOf(s3) > -1) && (s3 = false), r2 !== `
` && r2 !== "\r" && r2 !== `\r
` && (r2 = `
`);
      var d3 = 0, L4 = false;
      this.parse = function(u3, c3, Q4) {
        if (typeof u3 != "string") throw new Error("Input must be a string");
        var v2 = u3.length, k3 = t4.length, S3 = r2.length, w4 = s3.length, M4 = g2(n3);
        d3 = 0;
        var T3 = [], q2 = [], _4 = [], j2 = 0;
        if (!u3) return I2();
        if (h3 || h3 !== false && u3.indexOf(i4) === -1) {
          for (var W4 = u3.split(r2), o2 = 0; o2 < W4.length; o2++) {
            if (_4 = W4[o2], d3 += _4.length, o2 !== W4.length - 1) d3 += r2.length;
            else if (Q4) return I2();
            if (!(s3 && _4.substring(0, w4) === s3)) {
              if (M4) {
                if (T3 = [], N2(_4.split(t4)), H2(), L4) return I2();
              } else N2(_4.split(t4));
              if (p3 && o2 >= p3) return T3 = T3.slice(0, p3), I2(true);
            }
          }
          return I2();
        }
        for (var f3 = u3.indexOf(t4, d3), m3 = u3.indexOf(r2, d3), b4 = new RegExp(se3(O2) + se3(i4), "g"), a3 = u3.indexOf(i4, d3); ; ) {
          if (u3[d3] === i4) {
            for (a3 = d3, d3++; ; ) {
              if (a3 = u3.indexOf(i4, a3 + 1), a3 === -1) return Q4 || q2.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: T3.length, index: d3 }), X3();
              if (a3 === v2 - 1) {
                var C2 = u3.substring(d3, a3).replace(b4, i4);
                return X3(C2);
              }
              if (i4 === O2 && u3[a3 + 1] === O2) {
                a3++;
                continue;
              }
              if (!(i4 !== O2 && a3 !== 0 && u3[a3 - 1] === O2)) {
                f3 !== -1 && f3 < a3 + 1 && (f3 = u3.indexOf(t4, a3 + 1)), m3 !== -1 && m3 < a3 + 1 && (m3 = u3.indexOf(r2, a3 + 1));
                var A2 = m3 === -1 ? f3 : Math.min(f3, m3), x4 = ie2(A2);
                if (u3.substr(a3 + 1 + x4, k3) === t4) {
                  _4.push(u3.substring(d3, a3).replace(b4, i4)), d3 = a3 + 1 + x4 + k3, u3[a3 + 1 + x4 + k3] !== i4 && (a3 = u3.indexOf(i4, d3)), f3 = u3.indexOf(t4, d3), m3 = u3.indexOf(r2, d3);
                  break;
                }
                var J3 = ie2(m3);
                if (u3.substring(a3 + 1 + J3, a3 + 1 + J3 + S3) === r2) {
                  if (_4.push(u3.substring(d3, a3).replace(b4, i4)), K2(a3 + 1 + J3 + S3), f3 = u3.indexOf(t4, d3), a3 = u3.indexOf(i4, d3), M4 && (H2(), L4)) return I2();
                  if (p3 && T3.length >= p3) return I2(true);
                  break;
                }
                q2.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: T3.length, index: d3 }), a3++;
              }
            }
            continue;
          }
          if (s3 && _4.length === 0 && u3.substring(d3, d3 + w4) === s3) {
            if (m3 === -1) return I2();
            d3 = m3 + S3, m3 = u3.indexOf(r2, d3), f3 = u3.indexOf(t4, d3);
            continue;
          }
          if (f3 !== -1 && (f3 < m3 || m3 === -1)) {
            _4.push(u3.substring(d3, f3)), d3 = f3 + k3, f3 = u3.indexOf(t4, d3);
            continue;
          }
          if (m3 !== -1) {
            if (_4.push(u3.substring(d3, m3)), K2(m3 + S3), M4 && (H2(), L4)) return I2();
            if (p3 && T3.length >= p3) return I2(true);
            continue;
          }
          break;
        }
        return X3();
        function N2(D3) {
          T3.push(D3), j2 = d3;
        }
        function ie2(D3) {
          var P2 = 0;
          if (D3 !== -1) {
            var B2 = u3.substring(a3 + 1, D3);
            B2 && B2.trim() === "" && (P2 = B2.length);
          }
          return P2;
        }
        function X3(D3) {
          return Q4 || (typeof D3 > "u" && (D3 = u3.substring(d3)), _4.push(D3), d3 = v2, N2(_4), M4 && H2()), I2();
        }
        function K2(D3) {
          d3 = D3, N2(_4), _4 = [], m3 = u3.indexOf(r2, d3);
        }
        function I2(D3) {
          if (e5.header && !c3 && T3.length && !E2) {
            let P2 = T3[0], B2 = /* @__PURE__ */ Object.create(null), le2 = new Set(P2), ve2 = false;
            for (let $5 = 0; $5 < P2.length; $5++) {
              let U2 = P2[$5];
              if (g2(e5.transformHeader) && (U2 = e5.transformHeader(U2, $5)), !B2[U2]) B2[U2] = 1, P2[$5] = U2;
              else {
                let ne2, ke2 = B2[U2];
                do
                  ne2 = `${U2}_${ke2}`, ke2++;
                while (le2.has(ne2));
                le2.add(ne2), P2[$5] = ne2, B2[U2]++, ve2 = true, y2 === null && (y2 = {}), y2[ne2] = U2;
              }
              le2.add(U2);
            }
            ve2 && console.warn("Duplicate headers found and renamed."), E2 = true;
          }
          return { data: T3, errors: q2, meta: { delimiter: t4, linebreak: r2, aborted: L4, truncated: !!D3, cursor: j2 + (c3 || 0), renamedHeaders: y2 } };
        }
        function H2() {
          n3(I2()), T3 = [], q2 = [];
        }
      }, this.abort = function() {
        L4 = true;
      }, this.getCharIndex = function() {
        return d3;
      };
    }
    function Ee2() {
      if (!l3.WORKERS_SUPPORTED) return false;
      var e5 = _e2(), t4 = new R2.Worker(e5);
      return t4.onmessage = be3, t4.id = ge2++, ae2[t4.id] = t4, t4;
    }
    function be3(e5) {
      var t4 = e5.data, r2 = ae2[t4.workerId], s3 = false;
      if (t4.error) r2.userError(t4.error, t4.file);
      else if (t4.results && t4.results.data) {
        var n3 = function() {
          s3 = true, me2(t4.workerId, { data: [], errors: [], meta: { aborted: true } });
        }, p3 = { abort: n3, pause: ye2, resume: ye2 };
        if (g2(r2.userStep)) {
          for (var h3 = 0; h3 < t4.results.data.length && (r2.userStep({ data: t4.results.data[h3], errors: t4.results.errors, meta: t4.results.meta }, p3), !s3); h3++) ;
          delete t4.results;
        } else g2(r2.userChunk) && (r2.userChunk(t4.results, p3, t4.file), delete t4.results);
      }
      t4.finished && !s3 && me2(t4.workerId, t4.results);
    }
    function me2(e5, t4) {
      var r2 = ae2[e5];
      g2(r2.userComplete) && r2.userComplete(t4), r2.terminate(), delete ae2[e5];
    }
    function ye2() {
      throw new Error("Not implemented.");
    }
    function Se2(e5) {
      var t4 = e5.data;
      if (typeof l3.WORKER_ID > "u" && t4 && (l3.WORKER_ID = t4.workerId), typeof t4.input == "string") R2.postMessage({ workerId: l3.WORKER_ID, results: l3.parse(t4.input, t4.config), finished: true });
      else if (R2.File && t4.input instanceof File || t4.input instanceof Object) {
        var r2 = l3.parse(t4.input, t4.config);
        r2 && R2.postMessage({ workerId: l3.WORKER_ID, results: r2, finished: true });
      }
    }
    function he3(e5) {
      if (typeof e5 != "object" || e5 === null) return e5;
      var t4 = Array.isArray(e5) ? [] : {};
      for (var r2 in e5) t4[r2] = he3(e5[r2]);
      return t4;
    }
    function F2(e5, t4) {
      return function() {
        e5.apply(t4, arguments);
      };
    }
    function g2(e5) {
      return typeof e5 == "function";
    }
    return l3;
  });
});
var Yi = o$4((rp, Ri2) => {
  var { hasOwnProperty: Ps2 } = Object.prototype, Ms2 = (s3, e5 = {}) => {
    typeof e5 == "string" && (e5 = { section: e5 }), e5.align = e5.align === true, e5.newline = e5.newline === true, e5.sort = e5.sort === true, e5.whitespace = e5.whitespace === true || e5.align === true, e5.platform = e5.platform || typeof process < "u" && process.platform, e5.bracketedArray = e5.bracketedArray !== false;
    let t4 = e5.platform === "win32" ? `\r
` : `
`, n3 = e5.whitespace ? " = " : "=", i4 = [], r2 = e5.sort ? Object.keys(s3).sort() : Object.keys(s3), o2 = 0;
    e5.align && (o2 = G2(r2.filter((c3) => s3[c3] === null || Array.isArray(s3[c3]) || typeof s3[c3] != "object").map((c3) => Array.isArray(s3[c3]) ? `${c3}[]` : c3).concat([""]).reduce((c3, u3) => G2(c3).length >= G2(u3).length ? c3 : u3)).length);
    let a3 = "", l3 = e5.bracketedArray ? "[]" : "";
    for (let c3 of r2) {
      let u3 = s3[c3];
      if (u3 && Array.isArray(u3)) for (let f3 of u3) a3 += G2(`${c3}${l3}`).padEnd(o2, " ") + n3 + G2(f3) + t4;
      else u3 && typeof u3 == "object" ? i4.push(c3) : a3 += G2(c3).padEnd(o2, " ") + n3 + G2(u3) + t4;
    }
    e5.section && a3.length && (a3 = "[" + G2(e5.section) + "]" + (e5.newline ? t4 + t4 : t4) + a3);
    for (let c3 of i4) {
      let u3 = Vi2(c3, ".").join("\\."), f3 = (e5.section ? e5.section + "." : "") + u3, d3 = Ms2(s3[c3], { ...e5, section: f3 });
      a3.length && d3.length && (a3 += t4), a3 += d3;
    }
    return a3;
  };
  function Vi2(s3, e5) {
    var t4 = 0, n3 = 0, i4 = 0, r2 = [];
    do
      if (i4 = s3.indexOf(e5, t4), i4 !== -1) {
        if (t4 = i4 + e5.length, i4 > 0 && s3[i4 - 1] === "\\") continue;
        r2.push(s3.slice(n3, i4)), n3 = i4 + e5.length;
      }
    while (i4 !== -1);
    return r2.push(s3.slice(n3)), r2;
  }
  var ji2 = (s3, e5 = {}) => {
    e5.bracketedArray = e5.bracketedArray !== false;
    let t4 = /* @__PURE__ */ Object.create(null), n3 = t4, i4 = null, r2 = /^\[([^\]]*)\]\s*$|^([^=]+)(=(.*))?$/i, o2 = s3.split(/[\r\n]+/g), a3 = {};
    for (let c3 of o2) {
      if (!c3 || c3.match(/^\s*[;#]/) || c3.match(/^\s*$/)) continue;
      let u3 = c3.match(r2);
      if (!u3) continue;
      if (u3[1] !== void 0) {
        if (i4 = Nt2(u3[1]), i4 === "__proto__") {
          n3 = /* @__PURE__ */ Object.create(null);
          continue;
        }
        n3 = t4[i4] = t4[i4] || /* @__PURE__ */ Object.create(null);
        continue;
      }
      let f3 = Nt2(u3[2]), d3;
      e5.bracketedArray ? d3 = f3.length > 2 && f3.slice(-2) === "[]" : (a3[f3] = (a3?.[f3] || 0) + 1, d3 = a3[f3] > 1);
      let p3 = d3 && f3.endsWith("[]") ? f3.slice(0, -2) : f3;
      if (p3 === "__proto__") continue;
      let g2 = u3[3] ? Nt2(u3[4]) : true, h3 = g2 === "true" || g2 === "false" || g2 === "null" ? JSON.parse(g2) : g2;
      d3 && (Ps2.call(n3, p3) ? Array.isArray(n3[p3]) || (n3[p3] = [n3[p3]]) : n3[p3] = []), Array.isArray(n3[p3]) ? n3[p3].push(h3) : n3[p3] = h3;
    }
    let l3 = [];
    for (let c3 of Object.keys(t4)) {
      if (!Ps2.call(t4, c3) || typeof t4[c3] != "object" || Array.isArray(t4[c3])) continue;
      let u3 = Vi2(c3, ".");
      n3 = t4;
      let f3 = u3.pop(), d3 = f3.replace(/\\\./g, ".");
      for (let p3 of u3) p3 !== "__proto__" && ((!Ps2.call(n3, p3) || typeof n3[p3] != "object") && (n3[p3] = /* @__PURE__ */ Object.create(null)), n3 = n3[p3]);
      n3 === t4 && d3 === f3 || (n3[d3] = t4[c3], l3.push(c3));
    }
    for (let c3 of l3) delete t4[c3];
    return t4;
  }, Ki2 = (s3) => s3.startsWith('"') && s3.endsWith('"') || s3.startsWith("'") && s3.endsWith("'"), G2 = (s3) => typeof s3 != "string" || s3.match(/[=\r\n]/) || s3.match(/^\[/) || s3.length > 1 && Ki2(s3) || s3 !== s3.trim() ? JSON.stringify(s3) : s3.split(";").join("\\;").split("#").join("\\#"), Nt2 = (s3) => {
    if (s3 = (s3 || "").trim(), Ki2(s3)) {
      s3.charAt(0) === "'" && (s3 = s3.slice(1, -1));
      try {
        s3 = JSON.parse(s3);
      } catch {
      }
    } else {
      let e5 = false, t4 = "";
      for (let n3 = 0, i4 = s3.length; n3 < i4; n3++) {
        let r2 = s3.charAt(n3);
        if (e5) "\\;#".indexOf(r2) !== -1 ? t4 += r2 : t4 += "\\" + r2, e5 = false;
        else {
          if (";#".indexOf(r2) !== -1) break;
          r2 === "\\" ? e5 = true : t4 += r2;
        }
      }
      return e5 && (t4 += "\\"), t4.trim();
    }
    return s3;
  };
  Ri2.exports = { parse: ji2, decode: ji2, stringify: Ms2, encode: Ms2, safe: G2, unsafe: Nt2 };
});
var O$4 = o$4(($5) => {
  var Fs2 = /* @__PURE__ */ Symbol.for("yaml.alias"), Di2 = /* @__PURE__ */ Symbol.for("yaml.document"), kt2 = /* @__PURE__ */ Symbol.for("yaml.map"), Zi2 = /* @__PURE__ */ Symbol.for("yaml.pair"), js = /* @__PURE__ */ Symbol.for("yaml.scalar"), It2 = /* @__PURE__ */ Symbol.for("yaml.seq"), X3 = /* @__PURE__ */ Symbol.for("yaml.node.type"), Xl = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === Fs2, Ql = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === Di2, Hl = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === kt2, Dl = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === Zi2, zi2 = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === js, Zl = (s3) => !!s3 && typeof s3 == "object" && s3[X3] === It2;
  function er2(s3) {
    if (s3 && typeof s3 == "object") switch (s3[X3]) {
      case kt2:
      case It2:
        return true;
    }
    return false;
  }
  function zl(s3) {
    if (s3 && typeof s3 == "object") switch (s3[X3]) {
      case Fs2:
      case kt2:
      case js:
      case It2:
        return true;
    }
    return false;
  }
  var ec = (s3) => (zi2(s3) || er2(s3)) && !!s3.anchor;
  $5.ALIAS = Fs2;
  $5.DOC = Di2;
  $5.MAP = kt2;
  $5.NODE_TYPE = X3;
  $5.PAIR = Zi2;
  $5.SCALAR = js;
  $5.SEQ = It2;
  $5.hasAnchor = ec;
  $5.isAlias = Xl;
  $5.isCollection = er2;
  $5.isDocument = Ql;
  $5.isMap = Hl;
  $5.isNode = zl;
  $5.isPair = Dl;
  $5.isScalar = zi2;
  $5.isSeq = Zl;
});
var Ve$1 = o$4((Vs2) => {
  var M4 = O$4(), F2 = /* @__PURE__ */ Symbol("break visit"), tr2 = /* @__PURE__ */ Symbol("skip children"), J3 = /* @__PURE__ */ Symbol("remove node");
  function qt2(s3, e5) {
    let t4 = sr2(e5);
    M4.isDocument(s3) ? Se2(null, s3.contents, t4, Object.freeze([s3])) === J3 && (s3.contents = null) : Se2(null, s3, t4, Object.freeze([]));
  }
  qt2.BREAK = F2;
  qt2.SKIP = tr2;
  qt2.REMOVE = J3;
  function Se2(s3, e5, t4, n3) {
    let i4 = nr2(s3, e5, t4, n3);
    if (M4.isNode(i4) || M4.isPair(i4)) return ir2(s3, n3, i4), Se2(s3, i4, t4, n3);
    if (typeof i4 != "symbol") {
      if (M4.isCollection(e5)) {
        n3 = Object.freeze(n3.concat(e5));
        for (let r2 = 0; r2 < e5.items.length; ++r2) {
          let o2 = Se2(r2, e5.items[r2], t4, n3);
          if (typeof o2 == "number") r2 = o2 - 1;
          else {
            if (o2 === F2) return F2;
            o2 === J3 && (e5.items.splice(r2, 1), r2 -= 1);
          }
        }
      } else if (M4.isPair(e5)) {
        n3 = Object.freeze(n3.concat(e5));
        let r2 = Se2("key", e5.key, t4, n3);
        if (r2 === F2) return F2;
        r2 === J3 && (e5.key = null);
        let o2 = Se2("value", e5.value, t4, n3);
        if (o2 === F2) return F2;
        o2 === J3 && (e5.value = null);
      }
    }
    return i4;
  }
  async function Ct2(s3, e5) {
    let t4 = sr2(e5);
    M4.isDocument(s3) ? await Ne2(null, s3.contents, t4, Object.freeze([s3])) === J3 && (s3.contents = null) : await Ne2(null, s3, t4, Object.freeze([]));
  }
  Ct2.BREAK = F2;
  Ct2.SKIP = tr2;
  Ct2.REMOVE = J3;
  async function Ne2(s3, e5, t4, n3) {
    let i4 = await nr2(s3, e5, t4, n3);
    if (M4.isNode(i4) || M4.isPair(i4)) return ir2(s3, n3, i4), Ne2(s3, i4, t4, n3);
    if (typeof i4 != "symbol") {
      if (M4.isCollection(e5)) {
        n3 = Object.freeze(n3.concat(e5));
        for (let r2 = 0; r2 < e5.items.length; ++r2) {
          let o2 = await Ne2(r2, e5.items[r2], t4, n3);
          if (typeof o2 == "number") r2 = o2 - 1;
          else {
            if (o2 === F2) return F2;
            o2 === J3 && (e5.items.splice(r2, 1), r2 -= 1);
          }
        }
      } else if (M4.isPair(e5)) {
        n3 = Object.freeze(n3.concat(e5));
        let r2 = await Ne2("key", e5.key, t4, n3);
        if (r2 === F2) return F2;
        r2 === J3 && (e5.key = null);
        let o2 = await Ne2("value", e5.value, t4, n3);
        if (o2 === F2) return F2;
        o2 === J3 && (e5.value = null);
      }
    }
    return i4;
  }
  function sr2(s3) {
    return typeof s3 == "object" && (s3.Collection || s3.Node || s3.Value) ? Object.assign({ Alias: s3.Node, Map: s3.Node, Scalar: s3.Node, Seq: s3.Node }, s3.Value && { Map: s3.Value, Scalar: s3.Value, Seq: s3.Value }, s3.Collection && { Map: s3.Collection, Seq: s3.Collection }, s3) : s3;
  }
  function nr2(s3, e5, t4, n3) {
    if (typeof t4 == "function") return t4(s3, e5, n3);
    if (M4.isMap(e5)) return t4.Map?.(s3, e5, n3);
    if (M4.isSeq(e5)) return t4.Seq?.(s3, e5, n3);
    if (M4.isPair(e5)) return t4.Pair?.(s3, e5, n3);
    if (M4.isScalar(e5)) return t4.Scalar?.(s3, e5, n3);
    if (M4.isAlias(e5)) return t4.Alias?.(s3, e5, n3);
  }
  function ir2(s3, e5, t4) {
    let n3 = e5[e5.length - 1];
    if (M4.isCollection(n3)) n3.items[s3] = t4;
    else if (M4.isPair(n3)) s3 === "key" ? n3.key = t4 : n3.value = t4;
    else if (M4.isDocument(n3)) n3.contents = t4;
    else {
      let i4 = M4.isAlias(n3) ? "alias" : "scalar";
      throw new Error(`Cannot replace node with ${i4} parent`);
    }
  }
  Vs2.visit = qt2;
  Vs2.visitAsync = Ct2;
});
var Ks = o$4((or2) => {
  var rr2 = O$4(), tc = Ve$1(), sc = { "!": "%21", ",": "%2C", "[": "%5B", "]": "%5D", "{": "%7B", "}": "%7D" }, nc = (s3) => s3.replace(/[!,[\]{}]/g, (e5) => sc[e5]), Ke2 = class s3 {
    constructor(e5, t4) {
      this.docStart = null, this.docEnd = false, this.yaml = Object.assign({}, s3.defaultYaml, e5), this.tags = Object.assign({}, s3.defaultTags, t4);
    }
    clone() {
      let e5 = new s3(this.yaml, this.tags);
      return e5.docStart = this.docStart, e5;
    }
    atDocument() {
      let e5 = new s3(this.yaml, this.tags);
      switch (this.yaml.version) {
        case "1.1":
          this.atNextDocument = true;
          break;
        case "1.2":
          this.atNextDocument = false, this.yaml = { explicit: s3.defaultYaml.explicit, version: "1.2" }, this.tags = Object.assign({}, s3.defaultTags);
          break;
      }
      return e5;
    }
    add(e5, t4) {
      this.atNextDocument && (this.yaml = { explicit: s3.defaultYaml.explicit, version: "1.1" }, this.tags = Object.assign({}, s3.defaultTags), this.atNextDocument = false);
      let n3 = e5.trim().split(/[ \t]+/), i4 = n3.shift();
      switch (i4) {
        case "%TAG": {
          if (n3.length !== 2 && (t4(0, "%TAG directive should contain exactly two parts"), n3.length < 2)) return false;
          let [r2, o2] = n3;
          return this.tags[r2] = o2, true;
        }
        case "%YAML": {
          if (this.yaml.explicit = true, n3.length !== 1) return t4(0, "%YAML directive should contain exactly one part"), false;
          let [r2] = n3;
          if (r2 === "1.1" || r2 === "1.2") return this.yaml.version = r2, true;
          {
            let o2 = /^\d+\.\d+$/.test(r2);
            return t4(6, `Unsupported YAML version ${r2}`, o2), false;
          }
        }
        default:
          return t4(0, `Unknown directive ${i4}`, true), false;
      }
    }
    tagName(e5, t4) {
      if (e5 === "!") return "!";
      if (e5[0] !== "!") return t4(`Not a valid tag: ${e5}`), null;
      if (e5[1] === "<") {
        let o2 = e5.slice(2, -1);
        return o2 === "!" || o2 === "!!" ? (t4(`Verbatim tags aren't resolved, so ${e5} is invalid.`), null) : (e5[e5.length - 1] !== ">" && t4("Verbatim tags must end with a >"), o2);
      }
      let [, n3, i4] = e5.match(/^(.*!)([^!]*)$/s);
      i4 || t4(`The ${e5} tag has no suffix`);
      let r2 = this.tags[n3];
      if (r2) try {
        return r2 + decodeURIComponent(i4);
      } catch (o2) {
        return t4(String(o2)), null;
      }
      return n3 === "!" ? e5 : (t4(`Could not resolve tag: ${e5}`), null);
    }
    tagString(e5) {
      for (let [t4, n3] of Object.entries(this.tags)) if (e5.startsWith(n3)) return t4 + nc(e5.substring(n3.length));
      return e5[0] === "!" ? e5 : `!<${e5}>`;
    }
    toString(e5) {
      let t4 = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [], n3 = Object.entries(this.tags), i4;
      if (e5 && n3.length > 0 && rr2.isNode(e5.contents)) {
        let r2 = {};
        tc.visit(e5.contents, (o2, a3) => {
          rr2.isNode(a3) && a3.tag && (r2[a3.tag] = true);
        }), i4 = Object.keys(r2);
      } else i4 = [];
      for (let [r2, o2] of n3) r2 === "!!" && o2 === "tag:yaml.org,2002:" || (!e5 || i4.some((a3) => a3.startsWith(o2))) && t4.push(`%TAG ${r2} ${o2}`);
      return t4.join(`
`);
    }
  };
  Ke2.defaultYaml = { explicit: false, version: "1.2" };
  Ke2.defaultTags = { "!!": "tag:yaml.org,2002:" };
  or2.Directives = Ke2;
});
var Lt = o$4((Re3) => {
  var ar2 = O$4(), ic = Ve$1();
  function rc(s3) {
    if (/[\x00-\x19\s,[\]{}]/.test(s3)) {
      let t4 = `Anchor must not contain whitespace or control characters: ${JSON.stringify(s3)}`;
      throw new Error(t4);
    }
    return true;
  }
  function lr2(s3) {
    let e5 = /* @__PURE__ */ new Set();
    return ic.visit(s3, { Value(t4, n3) {
      n3.anchor && e5.add(n3.anchor);
    } }), e5;
  }
  function cr2(s3, e5) {
    for (let t4 = 1; ; ++t4) {
      let n3 = `${s3}${t4}`;
      if (!e5.has(n3)) return n3;
    }
  }
  function oc(s3, e5) {
    let t4 = [], n3 = /* @__PURE__ */ new Map(), i4 = null;
    return { onAnchor: (r2) => {
      t4.push(r2), i4 ?? (i4 = lr2(s3));
      let o2 = cr2(e5, i4);
      return i4.add(o2), o2;
    }, setAnchors: () => {
      for (let r2 of t4) {
        let o2 = n3.get(r2);
        if (typeof o2 == "object" && o2.anchor && (ar2.isScalar(o2.node) || ar2.isCollection(o2.node))) o2.node.anchor = o2.anchor;
        else {
          let a3 = new Error("Failed to resolve repeated object (this should not happen)");
          throw a3.source = r2, a3;
        }
      }
    }, sourceObjects: n3 };
  }
  Re3.anchorIsValid = rc;
  Re3.anchorNames = lr2;
  Re3.createNodeAnchors = oc;
  Re3.findNewAnchor = cr2;
});
var Rs = o$4((fr2) => {
  function Ye2(s3, e5, t4, n3) {
    if (n3 && typeof n3 == "object") if (Array.isArray(n3)) for (let i4 = 0, r2 = n3.length; i4 < r2; ++i4) {
      let o2 = n3[i4], a3 = Ye2(s3, n3, String(i4), o2);
      a3 === void 0 ? delete n3[i4] : a3 !== o2 && (n3[i4] = a3);
    }
    else if (n3 instanceof Map) for (let i4 of Array.from(n3.keys())) {
      let r2 = n3.get(i4), o2 = Ye2(s3, n3, i4, r2);
      o2 === void 0 ? n3.delete(i4) : o2 !== r2 && n3.set(i4, o2);
    }
    else if (n3 instanceof Set) for (let i4 of Array.from(n3)) {
      let r2 = Ye2(s3, n3, i4, i4);
      r2 === void 0 ? n3.delete(i4) : r2 !== i4 && (n3.delete(i4), n3.add(r2));
    }
    else for (let [i4, r2] of Object.entries(n3)) {
      let o2 = Ye2(s3, n3, i4, r2);
      o2 === void 0 ? delete n3[i4] : o2 !== r2 && (n3[i4] = o2);
    }
    return s3.call(e5, t4, n3);
  }
  fr2.applyReviver = Ye2;
});
var D$1 = o$4((dr2) => {
  var ac = O$4();
  function ur2(s3, e5, t4) {
    if (Array.isArray(s3)) return s3.map((n3, i4) => ur2(n3, String(i4), t4));
    if (s3 && typeof s3.toJSON == "function") {
      if (!t4 || !ac.hasAnchor(s3)) return s3.toJSON(e5, t4);
      let n3 = { aliasCount: 0, count: 1, res: void 0 };
      t4.anchors.set(s3, n3), t4.onCreate = (r2) => {
        n3.res = r2, delete t4.onCreate;
      };
      let i4 = s3.toJSON(e5, t4);
      return t4.onCreate && t4.onCreate(i4), i4;
    }
    return typeof s3 == "bigint" && !t4?.keep ? Number(s3) : s3;
  }
  dr2.toJS = ur2;
});
var Pt = o$4((pr2) => {
  var lc = Rs(), hr2 = O$4(), cc = D$1(), Ys = class {
    constructor(e5) {
      Object.defineProperty(this, hr2.NODE_TYPE, { value: e5 });
    }
    clone() {
      let e5 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      return this.range && (e5.range = this.range.slice()), e5;
    }
    toJS(e5, { mapAsMap: t4, maxAliasCount: n3, onAnchor: i4, reviver: r2 } = {}) {
      if (!hr2.isDocument(e5)) throw new TypeError("A document argument is required");
      let o2 = { anchors: /* @__PURE__ */ new Map(), doc: e5, keep: true, mapAsMap: t4 === true, mapKeyWarned: false, maxAliasCount: typeof n3 == "number" ? n3 : 100 }, a3 = cc.toJS(this, "", o2);
      if (typeof i4 == "function") for (let { count: l3, res: c3 } of o2.anchors.values()) i4(c3, l3);
      return typeof r2 == "function" ? lc.applyReviver(r2, { "": a3 }, "", a3) : a3;
    }
  };
  pr2.NodeBase = Ys;
});
var Ue$1 = o$4((mr2) => {
  var fc = Lt(), uc = Ve$1(), Ee2 = O$4(), dc = Pt(), hc = D$1(), Us = class extends dc.NodeBase {
    constructor(e5) {
      super(Ee2.ALIAS), this.source = e5, Object.defineProperty(this, "tag", { set() {
        throw new Error("Alias nodes cannot have tags");
      } });
    }
    resolve(e5, t4) {
      let n3;
      t4?.aliasResolveCache ? n3 = t4.aliasResolveCache : (n3 = [], uc.visit(e5, { Node: (r2, o2) => {
        (Ee2.isAlias(o2) || Ee2.hasAnchor(o2)) && n3.push(o2);
      } }), t4 && (t4.aliasResolveCache = n3));
      let i4;
      for (let r2 of n3) {
        if (r2 === this) break;
        r2.anchor === this.source && (i4 = r2);
      }
      return i4;
    }
    toJSON(e5, t4) {
      if (!t4) return { source: this.source };
      let { anchors: n3, doc: i4, maxAliasCount: r2 } = t4, o2 = this.resolve(i4, t4);
      if (!o2) {
        let l3 = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new ReferenceError(l3);
      }
      let a3 = n3.get(o2);
      if (a3 || (hc.toJS(o2, null, t4), a3 = n3.get(o2)), a3?.res === void 0) {
        let l3 = "This should not happen: Alias anchor was not resolved?";
        throw new ReferenceError(l3);
      }
      if (r2 >= 0 && (a3.count += 1, a3.aliasCount === 0 && (a3.aliasCount = Mt2(i4, o2, n3)), a3.count * a3.aliasCount > r2)) {
        let l3 = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(l3);
      }
      return a3.res;
    }
    toString(e5, t4, n3) {
      let i4 = `*${this.source}`;
      if (e5) {
        if (fc.anchorIsValid(this.source), e5.options.verifyAliasOrder && !e5.anchors.has(this.source)) {
          let r2 = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new Error(r2);
        }
        if (e5.implicitKey) return `${i4} `;
      }
      return i4;
    }
  };
  function Mt2(s3, e5, t4) {
    if (Ee2.isAlias(e5)) {
      let n3 = e5.resolve(s3), i4 = t4 && n3 && t4.get(n3);
      return i4 ? i4.count * i4.aliasCount : 0;
    } else if (Ee2.isCollection(e5)) {
      let n3 = 0;
      for (let i4 of e5.items) {
        let r2 = Mt2(s3, i4, t4);
        r2 > n3 && (n3 = r2);
      }
      return n3;
    } else if (Ee2.isPair(e5)) {
      let n3 = Mt2(s3, e5.key, t4), i4 = Mt2(s3, e5.value, t4);
      return Math.max(n3, i4);
    }
    return 1;
  }
  mr2.Alias = Us;
});
var C$2 = o$4((Js) => {
  var pc = O$4(), mc = Pt(), gc = D$1(), yc = (s3) => !s3 || typeof s3 != "function" && typeof s3 != "object", Z3 = class extends mc.NodeBase {
    constructor(e5) {
      super(pc.SCALAR), this.value = e5;
    }
    toJSON(e5, t4) {
      return t4?.keep ? this.value : gc.toJS(this.value, e5, t4);
    }
    toString() {
      return String(this.value);
    }
  };
  Z3.BLOCK_FOLDED = "BLOCK_FOLDED";
  Z3.BLOCK_LITERAL = "BLOCK_LITERAL";
  Z3.PLAIN = "PLAIN";
  Z3.QUOTE_DOUBLE = "QUOTE_DOUBLE";
  Z3.QUOTE_SINGLE = "QUOTE_SINGLE";
  Js.Scalar = Z3;
  Js.isScalarValue = yc;
});
var Je$1 = o$4((yr2) => {
  var bc = Ue$1(), fe2 = O$4(), gr2 = C$2(), wc = "tag:yaml.org,2002:";
  function Sc(s3, e5, t4) {
    if (e5) {
      let n3 = t4.filter((r2) => r2.tag === e5), i4 = n3.find((r2) => !r2.format) ?? n3[0];
      if (!i4) throw new Error(`Tag ${e5} not found`);
      return i4;
    }
    return t4.find((n3) => n3.identify?.(s3) && !n3.format);
  }
  function Nc(s3, e5, t4) {
    if (fe2.isDocument(s3) && (s3 = s3.contents), fe2.isNode(s3)) return s3;
    if (fe2.isPair(s3)) {
      let f3 = t4.schema[fe2.MAP].createNode?.(t4.schema, null, t4);
      return f3.items.push(s3), f3;
    }
    (s3 instanceof String || s3 instanceof Number || s3 instanceof Boolean || typeof BigInt < "u" && s3 instanceof BigInt) && (s3 = s3.valueOf());
    let { aliasDuplicateObjects: n3, onAnchor: i4, onTagObj: r2, schema: o2, sourceObjects: a3 } = t4, l3;
    if (n3 && s3 && typeof s3 == "object") {
      if (l3 = a3.get(s3), l3) return l3.anchor ?? (l3.anchor = i4(s3)), new bc.Alias(l3.anchor);
      l3 = { anchor: null, node: null }, a3.set(s3, l3);
    }
    e5?.startsWith("!!") && (e5 = wc + e5.slice(2));
    let c3 = Sc(s3, e5, o2.tags);
    if (!c3) {
      if (s3 && typeof s3.toJSON == "function" && (s3 = s3.toJSON()), !s3 || typeof s3 != "object") {
        let f3 = new gr2.Scalar(s3);
        return l3 && (l3.node = f3), f3;
      }
      c3 = s3 instanceof Map ? o2[fe2.MAP] : Symbol.iterator in Object(s3) ? o2[fe2.SEQ] : o2[fe2.MAP];
    }
    r2 && (r2(c3), delete t4.onTagObj);
    let u3 = c3?.createNode ? c3.createNode(t4.schema, s3, t4) : typeof c3?.nodeClass?.from == "function" ? c3.nodeClass.from(t4.schema, s3, t4) : new gr2.Scalar(s3);
    return e5 ? u3.tag = e5 : c3.default || (u3.tag = c3.tag), l3 && (l3.node = u3), u3;
  }
  yr2.createNode = Nc;
});
var _t = o$4(($t2) => {
  var Ec = Je$1(), W4 = O$4(), vc = Pt();
  function Ws2(s3, e5, t4) {
    let n3 = t4;
    for (let i4 = e5.length - 1; i4 >= 0; --i4) {
      let r2 = e5[i4];
      if (typeof r2 == "number" && Number.isInteger(r2) && r2 >= 0) {
        let o2 = [];
        o2[r2] = n3, n3 = o2;
      } else n3 = /* @__PURE__ */ new Map([[r2, n3]]);
    }
    return Ec.createNode(n3, void 0, { aliasDuplicateObjects: false, keepUndefined: false, onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    }, schema: s3, sourceObjects: /* @__PURE__ */ new Map() });
  }
  var br2 = (s3) => s3 == null || typeof s3 == "object" && !!s3[Symbol.iterator]().next().done, Gs = class extends vc.NodeBase {
    constructor(e5, t4) {
      super(e5), Object.defineProperty(this, "schema", { value: t4, configurable: true, enumerable: false, writable: true });
    }
    clone(e5) {
      let t4 = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
      return e5 && (t4.schema = e5), t4.items = t4.items.map((n3) => W4.isNode(n3) || W4.isPair(n3) ? n3.clone(e5) : n3), this.range && (t4.range = this.range.slice()), t4;
    }
    addIn(e5, t4) {
      if (br2(e5)) this.add(t4);
      else {
        let [n3, ...i4] = e5, r2 = this.get(n3, true);
        if (W4.isCollection(r2)) r2.addIn(i4, t4);
        else if (r2 === void 0 && this.schema) this.set(n3, Ws2(this.schema, i4, t4));
        else throw new Error(`Expected YAML collection at ${n3}. Remaining path: ${i4}`);
      }
    }
    deleteIn(e5) {
      let [t4, ...n3] = e5;
      if (n3.length === 0) return this.delete(t4);
      let i4 = this.get(t4, true);
      if (W4.isCollection(i4)) return i4.deleteIn(n3);
      throw new Error(`Expected YAML collection at ${t4}. Remaining path: ${n3}`);
    }
    getIn(e5, t4) {
      let [n3, ...i4] = e5, r2 = this.get(n3, true);
      return i4.length === 0 ? !t4 && W4.isScalar(r2) ? r2.value : r2 : W4.isCollection(r2) ? r2.getIn(i4, t4) : void 0;
    }
    hasAllNullValues(e5) {
      return this.items.every((t4) => {
        if (!W4.isPair(t4)) return false;
        let n3 = t4.value;
        return n3 == null || e5 && W4.isScalar(n3) && n3.value == null && !n3.commentBefore && !n3.comment && !n3.tag;
      });
    }
    hasIn(e5) {
      let [t4, ...n3] = e5;
      if (n3.length === 0) return this.has(t4);
      let i4 = this.get(t4, true);
      return W4.isCollection(i4) ? i4.hasIn(n3) : false;
    }
    setIn(e5, t4) {
      let [n3, ...i4] = e5;
      if (i4.length === 0) this.set(n3, t4);
      else {
        let r2 = this.get(n3, true);
        if (W4.isCollection(r2)) r2.setIn(i4, t4);
        else if (r2 === void 0 && this.schema) this.set(n3, Ws2(this.schema, i4, t4));
        else throw new Error(`Expected YAML collection at ${n3}. Remaining path: ${i4}`);
      }
    }
  };
  $t2.Collection = Gs;
  $t2.collectionFromPath = Ws2;
  $t2.isEmptyPath = br2;
});
var We$1 = o$4((xt3) => {
  var Ac = (s3) => s3.replace(/^(?!$)(?: $)?/gm, "#");
  function Xs(s3, e5) {
    return /^\n+$/.test(s3) ? s3.substring(1) : e5 ? s3.replace(/^(?! *$)/gm, e5) : s3;
  }
  var Tc = (s3, e5, t4) => s3.endsWith(`
`) ? Xs(t4, e5) : t4.includes(`
`) ? `
` + Xs(t4, e5) : (s3.endsWith(" ") ? "" : " ") + t4;
  xt3.indentComment = Xs;
  xt3.lineComment = Tc;
  xt3.stringifyComment = Ac;
});
var Sr = o$4((Ge2) => {
  var Oc = "flow", Qs = "block", Bt2 = "quoted";
  function kc(s3, e5, t4 = "flow", { indentAtStart: n3, lineWidth: i4 = 80, minContentWidth: r2 = 20, onFold: o2, onOverflow: a3 } = {}) {
    if (!i4 || i4 < 0) return s3;
    i4 < r2 && (r2 = 0);
    let l3 = Math.max(1 + r2, 1 + i4 - e5.length);
    if (s3.length <= l3) return s3;
    let c3 = [], u3 = {}, f3 = i4 - e5.length;
    typeof n3 == "number" && (n3 > i4 - Math.max(2, r2) ? c3.push(0) : f3 = i4 - n3);
    let d3, p3, g2 = false, h3 = -1, m3 = -1, y2 = -1;
    t4 === Qs && (h3 = wr2(s3, h3, e5.length), h3 !== -1 && (f3 = h3 + l3));
    for (let N2; N2 = s3[h3 += 1]; ) {
      if (t4 === Bt2 && N2 === "\\") {
        switch (m3 = h3, s3[h3 + 1]) {
          case "x":
            h3 += 3;
            break;
          case "u":
            h3 += 5;
            break;
          case "U":
            h3 += 9;
            break;
          default:
            h3 += 1;
        }
        y2 = h3;
      }
      if (N2 === `
`) t4 === Qs && (h3 = wr2(s3, h3, e5.length)), f3 = h3 + e5.length + l3, d3 = void 0;
      else {
        if (N2 === " " && p3 && p3 !== " " && p3 !== `
` && p3 !== "	") {
          let E2 = s3[h3 + 1];
          E2 && E2 !== " " && E2 !== `
` && E2 !== "	" && (d3 = h3);
        }
        if (h3 >= f3) if (d3) c3.push(d3), f3 = d3 + l3, d3 = void 0;
        else if (t4 === Bt2) {
          for (; p3 === " " || p3 === "	"; ) p3 = N2, N2 = s3[h3 += 1], g2 = true;
          let E2 = h3 > y2 + 1 ? h3 - 2 : m3 - 1;
          if (u3[E2]) return s3;
          c3.push(E2), u3[E2] = true, f3 = E2 + l3, d3 = void 0;
        } else g2 = true;
      }
      p3 = N2;
    }
    if (g2 && a3 && a3(), c3.length === 0) return s3;
    o2 && o2();
    let S3 = s3.slice(0, c3[0]);
    for (let N2 = 0; N2 < c3.length; ++N2) {
      let E2 = c3[N2], v2 = c3[N2 + 1] || s3.length;
      E2 === 0 ? S3 = `
${e5}${s3.slice(0, v2)}` : (t4 === Bt2 && u3[E2] && (S3 += `${s3[E2]}\\`), S3 += `
${e5}${s3.slice(E2 + 1, v2)}`);
    }
    return S3;
  }
  function wr2(s3, e5, t4) {
    let n3 = e5, i4 = e5 + 1, r2 = s3[i4];
    for (; r2 === " " || r2 === "	"; ) if (e5 < i4 + t4) r2 = s3[++e5];
    else {
      do
        r2 = s3[++e5];
      while (r2 && r2 !== `
`);
      n3 = e5, i4 = e5 + 1, r2 = s3[i4];
    }
    return n3;
  }
  Ge2.FOLD_BLOCK = Qs;
  Ge2.FOLD_FLOW = Oc;
  Ge2.FOLD_QUOTED = Bt2;
  Ge2.foldFlowLines = kc;
});
var Qe$1 = o$4((Nr2) => {
  var Y2 = C$2(), z2 = Sr(), jt2 = (s3, e5) => ({ indentAtStart: e5 ? s3.indent.length : s3.indentAtStart, lineWidth: s3.options.lineWidth, minContentWidth: s3.options.minContentWidth }), Vt2 = (s3) => /^(%|---|\.\.\.)/m.test(s3);
  function Ic(s3, e5, t4) {
    if (!e5 || e5 < 0) return false;
    let n3 = e5 - t4, i4 = s3.length;
    if (i4 <= n3) return false;
    for (let r2 = 0, o2 = 0; r2 < i4; ++r2) if (s3[r2] === `
`) {
      if (r2 - o2 > n3) return true;
      if (o2 = r2 + 1, i4 - o2 <= n3) return false;
    }
    return true;
  }
  function Xe2(s3, e5) {
    let t4 = JSON.stringify(s3);
    if (e5.options.doubleQuotedAsJSON) return t4;
    let { implicitKey: n3 } = e5, i4 = e5.options.doubleQuotedMinMultiLineLength, r2 = e5.indent || (Vt2(s3) ? "  " : ""), o2 = "", a3 = 0;
    for (let l3 = 0, c3 = t4[l3]; c3; c3 = t4[++l3]) if (c3 === " " && t4[l3 + 1] === "\\" && t4[l3 + 2] === "n" && (o2 += t4.slice(a3, l3) + "\\ ", l3 += 1, a3 = l3, c3 = "\\"), c3 === "\\") switch (t4[l3 + 1]) {
      case "u":
        {
          o2 += t4.slice(a3, l3);
          let u3 = t4.substr(l3 + 2, 4);
          switch (u3) {
            case "0000":
              o2 += "\\0";
              break;
            case "0007":
              o2 += "\\a";
              break;
            case "000b":
              o2 += "\\v";
              break;
            case "001b":
              o2 += "\\e";
              break;
            case "0085":
              o2 += "\\N";
              break;
            case "00a0":
              o2 += "\\_";
              break;
            case "2028":
              o2 += "\\L";
              break;
            case "2029":
              o2 += "\\P";
              break;
            default:
              u3.substr(0, 2) === "00" ? o2 += "\\x" + u3.substr(2) : o2 += t4.substr(l3, 6);
          }
          l3 += 5, a3 = l3 + 1;
        }
        break;
      case "n":
        if (n3 || t4[l3 + 2] === '"' || t4.length < i4) l3 += 1;
        else {
          for (o2 += t4.slice(a3, l3) + `

`; t4[l3 + 2] === "\\" && t4[l3 + 3] === "n" && t4[l3 + 4] !== '"'; ) o2 += `
`, l3 += 2;
          o2 += r2, t4[l3 + 2] === " " && (o2 += "\\"), l3 += 1, a3 = l3 + 1;
        }
        break;
      default:
        l3 += 1;
    }
    return o2 = a3 ? o2 + t4.slice(a3) : t4, n3 ? o2 : z2.foldFlowLines(o2, r2, z2.FOLD_QUOTED, jt2(e5, false));
  }
  function Hs(s3, e5) {
    if (e5.options.singleQuote === false || e5.implicitKey && s3.includes(`
`) || /[ \t]\n|\n[ \t]/.test(s3)) return Xe2(s3, e5);
    let t4 = e5.indent || (Vt2(s3) ? "  " : ""), n3 = "'" + s3.replace(/'/g, "''").replace(/\n+/g, `$&
${t4}`) + "'";
    return e5.implicitKey ? n3 : z2.foldFlowLines(n3, t4, z2.FOLD_FLOW, jt2(e5, false));
  }
  function ve2(s3, e5) {
    let { singleQuote: t4 } = e5.options, n3;
    if (t4 === false) n3 = Xe2;
    else {
      let i4 = s3.includes('"'), r2 = s3.includes("'");
      i4 && !r2 ? n3 = Hs : r2 && !i4 ? n3 = Xe2 : n3 = t4 ? Hs : Xe2;
    }
    return n3(s3, e5);
  }
  var Ds2;
  try {
    Ds2 = new RegExp(`(^|(?<!
))
+(?!
|$)`, "g");
  } catch {
    Ds2 = /\n+(?!\n|$)/g;
  }
  function Ft2({ comment: s3, type: e5, value: t4 }, n3, i4, r2) {
    let { blockQuote: o2, commentString: a3, lineWidth: l3 } = n3.options;
    if (!o2 || /\n[\t ]+$/.test(t4)) return ve2(t4, n3);
    let c3 = n3.indent || (n3.forceBlockIndent || Vt2(t4) ? "  " : ""), u3 = o2 === "literal" ? true : o2 === "folded" || e5 === Y2.Scalar.BLOCK_FOLDED ? false : e5 === Y2.Scalar.BLOCK_LITERAL ? true : !Ic(t4, l3, c3.length);
    if (!t4) return u3 ? `|
` : `>
`;
    let f3, d3;
    for (d3 = t4.length; d3 > 0; --d3) {
      let v2 = t4[d3 - 1];
      if (v2 !== `
` && v2 !== "	" && v2 !== " ") break;
    }
    let p3 = t4.substring(d3), g2 = p3.indexOf(`
`);
    g2 === -1 ? f3 = "-" : t4 === p3 || g2 !== p3.length - 1 ? (f3 = "+", r2 && r2()) : f3 = "", p3 && (t4 = t4.slice(0, -p3.length), p3[p3.length - 1] === `
` && (p3 = p3.slice(0, -1)), p3 = p3.replace(Ds2, `$&${c3}`));
    let h3 = false, m3, y2 = -1;
    for (m3 = 0; m3 < t4.length; ++m3) {
      let v2 = t4[m3];
      if (v2 === " ") h3 = true;
      else if (v2 === `
`) y2 = m3;
      else break;
    }
    let S3 = t4.substring(0, y2 < m3 ? y2 + 1 : m3);
    S3 && (t4 = t4.substring(S3.length), S3 = S3.replace(/\n+/g, `$&${c3}`));
    let E2 = (h3 ? c3 ? "2" : "1" : "") + f3;
    if (s3 && (E2 += " " + a3(s3.replace(/ ?[\r\n]+/g, " ")), i4 && i4()), !u3) {
      let v2 = t4.replace(/\n+/g, `
$&`).replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${c3}`), A2 = false, I2 = jt2(n3, true);
      o2 !== "folded" && e5 !== Y2.Scalar.BLOCK_FOLDED && (I2.onOverflow = () => {
        A2 = true;
      });
      let w4 = z2.foldFlowLines(`${S3}${v2}${p3}`, c3, z2.FOLD_BLOCK, I2);
      if (!A2) return `>${E2}
${c3}${w4}`;
    }
    return t4 = t4.replace(/\n+/g, `$&${c3}`), `|${E2}
${c3}${S3}${t4}${p3}`;
  }
  function qc(s3, e5, t4, n3) {
    let { type: i4, value: r2 } = s3, { actualString: o2, implicitKey: a3, indent: l3, indentStep: c3, inFlow: u3 } = e5;
    if (a3 && r2.includes(`
`) || u3 && /[[\]{},]/.test(r2)) return ve2(r2, e5);
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(r2)) return a3 || u3 || !r2.includes(`
`) ? ve2(r2, e5) : Ft2(s3, e5, t4, n3);
    if (!a3 && !u3 && i4 !== Y2.Scalar.PLAIN && r2.includes(`
`)) return Ft2(s3, e5, t4, n3);
    if (Vt2(r2)) {
      if (l3 === "") return e5.forceBlockIndent = true, Ft2(s3, e5, t4, n3);
      if (a3 && l3 === c3) return ve2(r2, e5);
    }
    let f3 = r2.replace(/\n+/g, `$&
${l3}`);
    if (o2) {
      let d3 = (h3) => h3.default && h3.tag !== "tag:yaml.org,2002:str" && h3.test?.test(f3), { compat: p3, tags: g2 } = e5.doc.schema;
      if (g2.some(d3) || p3?.some(d3)) return ve2(r2, e5);
    }
    return a3 ? f3 : z2.foldFlowLines(f3, l3, z2.FOLD_FLOW, jt2(e5, false));
  }
  function Cc(s3, e5, t4, n3) {
    let { implicitKey: i4, inFlow: r2 } = e5, o2 = typeof s3.value == "string" ? s3 : Object.assign({}, s3, { value: String(s3.value) }), { type: a3 } = s3;
    a3 !== Y2.Scalar.QUOTE_DOUBLE && /[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(o2.value) && (a3 = Y2.Scalar.QUOTE_DOUBLE);
    let l3 = (u3) => {
      switch (u3) {
        case Y2.Scalar.BLOCK_FOLDED:
        case Y2.Scalar.BLOCK_LITERAL:
          return i4 || r2 ? ve2(o2.value, e5) : Ft2(o2, e5, t4, n3);
        case Y2.Scalar.QUOTE_DOUBLE:
          return Xe2(o2.value, e5);
        case Y2.Scalar.QUOTE_SINGLE:
          return Hs(o2.value, e5);
        case Y2.Scalar.PLAIN:
          return qc(o2, e5, t4, n3);
        default:
          return null;
      }
    }, c3 = l3(a3);
    if (c3 === null) {
      let { defaultKeyType: u3, defaultStringType: f3 } = e5.options, d3 = i4 && u3 || f3;
      if (c3 = l3(d3), c3 === null) throw new Error(`Unsupported default string type ${d3}`);
    }
    return c3;
  }
  Nr2.stringifyString = Cc;
});
var He$1 = o$4((Zs) => {
  var Lc = Lt(), ee2 = O$4(), Pc = We$1(), Mc = Qe$1();
  function $c(s3, e5) {
    let t4 = Object.assign({ blockQuote: true, commentString: Pc.stringifyComment, defaultKeyType: null, defaultStringType: "PLAIN", directives: null, doubleQuotedAsJSON: false, doubleQuotedMinMultiLineLength: 40, falseStr: "false", flowCollectionPadding: true, indentSeq: true, lineWidth: 80, minContentWidth: 20, nullStr: "null", simpleKeys: false, singleQuote: null, trueStr: "true", verifyAliasOrder: true }, s3.schema.toStringOptions, e5), n3;
    switch (t4.collectionStyle) {
      case "block":
        n3 = false;
        break;
      case "flow":
        n3 = true;
        break;
      default:
        n3 = null;
    }
    return { anchors: /* @__PURE__ */ new Set(), doc: s3, flowCollectionPadding: t4.flowCollectionPadding ? " " : "", indent: "", indentStep: typeof t4.indent == "number" ? " ".repeat(t4.indent) : "  ", inFlow: n3, options: t4 };
  }
  function _c(s3, e5) {
    if (e5.tag) {
      let i4 = s3.filter((r2) => r2.tag === e5.tag);
      if (i4.length > 0) return i4.find((r2) => r2.format === e5.format) ?? i4[0];
    }
    let t4, n3;
    if (ee2.isScalar(e5)) {
      n3 = e5.value;
      let i4 = s3.filter((r2) => r2.identify?.(n3));
      if (i4.length > 1) {
        let r2 = i4.filter((o2) => o2.test);
        r2.length > 0 && (i4 = r2);
      }
      t4 = i4.find((r2) => r2.format === e5.format) ?? i4.find((r2) => !r2.format);
    } else n3 = e5, t4 = s3.find((i4) => i4.nodeClass && n3 instanceof i4.nodeClass);
    if (!t4) {
      let i4 = n3?.constructor?.name ?? (n3 === null ? "null" : typeof n3);
      throw new Error(`Tag not resolved for ${i4} value`);
    }
    return t4;
  }
  function xc(s3, e5, { anchors: t4, doc: n3 }) {
    if (!n3.directives) return "";
    let i4 = [], r2 = (ee2.isScalar(s3) || ee2.isCollection(s3)) && s3.anchor;
    r2 && Lc.anchorIsValid(r2) && (t4.add(r2), i4.push(`&${r2}`));
    let o2 = s3.tag ?? (e5.default ? null : e5.tag);
    return o2 && i4.push(n3.directives.tagString(o2)), i4.join(" ");
  }
  function Bc(s3, e5, t4, n3) {
    if (ee2.isPair(s3)) return s3.toString(e5, t4, n3);
    if (ee2.isAlias(s3)) {
      if (e5.doc.directives) return s3.toString(e5);
      if (e5.resolvedAliases?.has(s3)) throw new TypeError("Cannot stringify circular structure without alias nodes");
      e5.resolvedAliases ? e5.resolvedAliases.add(s3) : e5.resolvedAliases = /* @__PURE__ */ new Set([s3]), s3 = s3.resolve(e5.doc);
    }
    let i4, r2 = ee2.isNode(s3) ? s3 : e5.doc.createNode(s3, { onTagObj: (l3) => i4 = l3 });
    i4 ?? (i4 = _c(e5.doc.schema.tags, r2));
    let o2 = xc(r2, i4, e5);
    o2.length > 0 && (e5.indentAtStart = (e5.indentAtStart ?? 0) + o2.length + 1);
    let a3 = typeof i4.stringify == "function" ? i4.stringify(r2, e5, t4, n3) : ee2.isScalar(r2) ? Mc.stringifyString(r2, e5, t4, n3) : r2.toString(e5, t4, n3);
    return o2 ? ee2.isScalar(r2) || a3[0] === "{" || a3[0] === "[" ? `${o2} ${a3}` : `${o2}
${e5.indent}${a3}` : a3;
  }
  Zs.createStringifyContext = $c;
  Zs.stringify = Bc;
});
var Tr = o$4((Ar2) => {
  var Q4 = O$4(), Er2 = C$2(), vr2 = He$1(), De2 = We$1();
  function Fc({ key: s3, value: e5 }, t4, n3, i4) {
    let { allNullValues: r2, doc: o2, indent: a3, indentStep: l3, options: { commentString: c3, indentSeq: u3, simpleKeys: f3 } } = t4, d3 = Q4.isNode(s3) && s3.comment || null;
    if (f3) {
      if (d3) throw new Error("With simple keys, key nodes cannot have comments");
      if (Q4.isCollection(s3) || !Q4.isNode(s3) && typeof s3 == "object") {
        let I2 = "With simple keys, collection cannot be used as a key value";
        throw new Error(I2);
      }
    }
    let p3 = !f3 && (!s3 || d3 && e5 == null && !t4.inFlow || Q4.isCollection(s3) || (Q4.isScalar(s3) ? s3.type === Er2.Scalar.BLOCK_FOLDED || s3.type === Er2.Scalar.BLOCK_LITERAL : typeof s3 == "object"));
    t4 = Object.assign({}, t4, { allNullValues: false, implicitKey: !p3 && (f3 || !r2), indent: a3 + l3 });
    let g2 = false, h3 = false, m3 = vr2.stringify(s3, t4, () => g2 = true, () => h3 = true);
    if (!p3 && !t4.inFlow && m3.length > 1024) {
      if (f3) throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
      p3 = true;
    }
    if (t4.inFlow) {
      if (r2 || e5 == null) return g2 && n3 && n3(), m3 === "" ? "?" : p3 ? `? ${m3}` : m3;
    } else if (r2 && !f3 || e5 == null && p3) return m3 = `? ${m3}`, d3 && !g2 ? m3 += De2.lineComment(m3, t4.indent, c3(d3)) : h3 && i4 && i4(), m3;
    g2 && (d3 = null), p3 ? (d3 && (m3 += De2.lineComment(m3, t4.indent, c3(d3))), m3 = `? ${m3}
${a3}:`) : (m3 = `${m3}:`, d3 && (m3 += De2.lineComment(m3, t4.indent, c3(d3))));
    let y2, S3, N2;
    Q4.isNode(e5) ? (y2 = !!e5.spaceBefore, S3 = e5.commentBefore, N2 = e5.comment) : (y2 = false, S3 = null, N2 = null, e5 && typeof e5 == "object" && (e5 = o2.createNode(e5))), t4.implicitKey = false, !p3 && !d3 && Q4.isScalar(e5) && (t4.indentAtStart = m3.length + 1), h3 = false, !u3 && l3.length >= 2 && !t4.inFlow && !p3 && Q4.isSeq(e5) && !e5.flow && !e5.tag && !e5.anchor && (t4.indent = t4.indent.substring(2));
    let E2 = false, v2 = vr2.stringify(e5, t4, () => E2 = true, () => h3 = true), A2 = " ";
    if (d3 || y2 || S3) {
      if (A2 = y2 ? `
` : "", S3) {
        let I2 = c3(S3);
        A2 += `
${De2.indentComment(I2, t4.indent)}`;
      }
      v2 === "" && !t4.inFlow ? A2 === `
` && N2 && (A2 = `

`) : A2 += `
${t4.indent}`;
    } else if (!p3 && Q4.isCollection(e5)) {
      let I2 = v2[0], w4 = v2.indexOf(`
`), L4 = w4 !== -1, H2 = t4.inFlow ?? e5.flow ?? e5.items.length === 0;
      if (L4 || !H2) {
        let ge2 = false;
        if (L4 && (I2 === "&" || I2 === "!")) {
          let P2 = v2.indexOf(" ");
          I2 === "&" && P2 !== -1 && P2 < w4 && v2[P2 + 1] === "!" && (P2 = v2.indexOf(" ", P2 + 1)), (P2 === -1 || w4 < P2) && (ge2 = true);
        }
        ge2 || (A2 = `
${t4.indent}`);
      }
    } else (v2 === "" || v2[0] === `
`) && (A2 = "");
    return m3 += A2 + v2, t4.inFlow ? E2 && n3 && n3() : N2 && !E2 ? m3 += De2.lineComment(m3, t4.indent, c3(N2)) : h3 && i4 && i4(), m3;
  }
  Ar2.stringifyPair = Fc;
});
var en$1 = o$4((zs2) => {
  var Or2 = m$d("process");
  function jc(s3, ...e5) {
    s3 === "debug" && console.log(...e5);
  }
  function Vc(s3, e5) {
    (s3 === "debug" || s3 === "warn") && (typeof Or2.emitWarning == "function" ? Or2.emitWarning(e5) : console.warn(e5));
  }
  zs2.debug = jc;
  zs2.warn = Vc;
});
var Ut = o$4((Yt2) => {
  var Ze2 = O$4(), kr2 = C$2(), Kt2 = "<<", Rt2 = { identify: (s3) => s3 === Kt2 || typeof s3 == "symbol" && s3.description === Kt2, default: "key", tag: "tag:yaml.org,2002:merge", test: /^<<$/, resolve: () => Object.assign(new kr2.Scalar(Symbol(Kt2)), { addToJSMap: Ir2 }), stringify: () => Kt2 }, Kc = (s3, e5) => (Rt2.identify(e5) || Ze2.isScalar(e5) && (!e5.type || e5.type === kr2.Scalar.PLAIN) && Rt2.identify(e5.value)) && s3?.doc.schema.tags.some((t4) => t4.tag === Rt2.tag && t4.default);
  function Ir2(s3, e5, t4) {
    if (t4 = s3 && Ze2.isAlias(t4) ? t4.resolve(s3.doc) : t4, Ze2.isSeq(t4)) for (let n3 of t4.items) tn2(s3, e5, n3);
    else if (Array.isArray(t4)) for (let n3 of t4) tn2(s3, e5, n3);
    else tn2(s3, e5, t4);
  }
  function tn2(s3, e5, t4) {
    let n3 = s3 && Ze2.isAlias(t4) ? t4.resolve(s3.doc) : t4;
    if (!Ze2.isMap(n3)) throw new Error("Merge sources must be maps or map aliases");
    let i4 = n3.toJSON(null, s3, Map);
    for (let [r2, o2] of i4) e5 instanceof Map ? e5.has(r2) || e5.set(r2, o2) : e5 instanceof Set ? e5.add(r2) : Object.prototype.hasOwnProperty.call(e5, r2) || Object.defineProperty(e5, r2, { value: o2, writable: true, enumerable: true, configurable: true });
    return e5;
  }
  Yt2.addMergeToJSMap = Ir2;
  Yt2.isMergeKey = Kc;
  Yt2.merge = Rt2;
});
var nn = o$4((Lr2) => {
  var Rc = en$1(), qr2 = Ut(), Yc = He$1(), Cr2 = O$4(), sn2 = D$1();
  function Uc(s3, e5, { key: t4, value: n3 }) {
    if (Cr2.isNode(t4) && t4.addToJSMap) t4.addToJSMap(s3, e5, n3);
    else if (qr2.isMergeKey(s3, t4)) qr2.addMergeToJSMap(s3, e5, n3);
    else {
      let i4 = sn2.toJS(t4, "", s3);
      if (e5 instanceof Map) e5.set(i4, sn2.toJS(n3, i4, s3));
      else if (e5 instanceof Set) e5.add(i4);
      else {
        let r2 = Jc(t4, i4, s3), o2 = sn2.toJS(n3, r2, s3);
        r2 in e5 ? Object.defineProperty(e5, r2, { value: o2, writable: true, enumerable: true, configurable: true }) : e5[r2] = o2;
      }
    }
    return e5;
  }
  function Jc(s3, e5, t4) {
    if (e5 === null) return "";
    if (typeof e5 != "object") return String(e5);
    if (Cr2.isNode(s3) && t4?.doc) {
      let n3 = Yc.createStringifyContext(t4.doc, {});
      n3.anchors = /* @__PURE__ */ new Set();
      for (let r2 of t4.anchors.keys()) n3.anchors.add(r2.anchor);
      n3.inFlow = true, n3.inStringifyKey = true;
      let i4 = s3.toString(n3);
      if (!t4.mapKeyWarned) {
        let r2 = JSON.stringify(i4);
        r2.length > 40 && (r2 = r2.substring(0, 36) + '..."'), Rc.warn(t4.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${r2}. Set mapAsMap: true to use object keys.`), t4.mapKeyWarned = true;
      }
      return i4;
    }
    return JSON.stringify(e5);
  }
  Lr2.addPairToJSMap = Uc;
});
var te$2 = o$4((rn2) => {
  var Pr2 = Je$1(), Wc = Tr(), Gc = nn(), Jt2 = O$4();
  function Xc(s3, e5, t4) {
    let n3 = Pr2.createNode(s3, void 0, t4), i4 = Pr2.createNode(e5, void 0, t4);
    return new Wt2(n3, i4);
  }
  var Wt2 = class s3 {
    constructor(e5, t4 = null) {
      Object.defineProperty(this, Jt2.NODE_TYPE, { value: Jt2.PAIR }), this.key = e5, this.value = t4;
    }
    clone(e5) {
      let { key: t4, value: n3 } = this;
      return Jt2.isNode(t4) && (t4 = t4.clone(e5)), Jt2.isNode(n3) && (n3 = n3.clone(e5)), new s3(t4, n3);
    }
    toJSON(e5, t4) {
      let n3 = t4?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      return Gc.addPairToJSMap(t4, n3, this);
    }
    toString(e5, t4, n3) {
      return e5?.doc ? Wc.stringifyPair(this, e5, t4, n3) : JSON.stringify(this);
    }
  };
  rn2.Pair = Wt2;
  rn2.createPair = Xc;
});
var on = o$4(($r2) => {
  var ue2 = O$4(), Mr2 = He$1(), Gt2 = We$1();
  function Qc(s3, e5, t4) {
    return (e5.inFlow ?? s3.flow ? Dc : Hc)(s3, e5, t4);
  }
  function Hc({ comment: s3, items: e5 }, t4, { blockItemPrefix: n3, flowChars: i4, itemIndent: r2, onChompKeep: o2, onComment: a3 }) {
    let { indent: l3, options: { commentString: c3 } } = t4, u3 = Object.assign({}, t4, { indent: r2, type: null }), f3 = false, d3 = [];
    for (let g2 = 0; g2 < e5.length; ++g2) {
      let h3 = e5[g2], m3 = null;
      if (ue2.isNode(h3)) !f3 && h3.spaceBefore && d3.push(""), Xt2(t4, d3, h3.commentBefore, f3), h3.comment && (m3 = h3.comment);
      else if (ue2.isPair(h3)) {
        let S3 = ue2.isNode(h3.key) ? h3.key : null;
        S3 && (!f3 && S3.spaceBefore && d3.push(""), Xt2(t4, d3, S3.commentBefore, f3));
      }
      f3 = false;
      let y2 = Mr2.stringify(h3, u3, () => m3 = null, () => f3 = true);
      m3 && (y2 += Gt2.lineComment(y2, r2, c3(m3))), f3 && m3 && (f3 = false), d3.push(n3 + y2);
    }
    let p3;
    if (d3.length === 0) p3 = i4.start + i4.end;
    else {
      p3 = d3[0];
      for (let g2 = 1; g2 < d3.length; ++g2) {
        let h3 = d3[g2];
        p3 += h3 ? `
${l3}${h3}` : `
`;
      }
    }
    return s3 ? (p3 += `
` + Gt2.indentComment(c3(s3), l3), a3 && a3()) : f3 && o2 && o2(), p3;
  }
  function Dc({ items: s3 }, e5, { flowChars: t4, itemIndent: n3 }) {
    let { indent: i4, indentStep: r2, flowCollectionPadding: o2, options: { commentString: a3 } } = e5;
    n3 += r2;
    let l3 = Object.assign({}, e5, { indent: n3, inFlow: true, type: null }), c3 = false, u3 = 0, f3 = [];
    for (let g2 = 0; g2 < s3.length; ++g2) {
      let h3 = s3[g2], m3 = null;
      if (ue2.isNode(h3)) h3.spaceBefore && f3.push(""), Xt2(e5, f3, h3.commentBefore, false), h3.comment && (m3 = h3.comment);
      else if (ue2.isPair(h3)) {
        let S3 = ue2.isNode(h3.key) ? h3.key : null;
        S3 && (S3.spaceBefore && f3.push(""), Xt2(e5, f3, S3.commentBefore, false), S3.comment && (c3 = true));
        let N2 = ue2.isNode(h3.value) ? h3.value : null;
        N2 ? (N2.comment && (m3 = N2.comment), N2.commentBefore && (c3 = true)) : h3.value == null && S3?.comment && (m3 = S3.comment);
      }
      m3 && (c3 = true);
      let y2 = Mr2.stringify(h3, l3, () => m3 = null);
      g2 < s3.length - 1 && (y2 += ","), m3 && (y2 += Gt2.lineComment(y2, n3, a3(m3))), !c3 && (f3.length > u3 || y2.includes(`
`)) && (c3 = true), f3.push(y2), u3 = f3.length;
    }
    let { start: d3, end: p3 } = t4;
    if (f3.length === 0) return d3 + p3;
    if (!c3) {
      let g2 = f3.reduce((h3, m3) => h3 + m3.length + 2, 2);
      c3 = e5.options.lineWidth > 0 && g2 > e5.options.lineWidth;
    }
    if (c3) {
      let g2 = d3;
      for (let h3 of f3) g2 += h3 ? `
${r2}${i4}${h3}` : `
`;
      return `${g2}
${i4}${p3}`;
    } else return `${d3}${o2}${f3.join(" ")}${o2}${p3}`;
  }
  function Xt2({ indent: s3, options: { commentString: e5 } }, t4, n3, i4) {
    if (n3 && i4 && (n3 = n3.replace(/^\n+/, "")), n3) {
      let r2 = Gt2.indentComment(e5(n3), s3);
      t4.push(r2.trimStart());
    }
  }
  $r2.stringifyCollection = Qc;
});
var ne$1 = o$4((ln2) => {
  var Zc = on(), zc = nn(), ef = _t(), se3 = O$4(), Qt2 = te$2(), tf = C$2();
  function ze2(s3, e5) {
    let t4 = se3.isScalar(e5) ? e5.value : e5;
    for (let n3 of s3) if (se3.isPair(n3) && (n3.key === e5 || n3.key === t4 || se3.isScalar(n3.key) && n3.key.value === t4)) return n3;
  }
  var an2 = class extends ef.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:map";
    }
    constructor(e5) {
      super(se3.MAP, e5), this.items = [];
    }
    static from(e5, t4, n3) {
      let { keepUndefined: i4, replacer: r2 } = n3, o2 = new this(e5), a3 = (l3, c3) => {
        if (typeof r2 == "function") c3 = r2.call(t4, l3, c3);
        else if (Array.isArray(r2) && !r2.includes(l3)) return;
        (c3 !== void 0 || i4) && o2.items.push(Qt2.createPair(l3, c3, n3));
      };
      if (t4 instanceof Map) for (let [l3, c3] of t4) a3(l3, c3);
      else if (t4 && typeof t4 == "object") for (let l3 of Object.keys(t4)) a3(l3, t4[l3]);
      return typeof e5.sortMapEntries == "function" && o2.items.sort(e5.sortMapEntries), o2;
    }
    add(e5, t4) {
      let n3;
      se3.isPair(e5) ? n3 = e5 : !e5 || typeof e5 != "object" || !("key" in e5) ? n3 = new Qt2.Pair(e5, e5?.value) : n3 = new Qt2.Pair(e5.key, e5.value);
      let i4 = ze2(this.items, n3.key), r2 = this.schema?.sortMapEntries;
      if (i4) {
        if (!t4) throw new Error(`Key ${n3.key} already set`);
        se3.isScalar(i4.value) && tf.isScalarValue(n3.value) ? i4.value.value = n3.value : i4.value = n3.value;
      } else if (r2) {
        let o2 = this.items.findIndex((a3) => r2(n3, a3) < 0);
        o2 === -1 ? this.items.push(n3) : this.items.splice(o2, 0, n3);
      } else this.items.push(n3);
    }
    delete(e5) {
      let t4 = ze2(this.items, e5);
      return t4 ? this.items.splice(this.items.indexOf(t4), 1).length > 0 : false;
    }
    get(e5, t4) {
      let i4 = ze2(this.items, e5)?.value;
      return (!t4 && se3.isScalar(i4) ? i4.value : i4) ?? void 0;
    }
    has(e5) {
      return !!ze2(this.items, e5);
    }
    set(e5, t4) {
      this.add(new Qt2.Pair(e5, t4), true);
    }
    toJSON(e5, t4, n3) {
      let i4 = n3 ? new n3() : t4?.mapAsMap ? /* @__PURE__ */ new Map() : {};
      t4?.onCreate && t4.onCreate(i4);
      for (let r2 of this.items) zc.addPairToJSMap(t4, i4, r2);
      return i4;
    }
    toString(e5, t4, n3) {
      if (!e5) return JSON.stringify(this);
      for (let i4 of this.items) if (!se3.isPair(i4)) throw new Error(`Map items must all be pairs; found ${JSON.stringify(i4)} instead`);
      return !e5.allNullValues && this.hasAllNullValues(false) && (e5 = Object.assign({}, e5, { allNullValues: true })), Zc.stringifyCollection(this, e5, { blockItemPrefix: "", flowChars: { start: "{", end: "}" }, itemIndent: e5.indent || "", onChompKeep: n3, onComment: t4 });
    }
  };
  ln2.YAMLMap = an2;
  ln2.findPair = ze2;
});
var Ae$1 = o$4((xr2) => {
  var sf = O$4(), _r2 = ne$1(), nf = { collection: "map", default: true, nodeClass: _r2.YAMLMap, tag: "tag:yaml.org,2002:map", resolve(s3, e5) {
    return sf.isMap(s3) || e5("Expected a mapping for this tag"), s3;
  }, createNode: (s3, e5, t4) => _r2.YAMLMap.from(s3, e5, t4) };
  xr2.map = nf;
});
var ie$1 = o$4((Br2) => {
  var rf = Je$1(), of = on(), af = _t(), Dt2 = O$4(), lf = C$2(), cf = D$1(), cn2 = class extends af.Collection {
    static get tagName() {
      return "tag:yaml.org,2002:seq";
    }
    constructor(e5) {
      super(Dt2.SEQ, e5), this.items = [];
    }
    add(e5) {
      this.items.push(e5);
    }
    delete(e5) {
      let t4 = Ht2(e5);
      return typeof t4 != "number" ? false : this.items.splice(t4, 1).length > 0;
    }
    get(e5, t4) {
      let n3 = Ht2(e5);
      if (typeof n3 != "number") return;
      let i4 = this.items[n3];
      return !t4 && Dt2.isScalar(i4) ? i4.value : i4;
    }
    has(e5) {
      let t4 = Ht2(e5);
      return typeof t4 == "number" && t4 < this.items.length;
    }
    set(e5, t4) {
      let n3 = Ht2(e5);
      if (typeof n3 != "number") throw new Error(`Expected a valid index, not ${e5}.`);
      let i4 = this.items[n3];
      Dt2.isScalar(i4) && lf.isScalarValue(t4) ? i4.value = t4 : this.items[n3] = t4;
    }
    toJSON(e5, t4) {
      let n3 = [];
      t4?.onCreate && t4.onCreate(n3);
      let i4 = 0;
      for (let r2 of this.items) n3.push(cf.toJS(r2, String(i4++), t4));
      return n3;
    }
    toString(e5, t4, n3) {
      return e5 ? of.stringifyCollection(this, e5, { blockItemPrefix: "- ", flowChars: { start: "[", end: "]" }, itemIndent: (e5.indent || "") + "  ", onChompKeep: n3, onComment: t4 }) : JSON.stringify(this);
    }
    static from(e5, t4, n3) {
      let { replacer: i4 } = n3, r2 = new this(e5);
      if (t4 && Symbol.iterator in Object(t4)) {
        let o2 = 0;
        for (let a3 of t4) {
          if (typeof i4 == "function") {
            let l3 = t4 instanceof Set ? a3 : String(o2++);
            a3 = i4.call(t4, l3, a3);
          }
          r2.items.push(rf.createNode(a3, void 0, n3));
        }
      }
      return r2;
    }
  };
  function Ht2(s3) {
    let e5 = Dt2.isScalar(s3) ? s3.value : s3;
    return e5 && typeof e5 == "string" && (e5 = Number(e5)), typeof e5 == "number" && Number.isInteger(e5) && e5 >= 0 ? e5 : null;
  }
  Br2.YAMLSeq = cn2;
});
var Te = o$4((jr2) => {
  var ff = O$4(), Fr = ie$1(), uf = { collection: "seq", default: true, nodeClass: Fr.YAMLSeq, tag: "tag:yaml.org,2002:seq", resolve(s3, e5) {
    return ff.isSeq(s3) || e5("Expected a sequence for this tag"), s3;
  }, createNode: (s3, e5, t4) => Fr.YAMLSeq.from(s3, e5, t4) };
  jr2.seq = uf;
});
var et$1 = o$4((Vr2) => {
  var df = Qe$1(), hf = { identify: (s3) => typeof s3 == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: (s3) => s3, stringify(s3, e5, t4, n3) {
    return e5 = Object.assign({ actualString: true }, e5), df.stringifyString(s3, e5, t4, n3);
  } };
  Vr2.string = hf;
});
var Zt = o$4((Yr2) => {
  var Kr2 = C$2(), Rr2 = { identify: (s3) => s3 == null, createNode: () => new Kr2.Scalar(null), default: true, tag: "tag:yaml.org,2002:null", test: /^(?:~|[Nn]ull|NULL)?$/, resolve: () => new Kr2.Scalar(null), stringify: ({ source: s3 }, e5) => typeof s3 == "string" && Rr2.test.test(s3) ? s3 : e5.options.nullStr };
  Yr2.nullTag = Rr2;
});
var fn = o$4((Jr2) => {
  var pf = C$2(), Ur2 = { identify: (s3) => typeof s3 == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/, resolve: (s3) => new pf.Scalar(s3[0] === "t" || s3[0] === "T"), stringify({ source: s3, value: e5 }, t4) {
    if (s3 && Ur2.test.test(s3)) {
      let n3 = s3[0] === "t" || s3[0] === "T";
      if (e5 === n3) return s3;
    }
    return e5 ? t4.options.trueStr : t4.options.falseStr;
  } };
  Jr2.boolTag = Ur2;
});
var Oe$1 = o$4((Wr) => {
  function mf({ format: s3, minFractionDigits: e5, tag: t4, value: n3 }) {
    if (typeof n3 == "bigint") return String(n3);
    let i4 = typeof n3 == "number" ? n3 : Number(n3);
    if (!isFinite(i4)) return isNaN(i4) ? ".nan" : i4 < 0 ? "-.inf" : ".inf";
    let r2 = Object.is(n3, -0) ? "-0" : JSON.stringify(n3);
    if (!s3 && e5 && (!t4 || t4 === "tag:yaml.org,2002:float") && /^\d/.test(r2)) {
      let o2 = r2.indexOf(".");
      o2 < 0 && (o2 = r2.length, r2 += ".");
      let a3 = e5 - (r2.length - o2 - 1);
      for (; a3-- > 0; ) r2 += "0";
    }
    return r2;
  }
  Wr.stringifyNumber = mf;
});
var dn = o$4((zt2) => {
  var gf = C$2(), un2 = Oe$1(), yf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/, resolve: (s3) => s3.slice(-3).toLowerCase() === "nan" ? NaN : s3[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: un2.stringifyNumber }, bf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/, resolve: (s3) => parseFloat(s3), stringify(s3) {
    let e5 = Number(s3.value);
    return isFinite(e5) ? e5.toExponential() : un2.stringifyNumber(s3);
  } }, wf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/, resolve(s3) {
    let e5 = new gf.Scalar(parseFloat(s3)), t4 = s3.indexOf(".");
    return t4 !== -1 && s3[s3.length - 1] === "0" && (e5.minFractionDigits = s3.length - t4 - 1), e5;
  }, stringify: un2.stringifyNumber };
  zt2.float = wf;
  zt2.floatExp = bf;
  zt2.floatNaN = yf;
});
var pn = o$4((ts2) => {
  var Gr2 = Oe$1(), es2 = (s3) => typeof s3 == "bigint" || Number.isInteger(s3), hn2 = (s3, e5, t4, { intAsBigInt: n3 }) => n3 ? BigInt(s3) : parseInt(s3.substring(e5), t4);
  function Xr2(s3, e5, t4) {
    let { value: n3 } = s3;
    return es2(n3) && n3 >= 0 ? t4 + n3.toString(e5) : Gr2.stringifyNumber(s3);
  }
  var Sf = { identify: (s3) => es2(s3) && s3 >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^0o[0-7]+$/, resolve: (s3, e5, t4) => hn2(s3, 2, 8, t4), stringify: (s3) => Xr2(s3, 8, "0o") }, Nf = { identify: es2, default: true, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9]+$/, resolve: (s3, e5, t4) => hn2(s3, 0, 10, t4), stringify: Gr2.stringifyNumber }, Ef = { identify: (s3) => es2(s3) && s3 >= 0, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^0x[0-9a-fA-F]+$/, resolve: (s3, e5, t4) => hn2(s3, 2, 16, t4), stringify: (s3) => Xr2(s3, 16, "0x") };
  ts2.int = Nf;
  ts2.intHex = Ef;
  ts2.intOct = Sf;
});
var Hr = o$4((Qr2) => {
  var vf = Ae$1(), Af = Zt(), Tf = Te(), Of = et$1(), kf = fn(), mn2 = dn(), gn2 = pn(), If = [vf.map, Tf.seq, Of.string, Af.nullTag, kf.boolTag, gn2.intOct, gn2.int, gn2.intHex, mn2.floatNaN, mn2.floatExp, mn2.float];
  Qr2.schema = If;
});
var zr = o$4((Zr2) => {
  var qf = C$2(), Cf = Ae$1(), Lf = Te();
  function Dr2(s3) {
    return typeof s3 == "bigint" || Number.isInteger(s3);
  }
  var ss2 = ({ value: s3 }) => JSON.stringify(s3), Pf = [{ identify: (s3) => typeof s3 == "string", default: true, tag: "tag:yaml.org,2002:str", resolve: (s3) => s3, stringify: ss2 }, { identify: (s3) => s3 == null, createNode: () => new qf.Scalar(null), default: true, tag: "tag:yaml.org,2002:null", test: /^null$/, resolve: () => null, stringify: ss2 }, { identify: (s3) => typeof s3 == "boolean", default: true, tag: "tag:yaml.org,2002:bool", test: /^true$|^false$/, resolve: (s3) => s3 === "true", stringify: ss2 }, { identify: Dr2, default: true, tag: "tag:yaml.org,2002:int", test: /^-?(?:0|[1-9][0-9]*)$/, resolve: (s3, e5, { intAsBigInt: t4 }) => t4 ? BigInt(s3) : parseInt(s3, 10), stringify: ({ value: s3 }) => Dr2(s3) ? s3.toString() : JSON.stringify(s3) }, { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/, resolve: (s3) => parseFloat(s3), stringify: ss2 }], Mf = { default: true, tag: "", test: /^/, resolve(s3, e5) {
    return e5(`Unresolved plain scalar ${JSON.stringify(s3)}`), s3;
  } }, $f = [Cf.map, Lf.seq].concat(Pf, Mf);
  Zr2.schema = $f;
});
var bn = o$4((eo2) => {
  var tt2 = m$d("buffer"), yn2 = C$2(), _f = Qe$1(), xf = { identify: (s3) => s3 instanceof Uint8Array, default: false, tag: "tag:yaml.org,2002:binary", resolve(s3, e5) {
    if (typeof tt2.Buffer == "function") return tt2.Buffer.from(s3, "base64");
    if (typeof atob == "function") {
      let t4 = atob(s3.replace(/[\n\r]/g, "")), n3 = new Uint8Array(t4.length);
      for (let i4 = 0; i4 < t4.length; ++i4) n3[i4] = t4.charCodeAt(i4);
      return n3;
    } else return e5("This environment does not support reading binary tags; either Buffer or atob is required"), s3;
  }, stringify({ comment: s3, type: e5, value: t4 }, n3, i4, r2) {
    if (!t4) return "";
    let o2 = t4, a3;
    if (typeof tt2.Buffer == "function") a3 = o2 instanceof tt2.Buffer ? o2.toString("base64") : tt2.Buffer.from(o2.buffer).toString("base64");
    else if (typeof btoa == "function") {
      let l3 = "";
      for (let c3 = 0; c3 < o2.length; ++c3) l3 += String.fromCharCode(o2[c3]);
      a3 = btoa(l3);
    } else throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    if (e5 ?? (e5 = yn2.Scalar.BLOCK_LITERAL), e5 !== yn2.Scalar.QUOTE_DOUBLE) {
      let l3 = Math.max(n3.options.lineWidth - n3.indent.length, n3.options.minContentWidth), c3 = Math.ceil(a3.length / l3), u3 = new Array(c3);
      for (let f3 = 0, d3 = 0; f3 < c3; ++f3, d3 += l3) u3[f3] = a3.substr(d3, l3);
      a3 = u3.join(e5 === yn2.Scalar.BLOCK_LITERAL ? `
` : " ");
    }
    return _f.stringifyString({ comment: s3, type: e5, value: a3 }, n3, i4, r2);
  } };
  eo2.binary = xf;
});
var rs = o$4((is2) => {
  var ns2 = O$4(), wn2 = te$2(), Bf = C$2(), Ff = ie$1();
  function to2(s3, e5) {
    if (ns2.isSeq(s3)) for (let t4 = 0; t4 < s3.items.length; ++t4) {
      let n3 = s3.items[t4];
      if (!ns2.isPair(n3)) {
        if (ns2.isMap(n3)) {
          n3.items.length > 1 && e5("Each pair must have its own sequence indicator");
          let i4 = n3.items[0] || new wn2.Pair(new Bf.Scalar(null));
          if (n3.commentBefore && (i4.key.commentBefore = i4.key.commentBefore ? `${n3.commentBefore}
${i4.key.commentBefore}` : n3.commentBefore), n3.comment) {
            let r2 = i4.value ?? i4.key;
            r2.comment = r2.comment ? `${n3.comment}
${r2.comment}` : n3.comment;
          }
          n3 = i4;
        }
        s3.items[t4] = ns2.isPair(n3) ? n3 : new wn2.Pair(n3);
      }
    }
    else e5("Expected a sequence for this tag");
    return s3;
  }
  function so2(s3, e5, t4) {
    let { replacer: n3 } = t4, i4 = new Ff.YAMLSeq(s3);
    i4.tag = "tag:yaml.org,2002:pairs";
    let r2 = 0;
    if (e5 && Symbol.iterator in Object(e5)) for (let o2 of e5) {
      typeof n3 == "function" && (o2 = n3.call(e5, String(r2++), o2));
      let a3, l3;
      if (Array.isArray(o2)) if (o2.length === 2) a3 = o2[0], l3 = o2[1];
      else throw new TypeError(`Expected [key, value] tuple: ${o2}`);
      else if (o2 && o2 instanceof Object) {
        let c3 = Object.keys(o2);
        if (c3.length === 1) a3 = c3[0], l3 = o2[a3];
        else throw new TypeError(`Expected tuple with one key, not ${c3.length} keys`);
      } else a3 = o2;
      i4.items.push(wn2.createPair(a3, l3, t4));
    }
    return i4;
  }
  var jf = { collection: "seq", default: false, tag: "tag:yaml.org,2002:pairs", resolve: to2, createNode: so2 };
  is2.createPairs = so2;
  is2.pairs = jf;
  is2.resolvePairs = to2;
});
var En = o$4((Nn2) => {
  var no2 = O$4(), Sn2 = D$1(), st2 = ne$1(), Vf = ie$1(), io2 = rs(), de2 = class s3 extends Vf.YAMLSeq {
    constructor() {
      super(), this.add = st2.YAMLMap.prototype.add.bind(this), this.delete = st2.YAMLMap.prototype.delete.bind(this), this.get = st2.YAMLMap.prototype.get.bind(this), this.has = st2.YAMLMap.prototype.has.bind(this), this.set = st2.YAMLMap.prototype.set.bind(this), this.tag = s3.tag;
    }
    toJSON(e5, t4) {
      if (!t4) return super.toJSON(e5);
      let n3 = /* @__PURE__ */ new Map();
      t4?.onCreate && t4.onCreate(n3);
      for (let i4 of this.items) {
        let r2, o2;
        if (no2.isPair(i4) ? (r2 = Sn2.toJS(i4.key, "", t4), o2 = Sn2.toJS(i4.value, r2, t4)) : r2 = Sn2.toJS(i4, "", t4), n3.has(r2)) throw new Error("Ordered maps must not include duplicate keys");
        n3.set(r2, o2);
      }
      return n3;
    }
    static from(e5, t4, n3) {
      let i4 = io2.createPairs(e5, t4, n3), r2 = new this();
      return r2.items = i4.items, r2;
    }
  };
  de2.tag = "tag:yaml.org,2002:omap";
  var Kf = { collection: "seq", identify: (s3) => s3 instanceof Map, nodeClass: de2, default: false, tag: "tag:yaml.org,2002:omap", resolve(s3, e5) {
    let t4 = io2.resolvePairs(s3, e5), n3 = [];
    for (let { key: i4 } of t4.items) no2.isScalar(i4) && (n3.includes(i4.value) ? e5(`Ordered maps must not include duplicate keys: ${i4.value}`) : n3.push(i4.value));
    return Object.assign(new de2(), t4);
  }, createNode: (s3, e5, t4) => de2.from(s3, e5, t4) };
  Nn2.YAMLOMap = de2;
  Nn2.omap = Kf;
});
var co = o$4((vn2) => {
  var ro2 = C$2();
  function oo2({ value: s3, source: e5 }, t4) {
    return e5 && (s3 ? ao2 : lo2).test.test(e5) ? e5 : s3 ? t4.options.trueStr : t4.options.falseStr;
  }
  var ao2 = { identify: (s3) => s3 === true, default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/, resolve: () => new ro2.Scalar(true), stringify: oo2 }, lo2 = { identify: (s3) => s3 === false, default: true, tag: "tag:yaml.org,2002:bool", test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/, resolve: () => new ro2.Scalar(false), stringify: oo2 };
  vn2.falseTag = lo2;
  vn2.trueTag = ao2;
});
var fo = o$4((os2) => {
  var Rf = C$2(), An2 = Oe$1(), Yf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/, resolve: (s3) => s3.slice(-3).toLowerCase() === "nan" ? NaN : s3[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY, stringify: An2.stringifyNumber }, Uf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", format: "EXP", test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/, resolve: (s3) => parseFloat(s3.replace(/_/g, "")), stringify(s3) {
    let e5 = Number(s3.value);
    return isFinite(e5) ? e5.toExponential() : An2.stringifyNumber(s3);
  } }, Jf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/, resolve(s3) {
    let e5 = new Rf.Scalar(parseFloat(s3.replace(/_/g, ""))), t4 = s3.indexOf(".");
    if (t4 !== -1) {
      let n3 = s3.substring(t4 + 1).replace(/_/g, "");
      n3[n3.length - 1] === "0" && (e5.minFractionDigits = n3.length);
    }
    return e5;
  }, stringify: An2.stringifyNumber };
  os2.float = Jf;
  os2.floatExp = Uf;
  os2.floatNaN = Yf;
});
var ho = o$4((it2) => {
  var uo2 = Oe$1(), nt3 = (s3) => typeof s3 == "bigint" || Number.isInteger(s3);
  function as2(s3, e5, t4, { intAsBigInt: n3 }) {
    let i4 = s3[0];
    if ((i4 === "-" || i4 === "+") && (e5 += 1), s3 = s3.substring(e5).replace(/_/g, ""), n3) {
      switch (t4) {
        case 2:
          s3 = `0b${s3}`;
          break;
        case 8:
          s3 = `0o${s3}`;
          break;
        case 16:
          s3 = `0x${s3}`;
          break;
      }
      let o2 = BigInt(s3);
      return i4 === "-" ? BigInt(-1) * o2 : o2;
    }
    let r2 = parseInt(s3, t4);
    return i4 === "-" ? -1 * r2 : r2;
  }
  function Tn2(s3, e5, t4) {
    let { value: n3 } = s3;
    if (nt3(n3)) {
      let i4 = n3.toString(e5);
      return n3 < 0 ? "-" + t4 + i4.substr(1) : t4 + i4;
    }
    return uo2.stringifyNumber(s3);
  }
  var Wf = { identify: nt3, default: true, tag: "tag:yaml.org,2002:int", format: "BIN", test: /^[-+]?0b[0-1_]+$/, resolve: (s3, e5, t4) => as2(s3, 2, 2, t4), stringify: (s3) => Tn2(s3, 2, "0b") }, Gf = { identify: nt3, default: true, tag: "tag:yaml.org,2002:int", format: "OCT", test: /^[-+]?0[0-7_]+$/, resolve: (s3, e5, t4) => as2(s3, 1, 8, t4), stringify: (s3) => Tn2(s3, 8, "0") }, Xf = { identify: nt3, default: true, tag: "tag:yaml.org,2002:int", test: /^[-+]?[0-9][0-9_]*$/, resolve: (s3, e5, t4) => as2(s3, 0, 10, t4), stringify: uo2.stringifyNumber }, Qf = { identify: nt3, default: true, tag: "tag:yaml.org,2002:int", format: "HEX", test: /^[-+]?0x[0-9a-fA-F_]+$/, resolve: (s3, e5, t4) => as2(s3, 2, 16, t4), stringify: (s3) => Tn2(s3, 16, "0x") };
  it2.int = Xf;
  it2.intBin = Wf;
  it2.intHex = Qf;
  it2.intOct = Gf;
});
var kn = o$4((On2) => {
  var fs2 = O$4(), ls2 = te$2(), cs2 = ne$1(), he3 = class s3 extends cs2.YAMLMap {
    constructor(e5) {
      super(e5), this.tag = s3.tag;
    }
    add(e5) {
      let t4;
      fs2.isPair(e5) ? t4 = e5 : e5 && typeof e5 == "object" && "key" in e5 && "value" in e5 && e5.value === null ? t4 = new ls2.Pair(e5.key, null) : t4 = new ls2.Pair(e5, null), cs2.findPair(this.items, t4.key) || this.items.push(t4);
    }
    get(e5, t4) {
      let n3 = cs2.findPair(this.items, e5);
      return !t4 && fs2.isPair(n3) ? fs2.isScalar(n3.key) ? n3.key.value : n3.key : n3;
    }
    set(e5, t4) {
      if (typeof t4 != "boolean") throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof t4}`);
      let n3 = cs2.findPair(this.items, e5);
      n3 && !t4 ? this.items.splice(this.items.indexOf(n3), 1) : !n3 && t4 && this.items.push(new ls2.Pair(e5));
    }
    toJSON(e5, t4) {
      return super.toJSON(e5, t4, Set);
    }
    toString(e5, t4, n3) {
      if (!e5) return JSON.stringify(this);
      if (this.hasAllNullValues(true)) return super.toString(Object.assign({}, e5, { allNullValues: true }), t4, n3);
      throw new Error("Set items must all have null values");
    }
    static from(e5, t4, n3) {
      let { replacer: i4 } = n3, r2 = new this(e5);
      if (t4 && Symbol.iterator in Object(t4)) for (let o2 of t4) typeof i4 == "function" && (o2 = i4.call(t4, o2, o2)), r2.items.push(ls2.createPair(o2, null, n3));
      return r2;
    }
  };
  he3.tag = "tag:yaml.org,2002:set";
  var Hf = { collection: "map", identify: (s3) => s3 instanceof Set, nodeClass: he3, default: false, tag: "tag:yaml.org,2002:set", createNode: (s3, e5, t4) => he3.from(s3, e5, t4), resolve(s3, e5) {
    if (fs2.isMap(s3)) {
      if (s3.hasAllNullValues(true)) return Object.assign(new he3(), s3);
      e5("Set items must all have null values");
    } else e5("Expected a mapping for this tag");
    return s3;
  } };
  On2.YAMLSet = he3;
  On2.set = Hf;
});
var qn = o$4((us2) => {
  var Df = Oe$1();
  function In2(s3, e5) {
    let t4 = s3[0], n3 = t4 === "-" || t4 === "+" ? s3.substring(1) : s3, i4 = (o2) => e5 ? BigInt(o2) : Number(o2), r2 = n3.replace(/_/g, "").split(":").reduce((o2, a3) => o2 * i4(60) + i4(a3), i4(0));
    return t4 === "-" ? i4(-1) * r2 : r2;
  }
  function po2(s3) {
    let { value: e5 } = s3, t4 = (o2) => o2;
    if (typeof e5 == "bigint") t4 = (o2) => BigInt(o2);
    else if (isNaN(e5) || !isFinite(e5)) return Df.stringifyNumber(s3);
    let n3 = "";
    e5 < 0 && (n3 = "-", e5 *= t4(-1));
    let i4 = t4(60), r2 = [e5 % i4];
    return e5 < 60 ? r2.unshift(0) : (e5 = (e5 - r2[0]) / i4, r2.unshift(e5 % i4), e5 >= 60 && (e5 = (e5 - r2[0]) / i4, r2.unshift(e5))), n3 + r2.map((o2) => String(o2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
  }
  var Zf = { identify: (s3) => typeof s3 == "bigint" || Number.isInteger(s3), default: true, tag: "tag:yaml.org,2002:int", format: "TIME", test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/, resolve: (s3, e5, { intAsBigInt: t4 }) => In2(s3, t4), stringify: po2 }, zf = { identify: (s3) => typeof s3 == "number", default: true, tag: "tag:yaml.org,2002:float", format: "TIME", test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/, resolve: (s3) => In2(s3, false), stringify: po2 }, mo2 = { identify: (s3) => s3 instanceof Date, default: true, tag: "tag:yaml.org,2002:timestamp", test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"), resolve(s3) {
    let e5 = s3.match(mo2.test);
    if (!e5) throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    let [, t4, n3, i4, r2, o2, a3] = e5.map(Number), l3 = e5[7] ? Number((e5[7] + "00").substr(1, 3)) : 0, c3 = Date.UTC(t4, n3 - 1, i4, r2 || 0, o2 || 0, a3 || 0, l3), u3 = e5[8];
    if (u3 && u3 !== "Z") {
      let f3 = In2(u3, false);
      Math.abs(f3) < 30 && (f3 *= 60), c3 -= 6e4 * f3;
    }
    return new Date(c3);
  }, stringify: ({ value: s3 }) => s3?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? "" };
  us2.floatTime = zf;
  us2.intTime = Zf;
  us2.timestamp = mo2;
});
var bo = o$4((yo) => {
  var eu = Ae$1(), tu = Zt(), su = Te(), nu = et$1(), iu = bn(), go = co(), Cn2 = fo(), ds2 = ho(), ru = Ut(), ou = En(), au = rs(), lu = kn(), Ln2 = qn(), cu = [eu.map, su.seq, nu.string, tu.nullTag, go.trueTag, go.falseTag, ds2.intBin, ds2.intOct, ds2.int, ds2.intHex, Cn2.floatNaN, Cn2.floatExp, Cn2.float, iu.binary, ru.merge, ou.omap, au.pairs, lu.set, Ln2.intTime, Ln2.floatTime, Ln2.timestamp];
  yo.schema = cu;
});
var Io = o$4(($n2) => {
  var Eo = Ae$1(), fu = Zt(), vo = Te(), uu = et$1(), du = fn(), Pn2 = dn(), Mn2 = pn(), hu = Hr(), pu = zr(), Ao = bn(), rt2 = Ut(), To = En(), Oo = rs(), wo = bo(), ko = kn(), hs2 = qn(), So = /* @__PURE__ */ new Map([["core", hu.schema], ["failsafe", [Eo.map, vo.seq, uu.string]], ["json", pu.schema], ["yaml11", wo.schema], ["yaml-1.1", wo.schema]]), No = { binary: Ao.binary, bool: du.boolTag, float: Pn2.float, floatExp: Pn2.floatExp, floatNaN: Pn2.floatNaN, floatTime: hs2.floatTime, int: Mn2.int, intHex: Mn2.intHex, intOct: Mn2.intOct, intTime: hs2.intTime, map: Eo.map, merge: rt2.merge, null: fu.nullTag, omap: To.omap, pairs: Oo.pairs, seq: vo.seq, set: ko.set, timestamp: hs2.timestamp }, mu = { "tag:yaml.org,2002:binary": Ao.binary, "tag:yaml.org,2002:merge": rt2.merge, "tag:yaml.org,2002:omap": To.omap, "tag:yaml.org,2002:pairs": Oo.pairs, "tag:yaml.org,2002:set": ko.set, "tag:yaml.org,2002:timestamp": hs2.timestamp };
  function gu(s3, e5, t4) {
    let n3 = So.get(e5);
    if (n3 && !s3) return t4 && !n3.includes(rt2.merge) ? n3.concat(rt2.merge) : n3.slice();
    let i4 = n3;
    if (!i4) if (Array.isArray(s3)) i4 = [];
    else {
      let r2 = Array.from(So.keys()).filter((o2) => o2 !== "yaml11").map((o2) => JSON.stringify(o2)).join(", ");
      throw new Error(`Unknown schema "${e5}"; use one of ${r2} or define customTags array`);
    }
    if (Array.isArray(s3)) for (let r2 of s3) i4 = i4.concat(r2);
    else typeof s3 == "function" && (i4 = s3(i4.slice()));
    return t4 && (i4 = i4.concat(rt2.merge)), i4.reduce((r2, o2) => {
      let a3 = typeof o2 == "string" ? No[o2] : o2;
      if (!a3) {
        let l3 = JSON.stringify(o2), c3 = Object.keys(No).map((u3) => JSON.stringify(u3)).join(", ");
        throw new Error(`Unknown custom tag ${l3}; use one of ${c3}`);
      }
      return r2.includes(a3) || r2.push(a3), r2;
    }, []);
  }
  $n2.coreKnownTags = mu;
  $n2.getTags = gu;
});
var Bn = o$4((qo) => {
  var _n2 = O$4(), yu = Ae$1(), bu = Te(), wu = et$1(), ps2 = Io(), Su = (s3, e5) => s3.key < e5.key ? -1 : s3.key > e5.key ? 1 : 0, xn2 = class s3 {
    constructor({ compat: e5, customTags: t4, merge: n3, resolveKnownTags: i4, schema: r2, sortMapEntries: o2, toStringDefaults: a3 }) {
      this.compat = Array.isArray(e5) ? ps2.getTags(e5, "compat") : e5 ? ps2.getTags(null, e5) : null, this.name = typeof r2 == "string" && r2 || "core", this.knownTags = i4 ? ps2.coreKnownTags : {}, this.tags = ps2.getTags(t4, this.name, n3), this.toStringOptions = a3 ?? null, Object.defineProperty(this, _n2.MAP, { value: yu.map }), Object.defineProperty(this, _n2.SCALAR, { value: wu.string }), Object.defineProperty(this, _n2.SEQ, { value: bu.seq }), this.sortMapEntries = typeof o2 == "function" ? o2 : o2 === true ? Su : null;
    }
    clone() {
      let e5 = Object.create(s3.prototype, Object.getOwnPropertyDescriptors(this));
      return e5.tags = this.tags.slice(), e5;
    }
  };
  qo.Schema = xn2;
});
var Lo = o$4((Co) => {
  var Nu = O$4(), Fn2 = He$1(), ot2 = We$1();
  function Eu(s3, e5) {
    let t4 = [], n3 = e5.directives === true;
    if (e5.directives !== false && s3.directives) {
      let l3 = s3.directives.toString(s3);
      l3 ? (t4.push(l3), n3 = true) : s3.directives.docStart && (n3 = true);
    }
    n3 && t4.push("---");
    let i4 = Fn2.createStringifyContext(s3, e5), { commentString: r2 } = i4.options;
    if (s3.commentBefore) {
      t4.length !== 1 && t4.unshift("");
      let l3 = r2(s3.commentBefore);
      t4.unshift(ot2.indentComment(l3, ""));
    }
    let o2 = false, a3 = null;
    if (s3.contents) {
      if (Nu.isNode(s3.contents)) {
        if (s3.contents.spaceBefore && n3 && t4.push(""), s3.contents.commentBefore) {
          let u3 = r2(s3.contents.commentBefore);
          t4.push(ot2.indentComment(u3, ""));
        }
        i4.forceBlockIndent = !!s3.comment, a3 = s3.contents.comment;
      }
      let l3 = a3 ? void 0 : () => o2 = true, c3 = Fn2.stringify(s3.contents, i4, () => a3 = null, l3);
      a3 && (c3 += ot2.lineComment(c3, "", r2(a3))), (c3[0] === "|" || c3[0] === ">") && t4[t4.length - 1] === "---" ? t4[t4.length - 1] = `--- ${c3}` : t4.push(c3);
    } else t4.push(Fn2.stringify(s3.contents, i4));
    if (s3.directives?.docEnd) if (s3.comment) {
      let l3 = r2(s3.comment);
      l3.includes(`
`) ? (t4.push("..."), t4.push(ot2.indentComment(l3, ""))) : t4.push(`... ${l3}`);
    } else t4.push("...");
    else {
      let l3 = s3.comment;
      l3 && o2 && (l3 = l3.replace(/^\n+/, "")), l3 && ((!o2 || a3) && t4[t4.length - 1] !== "" && t4.push(""), t4.push(ot2.indentComment(r2(l3), "")));
    }
    return t4.join(`
`) + `
`;
  }
  Co.stringifyDocument = Eu;
});
var at = o$4((Po) => {
  var vu = Ue$1(), ke2 = _t(), K2 = O$4(), Au = te$2(), Tu = D$1(), Ou = Bn(), ku = Lo(), jn2 = Lt(), Iu = Rs(), qu = Je$1(), Vn2 = Ks(), Kn2 = class s3 {
    constructor(e5, t4, n3) {
      this.commentBefore = null, this.comment = null, this.errors = [], this.warnings = [], Object.defineProperty(this, K2.NODE_TYPE, { value: K2.DOC });
      let i4 = null;
      typeof t4 == "function" || Array.isArray(t4) ? i4 = t4 : n3 === void 0 && t4 && (n3 = t4, t4 = void 0);
      let r2 = Object.assign({ intAsBigInt: false, keepSourceTokens: false, logLevel: "warn", prettyErrors: true, strict: true, stringKeys: false, uniqueKeys: true, version: "1.2" }, n3);
      this.options = r2;
      let { version: o2 } = r2;
      n3?._directives ? (this.directives = n3._directives.atDocument(), this.directives.yaml.explicit && (o2 = this.directives.yaml.version)) : this.directives = new Vn2.Directives({ version: o2 }), this.setSchema(o2, n3), this.contents = e5 === void 0 ? null : this.createNode(e5, i4, n3);
    }
    clone() {
      let e5 = Object.create(s3.prototype, { [K2.NODE_TYPE]: { value: K2.DOC } });
      return e5.commentBefore = this.commentBefore, e5.comment = this.comment, e5.errors = this.errors.slice(), e5.warnings = this.warnings.slice(), e5.options = Object.assign({}, this.options), this.directives && (e5.directives = this.directives.clone()), e5.schema = this.schema.clone(), e5.contents = K2.isNode(this.contents) ? this.contents.clone(e5.schema) : this.contents, this.range && (e5.range = this.range.slice()), e5;
    }
    add(e5) {
      Ie2(this.contents) && this.contents.add(e5);
    }
    addIn(e5, t4) {
      Ie2(this.contents) && this.contents.addIn(e5, t4);
    }
    createAlias(e5, t4) {
      if (!e5.anchor) {
        let n3 = jn2.anchorNames(this);
        e5.anchor = !t4 || n3.has(t4) ? jn2.findNewAnchor(t4 || "a", n3) : t4;
      }
      return new vu.Alias(e5.anchor);
    }
    createNode(e5, t4, n3) {
      let i4;
      if (typeof t4 == "function") e5 = t4.call({ "": e5 }, "", e5), i4 = t4;
      else if (Array.isArray(t4)) {
        let m3 = (S3) => typeof S3 == "number" || S3 instanceof String || S3 instanceof Number, y2 = t4.filter(m3).map(String);
        y2.length > 0 && (t4 = t4.concat(y2)), i4 = t4;
      } else n3 === void 0 && t4 && (n3 = t4, t4 = void 0);
      let { aliasDuplicateObjects: r2, anchorPrefix: o2, flow: a3, keepUndefined: l3, onTagObj: c3, tag: u3 } = n3 ?? {}, { onAnchor: f3, setAnchors: d3, sourceObjects: p3 } = jn2.createNodeAnchors(this, o2 || "a"), g2 = { aliasDuplicateObjects: r2 ?? true, keepUndefined: l3 ?? false, onAnchor: f3, onTagObj: c3, replacer: i4, schema: this.schema, sourceObjects: p3 }, h3 = qu.createNode(e5, u3, g2);
      return a3 && K2.isCollection(h3) && (h3.flow = true), d3(), h3;
    }
    createPair(e5, t4, n3 = {}) {
      let i4 = this.createNode(e5, null, n3), r2 = this.createNode(t4, null, n3);
      return new Au.Pair(i4, r2);
    }
    delete(e5) {
      return Ie2(this.contents) ? this.contents.delete(e5) : false;
    }
    deleteIn(e5) {
      return ke2.isEmptyPath(e5) ? this.contents == null ? false : (this.contents = null, true) : Ie2(this.contents) ? this.contents.deleteIn(e5) : false;
    }
    get(e5, t4) {
      return K2.isCollection(this.contents) ? this.contents.get(e5, t4) : void 0;
    }
    getIn(e5, t4) {
      return ke2.isEmptyPath(e5) ? !t4 && K2.isScalar(this.contents) ? this.contents.value : this.contents : K2.isCollection(this.contents) ? this.contents.getIn(e5, t4) : void 0;
    }
    has(e5) {
      return K2.isCollection(this.contents) ? this.contents.has(e5) : false;
    }
    hasIn(e5) {
      return ke2.isEmptyPath(e5) ? this.contents !== void 0 : K2.isCollection(this.contents) ? this.contents.hasIn(e5) : false;
    }
    set(e5, t4) {
      this.contents == null ? this.contents = ke2.collectionFromPath(this.schema, [e5], t4) : Ie2(this.contents) && this.contents.set(e5, t4);
    }
    setIn(e5, t4) {
      ke2.isEmptyPath(e5) ? this.contents = t4 : this.contents == null ? this.contents = ke2.collectionFromPath(this.schema, Array.from(e5), t4) : Ie2(this.contents) && this.contents.setIn(e5, t4);
    }
    setSchema(e5, t4 = {}) {
      typeof e5 == "number" && (e5 = String(e5));
      let n3;
      switch (e5) {
        case "1.1":
          this.directives ? this.directives.yaml.version = "1.1" : this.directives = new Vn2.Directives({ version: "1.1" }), n3 = { resolveKnownTags: false, schema: "yaml-1.1" };
          break;
        case "1.2":
        case "next":
          this.directives ? this.directives.yaml.version = e5 : this.directives = new Vn2.Directives({ version: e5 }), n3 = { resolveKnownTags: true, schema: "core" };
          break;
        case null:
          this.directives && delete this.directives, n3 = null;
          break;
        default: {
          let i4 = JSON.stringify(e5);
          throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${i4}`);
        }
      }
      if (t4.schema instanceof Object) this.schema = t4.schema;
      else if (n3) this.schema = new Ou.Schema(Object.assign(n3, t4));
      else throw new Error("With a null YAML version, the { schema: Schema } option is required");
    }
    toJS({ json: e5, jsonArg: t4, mapAsMap: n3, maxAliasCount: i4, onAnchor: r2, reviver: o2 } = {}) {
      let a3 = { anchors: /* @__PURE__ */ new Map(), doc: this, keep: !e5, mapAsMap: n3 === true, mapKeyWarned: false, maxAliasCount: typeof i4 == "number" ? i4 : 100 }, l3 = Tu.toJS(this.contents, t4 ?? "", a3);
      if (typeof r2 == "function") for (let { count: c3, res: u3 } of a3.anchors.values()) r2(u3, c3);
      return typeof o2 == "function" ? Iu.applyReviver(o2, { "": l3 }, "", l3) : l3;
    }
    toJSON(e5, t4) {
      return this.toJS({ json: true, jsonArg: e5, mapAsMap: false, onAnchor: t4 });
    }
    toString(e5 = {}) {
      if (this.errors.length > 0) throw new Error("Document with errors cannot be stringified");
      if ("indent" in e5 && (!Number.isInteger(e5.indent) || Number(e5.indent) <= 0)) {
        let t4 = JSON.stringify(e5.indent);
        throw new Error(`"indent" option must be a positive integer, not ${t4}`);
      }
      return ku.stringifyDocument(this, e5);
    }
  };
  function Ie2(s3) {
    if (K2.isCollection(s3)) return true;
    throw new Error("Expected a YAML collection as document contents");
  }
  Po.Document = Kn2;
});
var ft = o$4((ct2) => {
  var lt2 = class extends Error {
    constructor(e5, t4, n3, i4) {
      super(), this.name = e5, this.code = n3, this.message = i4, this.pos = t4;
    }
  }, Rn2 = class extends lt2 {
    constructor(e5, t4, n3) {
      super("YAMLParseError", e5, t4, n3);
    }
  }, Yn2 = class extends lt2 {
    constructor(e5, t4, n3) {
      super("YAMLWarning", e5, t4, n3);
    }
  }, Cu = (s3, e5) => (t4) => {
    if (t4.pos[0] === -1) return;
    t4.linePos = t4.pos.map((a3) => e5.linePos(a3));
    let { line: n3, col: i4 } = t4.linePos[0];
    t4.message += ` at line ${n3}, column ${i4}`;
    let r2 = i4 - 1, o2 = s3.substring(e5.lineStarts[n3 - 1], e5.lineStarts[n3]).replace(/[\n\r]+$/, "");
    if (r2 >= 60 && o2.length > 80) {
      let a3 = Math.min(r2 - 39, o2.length - 79);
      o2 = "" + o2.substring(a3), r2 -= a3 - 1;
    }
    if (o2.length > 80 && (o2 = o2.substring(0, 79) + ""), n3 > 1 && /^ *$/.test(o2.substring(0, r2))) {
      let a3 = s3.substring(e5.lineStarts[n3 - 2], e5.lineStarts[n3 - 1]);
      a3.length > 80 && (a3 = a3.substring(0, 79) + `
`), o2 = a3 + o2;
    }
    if (/[^ ]/.test(o2)) {
      let a3 = 1, l3 = t4.linePos[1];
      l3?.line === n3 && l3.col > i4 && (a3 = Math.max(1, Math.min(l3.col - i4, 80 - r2)));
      let c3 = " ".repeat(r2) + "^".repeat(a3);
      t4.message += `:

${o2}
${c3}
`;
    }
  };
  ct2.YAMLError = lt2;
  ct2.YAMLParseError = Rn2;
  ct2.YAMLWarning = Yn2;
  ct2.prettifyError = Cu;
});
var ut = o$4((Mo) => {
  function Lu(s3, { flow: e5, indicator: t4, next: n3, offset: i4, onError: r2, parentIndent: o2, startOnNewline: a3 }) {
    let l3 = false, c3 = a3, u3 = a3, f3 = "", d3 = "", p3 = false, g2 = false, h3 = null, m3 = null, y2 = null, S3 = null, N2 = null, E2 = null, v2 = null;
    for (let w4 of s3) switch (g2 && (w4.type !== "space" && w4.type !== "newline" && w4.type !== "comma" && r2(w4.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), g2 = false), h3 && (c3 && w4.type !== "comment" && w4.type !== "newline" && r2(h3, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), h3 = null), w4.type) {
      case "space":
        !e5 && (t4 !== "doc-start" || n3?.type !== "flow-collection") && w4.source.includes("	") && (h3 = w4), u3 = true;
        break;
      case "comment": {
        u3 || r2(w4, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        let L4 = w4.source.substring(1) || " ";
        f3 ? f3 += d3 + L4 : f3 = L4, d3 = "", c3 = false;
        break;
      }
      case "newline":
        c3 ? f3 ? f3 += w4.source : (!E2 || t4 !== "seq-item-ind") && (l3 = true) : d3 += w4.source, c3 = true, p3 = true, (m3 || y2) && (S3 = w4), u3 = true;
        break;
      case "anchor":
        m3 && r2(w4, "MULTIPLE_ANCHORS", "A node can have at most one anchor"), w4.source.endsWith(":") && r2(w4.offset + w4.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true), m3 = w4, v2 ?? (v2 = w4.offset), c3 = false, u3 = false, g2 = true;
        break;
      case "tag": {
        y2 && r2(w4, "MULTIPLE_TAGS", "A node can have at most one tag"), y2 = w4, v2 ?? (v2 = w4.offset), c3 = false, u3 = false, g2 = true;
        break;
      }
      case t4:
        (m3 || y2) && r2(w4, "BAD_PROP_ORDER", `Anchors and tags must be after the ${w4.source} indicator`), E2 && r2(w4, "UNEXPECTED_TOKEN", `Unexpected ${w4.source} in ${e5 ?? "collection"}`), E2 = w4, c3 = t4 === "seq-item-ind" || t4 === "explicit-key-ind", u3 = false;
        break;
      case "comma":
        if (e5) {
          N2 && r2(w4, "UNEXPECTED_TOKEN", `Unexpected , in ${e5}`), N2 = w4, c3 = false, u3 = false;
          break;
        }
      default:
        r2(w4, "UNEXPECTED_TOKEN", `Unexpected ${w4.type} token`), c3 = false, u3 = false;
    }
    let A2 = s3[s3.length - 1], I2 = A2 ? A2.offset + A2.source.length : i4;
    return g2 && n3 && n3.type !== "space" && n3.type !== "newline" && n3.type !== "comma" && (n3.type !== "scalar" || n3.source !== "") && r2(n3.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space"), h3 && (c3 && h3.indent <= o2 || n3?.type === "block-map" || n3?.type === "block-seq") && r2(h3, "TAB_AS_INDENT", "Tabs are not allowed as indentation"), { comma: N2, found: E2, spaceBefore: l3, comment: f3, hasNewline: p3, anchor: m3, tag: y2, newlineAfterProp: S3, end: I2, start: v2 ?? I2 };
  }
  Mo.resolveProps = Lu;
});
var ms = o$4(($o) => {
  function Un2(s3) {
    if (!s3) return null;
    switch (s3.type) {
      case "alias":
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        if (s3.source.includes(`
`)) return true;
        if (s3.end) {
          for (let e5 of s3.end) if (e5.type === "newline") return true;
        }
        return false;
      case "flow-collection":
        for (let e5 of s3.items) {
          for (let t4 of e5.start) if (t4.type === "newline") return true;
          if (e5.sep) {
            for (let t4 of e5.sep) if (t4.type === "newline") return true;
          }
          if (Un2(e5.key) || Un2(e5.value)) return true;
        }
        return false;
      default:
        return true;
    }
  }
  $o.containsNewline = Un2;
});
var Jn = o$4((_o) => {
  var Pu = ms();
  function Mu(s3, e5, t4) {
    if (e5?.type === "flow-collection") {
      let n3 = e5.end[0];
      n3.indent === s3 && (n3.source === "]" || n3.source === "}") && Pu.containsNewline(e5) && t4(n3, "BAD_INDENT", "Flow end indicator should be more indented than parent", true);
    }
  }
  _o.flowIndentCheck = Mu;
});
var Wn = o$4((Bo) => {
  var xo = O$4();
  function $u(s3, e5, t4) {
    let { uniqueKeys: n3 } = s3.options;
    if (n3 === false) return false;
    let i4 = typeof n3 == "function" ? n3 : (r2, o2) => r2 === o2 || xo.isScalar(r2) && xo.isScalar(o2) && r2.value === o2.value;
    return e5.some((r2) => i4(r2.key, t4));
  }
  Bo.mapIncludes = $u;
});
var Yo = o$4((Ro) => {
  var Fo = te$2(), _u = ne$1(), jo = ut(), xu = ms(), Vo = Jn(), Bu = Wn(), Ko = "All mapping items must start at the same column";
  function Fu({ composeNode: s3, composeEmptyNode: e5 }, t4, n3, i4, r2) {
    let o2 = r2?.nodeClass ?? _u.YAMLMap, a3 = new o2(t4.schema);
    t4.atRoot && (t4.atRoot = false);
    let l3 = n3.offset, c3 = null;
    for (let u3 of n3.items) {
      let { start: f3, key: d3, sep: p3, value: g2 } = u3, h3 = jo.resolveProps(f3, { indicator: "explicit-key-ind", next: d3 ?? p3?.[0], offset: l3, onError: i4, parentIndent: n3.indent, startOnNewline: true }), m3 = !h3.found;
      if (m3) {
        if (d3 && (d3.type === "block-seq" ? i4(l3, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key") : "indent" in d3 && d3.indent !== n3.indent && i4(l3, "BAD_INDENT", Ko)), !h3.anchor && !h3.tag && !p3) {
          c3 = h3.end, h3.comment && (a3.comment ? a3.comment += `
` + h3.comment : a3.comment = h3.comment);
          continue;
        }
        (h3.newlineAfterProp || xu.containsNewline(d3)) && i4(d3 ?? f3[f3.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      } else h3.found?.indent !== n3.indent && i4(l3, "BAD_INDENT", Ko);
      t4.atKey = true;
      let y2 = h3.end, S3 = d3 ? s3(t4, d3, h3, i4) : e5(t4, y2, f3, null, h3, i4);
      t4.schema.compat && Vo.flowIndentCheck(n3.indent, d3, i4), t4.atKey = false, Bu.mapIncludes(t4, a3.items, S3) && i4(y2, "DUPLICATE_KEY", "Map keys must be unique");
      let N2 = jo.resolveProps(p3 ?? [], { indicator: "map-value-ind", next: g2, offset: S3.range[2], onError: i4, parentIndent: n3.indent, startOnNewline: !d3 || d3.type === "block-scalar" });
      if (l3 = N2.end, N2.found) {
        m3 && (g2?.type === "block-map" && !N2.hasNewline && i4(l3, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings"), t4.options.strict && h3.start < N2.found.offset - 1024 && i4(S3.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key"));
        let E2 = g2 ? s3(t4, g2, N2, i4) : e5(t4, l3, p3, null, N2, i4);
        t4.schema.compat && Vo.flowIndentCheck(n3.indent, g2, i4), l3 = E2.range[2];
        let v2 = new Fo.Pair(S3, E2);
        t4.options.keepSourceTokens && (v2.srcToken = u3), a3.items.push(v2);
      } else {
        m3 && i4(S3.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values"), N2.comment && (S3.comment ? S3.comment += `
` + N2.comment : S3.comment = N2.comment);
        let E2 = new Fo.Pair(S3);
        t4.options.keepSourceTokens && (E2.srcToken = u3), a3.items.push(E2);
      }
    }
    return c3 && c3 < l3 && i4(c3, "IMPOSSIBLE", "Map comment with trailing content"), a3.range = [n3.offset, l3, c3 ?? l3], a3;
  }
  Ro.resolveBlockMap = Fu;
});
var Jo = o$4((Uo) => {
  var ju = ie$1(), Vu = ut(), Ku = Jn();
  function Ru({ composeNode: s3, composeEmptyNode: e5 }, t4, n3, i4, r2) {
    let o2 = r2?.nodeClass ?? ju.YAMLSeq, a3 = new o2(t4.schema);
    t4.atRoot && (t4.atRoot = false), t4.atKey && (t4.atKey = false);
    let l3 = n3.offset, c3 = null;
    for (let { start: u3, value: f3 } of n3.items) {
      let d3 = Vu.resolveProps(u3, { indicator: "seq-item-ind", next: f3, offset: l3, onError: i4, parentIndent: n3.indent, startOnNewline: true });
      if (!d3.found) if (d3.anchor || d3.tag || f3) f3?.type === "block-seq" ? i4(d3.end, "BAD_INDENT", "All sequence items must start at the same column") : i4(l3, "MISSING_CHAR", "Sequence item without - indicator");
      else {
        c3 = d3.end, d3.comment && (a3.comment = d3.comment);
        continue;
      }
      let p3 = f3 ? s3(t4, f3, d3, i4) : e5(t4, d3.end, u3, null, d3, i4);
      t4.schema.compat && Ku.flowIndentCheck(n3.indent, f3, i4), l3 = p3.range[2], a3.items.push(p3);
    }
    return a3.range = [n3.offset, l3, c3 ?? l3], a3;
  }
  Uo.resolveBlockSeq = Ru;
});
var qe$1 = o$4((Wo) => {
  function Yu(s3, e5, t4, n3) {
    let i4 = "";
    if (s3) {
      let r2 = false, o2 = "";
      for (let a3 of s3) {
        let { source: l3, type: c3 } = a3;
        switch (c3) {
          case "space":
            r2 = true;
            break;
          case "comment": {
            t4 && !r2 && n3(a3, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            let u3 = l3.substring(1) || " ";
            i4 ? i4 += o2 + u3 : i4 = u3, o2 = "";
            break;
          }
          case "newline":
            i4 && (o2 += l3), r2 = true;
            break;
          default:
            n3(a3, "UNEXPECTED_TOKEN", `Unexpected ${c3} at node end`);
        }
        e5 += l3.length;
      }
    }
    return { comment: i4, offset: e5 };
  }
  Wo.resolveEnd = Yu;
});
var Ho = o$4((Qo) => {
  var Uu = O$4(), Ju = te$2(), Go = ne$1(), Wu = ie$1(), Gu = qe$1(), Xo = ut(), Xu = ms(), Qu = Wn(), Gn2 = "Block collections are not allowed within flow collections", Xn2 = (s3) => s3 && (s3.type === "block-map" || s3.type === "block-seq");
  function Hu({ composeNode: s3, composeEmptyNode: e5 }, t4, n3, i4, r2) {
    let o2 = n3.start.source === "{", a3 = o2 ? "flow map" : "flow sequence", l3 = r2?.nodeClass ?? (o2 ? Go.YAMLMap : Wu.YAMLSeq), c3 = new l3(t4.schema);
    c3.flow = true;
    let u3 = t4.atRoot;
    u3 && (t4.atRoot = false), t4.atKey && (t4.atKey = false);
    let f3 = n3.offset + n3.start.source.length;
    for (let m3 = 0; m3 < n3.items.length; ++m3) {
      let y2 = n3.items[m3], { start: S3, key: N2, sep: E2, value: v2 } = y2, A2 = Xo.resolveProps(S3, { flow: a3, indicator: "explicit-key-ind", next: N2 ?? E2?.[0], offset: f3, onError: i4, parentIndent: n3.indent, startOnNewline: false });
      if (!A2.found) {
        if (!A2.anchor && !A2.tag && !E2 && !v2) {
          m3 === 0 && A2.comma ? i4(A2.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a3}`) : m3 < n3.items.length - 1 && i4(A2.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${a3}`), A2.comment && (c3.comment ? c3.comment += `
` + A2.comment : c3.comment = A2.comment), f3 = A2.end;
          continue;
        }
        !o2 && t4.options.strict && Xu.containsNewline(N2) && i4(N2, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
      }
      if (m3 === 0) A2.comma && i4(A2.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${a3}`);
      else if (A2.comma || i4(A2.start, "MISSING_CHAR", `Missing , between ${a3} items`), A2.comment) {
        let I2 = "";
        e: for (let w4 of S3) switch (w4.type) {
          case "comma":
          case "space":
            break;
          case "comment":
            I2 = w4.source.substring(1);
            break e;
          default:
            break e;
        }
        if (I2) {
          let w4 = c3.items[c3.items.length - 1];
          Uu.isPair(w4) && (w4 = w4.value ?? w4.key), w4.comment ? w4.comment += `
` + I2 : w4.comment = I2, A2.comment = A2.comment.substring(I2.length + 1);
        }
      }
      if (!o2 && !E2 && !A2.found) {
        let I2 = v2 ? s3(t4, v2, A2, i4) : e5(t4, A2.end, E2, null, A2, i4);
        c3.items.push(I2), f3 = I2.range[2], Xn2(v2) && i4(I2.range, "BLOCK_IN_FLOW", Gn2);
      } else {
        t4.atKey = true;
        let I2 = A2.end, w4 = N2 ? s3(t4, N2, A2, i4) : e5(t4, I2, S3, null, A2, i4);
        Xn2(N2) && i4(w4.range, "BLOCK_IN_FLOW", Gn2), t4.atKey = false;
        let L4 = Xo.resolveProps(E2 ?? [], { flow: a3, indicator: "map-value-ind", next: v2, offset: w4.range[2], onError: i4, parentIndent: n3.indent, startOnNewline: false });
        if (L4.found) {
          if (!o2 && !A2.found && t4.options.strict) {
            if (E2) for (let P2 of E2) {
              if (P2 === L4.found) break;
              if (P2.type === "newline") {
                i4(P2, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
            A2.start < L4.found.offset - 1024 && i4(L4.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
          }
        } else v2 && ("source" in v2 && v2.source?.[0] === ":" ? i4(v2, "MISSING_CHAR", `Missing space after : in ${a3}`) : i4(L4.start, "MISSING_CHAR", `Missing , or : between ${a3} items`));
        let H2 = v2 ? s3(t4, v2, L4, i4) : L4.found ? e5(t4, L4.end, E2, null, L4, i4) : null;
        H2 ? Xn2(v2) && i4(H2.range, "BLOCK_IN_FLOW", Gn2) : L4.comment && (w4.comment ? w4.comment += `
` + L4.comment : w4.comment = L4.comment);
        let ge2 = new Ju.Pair(w4, H2);
        if (t4.options.keepSourceTokens && (ge2.srcToken = y2), o2) {
          let P2 = c3;
          Qu.mapIncludes(t4, P2.items, w4) && i4(I2, "DUPLICATE_KEY", "Map keys must be unique"), P2.items.push(ge2);
        } else {
          let P2 = new Go.YAMLMap(t4.schema);
          P2.flow = true, P2.items.push(ge2);
          let vi2 = (H2 ?? w4).range;
          P2.range = [w4.range[0], vi2[1], vi2[2]], c3.items.push(P2);
        }
        f3 = H2 ? H2.range[2] : L4.end;
      }
    }
    let d3 = o2 ? "}" : "]", [p3, ...g2] = n3.end, h3 = f3;
    if (p3?.source === d3) h3 = p3.offset + p3.source.length;
    else {
      let m3 = a3[0].toUpperCase() + a3.substring(1), y2 = u3 ? `${m3} must end with a ${d3}` : `${m3} in block collection must be sufficiently indented and end with a ${d3}`;
      i4(f3, u3 ? "MISSING_CHAR" : "BAD_INDENT", y2), p3 && p3.source.length !== 1 && g2.unshift(p3);
    }
    if (g2.length > 0) {
      let m3 = Gu.resolveEnd(g2, h3, t4.options.strict, i4);
      m3.comment && (c3.comment ? c3.comment += `
` + m3.comment : c3.comment = m3.comment), c3.range = [n3.offset, h3, m3.offset];
    } else c3.range = [n3.offset, h3, h3];
    return c3;
  }
  Qo.resolveFlowCollection = Hu;
});
var Zo = o$4((Do) => {
  var Du = O$4(), Zu = C$2(), zu = ne$1(), ed = ie$1(), td = Yo(), sd = Jo(), nd = Ho();
  function Qn2(s3, e5, t4, n3, i4, r2) {
    let o2 = t4.type === "block-map" ? td.resolveBlockMap(s3, e5, t4, n3, r2) : t4.type === "block-seq" ? sd.resolveBlockSeq(s3, e5, t4, n3, r2) : nd.resolveFlowCollection(s3, e5, t4, n3, r2), a3 = o2.constructor;
    return i4 === "!" || i4 === a3.tagName ? (o2.tag = a3.tagName, o2) : (i4 && (o2.tag = i4), o2);
  }
  function id(s3, e5, t4, n3, i4) {
    let r2 = n3.tag, o2 = r2 ? e5.directives.tagName(r2.source, (d3) => i4(r2, "TAG_RESOLVE_FAILED", d3)) : null;
    if (t4.type === "block-seq") {
      let { anchor: d3, newlineAfterProp: p3 } = n3, g2 = d3 && r2 ? d3.offset > r2.offset ? d3 : r2 : d3 ?? r2;
      g2 && (!p3 || p3.offset < g2.offset) && i4(g2, "MISSING_CHAR", "Missing newline after block sequence props");
    }
    let a3 = t4.type === "block-map" ? "map" : t4.type === "block-seq" ? "seq" : t4.start.source === "{" ? "map" : "seq";
    if (!r2 || !o2 || o2 === "!" || o2 === zu.YAMLMap.tagName && a3 === "map" || o2 === ed.YAMLSeq.tagName && a3 === "seq") return Qn2(s3, e5, t4, i4, o2);
    let l3 = e5.schema.tags.find((d3) => d3.tag === o2 && d3.collection === a3);
    if (!l3) {
      let d3 = e5.schema.knownTags[o2];
      if (d3?.collection === a3) e5.schema.tags.push(Object.assign({}, d3, { default: false })), l3 = d3;
      else return d3 ? i4(r2, "BAD_COLLECTION_TYPE", `${d3.tag} used for ${a3} collection, but expects ${d3.collection ?? "scalar"}`, true) : i4(r2, "TAG_RESOLVE_FAILED", `Unresolved tag: ${o2}`, true), Qn2(s3, e5, t4, i4, o2);
    }
    let c3 = Qn2(s3, e5, t4, i4, o2, l3), u3 = l3.resolve?.(c3, (d3) => i4(r2, "TAG_RESOLVE_FAILED", d3), e5.options) ?? c3, f3 = Du.isNode(u3) ? u3 : new Zu.Scalar(u3);
    return f3.range = c3.range, f3.tag = o2, l3?.format && (f3.format = l3.format), f3;
  }
  Do.composeCollection = id;
});
var Dn = o$4((zo) => {
  var Hn2 = C$2();
  function rd(s3, e5, t4) {
    let n3 = e5.offset, i4 = od(e5, s3.options.strict, t4);
    if (!i4) return { value: "", type: null, comment: "", range: [n3, n3, n3] };
    let r2 = i4.mode === ">" ? Hn2.Scalar.BLOCK_FOLDED : Hn2.Scalar.BLOCK_LITERAL, o2 = e5.source ? ad(e5.source) : [], a3 = o2.length;
    for (let h3 = o2.length - 1; h3 >= 0; --h3) {
      let m3 = o2[h3][1];
      if (m3 === "" || m3 === "\r") a3 = h3;
      else break;
    }
    if (a3 === 0) {
      let h3 = i4.chomp === "+" && o2.length > 0 ? `
`.repeat(Math.max(1, o2.length - 1)) : "", m3 = n3 + i4.length;
      return e5.source && (m3 += e5.source.length), { value: h3, type: r2, comment: i4.comment, range: [n3, m3, m3] };
    }
    let l3 = e5.indent + i4.indent, c3 = e5.offset + i4.length, u3 = 0;
    for (let h3 = 0; h3 < a3; ++h3) {
      let [m3, y2] = o2[h3];
      if (y2 === "" || y2 === "\r") i4.indent === 0 && m3.length > l3 && (l3 = m3.length);
      else {
        m3.length < l3 && t4(c3 + m3.length, "MISSING_CHAR", "Block scalars with more-indented leading empty lines must use an explicit indentation indicator"), i4.indent === 0 && (l3 = m3.length), u3 = h3, l3 === 0 && !s3.atRoot && t4(c3, "BAD_INDENT", "Block scalar values in collections must be indented");
        break;
      }
      c3 += m3.length + y2.length + 1;
    }
    for (let h3 = o2.length - 1; h3 >= a3; --h3) o2[h3][0].length > l3 && (a3 = h3 + 1);
    let f3 = "", d3 = "", p3 = false;
    for (let h3 = 0; h3 < u3; ++h3) f3 += o2[h3][0].slice(l3) + `
`;
    for (let h3 = u3; h3 < a3; ++h3) {
      let [m3, y2] = o2[h3];
      c3 += m3.length + y2.length + 1;
      let S3 = y2[y2.length - 1] === "\r";
      if (S3 && (y2 = y2.slice(0, -1)), y2 && m3.length < l3) {
        let E2 = `Block scalar lines must not be less indented than their ${i4.indent ? "explicit indentation indicator" : "first line"}`;
        t4(c3 - y2.length - (S3 ? 2 : 1), "BAD_INDENT", E2), m3 = "";
      }
      r2 === Hn2.Scalar.BLOCK_LITERAL ? (f3 += d3 + m3.slice(l3) + y2, d3 = `
`) : m3.length > l3 || y2[0] === "	" ? (d3 === " " ? d3 = `
` : !p3 && d3 === `
` && (d3 = `

`), f3 += d3 + m3.slice(l3) + y2, d3 = `
`, p3 = true) : y2 === "" ? d3 === `
` ? f3 += `
` : d3 = `
` : (f3 += d3 + y2, d3 = " ", p3 = false);
    }
    switch (i4.chomp) {
      case "-":
        break;
      case "+":
        for (let h3 = a3; h3 < o2.length; ++h3) f3 += `
` + o2[h3][0].slice(l3);
        f3[f3.length - 1] !== `
` && (f3 += `
`);
        break;
      default:
        f3 += `
`;
    }
    let g2 = n3 + i4.length + e5.source.length;
    return { value: f3, type: r2, comment: i4.comment, range: [n3, g2, g2] };
  }
  function od({ offset: s3, props: e5 }, t4, n3) {
    if (e5[0].type !== "block-scalar-header") return n3(e5[0], "IMPOSSIBLE", "Block scalar header not found"), null;
    let { source: i4 } = e5[0], r2 = i4[0], o2 = 0, a3 = "", l3 = -1;
    for (let d3 = 1; d3 < i4.length; ++d3) {
      let p3 = i4[d3];
      if (!a3 && (p3 === "-" || p3 === "+")) a3 = p3;
      else {
        let g2 = Number(p3);
        !o2 && g2 ? o2 = g2 : l3 === -1 && (l3 = s3 + d3);
      }
    }
    l3 !== -1 && n3(l3, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${i4}`);
    let c3 = false, u3 = "", f3 = i4.length;
    for (let d3 = 1; d3 < e5.length; ++d3) {
      let p3 = e5[d3];
      switch (p3.type) {
        case "space":
          c3 = true;
        case "newline":
          f3 += p3.source.length;
          break;
        case "comment":
          t4 && !c3 && n3(p3, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters"), f3 += p3.source.length, u3 = p3.source.substring(1);
          break;
        case "error":
          n3(p3, "UNEXPECTED_TOKEN", p3.message), f3 += p3.source.length;
          break;
        default: {
          let g2 = `Unexpected token in block scalar header: ${p3.type}`;
          n3(p3, "UNEXPECTED_TOKEN", g2);
          let h3 = p3.source;
          h3 && typeof h3 == "string" && (f3 += h3.length);
        }
      }
    }
    return { mode: r2, indent: o2, chomp: a3, comment: u3, length: f3 };
  }
  function ad(s3) {
    let e5 = s3.split(/\n( *)/), t4 = e5[0], n3 = t4.match(/^( *)/), r2 = [n3?.[1] ? [n3[1], t4.slice(n3[1].length)] : ["", t4]];
    for (let o2 = 1; o2 < e5.length; o2 += 2) r2.push([e5[o2], e5[o2 + 1]]);
    return r2;
  }
  zo.resolveBlockScalar = rd;
});
var zn = o$4((ta) => {
  var Zn2 = C$2(), ld = qe$1();
  function cd(s3, e5, t4) {
    let { offset: n3, type: i4, source: r2, end: o2 } = s3, a3, l3, c3 = (d3, p3, g2) => t4(n3 + d3, p3, g2);
    switch (i4) {
      case "scalar":
        a3 = Zn2.Scalar.PLAIN, l3 = fd(r2, c3);
        break;
      case "single-quoted-scalar":
        a3 = Zn2.Scalar.QUOTE_SINGLE, l3 = ud(r2, c3);
        break;
      case "double-quoted-scalar":
        a3 = Zn2.Scalar.QUOTE_DOUBLE, l3 = dd(r2, c3);
        break;
      default:
        return t4(s3, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${i4}`), { value: "", type: null, comment: "", range: [n3, n3 + r2.length, n3 + r2.length] };
    }
    let u3 = n3 + r2.length, f3 = ld.resolveEnd(o2, u3, e5, t4);
    return { value: l3, type: a3, comment: f3.comment, range: [n3, u3, f3.offset] };
  }
  function fd(s3, e5) {
    let t4 = "";
    switch (s3[0]) {
      case "	":
        t4 = "a tab character";
        break;
      case ",":
        t4 = "flow indicator character ,";
        break;
      case "%":
        t4 = "directive indicator character %";
        break;
      case "|":
      case ">": {
        t4 = `block scalar indicator ${s3[0]}`;
        break;
      }
      case "@":
      case "`": {
        t4 = `reserved character ${s3[0]}`;
        break;
      }
    }
    return t4 && e5(0, "BAD_SCALAR_START", `Plain value cannot start with ${t4}`), ea(s3);
  }
  function ud(s3, e5) {
    return (s3[s3.length - 1] !== "'" || s3.length === 1) && e5(s3.length, "MISSING_CHAR", "Missing closing 'quote"), ea(s3.slice(1, -1)).replace(/''/g, "'");
  }
  function ea(s3) {
    let e5, t4;
    try {
      e5 = new RegExp(`(.*?)(?<![ 	])[ 	]*\r?
`, "sy"), t4 = new RegExp(`[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?
`, "sy");
    } catch {
      e5 = /(.*?)[ \t]*\r?\n/sy, t4 = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let n3 = e5.exec(s3);
    if (!n3) return s3;
    let i4 = n3[1], r2 = " ", o2 = e5.lastIndex;
    for (t4.lastIndex = o2; n3 = t4.exec(s3); ) n3[1] === "" ? r2 === `
` ? i4 += r2 : r2 = `
` : (i4 += r2 + n3[1], r2 = " "), o2 = t4.lastIndex;
    let a3 = /[ \t]*(.*)/sy;
    return a3.lastIndex = o2, n3 = a3.exec(s3), i4 + r2 + (n3?.[1] ?? "");
  }
  function dd(s3, e5) {
    let t4 = "";
    for (let n3 = 1; n3 < s3.length - 1; ++n3) {
      let i4 = s3[n3];
      if (!(i4 === "\r" && s3[n3 + 1] === `
`)) if (i4 === `
`) {
        let { fold: r2, offset: o2 } = hd(s3, n3);
        t4 += r2, n3 = o2;
      } else if (i4 === "\\") {
        let r2 = s3[++n3], o2 = pd[r2];
        if (o2) t4 += o2;
        else if (r2 === `
`) for (r2 = s3[n3 + 1]; r2 === " " || r2 === "	"; ) r2 = s3[++n3 + 1];
        else if (r2 === "\r" && s3[n3 + 1] === `
`) for (r2 = s3[++n3 + 1]; r2 === " " || r2 === "	"; ) r2 = s3[++n3 + 1];
        else if (r2 === "x" || r2 === "u" || r2 === "U") {
          let a3 = { x: 2, u: 4, U: 8 }[r2];
          t4 += md(s3, n3 + 1, a3, e5), n3 += a3;
        } else {
          let a3 = s3.substr(n3 - 1, 2);
          e5(n3 - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a3}`), t4 += a3;
        }
      } else if (i4 === " " || i4 === "	") {
        let r2 = n3, o2 = s3[n3 + 1];
        for (; o2 === " " || o2 === "	"; ) o2 = s3[++n3 + 1];
        o2 !== `
` && !(o2 === "\r" && s3[n3 + 2] === `
`) && (t4 += n3 > r2 ? s3.slice(r2, n3 + 1) : i4);
      } else t4 += i4;
    }
    return (s3[s3.length - 1] !== '"' || s3.length === 1) && e5(s3.length, "MISSING_CHAR", 'Missing closing "quote'), t4;
  }
  function hd(s3, e5) {
    let t4 = "", n3 = s3[e5 + 1];
    for (; (n3 === " " || n3 === "	" || n3 === `
` || n3 === "\r") && !(n3 === "\r" && s3[e5 + 2] !== `
`); ) n3 === `
` && (t4 += `
`), e5 += 1, n3 = s3[e5 + 1];
    return t4 || (t4 = " "), { fold: t4, offset: e5 };
  }
  var pd = { 0: "\0", a: "\x07", b: "\b", e: "\x1B", f: "\f", n: `
`, r: "\r", t: "	", v: "\v", N: "", _: "", L: "\u2028", P: "\u2029", " ": " ", '"': '"', "/": "/", "\\": "\\", "	": "	" };
  function md(s3, e5, t4, n3) {
    let i4 = s3.substr(e5, t4), o2 = i4.length === t4 && /^[0-9a-fA-F]+$/.test(i4) ? parseInt(i4, 16) : NaN;
    if (isNaN(o2)) {
      let a3 = s3.substr(e5 - 2, t4 + 2);
      return n3(e5 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${a3}`), a3;
    }
    return String.fromCodePoint(o2);
  }
  ta.resolveFlowScalar = cd;
});
var ia = o$4((na) => {
  var pe2 = O$4(), sa = C$2(), gd = Dn(), yd = zn();
  function bd(s3, e5, t4, n3) {
    let { value: i4, type: r2, comment: o2, range: a3 } = e5.type === "block-scalar" ? gd.resolveBlockScalar(s3, e5, n3) : yd.resolveFlowScalar(e5, s3.options.strict, n3), l3 = t4 ? s3.directives.tagName(t4.source, (f3) => n3(t4, "TAG_RESOLVE_FAILED", f3)) : null, c3;
    s3.options.stringKeys && s3.atKey ? c3 = s3.schema[pe2.SCALAR] : l3 ? c3 = wd(s3.schema, i4, l3, t4, n3) : e5.type === "scalar" ? c3 = Sd(s3, i4, e5, n3) : c3 = s3.schema[pe2.SCALAR];
    let u3;
    try {
      let f3 = c3.resolve(i4, (d3) => n3(t4 ?? e5, "TAG_RESOLVE_FAILED", d3), s3.options);
      u3 = pe2.isScalar(f3) ? f3 : new sa.Scalar(f3);
    } catch (f3) {
      let d3 = f3 instanceof Error ? f3.message : String(f3);
      n3(t4 ?? e5, "TAG_RESOLVE_FAILED", d3), u3 = new sa.Scalar(i4);
    }
    return u3.range = a3, u3.source = i4, r2 && (u3.type = r2), l3 && (u3.tag = l3), c3.format && (u3.format = c3.format), o2 && (u3.comment = o2), u3;
  }
  function wd(s3, e5, t4, n3, i4) {
    if (t4 === "!") return s3[pe2.SCALAR];
    let r2 = [];
    for (let a3 of s3.tags) if (!a3.collection && a3.tag === t4) if (a3.default && a3.test) r2.push(a3);
    else return a3;
    for (let a3 of r2) if (a3.test?.test(e5)) return a3;
    let o2 = s3.knownTags[t4];
    return o2 && !o2.collection ? (s3.tags.push(Object.assign({}, o2, { default: false, test: void 0 })), o2) : (i4(n3, "TAG_RESOLVE_FAILED", `Unresolved tag: ${t4}`, t4 !== "tag:yaml.org,2002:str"), s3[pe2.SCALAR]);
  }
  function Sd({ atKey: s3, directives: e5, schema: t4 }, n3, i4, r2) {
    let o2 = t4.tags.find((a3) => (a3.default === true || s3 && a3.default === "key") && a3.test?.test(n3)) || t4[pe2.SCALAR];
    if (t4.compat) {
      let a3 = t4.compat.find((l3) => l3.default && l3.test?.test(n3)) ?? t4[pe2.SCALAR];
      if (o2.tag !== a3.tag) {
        let l3 = e5.tagString(o2.tag), c3 = e5.tagString(a3.tag), u3 = `Value may be parsed as either ${l3} or ${c3}`;
        r2(i4, "TAG_RESOLVE_FAILED", u3, true);
      }
    }
    return o2;
  }
  na.composeScalar = bd;
});
var oa = o$4((ra) => {
  function Nd(s3, e5, t4) {
    if (e5) {
      t4 ?? (t4 = e5.length);
      for (let n3 = t4 - 1; n3 >= 0; --n3) {
        let i4 = e5[n3];
        switch (i4.type) {
          case "space":
          case "comment":
          case "newline":
            s3 -= i4.source.length;
            continue;
        }
        for (i4 = e5[++n3]; i4?.type === "space"; ) s3 += i4.source.length, i4 = e5[++n3];
        break;
      }
    }
    return s3;
  }
  ra.emptyScalarPosition = Nd;
});
var ca = o$4((ti2) => {
  var Ed = Ue$1(), vd = O$4(), Ad = Zo(), aa2 = ia(), Td = qe$1(), Od = oa(), kd = { composeNode: la2, composeEmptyNode: ei2 };
  function la2(s3, e5, t4, n3) {
    let i4 = s3.atKey, { spaceBefore: r2, comment: o2, anchor: a3, tag: l3 } = t4, c3, u3 = true;
    switch (e5.type) {
      case "alias":
        c3 = Id(s3, e5, n3), (a3 || l3) && n3(e5, "ALIAS_PROPS", "An alias node must not specify any properties");
        break;
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "block-scalar":
        c3 = aa2.composeScalar(s3, e5, l3, n3), a3 && (c3.anchor = a3.source.substring(1));
        break;
      case "block-map":
      case "block-seq":
      case "flow-collection":
        c3 = Ad.composeCollection(kd, s3, e5, t4, n3), a3 && (c3.anchor = a3.source.substring(1));
        break;
      default: {
        let f3 = e5.type === "error" ? e5.message : `Unsupported token (type: ${e5.type})`;
        n3(e5, "UNEXPECTED_TOKEN", f3), c3 = ei2(s3, e5.offset, void 0, null, t4, n3), u3 = false;
      }
    }
    return a3 && c3.anchor === "" && n3(a3, "BAD_ALIAS", "Anchor cannot be an empty string"), i4 && s3.options.stringKeys && (!vd.isScalar(c3) || typeof c3.value != "string" || c3.tag && c3.tag !== "tag:yaml.org,2002:str") && n3(l3 ?? e5, "NON_STRING_KEY", "With stringKeys, all keys must be strings"), r2 && (c3.spaceBefore = true), o2 && (e5.type === "scalar" && e5.source === "" ? c3.comment = o2 : c3.commentBefore = o2), s3.options.keepSourceTokens && u3 && (c3.srcToken = e5), c3;
  }
  function ei2(s3, e5, t4, n3, { spaceBefore: i4, comment: r2, anchor: o2, tag: a3, end: l3 }, c3) {
    let u3 = { type: "scalar", offset: Od.emptyScalarPosition(e5, t4, n3), indent: -1, source: "" }, f3 = aa2.composeScalar(s3, u3, a3, c3);
    return o2 && (f3.anchor = o2.source.substring(1), f3.anchor === "" && c3(o2, "BAD_ALIAS", "Anchor cannot be an empty string")), i4 && (f3.spaceBefore = true), r2 && (f3.comment = r2, f3.range[2] = l3), f3;
  }
  function Id({ options: s3 }, { offset: e5, source: t4, end: n3 }, i4) {
    let r2 = new Ed.Alias(t4.substring(1));
    r2.source === "" && i4(e5, "BAD_ALIAS", "Alias cannot be an empty string"), r2.source.endsWith(":") && i4(e5 + t4.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
    let o2 = e5 + t4.length, a3 = Td.resolveEnd(n3, o2, s3.strict, i4);
    return r2.range = [e5, o2, a3.offset], a3.comment && (r2.comment = a3.comment), r2;
  }
  ti2.composeEmptyNode = ei2;
  ti2.composeNode = la2;
});
var da = o$4((ua) => {
  var qd = at(), fa = ca(), Cd = qe$1(), Ld = ut();
  function Pd(s3, e5, { offset: t4, start: n3, value: i4, end: r2 }, o2) {
    let a3 = Object.assign({ _directives: e5 }, s3), l3 = new qd.Document(void 0, a3), c3 = { atKey: false, atRoot: true, directives: l3.directives, options: l3.options, schema: l3.schema }, u3 = Ld.resolveProps(n3, { indicator: "doc-start", next: i4 ?? r2?.[0], offset: t4, onError: o2, parentIndent: 0, startOnNewline: true });
    u3.found && (l3.directives.docStart = true, i4 && (i4.type === "block-map" || i4.type === "block-seq") && !u3.hasNewline && o2(u3.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker")), l3.contents = i4 ? fa.composeNode(c3, i4, u3, o2) : fa.composeEmptyNode(c3, u3.end, n3, null, u3, o2);
    let f3 = l3.contents.range[2], d3 = Cd.resolveEnd(r2, f3, false, o2);
    return d3.comment && (l3.comment = d3.comment), l3.range = [t4, f3, d3.offset], l3;
  }
  ua.composeDoc = Pd;
});
var ni = o$4((ma) => {
  var Md = m$d("process"), $d = Ks(), _d = at(), dt2 = ft(), ha = O$4(), xd = da(), Bd = qe$1();
  function ht2(s3) {
    if (typeof s3 == "number") return [s3, s3 + 1];
    if (Array.isArray(s3)) return s3.length === 2 ? s3 : [s3[0], s3[1]];
    let { offset: e5, source: t4 } = s3;
    return [e5, e5 + (typeof t4 == "string" ? t4.length : 1)];
  }
  function pa(s3) {
    let e5 = "", t4 = false, n3 = false;
    for (let i4 = 0; i4 < s3.length; ++i4) {
      let r2 = s3[i4];
      switch (r2[0]) {
        case "#":
          e5 += (e5 === "" ? "" : n3 ? `

` : `
`) + (r2.substring(1) || " "), t4 = true, n3 = false;
          break;
        case "%":
          s3[i4 + 1]?.[0] !== "#" && (i4 += 1), t4 = false;
          break;
        default:
          t4 || (n3 = true), t4 = false;
      }
    }
    return { comment: e5, afterEmptyLine: n3 };
  }
  var si2 = class {
    constructor(e5 = {}) {
      this.doc = null, this.atDirectives = false, this.prelude = [], this.errors = [], this.warnings = [], this.onError = (t4, n3, i4, r2) => {
        let o2 = ht2(t4);
        r2 ? this.warnings.push(new dt2.YAMLWarning(o2, n3, i4)) : this.errors.push(new dt2.YAMLParseError(o2, n3, i4));
      }, this.directives = new $d.Directives({ version: e5.version || "1.2" }), this.options = e5;
    }
    decorate(e5, t4) {
      let { comment: n3, afterEmptyLine: i4 } = pa(this.prelude);
      if (n3) {
        let r2 = e5.contents;
        if (t4) e5.comment = e5.comment ? `${e5.comment}
${n3}` : n3;
        else if (i4 || e5.directives.docStart || !r2) e5.commentBefore = n3;
        else if (ha.isCollection(r2) && !r2.flow && r2.items.length > 0) {
          let o2 = r2.items[0];
          ha.isPair(o2) && (o2 = o2.key);
          let a3 = o2.commentBefore;
          o2.commentBefore = a3 ? `${n3}
${a3}` : n3;
        } else {
          let o2 = r2.commentBefore;
          r2.commentBefore = o2 ? `${n3}
${o2}` : n3;
        }
      }
      t4 ? (Array.prototype.push.apply(e5.errors, this.errors), Array.prototype.push.apply(e5.warnings, this.warnings)) : (e5.errors = this.errors, e5.warnings = this.warnings), this.prelude = [], this.errors = [], this.warnings = [];
    }
    streamInfo() {
      return { comment: pa(this.prelude).comment, directives: this.directives, errors: this.errors, warnings: this.warnings };
    }
    *compose(e5, t4 = false, n3 = -1) {
      for (let i4 of e5) yield* this.next(i4);
      yield* this.end(t4, n3);
    }
    *next(e5) {
      switch (Md.env.LOG_STREAM && console.dir(e5, { depth: null }), e5.type) {
        case "directive":
          this.directives.add(e5.source, (t4, n3, i4) => {
            let r2 = ht2(e5);
            r2[0] += t4, this.onError(r2, "BAD_DIRECTIVE", n3, i4);
          }), this.prelude.push(e5.source), this.atDirectives = true;
          break;
        case "document": {
          let t4 = xd.composeDoc(this.options, this.directives, e5, this.onError);
          this.atDirectives && !t4.directives.docStart && this.onError(e5, "MISSING_CHAR", "Missing directives-end/doc-start indicator line"), this.decorate(t4, false), this.doc && (yield this.doc), this.doc = t4, this.atDirectives = false;
          break;
        }
        case "byte-order-mark":
        case "space":
          break;
        case "comment":
        case "newline":
          this.prelude.push(e5.source);
          break;
        case "error": {
          let t4 = e5.source ? `${e5.message}: ${JSON.stringify(e5.source)}` : e5.message, n3 = new dt2.YAMLParseError(ht2(e5), "UNEXPECTED_TOKEN", t4);
          this.atDirectives || !this.doc ? this.errors.push(n3) : this.doc.errors.push(n3);
          break;
        }
        case "doc-end": {
          if (!this.doc) {
            let n3 = "Unexpected doc-end without preceding document";
            this.errors.push(new dt2.YAMLParseError(ht2(e5), "UNEXPECTED_TOKEN", n3));
            break;
          }
          this.doc.directives.docEnd = true;
          let t4 = Bd.resolveEnd(e5.end, e5.offset + e5.source.length, this.doc.options.strict, this.onError);
          if (this.decorate(this.doc, true), t4.comment) {
            let n3 = this.doc.comment;
            this.doc.comment = n3 ? `${n3}
${t4.comment}` : t4.comment;
          }
          this.doc.range[2] = t4.offset;
          break;
        }
        default:
          this.errors.push(new dt2.YAMLParseError(ht2(e5), "UNEXPECTED_TOKEN", `Unsupported token ${e5.type}`));
      }
    }
    *end(e5 = false, t4 = -1) {
      if (this.doc) this.decorate(this.doc, true), yield this.doc, this.doc = null;
      else if (e5) {
        let n3 = Object.assign({ _directives: this.directives }, this.options), i4 = new _d.Document(void 0, n3);
        this.atDirectives && this.onError(t4, "MISSING_CHAR", "Missing directives-end indicator line"), i4.range = [0, t4, t4], this.decorate(i4, false), yield i4;
      }
    }
  };
  ma.Composer = si2;
});
var ba = o$4((gs2) => {
  var Fd = Dn(), jd = zn(), Vd = ft(), ga = Qe$1();
  function Kd(s3, e5 = true, t4) {
    if (s3) {
      let n3 = (i4, r2, o2) => {
        let a3 = typeof i4 == "number" ? i4 : Array.isArray(i4) ? i4[0] : i4.offset;
        if (t4) t4(a3, r2, o2);
        else throw new Vd.YAMLParseError([a3, a3 + 1], r2, o2);
      };
      switch (s3.type) {
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return jd.resolveFlowScalar(s3, e5, n3);
        case "block-scalar":
          return Fd.resolveBlockScalar({ options: { strict: e5 } }, s3, n3);
      }
    }
    return null;
  }
  function Rd(s3, e5) {
    let { implicitKey: t4 = false, indent: n3, inFlow: i4 = false, offset: r2 = -1, type: o2 = "PLAIN" } = e5, a3 = ga.stringifyString({ type: o2, value: s3 }, { implicitKey: t4, indent: n3 > 0 ? " ".repeat(n3) : "", inFlow: i4, options: { blockQuote: true, lineWidth: -1 } }), l3 = e5.end ?? [{ type: "newline", offset: -1, indent: n3, source: `
` }];
    switch (a3[0]) {
      case "|":
      case ">": {
        let c3 = a3.indexOf(`
`), u3 = a3.substring(0, c3), f3 = a3.substring(c3 + 1) + `
`, d3 = [{ type: "block-scalar-header", offset: r2, indent: n3, source: u3 }];
        return ya(d3, l3) || d3.push({ type: "newline", offset: -1, indent: n3, source: `
` }), { type: "block-scalar", offset: r2, indent: n3, props: d3, source: f3 };
      }
      case '"':
        return { type: "double-quoted-scalar", offset: r2, indent: n3, source: a3, end: l3 };
      case "'":
        return { type: "single-quoted-scalar", offset: r2, indent: n3, source: a3, end: l3 };
      default:
        return { type: "scalar", offset: r2, indent: n3, source: a3, end: l3 };
    }
  }
  function Yd(s3, e5, t4 = {}) {
    let { afterKey: n3 = false, implicitKey: i4 = false, inFlow: r2 = false, type: o2 } = t4, a3 = "indent" in s3 ? s3.indent : null;
    if (n3 && typeof a3 == "number" && (a3 += 2), !o2) switch (s3.type) {
      case "single-quoted-scalar":
        o2 = "QUOTE_SINGLE";
        break;
      case "double-quoted-scalar":
        o2 = "QUOTE_DOUBLE";
        break;
      case "block-scalar": {
        let c3 = s3.props[0];
        if (c3.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
        o2 = c3.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
        break;
      }
      default:
        o2 = "PLAIN";
    }
    let l3 = ga.stringifyString({ type: o2, value: e5 }, { implicitKey: i4 || a3 === null, indent: a3 !== null && a3 > 0 ? " ".repeat(a3) : "", inFlow: r2, options: { blockQuote: true, lineWidth: -1 } });
    switch (l3[0]) {
      case "|":
      case ">":
        Ud(s3, l3);
        break;
      case '"':
        ii2(s3, l3, "double-quoted-scalar");
        break;
      case "'":
        ii2(s3, l3, "single-quoted-scalar");
        break;
      default:
        ii2(s3, l3, "scalar");
    }
  }
  function Ud(s3, e5) {
    let t4 = e5.indexOf(`
`), n3 = e5.substring(0, t4), i4 = e5.substring(t4 + 1) + `
`;
    if (s3.type === "block-scalar") {
      let r2 = s3.props[0];
      if (r2.type !== "block-scalar-header") throw new Error("Invalid block scalar header");
      r2.source = n3, s3.source = i4;
    } else {
      let { offset: r2 } = s3, o2 = "indent" in s3 ? s3.indent : -1, a3 = [{ type: "block-scalar-header", offset: r2, indent: o2, source: n3 }];
      ya(a3, "end" in s3 ? s3.end : void 0) || a3.push({ type: "newline", offset: -1, indent: o2, source: `
` });
      for (let l3 of Object.keys(s3)) l3 !== "type" && l3 !== "offset" && delete s3[l3];
      Object.assign(s3, { type: "block-scalar", indent: o2, props: a3, source: i4 });
    }
  }
  function ya(s3, e5) {
    if (e5) for (let t4 of e5) switch (t4.type) {
      case "space":
      case "comment":
        s3.push(t4);
        break;
      case "newline":
        return s3.push(t4), true;
    }
    return false;
  }
  function ii2(s3, e5, t4) {
    switch (s3.type) {
      case "scalar":
      case "double-quoted-scalar":
      case "single-quoted-scalar":
        s3.type = t4, s3.source = e5;
        break;
      case "block-scalar": {
        let n3 = s3.props.slice(1), i4 = e5.length;
        s3.props[0].type === "block-scalar-header" && (i4 -= s3.props[0].source.length);
        for (let r2 of n3) r2.offset += i4;
        delete s3.props, Object.assign(s3, { type: t4, source: e5, end: n3 });
        break;
      }
      case "block-map":
      case "block-seq": {
        let i4 = { type: "newline", offset: s3.offset + e5.length, indent: s3.indent, source: `
` };
        delete s3.items, Object.assign(s3, { type: t4, source: e5, end: [i4] });
        break;
      }
      default: {
        let n3 = "indent" in s3 ? s3.indent : -1, i4 = "end" in s3 && Array.isArray(s3.end) ? s3.end.filter((r2) => r2.type === "space" || r2.type === "comment" || r2.type === "newline") : [];
        for (let r2 of Object.keys(s3)) r2 !== "type" && r2 !== "offset" && delete s3[r2];
        Object.assign(s3, { type: t4, indent: n3, source: e5, end: i4 });
      }
    }
  }
  gs2.createScalarToken = Rd;
  gs2.resolveAsScalar = Kd;
  gs2.setScalarValue = Yd;
});
var Sa = o$4((wa) => {
  var Jd = (s3) => "type" in s3 ? bs2(s3) : ys2(s3);
  function bs2(s3) {
    switch (s3.type) {
      case "block-scalar": {
        let e5 = "";
        for (let t4 of s3.props) e5 += bs2(t4);
        return e5 + s3.source;
      }
      case "block-map":
      case "block-seq": {
        let e5 = "";
        for (let t4 of s3.items) e5 += ys2(t4);
        return e5;
      }
      case "flow-collection": {
        let e5 = s3.start.source;
        for (let t4 of s3.items) e5 += ys2(t4);
        for (let t4 of s3.end) e5 += t4.source;
        return e5;
      }
      case "document": {
        let e5 = ys2(s3);
        if (s3.end) for (let t4 of s3.end) e5 += t4.source;
        return e5;
      }
      default: {
        let e5 = s3.source;
        if ("end" in s3 && s3.end) for (let t4 of s3.end) e5 += t4.source;
        return e5;
      }
    }
  }
  function ys2({ start: s3, key: e5, sep: t4, value: n3 }) {
    let i4 = "";
    for (let r2 of s3) i4 += r2.source;
    if (e5 && (i4 += bs2(e5)), t4) for (let r2 of t4) i4 += r2.source;
    return n3 && (i4 += bs2(n3)), i4;
  }
  wa.stringify = Jd;
});
var Aa = o$4((va) => {
  var ri2 = /* @__PURE__ */ Symbol("break visit"), Wd = /* @__PURE__ */ Symbol("skip children"), Na = /* @__PURE__ */ Symbol("remove item");
  function me2(s3, e5) {
    "type" in s3 && s3.type === "document" && (s3 = { start: s3.start, value: s3.value }), Ea(Object.freeze([]), s3, e5);
  }
  me2.BREAK = ri2;
  me2.SKIP = Wd;
  me2.REMOVE = Na;
  me2.itemAtPath = (s3, e5) => {
    let t4 = s3;
    for (let [n3, i4] of e5) {
      let r2 = t4?.[n3];
      if (r2 && "items" in r2) t4 = r2.items[i4];
      else return;
    }
    return t4;
  };
  me2.parentCollection = (s3, e5) => {
    let t4 = me2.itemAtPath(s3, e5.slice(0, -1)), n3 = e5[e5.length - 1][0], i4 = t4?.[n3];
    if (i4 && "items" in i4) return i4;
    throw new Error("Parent collection not found");
  };
  function Ea(s3, e5, t4) {
    let n3 = t4(e5, s3);
    if (typeof n3 == "symbol") return n3;
    for (let i4 of ["key", "value"]) {
      let r2 = e5[i4];
      if (r2 && "items" in r2) {
        for (let o2 = 0; o2 < r2.items.length; ++o2) {
          let a3 = Ea(Object.freeze(s3.concat([[i4, o2]])), r2.items[o2], t4);
          if (typeof a3 == "number") o2 = a3 - 1;
          else {
            if (a3 === ri2) return ri2;
            a3 === Na && (r2.items.splice(o2, 1), o2 -= 1);
          }
        }
        typeof n3 == "function" && i4 === "key" && (n3 = n3(e5, s3));
      }
    }
    return typeof n3 == "function" ? n3(e5, s3) : n3;
  }
  va.visit = me2;
});
var ws = o$4((j2) => {
  var oi2 = ba(), Gd = Sa(), Xd = Aa(), ai2 = "\uFEFF", li2 = "", ci2 = "", fi2 = "", Qd = (s3) => !!s3 && "items" in s3, Hd = (s3) => !!s3 && (s3.type === "scalar" || s3.type === "single-quoted-scalar" || s3.type === "double-quoted-scalar" || s3.type === "block-scalar");
  function Dd(s3) {
    switch (s3) {
      case ai2:
        return "<BOM>";
      case li2:
        return "<DOC>";
      case ci2:
        return "<FLOW_END>";
      case fi2:
        return "<SCALAR>";
      default:
        return JSON.stringify(s3);
    }
  }
  function Zd(s3) {
    switch (s3) {
      case ai2:
        return "byte-order-mark";
      case li2:
        return "doc-mode";
      case ci2:
        return "flow-error-end";
      case fi2:
        return "scalar";
      case "---":
        return "doc-start";
      case "...":
        return "doc-end";
      case "":
      case `
`:
      case `\r
`:
        return "newline";
      case "-":
        return "seq-item-ind";
      case "?":
        return "explicit-key-ind";
      case ":":
        return "map-value-ind";
      case "{":
        return "flow-map-start";
      case "}":
        return "flow-map-end";
      case "[":
        return "flow-seq-start";
      case "]":
        return "flow-seq-end";
      case ",":
        return "comma";
    }
    switch (s3[0]) {
      case " ":
      case "	":
        return "space";
      case "#":
        return "comment";
      case "%":
        return "directive-line";
      case "*":
        return "alias";
      case "&":
        return "anchor";
      case "!":
        return "tag";
      case "'":
        return "single-quoted-scalar";
      case '"':
        return "double-quoted-scalar";
      case "|":
      case ">":
        return "block-scalar-header";
    }
    return null;
  }
  j2.createScalarToken = oi2.createScalarToken;
  j2.resolveAsScalar = oi2.resolveAsScalar;
  j2.setScalarValue = oi2.setScalarValue;
  j2.stringify = Gd.stringify;
  j2.visit = Xd.visit;
  j2.BOM = ai2;
  j2.DOCUMENT = li2;
  j2.FLOW_END = ci2;
  j2.SCALAR = fi2;
  j2.isCollection = Qd;
  j2.isScalar = Hd;
  j2.prettyToken = Dd;
  j2.tokenType = Zd;
});
var hi = o$4((Oa) => {
  var pt2 = ws();
  function U2(s3) {
    switch (s3) {
      case void 0:
      case " ":
      case `
`:
      case "\r":
      case "	":
        return true;
      default:
        return false;
    }
  }
  var Ta = new Set("0123456789ABCDEFabcdef"), zd = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()"), Ss2 = new Set(",[]{}"), eh = new Set(` ,[]{}
\r	`), ui2 = (s3) => !s3 || eh.has(s3), di2 = class {
    constructor() {
      this.atEnd = false, this.blockScalarIndent = -1, this.blockScalarKeep = false, this.buffer = "", this.flowKey = false, this.flowLevel = 0, this.indentNext = 0, this.indentValue = 0, this.lineEndPos = null, this.next = null, this.pos = 0;
    }
    *lex(e5, t4 = false) {
      if (e5) {
        if (typeof e5 != "string") throw TypeError("source is not a string");
        this.buffer = this.buffer ? this.buffer + e5 : e5, this.lineEndPos = null;
      }
      this.atEnd = !t4;
      let n3 = this.next ?? "stream";
      for (; n3 && (t4 || this.hasChars(1)); ) n3 = yield* this.parseNext(n3);
    }
    atLineEnd() {
      let e5 = this.pos, t4 = this.buffer[e5];
      for (; t4 === " " || t4 === "	"; ) t4 = this.buffer[++e5];
      return !t4 || t4 === "#" || t4 === `
` ? true : t4 === "\r" ? this.buffer[e5 + 1] === `
` : false;
    }
    charAt(e5) {
      return this.buffer[this.pos + e5];
    }
    continueScalar(e5) {
      let t4 = this.buffer[e5];
      if (this.indentNext > 0) {
        let n3 = 0;
        for (; t4 === " "; ) t4 = this.buffer[++n3 + e5];
        if (t4 === "\r") {
          let i4 = this.buffer[n3 + e5 + 1];
          if (i4 === `
` || !i4 && !this.atEnd) return e5 + n3 + 1;
        }
        return t4 === `
` || n3 >= this.indentNext || !t4 && !this.atEnd ? e5 + n3 : -1;
      }
      if (t4 === "-" || t4 === ".") {
        let n3 = this.buffer.substr(e5, 3);
        if ((n3 === "---" || n3 === "...") && U2(this.buffer[e5 + 3])) return -1;
      }
      return e5;
    }
    getLine() {
      let e5 = this.lineEndPos;
      return (typeof e5 != "number" || e5 !== -1 && e5 < this.pos) && (e5 = this.buffer.indexOf(`
`, this.pos), this.lineEndPos = e5), e5 === -1 ? this.atEnd ? this.buffer.substring(this.pos) : null : (this.buffer[e5 - 1] === "\r" && (e5 -= 1), this.buffer.substring(this.pos, e5));
    }
    hasChars(e5) {
      return this.pos + e5 <= this.buffer.length;
    }
    setNext(e5) {
      return this.buffer = this.buffer.substring(this.pos), this.pos = 0, this.lineEndPos = null, this.next = e5, null;
    }
    peek(e5) {
      return this.buffer.substr(this.pos, e5);
    }
    *parseNext(e5) {
      switch (e5) {
        case "stream":
          return yield* this.parseStream();
        case "line-start":
          return yield* this.parseLineStart();
        case "block-start":
          return yield* this.parseBlockStart();
        case "doc":
          return yield* this.parseDocument();
        case "flow":
          return yield* this.parseFlowCollection();
        case "quoted-scalar":
          return yield* this.parseQuotedScalar();
        case "block-scalar":
          return yield* this.parseBlockScalar();
        case "plain-scalar":
          return yield* this.parsePlainScalar();
      }
    }
    *parseStream() {
      let e5 = this.getLine();
      if (e5 === null) return this.setNext("stream");
      if (e5[0] === pt2.BOM && (yield* this.pushCount(1), e5 = e5.substring(1)), e5[0] === "%") {
        let t4 = e5.length, n3 = e5.indexOf("#");
        for (; n3 !== -1; ) {
          let r2 = e5[n3 - 1];
          if (r2 === " " || r2 === "	") {
            t4 = n3 - 1;
            break;
          } else n3 = e5.indexOf("#", n3 + 1);
        }
        for (; ; ) {
          let r2 = e5[t4 - 1];
          if (r2 === " " || r2 === "	") t4 -= 1;
          else break;
        }
        let i4 = (yield* this.pushCount(t4)) + (yield* this.pushSpaces(true));
        return yield* this.pushCount(e5.length - i4), this.pushNewline(), "stream";
      }
      if (this.atLineEnd()) {
        let t4 = yield* this.pushSpaces(true);
        return yield* this.pushCount(e5.length - t4), yield* this.pushNewline(), "stream";
      }
      return yield pt2.DOCUMENT, yield* this.parseLineStart();
    }
    *parseLineStart() {
      let e5 = this.charAt(0);
      if (!e5 && !this.atEnd) return this.setNext("line-start");
      if (e5 === "-" || e5 === ".") {
        if (!this.atEnd && !this.hasChars(4)) return this.setNext("line-start");
        let t4 = this.peek(3);
        if ((t4 === "---" || t4 === "...") && U2(this.charAt(3))) return yield* this.pushCount(3), this.indentValue = 0, this.indentNext = 0, t4 === "---" ? "doc" : "stream";
      }
      return this.indentValue = yield* this.pushSpaces(false), this.indentNext > this.indentValue && !U2(this.charAt(1)) && (this.indentNext = this.indentValue), yield* this.parseBlockStart();
    }
    *parseBlockStart() {
      let [e5, t4] = this.peek(2);
      if (!t4 && !this.atEnd) return this.setNext("block-start");
      if ((e5 === "-" || e5 === "?" || e5 === ":") && U2(t4)) {
        let n3 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
        return this.indentNext = this.indentValue + 1, this.indentValue += n3, yield* this.parseBlockStart();
      }
      return "doc";
    }
    *parseDocument() {
      yield* this.pushSpaces(true);
      let e5 = this.getLine();
      if (e5 === null) return this.setNext("doc");
      let t4 = yield* this.pushIndicators();
      switch (e5[t4]) {
        case "#":
          yield* this.pushCount(e5.length - t4);
        case void 0:
          return yield* this.pushNewline(), yield* this.parseLineStart();
        case "{":
        case "[":
          return yield* this.pushCount(1), this.flowKey = false, this.flowLevel = 1, "flow";
        case "}":
        case "]":
          return yield* this.pushCount(1), "doc";
        case "*":
          return yield* this.pushUntil(ui2), "doc";
        case '"':
        case "'":
          return yield* this.parseQuotedScalar();
        case "|":
        case ">":
          return t4 += yield* this.parseBlockScalarHeader(), t4 += yield* this.pushSpaces(true), yield* this.pushCount(e5.length - t4), yield* this.pushNewline(), yield* this.parseBlockScalar();
        default:
          return yield* this.parsePlainScalar();
      }
    }
    *parseFlowCollection() {
      let e5, t4, n3 = -1;
      do
        e5 = yield* this.pushNewline(), e5 > 0 ? (t4 = yield* this.pushSpaces(false), this.indentValue = n3 = t4) : t4 = 0, t4 += yield* this.pushSpaces(true);
      while (e5 + t4 > 0);
      let i4 = this.getLine();
      if (i4 === null) return this.setNext("flow");
      if ((n3 !== -1 && n3 < this.indentNext && i4[0] !== "#" || n3 === 0 && (i4.startsWith("---") || i4.startsWith("...")) && U2(i4[3])) && !(n3 === this.indentNext - 1 && this.flowLevel === 1 && (i4[0] === "]" || i4[0] === "}"))) return this.flowLevel = 0, yield pt2.FLOW_END, yield* this.parseLineStart();
      let r2 = 0;
      for (; i4[r2] === ","; ) r2 += yield* this.pushCount(1), r2 += yield* this.pushSpaces(true), this.flowKey = false;
      switch (r2 += yield* this.pushIndicators(), i4[r2]) {
        case void 0:
          return "flow";
        case "#":
          return yield* this.pushCount(i4.length - r2), "flow";
        case "{":
        case "[":
          return yield* this.pushCount(1), this.flowKey = false, this.flowLevel += 1, "flow";
        case "}":
        case "]":
          return yield* this.pushCount(1), this.flowKey = true, this.flowLevel -= 1, this.flowLevel ? "flow" : "doc";
        case "*":
          return yield* this.pushUntil(ui2), "flow";
        case '"':
        case "'":
          return this.flowKey = true, yield* this.parseQuotedScalar();
        case ":": {
          let o2 = this.charAt(1);
          if (this.flowKey || U2(o2) || o2 === ",") return this.flowKey = false, yield* this.pushCount(1), yield* this.pushSpaces(true), "flow";
        }
        default:
          return this.flowKey = false, yield* this.parsePlainScalar();
      }
    }
    *parseQuotedScalar() {
      let e5 = this.charAt(0), t4 = this.buffer.indexOf(e5, this.pos + 1);
      if (e5 === "'") for (; t4 !== -1 && this.buffer[t4 + 1] === "'"; ) t4 = this.buffer.indexOf("'", t4 + 2);
      else for (; t4 !== -1; ) {
        let r2 = 0;
        for (; this.buffer[t4 - 1 - r2] === "\\"; ) r2 += 1;
        if (r2 % 2 === 0) break;
        t4 = this.buffer.indexOf('"', t4 + 1);
      }
      let n3 = this.buffer.substring(0, t4), i4 = n3.indexOf(`
`, this.pos);
      if (i4 !== -1) {
        for (; i4 !== -1; ) {
          let r2 = this.continueScalar(i4 + 1);
          if (r2 === -1) break;
          i4 = n3.indexOf(`
`, r2);
        }
        i4 !== -1 && (t4 = i4 - (n3[i4 - 1] === "\r" ? 2 : 1));
      }
      if (t4 === -1) {
        if (!this.atEnd) return this.setNext("quoted-scalar");
        t4 = this.buffer.length;
      }
      return yield* this.pushToIndex(t4 + 1, false), this.flowLevel ? "flow" : "doc";
    }
    *parseBlockScalarHeader() {
      this.blockScalarIndent = -1, this.blockScalarKeep = false;
      let e5 = this.pos;
      for (; ; ) {
        let t4 = this.buffer[++e5];
        if (t4 === "+") this.blockScalarKeep = true;
        else if (t4 > "0" && t4 <= "9") this.blockScalarIndent = Number(t4) - 1;
        else if (t4 !== "-") break;
      }
      return yield* this.pushUntil((t4) => U2(t4) || t4 === "#");
    }
    *parseBlockScalar() {
      let e5 = this.pos - 1, t4 = 0, n3;
      e: for (let r2 = this.pos; n3 = this.buffer[r2]; ++r2) switch (n3) {
        case " ":
          t4 += 1;
          break;
        case `
`:
          e5 = r2, t4 = 0;
          break;
        case "\r": {
          let o2 = this.buffer[r2 + 1];
          if (!o2 && !this.atEnd) return this.setNext("block-scalar");
          if (o2 === `
`) break;
        }
        default:
          break e;
      }
      if (!n3 && !this.atEnd) return this.setNext("block-scalar");
      if (t4 >= this.indentNext) {
        this.blockScalarIndent === -1 ? this.indentNext = t4 : this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
        do {
          let r2 = this.continueScalar(e5 + 1);
          if (r2 === -1) break;
          e5 = this.buffer.indexOf(`
`, r2);
        } while (e5 !== -1);
        if (e5 === -1) {
          if (!this.atEnd) return this.setNext("block-scalar");
          e5 = this.buffer.length;
        }
      }
      let i4 = e5 + 1;
      for (n3 = this.buffer[i4]; n3 === " "; ) n3 = this.buffer[++i4];
      if (n3 === "	") {
        for (; n3 === "	" || n3 === " " || n3 === "\r" || n3 === `
`; ) n3 = this.buffer[++i4];
        e5 = i4 - 1;
      } else if (!this.blockScalarKeep) do {
        let r2 = e5 - 1, o2 = this.buffer[r2];
        o2 === "\r" && (o2 = this.buffer[--r2]);
        let a3 = r2;
        for (; o2 === " "; ) o2 = this.buffer[--r2];
        if (o2 === `
` && r2 >= this.pos && r2 + 1 + t4 > a3) e5 = r2;
        else break;
      } while (true);
      return yield pt2.SCALAR, yield* this.pushToIndex(e5 + 1, true), yield* this.parseLineStart();
    }
    *parsePlainScalar() {
      let e5 = this.flowLevel > 0, t4 = this.pos - 1, n3 = this.pos - 1, i4;
      for (; i4 = this.buffer[++n3]; ) if (i4 === ":") {
        let r2 = this.buffer[n3 + 1];
        if (U2(r2) || e5 && Ss2.has(r2)) break;
        t4 = n3;
      } else if (U2(i4)) {
        let r2 = this.buffer[n3 + 1];
        if (i4 === "\r" && (r2 === `
` ? (n3 += 1, i4 = `
`, r2 = this.buffer[n3 + 1]) : t4 = n3), r2 === "#" || e5 && Ss2.has(r2)) break;
        if (i4 === `
`) {
          let o2 = this.continueScalar(n3 + 1);
          if (o2 === -1) break;
          n3 = Math.max(n3, o2 - 2);
        }
      } else {
        if (e5 && Ss2.has(i4)) break;
        t4 = n3;
      }
      return !i4 && !this.atEnd ? this.setNext("plain-scalar") : (yield pt2.SCALAR, yield* this.pushToIndex(t4 + 1, true), e5 ? "flow" : "doc");
    }
    *pushCount(e5) {
      return e5 > 0 ? (yield this.buffer.substr(this.pos, e5), this.pos += e5, e5) : 0;
    }
    *pushToIndex(e5, t4) {
      let n3 = this.buffer.slice(this.pos, e5);
      return n3 ? (yield n3, this.pos += n3.length, n3.length) : (t4 && (yield ""), 0);
    }
    *pushIndicators() {
      switch (this.charAt(0)) {
        case "!":
          return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "&":
          return (yield* this.pushUntil(ui2)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        case "-":
        case "?":
        case ":": {
          let e5 = this.flowLevel > 0, t4 = this.charAt(1);
          if (U2(t4) || e5 && Ss2.has(t4)) return e5 ? this.flowKey && (this.flowKey = false) : this.indentNext = this.indentValue + 1, (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
      return 0;
    }
    *pushTag() {
      if (this.charAt(1) === "<") {
        let e5 = this.pos + 2, t4 = this.buffer[e5];
        for (; !U2(t4) && t4 !== ">"; ) t4 = this.buffer[++e5];
        return yield* this.pushToIndex(t4 === ">" ? e5 + 1 : e5, false);
      } else {
        let e5 = this.pos + 1, t4 = this.buffer[e5];
        for (; t4; ) if (zd.has(t4)) t4 = this.buffer[++e5];
        else if (t4 === "%" && Ta.has(this.buffer[e5 + 1]) && Ta.has(this.buffer[e5 + 2])) t4 = this.buffer[e5 += 3];
        else break;
        return yield* this.pushToIndex(e5, false);
      }
    }
    *pushNewline() {
      let e5 = this.buffer[this.pos];
      return e5 === `
` ? yield* this.pushCount(1) : e5 === "\r" && this.charAt(1) === `
` ? yield* this.pushCount(2) : 0;
    }
    *pushSpaces(e5) {
      let t4 = this.pos - 1, n3;
      do
        n3 = this.buffer[++t4];
      while (n3 === " " || e5 && n3 === "	");
      let i4 = t4 - this.pos;
      return i4 > 0 && (yield this.buffer.substr(this.pos, i4), this.pos = t4), i4;
    }
    *pushUntil(e5) {
      let t4 = this.pos, n3 = this.buffer[t4];
      for (; !e5(n3); ) n3 = this.buffer[++t4];
      return yield* this.pushToIndex(t4, false);
    }
  };
  Oa.Lexer = di2;
});
var mi = o$4((ka) => {
  var pi2 = class {
    constructor() {
      this.lineStarts = [], this.addNewLine = (e5) => this.lineStarts.push(e5), this.linePos = (e5) => {
        let t4 = 0, n3 = this.lineStarts.length;
        for (; t4 < n3; ) {
          let r2 = t4 + n3 >> 1;
          this.lineStarts[r2] < e5 ? t4 = r2 + 1 : n3 = r2;
        }
        if (this.lineStarts[t4] === e5) return { line: t4 + 1, col: 1 };
        if (t4 === 0) return { line: 0, col: e5 };
        let i4 = this.lineStarts[t4 - 1];
        return { line: t4, col: e5 - i4 + 1 };
      };
    }
  };
  ka.LineCounter = pi2;
});
var yi = o$4((Pa) => {
  var th = m$d("process"), Ia = ws(), sh = hi();
  function re2(s3, e5) {
    for (let t4 = 0; t4 < s3.length; ++t4) if (s3[t4].type === e5) return true;
    return false;
  }
  function qa(s3) {
    for (let e5 = 0; e5 < s3.length; ++e5) switch (s3[e5].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return e5;
    }
    return -1;
  }
  function La(s3) {
    switch (s3?.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
      case "flow-collection":
        return true;
      default:
        return false;
    }
  }
  function Ns2(s3) {
    switch (s3.type) {
      case "document":
        return s3.start;
      case "block-map": {
        let e5 = s3.items[s3.items.length - 1];
        return e5.sep ?? e5.start;
      }
      case "block-seq":
        return s3.items[s3.items.length - 1].start;
      default:
        return [];
    }
  }
  function Ce2(s3) {
    if (s3.length === 0) return [];
    let e5 = s3.length;
    e: for (; --e5 >= 0; ) switch (s3[e5].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break e;
    }
    for (; s3[++e5]?.type === "space"; ) ;
    return s3.splice(e5, s3.length);
  }
  function Ca(s3) {
    if (s3.start.type === "flow-seq-start") for (let e5 of s3.items) e5.sep && !e5.value && !re2(e5.start, "explicit-key-ind") && !re2(e5.sep, "map-value-ind") && (e5.key && (e5.value = e5.key), delete e5.key, La(e5.value) ? e5.value.end ? Array.prototype.push.apply(e5.value.end, e5.sep) : e5.value.end = e5.sep : Array.prototype.push.apply(e5.start, e5.sep), delete e5.sep);
  }
  var gi2 = class {
    constructor(e5) {
      this.atNewLine = true, this.atScalar = false, this.indent = 0, this.offset = 0, this.onKeyLine = false, this.stack = [], this.source = "", this.type = "", this.lexer = new sh.Lexer(), this.onNewLine = e5;
    }
    *parse(e5, t4 = false) {
      this.onNewLine && this.offset === 0 && this.onNewLine(0);
      for (let n3 of this.lexer.lex(e5, t4)) yield* this.next(n3);
      t4 || (yield* this.end());
    }
    *next(e5) {
      if (this.source = e5, th.env.LOG_TOKENS && console.log("|", Ia.prettyToken(e5)), this.atScalar) {
        this.atScalar = false, yield* this.step(), this.offset += e5.length;
        return;
      }
      let t4 = Ia.tokenType(e5);
      if (t4) if (t4 === "scalar") this.atNewLine = false, this.atScalar = true, this.type = "scalar";
      else {
        switch (this.type = t4, yield* this.step(), t4) {
          case "newline":
            this.atNewLine = true, this.indent = 0, this.onNewLine && this.onNewLine(this.offset + e5.length);
            break;
          case "space":
            this.atNewLine && e5[0] === " " && (this.indent += e5.length);
            break;
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
            this.atNewLine && (this.indent += e5.length);
            break;
          case "doc-mode":
          case "flow-error-end":
            return;
          default:
            this.atNewLine = false;
        }
        this.offset += e5.length;
      }
      else {
        let n3 = `Not a YAML token: ${e5}`;
        yield* this.pop({ type: "error", offset: this.offset, message: n3, source: e5 }), this.offset += e5.length;
      }
    }
    *end() {
      for (; this.stack.length > 0; ) yield* this.pop();
    }
    get sourceToken() {
      return { type: this.type, offset: this.offset, indent: this.indent, source: this.source };
    }
    *step() {
      let e5 = this.peek(1);
      if (this.type === "doc-end" && e5?.type !== "doc-end") {
        for (; this.stack.length > 0; ) yield* this.pop();
        this.stack.push({ type: "doc-end", offset: this.offset, source: this.source });
        return;
      }
      if (!e5) return yield* this.stream();
      switch (e5.type) {
        case "document":
          return yield* this.document(e5);
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return yield* this.scalar(e5);
        case "block-scalar":
          return yield* this.blockScalar(e5);
        case "block-map":
          return yield* this.blockMap(e5);
        case "block-seq":
          return yield* this.blockSequence(e5);
        case "flow-collection":
          return yield* this.flowCollection(e5);
        case "doc-end":
          return yield* this.documentEnd(e5);
      }
      yield* this.pop();
    }
    peek(e5) {
      return this.stack[this.stack.length - e5];
    }
    *pop(e5) {
      let t4 = e5 ?? this.stack.pop();
      if (!t4) yield { type: "error", offset: this.offset, source: "", message: "Tried to pop an empty stack" };
      else if (this.stack.length === 0) yield t4;
      else {
        let n3 = this.peek(1);
        switch (t4.type === "block-scalar" ? t4.indent = "indent" in n3 ? n3.indent : 0 : t4.type === "flow-collection" && n3.type === "document" && (t4.indent = 0), t4.type === "flow-collection" && Ca(t4), n3.type) {
          case "document":
            n3.value = t4;
            break;
          case "block-scalar":
            n3.props.push(t4);
            break;
          case "block-map": {
            let i4 = n3.items[n3.items.length - 1];
            if (i4.value) {
              n3.items.push({ start: [], key: t4, sep: [] }), this.onKeyLine = true;
              return;
            } else if (i4.sep) i4.value = t4;
            else {
              Object.assign(i4, { key: t4, sep: [] }), this.onKeyLine = !i4.explicitKey;
              return;
            }
            break;
          }
          case "block-seq": {
            let i4 = n3.items[n3.items.length - 1];
            i4.value ? n3.items.push({ start: [], value: t4 }) : i4.value = t4;
            break;
          }
          case "flow-collection": {
            let i4 = n3.items[n3.items.length - 1];
            !i4 || i4.value ? n3.items.push({ start: [], key: t4, sep: [] }) : i4.sep ? i4.value = t4 : Object.assign(i4, { key: t4, sep: [] });
            return;
          }
          default:
            yield* this.pop(), yield* this.pop(t4);
        }
        if ((n3.type === "document" || n3.type === "block-map" || n3.type === "block-seq") && (t4.type === "block-map" || t4.type === "block-seq")) {
          let i4 = t4.items[t4.items.length - 1];
          i4 && !i4.sep && !i4.value && i4.start.length > 0 && qa(i4.start) === -1 && (t4.indent === 0 || i4.start.every((r2) => r2.type !== "comment" || r2.indent < t4.indent)) && (n3.type === "document" ? n3.end = i4.start : n3.items.push({ start: i4.start }), t4.items.splice(-1, 1));
        }
      }
    }
    *stream() {
      switch (this.type) {
        case "directive-line":
          yield { type: "directive", offset: this.offset, source: this.source };
          return;
        case "byte-order-mark":
        case "space":
        case "comment":
        case "newline":
          yield this.sourceToken;
          return;
        case "doc-mode":
        case "doc-start": {
          let e5 = { type: "document", offset: this.offset, start: [] };
          this.type === "doc-start" && e5.start.push(this.sourceToken), this.stack.push(e5);
          return;
        }
      }
      yield { type: "error", offset: this.offset, message: `Unexpected ${this.type} token in YAML stream`, source: this.source };
    }
    *document(e5) {
      if (e5.value) return yield* this.lineEnd(e5);
      switch (this.type) {
        case "doc-start": {
          qa(e5.start) !== -1 ? (yield* this.pop(), yield* this.step()) : e5.start.push(this.sourceToken);
          return;
        }
        case "anchor":
        case "tag":
        case "space":
        case "comment":
        case "newline":
          e5.start.push(this.sourceToken);
          return;
      }
      let t4 = this.startBlockValue(e5);
      t4 ? this.stack.push(t4) : yield { type: "error", offset: this.offset, message: `Unexpected ${this.type} token in YAML document`, source: this.source };
    }
    *scalar(e5) {
      if (this.type === "map-value-ind") {
        let t4 = Ns2(this.peek(2)), n3 = Ce2(t4), i4;
        e5.end ? (i4 = e5.end, i4.push(this.sourceToken), delete e5.end) : i4 = [this.sourceToken];
        let r2 = { type: "block-map", offset: e5.offset, indent: e5.indent, items: [{ start: n3, key: e5, sep: i4 }] };
        this.onKeyLine = true, this.stack[this.stack.length - 1] = r2;
      } else yield* this.lineEnd(e5);
    }
    *blockScalar(e5) {
      switch (this.type) {
        case "space":
        case "comment":
        case "newline":
          e5.props.push(this.sourceToken);
          return;
        case "scalar":
          if (e5.source = this.source, this.atNewLine = true, this.indent = 0, this.onNewLine) {
            let t4 = this.source.indexOf(`
`) + 1;
            for (; t4 !== 0; ) this.onNewLine(this.offset + t4), t4 = this.source.indexOf(`
`, t4) + 1;
          }
          yield* this.pop();
          break;
        default:
          yield* this.pop(), yield* this.step();
      }
    }
    *blockMap(e5) {
      let t4 = e5.items[e5.items.length - 1];
      switch (this.type) {
        case "newline":
          if (this.onKeyLine = false, t4.value) {
            let n3 = "end" in t4.value ? t4.value.end : void 0;
            (Array.isArray(n3) ? n3[n3.length - 1] : void 0)?.type === "comment" ? n3?.push(this.sourceToken) : e5.items.push({ start: [this.sourceToken] });
          } else t4.sep ? t4.sep.push(this.sourceToken) : t4.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (t4.value) e5.items.push({ start: [this.sourceToken] });
          else if (t4.sep) t4.sep.push(this.sourceToken);
          else {
            if (this.atIndentedComment(t4.start, e5.indent)) {
              let i4 = e5.items[e5.items.length - 2]?.value?.end;
              if (Array.isArray(i4)) {
                Array.prototype.push.apply(i4, t4.start), i4.push(this.sourceToken), e5.items.pop();
                return;
              }
            }
            t4.start.push(this.sourceToken);
          }
          return;
      }
      if (this.indent >= e5.indent) {
        let n3 = !this.onKeyLine && this.indent === e5.indent, i4 = n3 && (t4.sep || t4.explicitKey) && this.type !== "seq-item-ind", r2 = [];
        if (i4 && t4.sep && !t4.value) {
          let o2 = [];
          for (let a3 = 0; a3 < t4.sep.length; ++a3) {
            let l3 = t4.sep[a3];
            switch (l3.type) {
              case "newline":
                o2.push(a3);
                break;
              case "space":
                break;
              case "comment":
                l3.indent > e5.indent && (o2.length = 0);
                break;
              default:
                o2.length = 0;
            }
          }
          o2.length >= 2 && (r2 = t4.sep.splice(o2[1]));
        }
        switch (this.type) {
          case "anchor":
          case "tag":
            i4 || t4.value ? (r2.push(this.sourceToken), e5.items.push({ start: r2 }), this.onKeyLine = true) : t4.sep ? t4.sep.push(this.sourceToken) : t4.start.push(this.sourceToken);
            return;
          case "explicit-key-ind":
            !t4.sep && !t4.explicitKey ? (t4.start.push(this.sourceToken), t4.explicitKey = true) : i4 || t4.value ? (r2.push(this.sourceToken), e5.items.push({ start: r2, explicitKey: true })) : this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: [this.sourceToken], explicitKey: true }] }), this.onKeyLine = true;
            return;
          case "map-value-ind":
            if (t4.explicitKey) if (t4.sep) if (t4.value) e5.items.push({ start: [], key: null, sep: [this.sourceToken] });
            else if (re2(t4.sep, "map-value-ind")) this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: r2, key: null, sep: [this.sourceToken] }] });
            else if (La(t4.key) && !re2(t4.sep, "newline")) {
              let o2 = Ce2(t4.start), a3 = t4.key, l3 = t4.sep;
              l3.push(this.sourceToken), delete t4.key, delete t4.sep, this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: o2, key: a3, sep: l3 }] });
            } else r2.length > 0 ? t4.sep = t4.sep.concat(r2, this.sourceToken) : t4.sep.push(this.sourceToken);
            else if (re2(t4.start, "newline")) Object.assign(t4, { key: null, sep: [this.sourceToken] });
            else {
              let o2 = Ce2(t4.start);
              this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: o2, key: null, sep: [this.sourceToken] }] });
            }
            else t4.sep ? t4.value || i4 ? e5.items.push({ start: r2, key: null, sep: [this.sourceToken] }) : re2(t4.sep, "map-value-ind") ? this.stack.push({ type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: [], key: null, sep: [this.sourceToken] }] }) : t4.sep.push(this.sourceToken) : Object.assign(t4, { key: null, sep: [this.sourceToken] });
            this.onKeyLine = true;
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            let o2 = this.flowScalar(this.type);
            i4 || t4.value ? (e5.items.push({ start: r2, key: o2, sep: [] }), this.onKeyLine = true) : t4.sep ? this.stack.push(o2) : (Object.assign(t4, { key: o2, sep: [] }), this.onKeyLine = true);
            return;
          }
          default: {
            let o2 = this.startBlockValue(e5);
            if (o2) {
              if (o2.type === "block-seq") {
                if (!t4.explicitKey && t4.sep && !re2(t4.sep, "newline")) {
                  yield* this.pop({ type: "error", offset: this.offset, message: "Unexpected block-seq-ind on same line with key", source: this.source });
                  return;
                }
              } else n3 && e5.items.push({ start: r2 });
              this.stack.push(o2);
              return;
            }
          }
        }
      }
      yield* this.pop(), yield* this.step();
    }
    *blockSequence(e5) {
      let t4 = e5.items[e5.items.length - 1];
      switch (this.type) {
        case "newline":
          if (t4.value) {
            let n3 = "end" in t4.value ? t4.value.end : void 0;
            (Array.isArray(n3) ? n3[n3.length - 1] : void 0)?.type === "comment" ? n3?.push(this.sourceToken) : e5.items.push({ start: [this.sourceToken] });
          } else t4.start.push(this.sourceToken);
          return;
        case "space":
        case "comment":
          if (t4.value) e5.items.push({ start: [this.sourceToken] });
          else {
            if (this.atIndentedComment(t4.start, e5.indent)) {
              let i4 = e5.items[e5.items.length - 2]?.value?.end;
              if (Array.isArray(i4)) {
                Array.prototype.push.apply(i4, t4.start), i4.push(this.sourceToken), e5.items.pop();
                return;
              }
            }
            t4.start.push(this.sourceToken);
          }
          return;
        case "anchor":
        case "tag":
          if (t4.value || this.indent <= e5.indent) break;
          t4.start.push(this.sourceToken);
          return;
        case "seq-item-ind":
          if (this.indent !== e5.indent) break;
          t4.value || re2(t4.start, "seq-item-ind") ? e5.items.push({ start: [this.sourceToken] }) : t4.start.push(this.sourceToken);
          return;
      }
      if (this.indent > e5.indent) {
        let n3 = this.startBlockValue(e5);
        if (n3) {
          this.stack.push(n3);
          return;
        }
      }
      yield* this.pop(), yield* this.step();
    }
    *flowCollection(e5) {
      let t4 = e5.items[e5.items.length - 1];
      if (this.type === "flow-error-end") {
        let n3;
        do
          yield* this.pop(), n3 = this.peek(1);
        while (n3?.type === "flow-collection");
      } else if (e5.end.length === 0) {
        switch (this.type) {
          case "comma":
          case "explicit-key-ind":
            !t4 || t4.sep ? e5.items.push({ start: [this.sourceToken] }) : t4.start.push(this.sourceToken);
            return;
          case "map-value-ind":
            !t4 || t4.value ? e5.items.push({ start: [], key: null, sep: [this.sourceToken] }) : t4.sep ? t4.sep.push(this.sourceToken) : Object.assign(t4, { key: null, sep: [this.sourceToken] });
            return;
          case "space":
          case "comment":
          case "newline":
          case "anchor":
          case "tag":
            !t4 || t4.value ? e5.items.push({ start: [this.sourceToken] }) : t4.sep ? t4.sep.push(this.sourceToken) : t4.start.push(this.sourceToken);
            return;
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar": {
            let i4 = this.flowScalar(this.type);
            !t4 || t4.value ? e5.items.push({ start: [], key: i4, sep: [] }) : t4.sep ? this.stack.push(i4) : Object.assign(t4, { key: i4, sep: [] });
            return;
          }
          case "flow-map-end":
          case "flow-seq-end":
            e5.end.push(this.sourceToken);
            return;
        }
        let n3 = this.startBlockValue(e5);
        n3 ? this.stack.push(n3) : (yield* this.pop(), yield* this.step());
      } else {
        let n3 = this.peek(2);
        if (n3.type === "block-map" && (this.type === "map-value-ind" && n3.indent === e5.indent || this.type === "newline" && !n3.items[n3.items.length - 1].sep)) yield* this.pop(), yield* this.step();
        else if (this.type === "map-value-ind" && n3.type !== "flow-collection") {
          let i4 = Ns2(n3), r2 = Ce2(i4);
          Ca(e5);
          let o2 = e5.end.splice(1, e5.end.length);
          o2.push(this.sourceToken);
          let a3 = { type: "block-map", offset: e5.offset, indent: e5.indent, items: [{ start: r2, key: e5, sep: o2 }] };
          this.onKeyLine = true, this.stack[this.stack.length - 1] = a3;
        } else yield* this.lineEnd(e5);
      }
    }
    flowScalar(e5) {
      if (this.onNewLine) {
        let t4 = this.source.indexOf(`
`) + 1;
        for (; t4 !== 0; ) this.onNewLine(this.offset + t4), t4 = this.source.indexOf(`
`, t4) + 1;
      }
      return { type: e5, offset: this.offset, indent: this.indent, source: this.source };
    }
    startBlockValue(e5) {
      switch (this.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
          return this.flowScalar(this.type);
        case "block-scalar-header":
          return { type: "block-scalar", offset: this.offset, indent: this.indent, props: [this.sourceToken], source: "" };
        case "flow-map-start":
        case "flow-seq-start":
          return { type: "flow-collection", offset: this.offset, indent: this.indent, start: this.sourceToken, items: [], end: [] };
        case "seq-item-ind":
          return { type: "block-seq", offset: this.offset, indent: this.indent, items: [{ start: [this.sourceToken] }] };
        case "explicit-key-ind": {
          this.onKeyLine = true;
          let t4 = Ns2(e5), n3 = Ce2(t4);
          return n3.push(this.sourceToken), { type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: n3, explicitKey: true }] };
        }
        case "map-value-ind": {
          this.onKeyLine = true;
          let t4 = Ns2(e5), n3 = Ce2(t4);
          return { type: "block-map", offset: this.offset, indent: this.indent, items: [{ start: n3, key: null, sep: [this.sourceToken] }] };
        }
      }
      return null;
    }
    atIndentedComment(e5, t4) {
      return this.type !== "comment" || this.indent <= t4 ? false : e5.every((n3) => n3.type === "newline" || n3.type === "space");
    }
    *documentEnd(e5) {
      this.type !== "doc-mode" && (e5.end ? e5.end.push(this.sourceToken) : e5.end = [this.sourceToken], this.type === "newline" && (yield* this.pop()));
    }
    *lineEnd(e5) {
      switch (this.type) {
        case "comma":
        case "doc-start":
        case "doc-end":
        case "flow-seq-end":
        case "flow-map-end":
        case "map-value-ind":
          yield* this.pop(), yield* this.step();
          break;
        case "newline":
          this.onKeyLine = false;
        default:
          e5.end ? e5.end.push(this.sourceToken) : e5.end = [this.sourceToken], this.type === "newline" && (yield* this.pop());
      }
    }
  };
  Pa.Parser = gi2;
});
var Ba = o$4((gt2) => {
  var Ma = ni(), nh = at(), mt2 = ft(), ih = en$1(), rh = O$4(), oh = mi(), $a = yi();
  function _a(s3) {
    let e5 = s3.prettyErrors !== false;
    return { lineCounter: s3.lineCounter || e5 && new oh.LineCounter() || null, prettyErrors: e5 };
  }
  function ah(s3, e5 = {}) {
    let { lineCounter: t4, prettyErrors: n3 } = _a(e5), i4 = new $a.Parser(t4?.addNewLine), r2 = new Ma.Composer(e5), o2 = Array.from(r2.compose(i4.parse(s3)));
    if (n3 && t4) for (let a3 of o2) a3.errors.forEach(mt2.prettifyError(s3, t4)), a3.warnings.forEach(mt2.prettifyError(s3, t4));
    return o2.length > 0 ? o2 : Object.assign([], { empty: true }, r2.streamInfo());
  }
  function xa(s3, e5 = {}) {
    let { lineCounter: t4, prettyErrors: n3 } = _a(e5), i4 = new $a.Parser(t4?.addNewLine), r2 = new Ma.Composer(e5), o2 = null;
    for (let a3 of r2.compose(i4.parse(s3), true, s3.length)) if (!o2) o2 = a3;
    else if (o2.options.logLevel !== "silent") {
      o2.errors.push(new mt2.YAMLParseError(a3.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
    return n3 && t4 && (o2.errors.forEach(mt2.prettifyError(s3, t4)), o2.warnings.forEach(mt2.prettifyError(s3, t4))), o2;
  }
  function lh(s3, e5, t4) {
    let n3;
    typeof e5 == "function" ? n3 = e5 : t4 === void 0 && e5 && typeof e5 == "object" && (t4 = e5);
    let i4 = xa(s3, t4);
    if (!i4) return null;
    if (i4.warnings.forEach((r2) => ih.warn(i4.options.logLevel, r2)), i4.errors.length > 0) {
      if (i4.options.logLevel !== "silent") throw i4.errors[0];
      i4.errors = [];
    }
    return i4.toJS(Object.assign({ reviver: n3 }, t4));
  }
  function ch(s3, e5, t4) {
    let n3 = null;
    if (typeof e5 == "function" || Array.isArray(e5) ? n3 = e5 : t4 === void 0 && e5 && (t4 = e5), typeof t4 == "string" && (t4 = t4.length), typeof t4 == "number") {
      let i4 = Math.round(t4);
      t4 = i4 < 1 ? void 0 : i4 > 8 ? { indent: 8 } : { indent: i4 };
    }
    if (s3 === void 0) {
      let { keepUndefined: i4 } = t4 ?? e5 ?? {};
      if (!i4) return;
    }
    return rh.isDocument(s3) && !n3 ? s3.toString(t4) : new nh.Document(s3, n3, t4).toString(t4);
  }
  gt2.parse = lh;
  gt2.parseAllDocuments = ah;
  gt2.parseDocument = xa;
  gt2.stringify = ch;
});
var ja = o$4((k3) => {
  var fh = ni(), uh = at(), dh = Bn(), bi2 = ft(), hh = Ue$1(), oe2 = O$4(), ph = te$2(), mh = C$2(), gh = ne$1(), yh = ie$1(), bh = ws(), wh = hi(), Sh = mi(), Nh = yi(), Es2 = Ba(), Fa = Ve$1();
  k3.Composer = fh.Composer;
  k3.Document = uh.Document;
  k3.Schema = dh.Schema;
  k3.YAMLError = bi2.YAMLError;
  k3.YAMLParseError = bi2.YAMLParseError;
  k3.YAMLWarning = bi2.YAMLWarning;
  k3.Alias = hh.Alias;
  k3.isAlias = oe2.isAlias;
  k3.isCollection = oe2.isCollection;
  k3.isDocument = oe2.isDocument;
  k3.isMap = oe2.isMap;
  k3.isNode = oe2.isNode;
  k3.isPair = oe2.isPair;
  k3.isScalar = oe2.isScalar;
  k3.isSeq = oe2.isSeq;
  k3.Pair = ph.Pair;
  k3.Scalar = mh.Scalar;
  k3.YAMLMap = gh.YAMLMap;
  k3.YAMLSeq = yh.YAMLSeq;
  k3.CST = bh;
  k3.Lexer = wh.Lexer;
  k3.LineCounter = Sh.LineCounter;
  k3.Parser = Nh.Parser;
  k3.parse = Es2.parse;
  k3.parseAllDocuments = Es2.parseAllDocuments;
  k3.parseDocument = Es2.parseDocument;
  k3.stringify = Es2.stringify;
  k3.visit = Fa.visit;
  k3.visitAsync = Fa.visitAsync;
});
var ki = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Wa = ki + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Ga = "[" + ki + "][" + Wa + "]*", Xa = new RegExp("^" + Ga + "$");
function wt(s3, e5) {
  let t4 = [], n3 = e5.exec(s3);
  for (; n3; ) {
    let i4 = [];
    i4.startIndex = e5.lastIndex - n3[0].length;
    let r2 = n3.length;
    for (let o2 = 0; o2 < r2; o2++) i4.push(n3[o2]);
    t4.push(i4), n3 = e5.exec(s3);
  }
  return t4;
}
var ye$1 = function(s3) {
  let e5 = Xa.exec(s3);
  return !(e5 === null || typeof e5 > "u");
};
function Ii(s3) {
  return typeof s3 < "u";
}
var Qa = { allowBooleanAttributes: false, unpairedTags: [] };
function Mi(s3, e5) {
  e5 = Object.assign({}, Qa, e5);
  let t4 = [], n3 = false, i4 = false;
  s3[0] === "\uFEFF" && (s3 = s3.substr(1));
  for (let r2 = 0; r2 < s3.length; r2++) if (s3[r2] === "<" && s3[r2 + 1] === "?") {
    if (r2 += 2, r2 = Ci(s3, r2), r2.err) return r2;
  } else if (s3[r2] === "<") {
    let o2 = r2;
    if (r2++, s3[r2] === "!") {
      r2 = Li(s3, r2);
      continue;
    } else {
      let a3 = false;
      s3[r2] === "/" && (a3 = true, r2++);
      let l3 = "";
      for (; r2 < s3.length && s3[r2] !== ">" && s3[r2] !== " " && s3[r2] !== "	" && s3[r2] !== `
` && s3[r2] !== "\r"; r2++) l3 += s3[r2];
      if (l3 = l3.trim(), l3[l3.length - 1] === "/" && (l3 = l3.substring(0, l3.length - 1), r2--), !nl(l3)) {
        let f3;
        return l3.trim().length === 0 ? f3 = "Invalid space after '<'." : f3 = "Tag '" + l3 + "' is an invalid name.", q$2("InvalidTag", f3, _$1(s3, r2));
      }
      let c3 = Za(s3, r2);
      if (c3 === false) return q$2("InvalidAttr", "Attributes for '" + l3 + "' have open quote.", _$1(s3, r2));
      let u3 = c3.value;
      if (r2 = c3.index, u3[u3.length - 1] === "/") {
        let f3 = r2 - u3.length;
        u3 = u3.substring(0, u3.length - 1);
        let d3 = Pi(u3, e5);
        if (d3 === true) n3 = true;
        else return q$2(d3.err.code, d3.err.msg, _$1(s3, f3 + d3.err.line));
      } else if (a3) if (c3.tagClosed) {
        if (u3.trim().length > 0) return q$2("InvalidTag", "Closing tag '" + l3 + "' can't have attributes or invalid starting.", _$1(s3, o2));
        if (t4.length === 0) return q$2("InvalidTag", "Closing tag '" + l3 + "' has not been opened.", _$1(s3, o2));
        {
          let f3 = t4.pop();
          if (l3 !== f3.tagName) {
            let d3 = _$1(s3, f3.tagStartPos);
            return q$2("InvalidTag", "Expected closing tag '" + f3.tagName + "' (opened in line " + d3.line + ", col " + d3.col + ") instead of closing tag '" + l3 + "'.", _$1(s3, o2));
          }
          t4.length == 0 && (i4 = true);
        }
      } else return q$2("InvalidTag", "Closing tag '" + l3 + "' doesn't have proper closing.", _$1(s3, r2));
      else {
        let f3 = Pi(u3, e5);
        if (f3 !== true) return q$2(f3.err.code, f3.err.msg, _$1(s3, r2 - u3.length + f3.err.line));
        if (i4 === true) return q$2("InvalidXml", "Multiple possible root nodes found.", _$1(s3, r2));
        e5.unpairedTags.indexOf(l3) !== -1 || t4.push({ tagName: l3, tagStartPos: o2 }), n3 = true;
      }
      for (r2++; r2 < s3.length; r2++) if (s3[r2] === "<") if (s3[r2 + 1] === "!") {
        r2++, r2 = Li(s3, r2);
        continue;
      } else if (s3[r2 + 1] === "?") {
        if (r2 = Ci(s3, ++r2), r2.err) return r2;
      } else break;
      else if (s3[r2] === "&") {
        let f3 = tl(s3, r2);
        if (f3 == -1) return q$2("InvalidChar", "char '&' is not expected.", _$1(s3, r2));
        r2 = f3;
      } else if (i4 === true && !qi(s3[r2])) return q$2("InvalidXml", "Extra text at the end", _$1(s3, r2));
      s3[r2] === "<" && r2--;
    }
  } else {
    if (qi(s3[r2])) continue;
    return q$2("InvalidChar", "char '" + s3[r2] + "' is not expected.", _$1(s3, r2));
  }
  if (n3) {
    if (t4.length == 1) return q$2("InvalidTag", "Unclosed tag '" + t4[0].tagName + "'.", _$1(s3, t4[0].tagStartPos));
    if (t4.length > 0) return q$2("InvalidXml", "Invalid '" + JSON.stringify(t4.map((r2) => r2.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  } else return q$2("InvalidXml", "Start tag expected.", 1);
  return true;
}
function qi(s3) {
  return s3 === " " || s3 === "	" || s3 === `
` || s3 === "\r";
}
function Ci(s3, e5) {
  let t4 = e5;
  for (; e5 < s3.length; e5++) if (s3[e5] == "?" || s3[e5] == " ") {
    let n3 = s3.substr(t4, e5 - t4);
    if (e5 > 5 && n3 === "xml") return q$2("InvalidXml", "XML declaration allowed only at the start of the document.", _$1(s3, e5));
    if (s3[e5] == "?" && s3[e5 + 1] == ">") {
      e5++;
      break;
    } else continue;
  }
  return e5;
}
function Li(s3, e5) {
  if (s3.length > e5 + 5 && s3[e5 + 1] === "-" && s3[e5 + 2] === "-") {
    for (e5 += 3; e5 < s3.length; e5++) if (s3[e5] === "-" && s3[e5 + 1] === "-" && s3[e5 + 2] === ">") {
      e5 += 2;
      break;
    }
  } else if (s3.length > e5 + 8 && s3[e5 + 1] === "D" && s3[e5 + 2] === "O" && s3[e5 + 3] === "C" && s3[e5 + 4] === "T" && s3[e5 + 5] === "Y" && s3[e5 + 6] === "P" && s3[e5 + 7] === "E") {
    let t4 = 1;
    for (e5 += 8; e5 < s3.length; e5++) if (s3[e5] === "<") t4++;
    else if (s3[e5] === ">" && (t4--, t4 === 0)) break;
  } else if (s3.length > e5 + 9 && s3[e5 + 1] === "[" && s3[e5 + 2] === "C" && s3[e5 + 3] === "D" && s3[e5 + 4] === "A" && s3[e5 + 5] === "T" && s3[e5 + 6] === "A" && s3[e5 + 7] === "[") {
    for (e5 += 8; e5 < s3.length; e5++) if (s3[e5] === "]" && s3[e5 + 1] === "]" && s3[e5 + 2] === ">") {
      e5 += 2;
      break;
    }
  }
  return e5;
}
var Ha = '"', Da = "'";
function Za(s3, e5) {
  let t4 = "", n3 = "", i4 = false;
  for (; e5 < s3.length; e5++) {
    if (s3[e5] === Ha || s3[e5] === Da) n3 === "" ? n3 = s3[e5] : n3 !== s3[e5] || (n3 = "");
    else if (s3[e5] === ">" && n3 === "") {
      i4 = true;
      break;
    }
    t4 += s3[e5];
  }
  return n3 !== "" ? false : { value: t4, index: e5, tagClosed: i4 };
}
var za = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function Pi(s3, e5) {
  let t4 = wt(s3, za), n3 = {};
  for (let i4 = 0; i4 < t4.length; i4++) {
    if (t4[i4][1].length === 0) return q$2("InvalidAttr", "Attribute '" + t4[i4][2] + "' has no space in starting.", Pe$1(t4[i4]));
    if (t4[i4][3] !== void 0 && t4[i4][4] === void 0) return q$2("InvalidAttr", "Attribute '" + t4[i4][2] + "' is without value.", Pe$1(t4[i4]));
    if (t4[i4][3] === void 0 && !e5.allowBooleanAttributes) return q$2("InvalidAttr", "boolean attribute '" + t4[i4][2] + "' is not allowed.", Pe$1(t4[i4]));
    let r2 = t4[i4][2];
    if (!sl(r2)) return q$2("InvalidAttr", "Attribute '" + r2 + "' is an invalid name.", Pe$1(t4[i4]));
    if (!n3.hasOwnProperty(r2)) n3[r2] = 1;
    else return q$2("InvalidAttr", "Attribute '" + r2 + "' is repeated.", Pe$1(t4[i4]));
  }
  return true;
}
function el(s3, e5) {
  let t4 = /\d/;
  for (s3[e5] === "x" && (e5++, t4 = /[\da-fA-F]/); e5 < s3.length; e5++) {
    if (s3[e5] === ";") return e5;
    if (!s3[e5].match(t4)) break;
  }
  return -1;
}
function tl(s3, e5) {
  if (e5++, s3[e5] === ";") return -1;
  if (s3[e5] === "#") return e5++, el(s3, e5);
  let t4 = 0;
  for (; e5 < s3.length; e5++, t4++) if (!(s3[e5].match(/\w/) && t4 < 20)) {
    if (s3[e5] === ";") break;
    return -1;
  }
  return e5;
}
function q$2(s3, e5, t4) {
  return { err: { code: s3, msg: e5, line: t4.line || t4, col: t4.col } };
}
function sl(s3) {
  return ye$1(s3);
}
function nl(s3) {
  return ye$1(s3);
}
function _$1(s3, e5) {
  let t4 = s3.substring(0, e5).split(/\r?\n/);
  return { line: t4.length, col: t4[t4.length - 1].length + 1 };
}
function Pe$1(s3) {
  return s3.startIndex + s3[1].length;
}
var il = { preserveOrder: false, attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, removeNSPrefix: false, allowBooleanAttributes: false, parseTagValue: true, parseAttributeValue: false, trimValues: true, cdataPropName: false, numberParseOptions: { hex: true, leadingZeros: true, eNotation: true }, tagValueProcessor: function(s3, e5) {
  return e5;
}, attributeValueProcessor: function(s3, e5) {
  return e5;
}, stopNodes: [], alwaysCreateTextNode: false, isArray: () => false, commentPropName: false, unpairedTags: [], processEntities: true, htmlEntities: false, ignoreDeclaration: false, ignorePiTags: false, transformTagName: false, transformAttributeName: false, updateTag: function(s3, e5, t4) {
  return s3;
}, captureMetaData: false }, $i = function(s3) {
  return Object.assign({}, il, s3);
};
var St;
typeof Symbol != "function" ? St = "@@xmlMetadata" : St = /* @__PURE__ */ Symbol("XML Node Metadata");
var V$3 = class V2 {
  constructor(e5) {
    this.tagname = e5, this.child = [], this[":@"] = {};
  }
  add(e5, t4) {
    e5 === "__proto__" && (e5 = "#__proto__"), this.child.push({ [e5]: t4 });
  }
  addChild(e5, t4) {
    e5.tagname === "__proto__" && (e5.tagname = "#__proto__"), e5[":@"] && Object.keys(e5[":@"]).length > 0 ? this.child.push({ [e5.tagname]: e5.child, ":@": e5[":@"] }) : this.child.push({ [e5.tagname]: e5.child }), t4 !== void 0 && (this.child[this.child.length - 1][St] = { startIndex: t4 });
  }
  static getMetaDataSymbol() {
    return St;
  }
};
var $e = class {
  constructor(e5) {
    this.suppressValidationErr = !e5;
  }
  readDocType(e5, t4) {
    let n3 = {};
    if (e5[t4 + 3] === "O" && e5[t4 + 4] === "C" && e5[t4 + 5] === "T" && e5[t4 + 6] === "Y" && e5[t4 + 7] === "P" && e5[t4 + 8] === "E") {
      t4 = t4 + 9;
      let i4 = 1, r2 = false, o2 = false, a3 = "";
      for (; t4 < e5.length; t4++) if (e5[t4] === "<" && !o2) {
        if (r2 && le$1(e5, "!ENTITY", t4)) {
          t4 += 7;
          let l3, c3;
          [l3, c3, t4] = this.readEntityExp(e5, t4 + 1, this.suppressValidationErr), c3.indexOf("&") === -1 && (n3[l3] = { regx: RegExp(`&${l3};`, "g"), val: c3 });
        } else if (r2 && le$1(e5, "!ELEMENT", t4)) {
          t4 += 8;
          let { index: l3 } = this.readElementExp(e5, t4 + 1);
          t4 = l3;
        } else if (r2 && le$1(e5, "!ATTLIST", t4)) t4 += 8;
        else if (r2 && le$1(e5, "!NOTATION", t4)) {
          t4 += 9;
          let { index: l3 } = this.readNotationExp(e5, t4 + 1, this.suppressValidationErr);
          t4 = l3;
        } else if (le$1(e5, "!--", t4)) o2 = true;
        else throw new Error("Invalid DOCTYPE");
        i4++, a3 = "";
      } else if (e5[t4] === ">") {
        if (o2 ? e5[t4 - 1] === "-" && e5[t4 - 2] === "-" && (o2 = false, i4--) : i4--, i4 === 0) break;
      } else e5[t4] === "[" ? r2 = true : a3 += e5[t4];
      if (i4 !== 0) throw new Error("Unclosed DOCTYPE");
    } else throw new Error("Invalid Tag instead of DOCTYPE");
    return { entities: n3, i: t4 };
  }
  readEntityExp(e5, t4) {
    t4 = x$1(e5, t4);
    let n3 = "";
    for (; t4 < e5.length && !/\s/.test(e5[t4]) && e5[t4] !== '"' && e5[t4] !== "'"; ) n3 += e5[t4], t4++;
    if (Me$1(n3), t4 = x$1(e5, t4), !this.suppressValidationErr) {
      if (e5.substring(t4, t4 + 6).toUpperCase() === "SYSTEM") throw new Error("External entities are not supported");
      if (e5[t4] === "%") throw new Error("Parameter entities are not supported");
    }
    let i4 = "";
    return [t4, i4] = this.readIdentifierVal(e5, t4, "entity"), t4--, [n3, i4, t4];
  }
  readNotationExp(e5, t4) {
    t4 = x$1(e5, t4);
    let n3 = "";
    for (; t4 < e5.length && !/\s/.test(e5[t4]); ) n3 += e5[t4], t4++;
    !this.suppressValidationErr && Me$1(n3), t4 = x$1(e5, t4);
    let i4 = e5.substring(t4, t4 + 6).toUpperCase();
    if (!this.suppressValidationErr && i4 !== "SYSTEM" && i4 !== "PUBLIC") throw new Error(`Expected SYSTEM or PUBLIC, found "${i4}"`);
    t4 += i4.length, t4 = x$1(e5, t4);
    let r2 = null, o2 = null;
    if (i4 === "PUBLIC") [t4, r2] = this.readIdentifierVal(e5, t4, "publicIdentifier"), t4 = x$1(e5, t4), (e5[t4] === '"' || e5[t4] === "'") && ([t4, o2] = this.readIdentifierVal(e5, t4, "systemIdentifier"));
    else if (i4 === "SYSTEM" && ([t4, o2] = this.readIdentifierVal(e5, t4, "systemIdentifier"), !this.suppressValidationErr && !o2)) throw new Error("Missing mandatory system identifier for SYSTEM notation");
    return { notationName: n3, publicIdentifier: r2, systemIdentifier: o2, index: --t4 };
  }
  readIdentifierVal(e5, t4, n3) {
    let i4 = "", r2 = e5[t4];
    if (r2 !== '"' && r2 !== "'") throw new Error(`Expected quoted string, found "${r2}"`);
    for (t4++; t4 < e5.length && e5[t4] !== r2; ) i4 += e5[t4], t4++;
    if (e5[t4] !== r2) throw new Error(`Unterminated ${n3} value`);
    return t4++, [t4, i4];
  }
  readElementExp(e5, t4) {
    t4 = x$1(e5, t4);
    let n3 = "";
    for (; t4 < e5.length && !/\s/.test(e5[t4]); ) n3 += e5[t4], t4++;
    if (!this.suppressValidationErr && !ye$1(n3)) throw new Error(`Invalid element name: "${n3}"`);
    t4 = x$1(e5, t4);
    let i4 = "";
    if (e5[t4] === "E" && le$1(e5, "MPTY", t4)) t4 += 4;
    else if (e5[t4] === "A" && le$1(e5, "NY", t4)) t4 += 2;
    else if (e5[t4] === "(") {
      for (t4++; t4 < e5.length && e5[t4] !== ")"; ) i4 += e5[t4], t4++;
      if (e5[t4] !== ")") throw new Error("Unterminated content model");
    } else if (!this.suppressValidationErr) throw new Error(`Invalid Element Expression, found "${e5[t4]}"`);
    return { elementName: n3, contentModel: i4.trim(), index: t4 };
  }
  readAttlistExp(e5, t4) {
    t4 = x$1(e5, t4);
    let n3 = "";
    for (; t4 < e5.length && !/\s/.test(e5[t4]); ) n3 += e5[t4], t4++;
    Me$1(n3), t4 = x$1(e5, t4);
    let i4 = "";
    for (; t4 < e5.length && !/\s/.test(e5[t4]); ) i4 += e5[t4], t4++;
    if (!Me$1(i4)) throw new Error(`Invalid attribute name: "${i4}"`);
    t4 = x$1(e5, t4);
    let r2 = "";
    if (e5.substring(t4, t4 + 8).toUpperCase() === "NOTATION") {
      if (r2 = "NOTATION", t4 += 8, t4 = x$1(e5, t4), e5[t4] !== "(") throw new Error(`Expected '(', found "${e5[t4]}"`);
      t4++;
      let a3 = [];
      for (; t4 < e5.length && e5[t4] !== ")"; ) {
        let l3 = "";
        for (; t4 < e5.length && e5[t4] !== "|" && e5[t4] !== ")"; ) l3 += e5[t4], t4++;
        if (l3 = l3.trim(), !Me$1(l3)) throw new Error(`Invalid notation name: "${l3}"`);
        a3.push(l3), e5[t4] === "|" && (t4++, t4 = x$1(e5, t4));
      }
      if (e5[t4] !== ")") throw new Error("Unterminated list of notations");
      t4++, r2 += " (" + a3.join("|") + ")";
    } else {
      for (; t4 < e5.length && !/\s/.test(e5[t4]); ) r2 += e5[t4], t4++;
      let a3 = ["CDATA", "ID", "IDREF", "IDREFS", "ENTITY", "ENTITIES", "NMTOKEN", "NMTOKENS"];
      if (!this.suppressValidationErr && !a3.includes(r2.toUpperCase())) throw new Error(`Invalid attribute type: "${r2}"`);
    }
    t4 = x$1(e5, t4);
    let o2 = "";
    return e5.substring(t4, t4 + 8).toUpperCase() === "#REQUIRED" ? (o2 = "#REQUIRED", t4 += 8) : e5.substring(t4, t4 + 7).toUpperCase() === "#IMPLIED" ? (o2 = "#IMPLIED", t4 += 7) : [t4, o2] = this.readIdentifierVal(e5, t4, "ATTLIST"), { elementName: n3, attributeName: i4, attributeType: r2, defaultValue: o2, index: t4 };
  }
}, x$1 = (s3, e5) => {
  for (; e5 < s3.length && /\s/.test(s3[e5]); ) e5++;
  return e5;
};
function le$1(s3, e5, t4) {
  for (let n3 = 0; n3 < e5.length; n3++) if (e5[n3] !== s3[t4 + n3 + 1]) return false;
  return true;
}
function Me$1(s3) {
  if (ye$1(s3)) return s3;
  throw new Error(`Invalid entity name ${s3}`);
}
var rl = /^[-+]?0x[a-fA-F0-9]+$/, ol = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/, al = { hex: true, leadingZeros: true, decimalPoint: ".", eNotation: true };
function Os(s3, e5 = {}) {
  if (e5 = Object.assign({}, al, e5), !s3 || typeof s3 != "string") return s3;
  let t4 = s3.trim();
  if (e5.skipLike !== void 0 && e5.skipLike.test(t4)) return s3;
  if (s3 === "0") return 0;
  if (e5.hex && rl.test(t4)) return ul(t4, 16);
  if (t4.includes("e") || t4.includes("E")) return cl(s3, t4, e5);
  {
    let n3 = ol.exec(t4);
    if (n3) {
      let i4 = n3[1] || "", r2 = n3[2], o2 = fl(n3[3]), a3 = i4 ? s3[r2.length + 1] === "." : s3[r2.length] === ".";
      if (!e5.leadingZeros && (r2.length > 1 || r2.length === 1 && !a3)) return s3;
      {
        let l3 = Number(t4), c3 = String(l3);
        if (l3 === 0) return l3;
        if (c3.search(/[eE]/) !== -1) return e5.eNotation ? l3 : s3;
        if (t4.indexOf(".") !== -1) return c3 === "0" || c3 === o2 || c3 === `${i4}${o2}` ? l3 : s3;
        let u3 = r2 ? o2 : t4;
        return r2 ? u3 === c3 || i4 + u3 === c3 ? l3 : s3 : u3 === c3 || u3 === i4 + c3 ? l3 : s3;
      }
    } else return s3;
  }
}
var ll = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
function cl(s3, e5, t4) {
  if (!t4.eNotation) return s3;
  let n3 = e5.match(ll);
  if (n3) {
    let i4 = n3[1] || "", r2 = n3[3].indexOf("e") === -1 ? "E" : "e", o2 = n3[2], a3 = i4 ? s3[o2.length + 1] === r2 : s3[o2.length] === r2;
    return o2.length > 1 && a3 ? s3 : o2.length === 1 && (n3[3].startsWith(`.${r2}`) || n3[3][0] === r2) ? Number(e5) : t4.leadingZeros && !a3 ? (e5 = (n3[1] || "") + n3[3], Number(e5)) : s3;
  } else return s3;
}
function fl(s3) {
  return s3 && s3.indexOf(".") !== -1 && (s3 = s3.replace(/0+$/, ""), s3 === "." ? s3 = "0" : s3[0] === "." ? s3 = "0" + s3 : s3[s3.length - 1] === "." && (s3 = s3.substring(0, s3.length - 1))), s3;
}
function ul(s3, e5) {
  if (parseInt) return parseInt(s3, e5);
  if (Number.parseInt) return Number.parseInt(s3, e5);
  if (window && window.parseInt) return window.parseInt(s3, e5);
  throw new Error("parseInt, Number.parseInt, window.parseInt are not supported");
}
function _e$1(s3) {
  return typeof s3 == "function" ? s3 : Array.isArray(s3) ? (e5) => {
    for (let t4 of s3) if (typeof t4 == "string" && e5 === t4 || t4 instanceof RegExp && t4.test(e5)) return true;
  } : () => false;
}
var xe$1 = class xe {
  constructor(e5) {
    if (this.options = e5, this.currentNode = null, this.tagsNodeStack = [], this.docTypeEntities = {}, this.lastEntities = { apos: { regex: /&(apos|#39|#x27);/g, val: "'" }, gt: { regex: /&(gt|#62|#x3E);/g, val: ">" }, lt: { regex: /&(lt|#60|#x3C);/g, val: "<" }, quot: { regex: /&(quot|#34|#x22);/g, val: '"' } }, this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }, this.htmlEntities = { space: { regex: /&(nbsp|#160);/g, val: " " }, cent: { regex: /&(cent|#162);/g, val: "" }, pound: { regex: /&(pound|#163);/g, val: "" }, yen: { regex: /&(yen|#165);/g, val: "" }, euro: { regex: /&(euro|#8364);/g, val: "" }, copyright: { regex: /&(copy|#169);/g, val: "" }, reg: { regex: /&(reg|#174);/g, val: "" }, inr: { regex: /&(inr|#8377);/g, val: "" }, num_dec: { regex: /&#([0-9]{1,7});/g, val: (t4, n3) => String.fromCodePoint(Number.parseInt(n3, 10)) }, num_hex: { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (t4, n3) => String.fromCodePoint(Number.parseInt(n3, 16)) } }, this.addExternalEntities = dl, this.parseXml = yl, this.parseTextData = hl, this.resolveNameSpace = pl, this.buildAttributesMap = gl, this.isItStopNode = Nl, this.replaceEntitiesValue = wl, this.readStopNodeData = vl, this.saveTextToParentTag = Sl, this.addChild = bl, this.ignoreAttributesFn = _e$1(this.options.ignoreAttributes), this.options.stopNodes && this.options.stopNodes.length > 0) {
      this.stopNodesExact = /* @__PURE__ */ new Set(), this.stopNodesWildcard = /* @__PURE__ */ new Set();
      for (let t4 = 0; t4 < this.options.stopNodes.length; t4++) {
        let n3 = this.options.stopNodes[t4];
        typeof n3 == "string" && (n3.startsWith("*.") ? this.stopNodesWildcard.add(n3.substring(2)) : this.stopNodesExact.add(n3));
      }
    }
  }
};
function dl(s3) {
  let e5 = Object.keys(s3);
  for (let t4 = 0; t4 < e5.length; t4++) {
    let n3 = e5[t4];
    this.lastEntities[n3] = { regex: new RegExp("&" + n3 + ";", "g"), val: s3[n3] };
  }
}
function hl(s3, e5, t4, n3, i4, r2, o2) {
  if (s3 !== void 0 && (this.options.trimValues && !n3 && (s3 = s3.trim()), s3.length > 0)) {
    o2 || (s3 = this.replaceEntitiesValue(s3));
    let a3 = this.options.tagValueProcessor(e5, s3, t4, i4, r2);
    return a3 == null ? s3 : typeof a3 != typeof s3 || a3 !== s3 ? a3 : this.options.trimValues ? Is(s3, this.options.parseTagValue, this.options.numberParseOptions) : s3.trim() === s3 ? Is(s3, this.options.parseTagValue, this.options.numberParseOptions) : s3;
  }
}
function pl(s3) {
  if (this.options.removeNSPrefix) {
    let e5 = s3.split(":"), t4 = s3.charAt(0) === "/" ? "/" : "";
    if (e5[0] === "xmlns") return "";
    e5.length === 2 && (s3 = t4 + e5[1]);
  }
  return s3;
}
var ml = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function gl(s3, e5) {
  if (this.options.ignoreAttributes !== true && typeof s3 == "string") {
    let t4 = wt(s3, ml), n3 = t4.length, i4 = {};
    for (let r2 = 0; r2 < n3; r2++) {
      let o2 = this.resolveNameSpace(t4[r2][1]);
      if (this.ignoreAttributesFn(o2, e5)) continue;
      let a3 = t4[r2][4], l3 = this.options.attributeNamePrefix + o2;
      if (o2.length) if (this.options.transformAttributeName && (l3 = this.options.transformAttributeName(l3)), l3 === "__proto__" && (l3 = "#__proto__"), a3 !== void 0) {
        this.options.trimValues && (a3 = a3.trim()), a3 = this.replaceEntitiesValue(a3);
        let c3 = this.options.attributeValueProcessor(o2, a3, e5);
        c3 == null ? i4[l3] = a3 : typeof c3 != typeof a3 || c3 !== a3 ? i4[l3] = c3 : i4[l3] = Is(a3, this.options.parseAttributeValue, this.options.numberParseOptions);
      } else this.options.allowBooleanAttributes && (i4[l3] = true);
    }
    if (!Object.keys(i4).length) return;
    if (this.options.attributesGroupName) {
      let r2 = {};
      return r2[this.options.attributesGroupName] = i4, r2;
    }
    return i4;
  }
}
var yl = function(s3) {
  s3 = s3.replace(/\r\n?/g, `
`);
  let e5 = new V$3("!xml"), t4 = e5, n3 = "", i4 = "", r2 = new $e(this.options.processEntities);
  for (let o2 = 0; o2 < s3.length; o2++) if (s3[o2] === "<") if (s3[o2 + 1] === "/") {
    let l3 = ce$1(s3, ">", o2, "Closing Tag is not closed."), c3 = s3.substring(o2 + 2, l3).trim();
    if (this.options.removeNSPrefix) {
      let d3 = c3.indexOf(":");
      d3 !== -1 && (c3 = c3.substr(d3 + 1));
    }
    this.options.transformTagName && (c3 = this.options.transformTagName(c3)), t4 && (n3 = this.saveTextToParentTag(n3, t4, i4));
    let u3 = i4.substring(i4.lastIndexOf(".") + 1);
    if (c3 && this.options.unpairedTags.indexOf(c3) !== -1) throw new Error(`Unpaired tag can not be used as closing tag: </${c3}>`);
    let f3 = 0;
    u3 && this.options.unpairedTags.indexOf(u3) !== -1 ? (f3 = i4.lastIndexOf(".", i4.lastIndexOf(".") - 1), this.tagsNodeStack.pop()) : f3 = i4.lastIndexOf("."), i4 = i4.substring(0, f3), t4 = this.tagsNodeStack.pop(), n3 = "", o2 = l3;
  } else if (s3[o2 + 1] === "?") {
    let l3 = ks(s3, o2, false, "?>");
    if (!l3) throw new Error("Pi Tag is not closed.");
    if (n3 = this.saveTextToParentTag(n3, t4, i4), !(this.options.ignoreDeclaration && l3.tagName === "?xml" || this.options.ignorePiTags)) {
      let c3 = new V$3(l3.tagName);
      c3.add(this.options.textNodeName, ""), l3.tagName !== l3.tagExp && l3.attrExpPresent && (c3[":@"] = this.buildAttributesMap(l3.tagExp, i4)), this.addChild(t4, c3, i4, o2);
    }
    o2 = l3.closeIndex + 1;
  } else if (s3.substr(o2 + 1, 3) === "!--") {
    let l3 = ce$1(s3, "-->", o2 + 4, "Comment is not closed.");
    if (this.options.commentPropName) {
      let c3 = s3.substring(o2 + 4, l3 - 2);
      n3 = this.saveTextToParentTag(n3, t4, i4), t4.add(this.options.commentPropName, [{ [this.options.textNodeName]: c3 }]);
    }
    o2 = l3;
  } else if (s3.substr(o2 + 1, 2) === "!D") {
    let l3 = r2.readDocType(s3, o2);
    this.docTypeEntities = l3.entities, o2 = l3.i;
  } else if (s3.substr(o2 + 1, 2) === "![") {
    let l3 = ce$1(s3, "]]>", o2, "CDATA is not closed.") - 2, c3 = s3.substring(o2 + 9, l3);
    n3 = this.saveTextToParentTag(n3, t4, i4);
    let u3 = this.parseTextData(c3, t4.tagname, i4, true, false, true, true);
    u3 == null && (u3 = ""), this.options.cdataPropName ? t4.add(this.options.cdataPropName, [{ [this.options.textNodeName]: c3 }]) : t4.add(this.options.textNodeName, u3), o2 = l3 + 2;
  } else {
    let l3 = ks(s3, o2, this.options.removeNSPrefix), c3 = l3.tagName, u3 = l3.rawTagName, f3 = l3.tagExp, d3 = l3.attrExpPresent, p3 = l3.closeIndex;
    if (this.options.transformTagName) {
      let m3 = this.options.transformTagName(c3);
      f3 === c3 && (f3 = m3), c3 = m3;
    }
    t4 && n3 && t4.tagname !== "!xml" && (n3 = this.saveTextToParentTag(n3, t4, i4, false));
    let g2 = t4;
    g2 && this.options.unpairedTags.indexOf(g2.tagname) !== -1 && (t4 = this.tagsNodeStack.pop(), i4 = i4.substring(0, i4.lastIndexOf("."))), c3 !== e5.tagname && (i4 += i4 ? "." + c3 : c3);
    let h3 = o2;
    if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, i4, c3)) {
      let m3 = "";
      if (f3.length > 0 && f3.lastIndexOf("/") === f3.length - 1) c3[c3.length - 1] === "/" ? (c3 = c3.substr(0, c3.length - 1), i4 = i4.substr(0, i4.length - 1), f3 = c3) : f3 = f3.substr(0, f3.length - 1), o2 = l3.closeIndex;
      else if (this.options.unpairedTags.indexOf(c3) !== -1) o2 = l3.closeIndex;
      else {
        let S3 = this.readStopNodeData(s3, u3, p3 + 1);
        if (!S3) throw new Error(`Unexpected end of ${u3}`);
        o2 = S3.i, m3 = S3.tagContent;
      }
      let y2 = new V$3(c3);
      c3 !== f3 && d3 && (y2[":@"] = this.buildAttributesMap(f3, i4)), m3 && (m3 = this.parseTextData(m3, c3, i4, true, d3, true, true)), i4 = i4.substr(0, i4.lastIndexOf(".")), y2.add(this.options.textNodeName, m3), this.addChild(t4, y2, i4, h3);
    } else {
      if (f3.length > 0 && f3.lastIndexOf("/") === f3.length - 1) {
        if (c3[c3.length - 1] === "/" ? (c3 = c3.substr(0, c3.length - 1), i4 = i4.substr(0, i4.length - 1), f3 = c3) : f3 = f3.substr(0, f3.length - 1), this.options.transformTagName) {
          let y2 = this.options.transformTagName(c3);
          f3 === c3 && (f3 = y2), c3 = y2;
        }
        let m3 = new V$3(c3);
        c3 !== f3 && d3 && (m3[":@"] = this.buildAttributesMap(f3, i4)), this.addChild(t4, m3, i4, h3), i4 = i4.substr(0, i4.lastIndexOf("."));
      } else {
        let m3 = new V$3(c3);
        this.tagsNodeStack.push(t4), c3 !== f3 && d3 && (m3[":@"] = this.buildAttributesMap(f3, i4)), this.addChild(t4, m3, i4, h3), t4 = m3;
      }
      n3 = "", o2 = p3;
    }
  }
  else n3 += s3[o2];
  return e5.child;
};
function bl(s3, e5, t4, n3) {
  this.options.captureMetaData || (n3 = void 0);
  let i4 = this.options.updateTag(e5.tagname, t4, e5[":@"]);
  i4 === false || (typeof i4 == "string" && (e5.tagname = i4), s3.addChild(e5, n3));
}
var wl = function(s3) {
  if (this.options.processEntities) {
    for (let e5 in this.docTypeEntities) {
      let t4 = this.docTypeEntities[e5];
      s3 = s3.replace(t4.regx, t4.val);
    }
    for (let e5 in this.lastEntities) {
      let t4 = this.lastEntities[e5];
      s3 = s3.replace(t4.regex, t4.val);
    }
    if (this.options.htmlEntities) for (let e5 in this.htmlEntities) {
      let t4 = this.htmlEntities[e5];
      s3 = s3.replace(t4.regex, t4.val);
    }
    s3 = s3.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return s3;
};
function Sl(s3, e5, t4, n3) {
  return s3 && (n3 === void 0 && (n3 = e5.child.length === 0), s3 = this.parseTextData(s3, e5.tagname, t4, false, e5[":@"] ? Object.keys(e5[":@"]).length !== 0 : false, n3), s3 !== void 0 && s3 !== "" && e5.add(this.options.textNodeName, s3), s3 = ""), s3;
}
function Nl(s3, e5, t4, n3) {
  return !!(e5 && e5.has(n3) || s3 && s3.has(t4));
}
function El(s3, e5, t4 = ">") {
  let n3, i4 = "";
  for (let r2 = e5; r2 < s3.length; r2++) {
    let o2 = s3[r2];
    if (n3) o2 === n3 && (n3 = "");
    else if (o2 === '"' || o2 === "'") n3 = o2;
    else if (o2 === t4[0]) if (t4[1]) {
      if (s3[r2 + 1] === t4[1]) return { data: i4, index: r2 };
    } else return { data: i4, index: r2 };
    else o2 === "	" && (o2 = " ");
    i4 += o2;
  }
}
function ce$1(s3, e5, t4, n3) {
  let i4 = s3.indexOf(e5, t4);
  if (i4 === -1) throw new Error(n3);
  return i4 + e5.length - 1;
}
function ks(s3, e5, t4, n3 = ">") {
  let i4 = El(s3, e5 + 1, n3);
  if (!i4) return;
  let r2 = i4.data, o2 = i4.index, a3 = r2.search(/\s/), l3 = r2, c3 = true;
  a3 !== -1 && (l3 = r2.substring(0, a3), r2 = r2.substring(a3 + 1).trimStart());
  let u3 = l3;
  if (t4) {
    let f3 = l3.indexOf(":");
    f3 !== -1 && (l3 = l3.substr(f3 + 1), c3 = l3 !== i4.data.substr(f3 + 1));
  }
  return { tagName: l3, tagExp: r2, closeIndex: o2, attrExpPresent: c3, rawTagName: u3 };
}
function vl(s3, e5, t4) {
  let n3 = t4, i4 = 1;
  for (; t4 < s3.length; t4++) if (s3[t4] === "<") if (s3[t4 + 1] === "/") {
    let r2 = ce$1(s3, ">", t4, `${e5} is not closed`);
    if (s3.substring(t4 + 2, r2).trim() === e5 && (i4--, i4 === 0)) return { tagContent: s3.substring(n3, t4), i: r2 };
    t4 = r2;
  } else if (s3[t4 + 1] === "?") t4 = ce$1(s3, "?>", t4 + 1, "StopNode is not closed.");
  else if (s3.substr(t4 + 1, 3) === "!--") t4 = ce$1(s3, "-->", t4 + 3, "StopNode is not closed.");
  else if (s3.substr(t4 + 1, 2) === "![") t4 = ce$1(s3, "]]>", t4, "StopNode is not closed.") - 2;
  else {
    let r2 = ks(s3, t4, ">");
    r2 && ((r2 && r2.tagName) === e5 && r2.tagExp[r2.tagExp.length - 1] !== "/" && i4++, t4 = r2.closeIndex);
  }
}
function Is(s3, e5, t4) {
  if (e5 && typeof s3 == "string") {
    let n3 = s3.trim();
    return n3 === "true" ? true : n3 === "false" ? false : Os(s3, t4);
  } else return Ii(s3) ? s3 : "";
}
var qs = V$3.getMetaDataSymbol();
function Cs(s3, e5) {
  return _i(s3, e5);
}
function _i(s3, e5, t4) {
  let n3, i4 = {};
  for (let r2 = 0; r2 < s3.length; r2++) {
    let o2 = s3[r2], a3 = Al(o2), l3 = "";
    if (t4 === void 0 ? l3 = a3 : l3 = t4 + "." + a3, a3 === e5.textNodeName) n3 === void 0 ? n3 = o2[a3] : n3 += "" + o2[a3];
    else {
      if (a3 === void 0) continue;
      if (o2[a3]) {
        let c3 = _i(o2[a3], e5, l3), u3 = Ol(c3, e5);
        o2[qs] !== void 0 && (c3[qs] = o2[qs]), o2[":@"] ? Tl(c3, o2[":@"], l3, e5) : Object.keys(c3).length === 1 && c3[e5.textNodeName] !== void 0 && !e5.alwaysCreateTextNode ? c3 = c3[e5.textNodeName] : Object.keys(c3).length === 0 && (e5.alwaysCreateTextNode ? c3[e5.textNodeName] = "" : c3 = ""), i4[a3] !== void 0 && i4.hasOwnProperty(a3) ? (Array.isArray(i4[a3]) || (i4[a3] = [i4[a3]]), i4[a3].push(c3)) : e5.isArray(a3, l3, u3) ? i4[a3] = [c3] : i4[a3] = c3;
      }
    }
  }
  return typeof n3 == "string" ? n3.length > 0 && (i4[e5.textNodeName] = n3) : n3 !== void 0 && (i4[e5.textNodeName] = n3), i4;
}
function Al(s3) {
  let e5 = Object.keys(s3);
  for (let t4 = 0; t4 < e5.length; t4++) {
    let n3 = e5[t4];
    if (n3 !== ":@") return n3;
  }
}
function Tl(s3, e5, t4, n3) {
  if (e5) {
    let i4 = Object.keys(e5), r2 = i4.length;
    for (let o2 = 0; o2 < r2; o2++) {
      let a3 = i4[o2];
      n3.isArray(a3, t4 + "." + a3, true, true) ? s3[a3] = [e5[a3]] : s3[a3] = e5[a3];
    }
  }
}
function Ol(s3, e5) {
  let { textNodeName: t4 } = e5, n3 = Object.keys(s3).length;
  return !!(n3 === 0 || n3 === 1 && (s3[t4] || typeof s3[t4] == "boolean" || s3[t4] === 0));
}
var be$1 = class be {
  constructor(e5) {
    this.externalEntities = {}, this.options = $i(e5);
  }
  parse(e5, t4) {
    if (typeof e5 != "string" && e5.toString) e5 = e5.toString();
    else if (typeof e5 != "string") throw new Error("XML data is accepted in String or Bytes[] form.");
    if (t4) {
      t4 === true && (t4 = {});
      let r2 = Mi(e5, t4);
      if (r2 !== true) throw Error(`${r2.err.msg}:${r2.err.line}:${r2.err.col}`);
    }
    let n3 = new xe$1(this.options);
    n3.addExternalEntities(this.externalEntities);
    let i4 = n3.parseXml(e5);
    return this.options.preserveOrder || i4 === void 0 ? i4 : Cs(i4, this.options);
  }
  addEntity(e5, t4) {
    if (t4.indexOf("&") !== -1) throw new Error("Entity value can't have '&'");
    if (e5.indexOf("&") !== -1 || e5.indexOf(";") !== -1) throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    if (t4 === "&") throw new Error("An entity with value '&' is not permitted");
    this.externalEntities[e5] = t4;
  }
  static getMetaDataSymbol() {
    return V$3.getMetaDataSymbol();
  }
};
function Ls(s3, e5) {
  let t4 = "";
  return e5.format && e5.indentBy.length > 0 && (t4 = `
`), Bi(s3, e5, "", t4);
}
function Bi(s3, e5, t4, n3) {
  let i4 = "", r2 = false;
  for (let o2 = 0; o2 < s3.length; o2++) {
    let a3 = s3[o2], l3 = kl(a3);
    if (l3 === void 0) continue;
    let c3 = "";
    if (t4.length === 0 ? c3 = l3 : c3 = `${t4}.${l3}`, l3 === e5.textNodeName) {
      let g2 = a3[l3];
      Il(c3, e5) || (g2 = e5.tagValueProcessor(l3, g2), g2 = Fi(g2, e5)), r2 && (i4 += n3), i4 += g2, r2 = false;
      continue;
    } else if (l3 === e5.cdataPropName) {
      r2 && (i4 += n3), i4 += `<![CDATA[${a3[l3][0][e5.textNodeName]}]]>`, r2 = false;
      continue;
    } else if (l3 === e5.commentPropName) {
      i4 += n3 + `<!--${a3[l3][0][e5.textNodeName]}-->`, r2 = true;
      continue;
    } else if (l3[0] === "?") {
      let g2 = xi(a3[":@"], e5), h3 = l3 === "?xml" ? "" : n3, m3 = a3[l3][0][e5.textNodeName];
      m3 = m3.length !== 0 ? " " + m3 : "", i4 += h3 + `<${l3}${m3}${g2}?>`, r2 = true;
      continue;
    }
    let u3 = n3;
    u3 !== "" && (u3 += e5.indentBy);
    let f3 = xi(a3[":@"], e5), d3 = n3 + `<${l3}${f3}`, p3 = Bi(a3[l3], e5, c3, u3);
    e5.unpairedTags.indexOf(l3) !== -1 ? e5.suppressUnpairedNode ? i4 += d3 + ">" : i4 += d3 + "/>" : (!p3 || p3.length === 0) && e5.suppressEmptyNode ? i4 += d3 + "/>" : p3 && p3.endsWith(">") ? i4 += d3 + `>${p3}${n3}</${l3}>` : (i4 += d3 + ">", p3 && n3 !== "" && (p3.includes("/>") || p3.includes("</")) ? i4 += n3 + e5.indentBy + p3 + n3 : i4 += p3, i4 += `</${l3}>`), r2 = true;
  }
  return i4;
}
function kl(s3) {
  let e5 = Object.keys(s3);
  for (let t4 = 0; t4 < e5.length; t4++) {
    let n3 = e5[t4];
    if (s3.hasOwnProperty(n3) && n3 !== ":@") return n3;
  }
}
function xi(s3, e5) {
  let t4 = "";
  if (s3 && !e5.ignoreAttributes) for (let n3 in s3) {
    if (!s3.hasOwnProperty(n3)) continue;
    let i4 = e5.attributeValueProcessor(n3, s3[n3]);
    i4 = Fi(i4, e5), i4 === true && e5.suppressBooleanAttributes ? t4 += ` ${n3.substr(e5.attributeNamePrefix.length)}` : t4 += ` ${n3.substr(e5.attributeNamePrefix.length)}="${i4}"`;
  }
  return t4;
}
function Il(s3, e5) {
  s3 = s3.substr(0, s3.length - e5.textNodeName.length - 1);
  let t4 = s3.substr(s3.lastIndexOf(".") + 1);
  for (let n3 in e5.stopNodes) if (e5.stopNodes[n3] === s3 || e5.stopNodes[n3] === "*." + t4) return true;
  return false;
}
function Fi(s3, e5) {
  if (s3 && s3.length > 0 && e5.processEntities) for (let t4 = 0; t4 < e5.entities.length; t4++) {
    let n3 = e5.entities[t4];
    s3 = s3.replace(n3.regex, n3.val);
  }
  return s3;
}
var ql = { attributeNamePrefix: "@_", attributesGroupName: false, textNodeName: "#text", ignoreAttributes: true, cdataPropName: false, format: false, indentBy: "  ", suppressEmptyNode: false, suppressUnpairedNode: true, suppressBooleanAttributes: true, tagValueProcessor: function(s3, e5) {
  return e5;
}, attributeValueProcessor: function(s3, e5) {
  return e5;
}, preserveOrder: false, commentPropName: false, unpairedTags: [], entities: [{ regex: new RegExp("&", "g"), val: "&amp;" }, { regex: new RegExp(">", "g"), val: "&gt;" }, { regex: new RegExp("<", "g"), val: "&lt;" }, { regex: new RegExp("'", "g"), val: "&apos;" }, { regex: new RegExp('"', "g"), val: "&quot;" }], processEntities: true, stopNodes: [], oneListGroup: false };
function R$2(s3) {
  this.options = Object.assign({}, ql, s3), this.options.ignoreAttributes === true || this.options.attributesGroupName ? this.isAttribute = function() {
    return false;
  } : (this.ignoreAttributesFn = _e$1(this.options.ignoreAttributes), this.attrPrefixLen = this.options.attributeNamePrefix.length, this.isAttribute = Pl), this.processTextOrObjNode = Cl, this.options.format ? (this.indentate = Ll, this.tagEndChar = `>
`, this.newLine = `
`) : (this.indentate = function() {
    return "";
  }, this.tagEndChar = ">", this.newLine = "");
}
R$2.prototype.build = function(s3) {
  return this.options.preserveOrder ? Ls(s3, this.options) : (Array.isArray(s3) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1 && (s3 = { [this.options.arrayNodeName]: s3 }), this.j2x(s3, 0, []).val);
};
R$2.prototype.j2x = function(s3, e5, t4) {
  let n3 = "", i4 = "", r2 = t4.join(".");
  for (let o2 in s3) if (Object.prototype.hasOwnProperty.call(s3, o2)) if (typeof s3[o2] > "u") this.isAttribute(o2) && (i4 += "");
  else if (s3[o2] === null) this.isAttribute(o2) || o2 === this.options.cdataPropName ? i4 += "" : o2[0] === "?" ? i4 += this.indentate(e5) + "<" + o2 + "?" + this.tagEndChar : i4 += this.indentate(e5) + "<" + o2 + "/" + this.tagEndChar;
  else if (s3[o2] instanceof Date) i4 += this.buildTextValNode(s3[o2], o2, "", e5);
  else if (typeof s3[o2] != "object") {
    let a3 = this.isAttribute(o2);
    if (a3 && !this.ignoreAttributesFn(a3, r2)) n3 += this.buildAttrPairStr(a3, "" + s3[o2]);
    else if (!a3) if (o2 === this.options.textNodeName) {
      let l3 = this.options.tagValueProcessor(o2, "" + s3[o2]);
      i4 += this.replaceEntitiesValue(l3);
    } else i4 += this.buildTextValNode(s3[o2], o2, "", e5);
  } else if (Array.isArray(s3[o2])) {
    let a3 = s3[o2].length, l3 = "", c3 = "";
    for (let u3 = 0; u3 < a3; u3++) {
      let f3 = s3[o2][u3];
      if (!(typeof f3 > "u")) if (f3 === null) o2[0] === "?" ? i4 += this.indentate(e5) + "<" + o2 + "?" + this.tagEndChar : i4 += this.indentate(e5) + "<" + o2 + "/" + this.tagEndChar;
      else if (typeof f3 == "object") if (this.options.oneListGroup) {
        let d3 = this.j2x(f3, e5 + 1, t4.concat(o2));
        l3 += d3.val, this.options.attributesGroupName && f3.hasOwnProperty(this.options.attributesGroupName) && (c3 += d3.attrStr);
      } else l3 += this.processTextOrObjNode(f3, o2, e5, t4);
      else if (this.options.oneListGroup) {
        let d3 = this.options.tagValueProcessor(o2, f3);
        d3 = this.replaceEntitiesValue(d3), l3 += d3;
      } else l3 += this.buildTextValNode(f3, o2, "", e5);
    }
    this.options.oneListGroup && (l3 = this.buildObjectNode(l3, o2, c3, e5)), i4 += l3;
  } else if (this.options.attributesGroupName && o2 === this.options.attributesGroupName) {
    let a3 = Object.keys(s3[o2]), l3 = a3.length;
    for (let c3 = 0; c3 < l3; c3++) n3 += this.buildAttrPairStr(a3[c3], "" + s3[o2][a3[c3]]);
  } else i4 += this.processTextOrObjNode(s3[o2], o2, e5, t4);
  return { attrStr: n3, val: i4 };
};
R$2.prototype.buildAttrPairStr = function(s3, e5) {
  return e5 = this.options.attributeValueProcessor(s3, "" + e5), e5 = this.replaceEntitiesValue(e5), this.options.suppressBooleanAttributes && e5 === "true" ? " " + s3 : " " + s3 + '="' + e5 + '"';
};
function Cl(s3, e5, t4, n3) {
  let i4 = this.j2x(s3, t4 + 1, n3.concat(e5));
  return s3[this.options.textNodeName] !== void 0 && Object.keys(s3).length === 1 ? this.buildTextValNode(s3[this.options.textNodeName], e5, i4.attrStr, t4) : this.buildObjectNode(i4.val, e5, i4.attrStr, t4);
}
R$2.prototype.buildObjectNode = function(s3, e5, t4, n3) {
  if (s3 === "") return e5[0] === "?" ? this.indentate(n3) + "<" + e5 + t4 + "?" + this.tagEndChar : this.indentate(n3) + "<" + e5 + t4 + this.closeTag(e5) + this.tagEndChar;
  {
    let i4 = "</" + e5 + this.tagEndChar, r2 = "";
    return e5[0] === "?" && (r2 = "?", i4 = ""), (t4 || t4 === "") && s3.indexOf("<") === -1 ? this.indentate(n3) + "<" + e5 + t4 + r2 + ">" + s3 + i4 : this.options.commentPropName !== false && e5 === this.options.commentPropName && r2.length === 0 ? this.indentate(n3) + `<!--${s3}-->` + this.newLine : this.indentate(n3) + "<" + e5 + t4 + r2 + this.tagEndChar + s3 + this.indentate(n3) + i4;
  }
};
R$2.prototype.closeTag = function(s3) {
  let e5 = "";
  return this.options.unpairedTags.indexOf(s3) !== -1 ? this.options.suppressUnpairedNode || (e5 = "/") : this.options.suppressEmptyNode ? e5 = "/" : e5 = `></${s3}`, e5;
};
R$2.prototype.buildTextValNode = function(s3, e5, t4, n3) {
  if (this.options.cdataPropName !== false && e5 === this.options.cdataPropName) return this.indentate(n3) + `<![CDATA[${s3}]]>` + this.newLine;
  if (this.options.commentPropName !== false && e5 === this.options.commentPropName) return this.indentate(n3) + `<!--${s3}-->` + this.newLine;
  if (e5[0] === "?") return this.indentate(n3) + "<" + e5 + t4 + "?" + this.tagEndChar;
  {
    let i4 = this.options.tagValueProcessor(e5, s3);
    return i4 = this.replaceEntitiesValue(i4), i4 === "" ? this.indentate(n3) + "<" + e5 + t4 + this.closeTag(e5) + this.tagEndChar : this.indentate(n3) + "<" + e5 + t4 + ">" + i4 + "</" + e5 + this.tagEndChar;
  }
};
R$2.prototype.replaceEntitiesValue = function(s3) {
  if (s3 && s3.length > 0 && this.options.processEntities) for (let e5 = 0; e5 < this.options.entities.length; e5++) {
    let t4 = this.options.entities[e5];
    s3 = s3.replace(t4.regex, t4.val);
  }
  return s3;
};
function Ll(s3) {
  return this.options.indentBy.repeat(s3);
}
function Pl(s3) {
  return s3.startsWith(this.options.attributeNamePrefix) && s3 !== this.options.textNodeName ? s3.substr(this.attrPrefixLen) : false;
}
var vs = q$d(Yi()), wi = q$d(xe$2());
function Ml(s3, e5) {
  let t4 = s3.slice(0, e5).split(/\r\n|\n|\r/g);
  return [t4.length, t4.pop().length + 1];
}
function $l(s3, e5, t4) {
  let n3 = s3.split(/\r\n|\n|\r/g), i4 = "", r2 = (Math.log10(e5 + 1) | 0) + 1;
  for (let o2 = e5 - 1; o2 <= e5 + 1; o2++) {
    let a3 = n3[o2 - 1];
    a3 && (i4 += o2.toString().padEnd(r2, " "), i4 += ":  ", i4 += a3, i4 += `
`, o2 === e5 && (i4 += " ".repeat(r2 + t4 + 2), i4 += `^
`));
  }
  return i4;
}
var T$1 = class T extends Error {
  line;
  column;
  codeblock;
  constructor(e5, t4) {
    let [n3, i4] = Ml(t4.toml, t4.ptr), r2 = $l(t4.toml, n3, i4);
    super(`Invalid TOML document: ${e5}

${r2}`, t4), this.line = n3, this.column = i4, this.codeblock = r2;
  }
};
function _l(s3, e5) {
  let t4 = 0;
  for (; s3[e5 - ++t4] === "\\"; ) ;
  return --t4 && t4 % 2;
}
function Et(s3, e5 = 0, t4 = s3.length) {
  let n3 = s3.indexOf(`
`, e5);
  return s3[n3 - 1] === "\r" && n3--, n3 <= t4 ? n3 : -1;
}
function we$1(s3, e5) {
  for (let t4 = e5; t4 < s3.length; t4++) {
    let n3 = s3[t4];
    if (n3 === `
`) return t4;
    if (n3 === "\r" && s3[t4 + 1] === `
`) return t4 + 1;
    if (n3 < " " && n3 !== "	" || n3 === "") throw new T$1("control characters are not allowed in comments", { toml: s3, ptr: e5 });
  }
  return s3.length;
}
function B$3(s3, e5, t4, n3) {
  let i4;
  for (; (i4 = s3[e5]) === " " || i4 === "	" || !t4 && (i4 === `
` || i4 === "\r" && s3[e5 + 1] === `
`); ) e5++;
  return n3 || i4 !== "#" ? e5 : B$3(s3, we$1(s3, e5), t4);
}
function Ui(s3, e5, t4, n3, i4 = false) {
  if (!n3) return e5 = Et(s3, e5), e5 < 0 ? s3.length : e5;
  for (let r2 = e5; r2 < s3.length; r2++) {
    let o2 = s3[r2];
    if (o2 === "#") r2 = Et(s3, r2);
    else {
      if (o2 === t4) return r2 + 1;
      if (o2 === n3 || i4 && (o2 === `
` || o2 === "\r" && s3[r2 + 1] === `
`)) return r2;
    }
  }
  throw new T$1("cannot find end of structure", { toml: s3, ptr: e5 });
}
function vt(s3, e5) {
  let t4 = s3[e5], n3 = t4 === s3[e5 + 1] && s3[e5 + 1] === s3[e5 + 2] ? s3.slice(e5, e5 + 3) : t4;
  e5 += n3.length - 1;
  do
    e5 = s3.indexOf(n3, ++e5);
  while (e5 > -1 && t4 !== "'" && _l(s3, e5));
  return e5 > -1 && (e5 += n3.length, n3.length > 1 && (s3[e5] === t4 && e5++, s3[e5] === t4 && e5++)), e5;
}
var xl = /^(\d{4}-\d{2}-\d{2})?[T ]?(?:(\d{2}):\d{2}(?::\d{2}(?:\.\d+)?)?)?(Z|[-+]\d{2}:\d{2})?$/i, Be$1 = class s2 extends Date {
  #t = false;
  #s = false;
  #e = null;
  constructor(e5) {
    let t4 = true, n3 = true, i4 = "Z";
    if (typeof e5 == "string") {
      let r2 = e5.match(xl);
      r2 ? (r2[1] || (t4 = false, e5 = `0000-01-01T${e5}`), n3 = !!r2[2], n3 && e5[10] === " " && (e5 = e5.replace(" ", "T")), r2[2] && +r2[2] > 23 ? e5 = "" : (i4 = r2[3] || null, e5 = e5.toUpperCase(), !i4 && n3 && (e5 += "Z"))) : e5 = "";
    }
    super(e5), isNaN(this.getTime()) || (this.#t = t4, this.#s = n3, this.#e = i4);
  }
  isDateTime() {
    return this.#t && this.#s;
  }
  isLocal() {
    return !this.#t || !this.#s || !this.#e;
  }
  isDate() {
    return this.#t && !this.#s;
  }
  isTime() {
    return this.#s && !this.#t;
  }
  isValid() {
    return this.#t || this.#s;
  }
  toISOString() {
    let e5 = super.toISOString();
    if (this.isDate()) return e5.slice(0, 10);
    if (this.isTime()) return e5.slice(11, 23);
    if (this.#e === null) return e5.slice(0, -1);
    if (this.#e === "Z") return e5;
    let t4 = +this.#e.slice(1, 3) * 60 + +this.#e.slice(4, 6);
    return t4 = this.#e[0] === "-" ? t4 : -t4, new Date(this.getTime() - t4 * 6e4).toISOString().slice(0, -1) + this.#e;
  }
  static wrapAsOffsetDateTime(e5, t4 = "Z") {
    let n3 = new s2(e5);
    return n3.#e = t4, n3;
  }
  static wrapAsLocalDateTime(e5) {
    let t4 = new s2(e5);
    return t4.#e = null, t4;
  }
  static wrapAsLocalDate(e5) {
    let t4 = new s2(e5);
    return t4.#s = false, t4.#e = null, t4;
  }
  static wrapAsLocalTime(e5) {
    let t4 = new s2(e5);
    return t4.#t = false, t4.#e = null, t4;
  }
};
var Bl = /^((0x[0-9a-fA-F](_?[0-9a-fA-F])*)|(([+-]|0[ob])?\d(_?\d)*))$/, Fl = /^[+-]?\d(_?\d)*(\.\d(_?\d)*)?([eE][+-]?\d(_?\d)*)?$/, jl = /^[+-]?0[0-9_]/, Vl = /^[0-9a-f]{2,8}$/i, Ji = { b: "\b", t: "	", n: `
`, f: "\f", r: "\r", e: "\x1B", '"': '"', "\\": "\\" };
function At(s3, e5 = 0, t4 = s3.length) {
  let n3 = s3[e5] === "'", i4 = s3[e5++] === s3[e5] && s3[e5] === s3[e5 + 1];
  i4 && (t4 -= 2, s3[e5 += 2] === "\r" && e5++, s3[e5] === `
` && e5++);
  let r2 = 0, o2, a3 = "", l3 = e5;
  for (; e5 < t4 - 1; ) {
    let c3 = s3[e5++];
    if (c3 === `
` || c3 === "\r" && s3[e5] === `
`) {
      if (!i4) throw new T$1("newlines are not allowed in strings", { toml: s3, ptr: e5 - 1 });
    } else if (c3 < " " && c3 !== "	" || c3 === "") throw new T$1("control characters are not allowed in strings", { toml: s3, ptr: e5 - 1 });
    if (o2) {
      if (o2 = false, c3 === "x" || c3 === "u" || c3 === "U") {
        let u3 = s3.slice(e5, e5 += c3 === "x" ? 2 : c3 === "u" ? 4 : 8);
        if (!Vl.test(u3)) throw new T$1("invalid unicode escape", { toml: s3, ptr: r2 });
        try {
          a3 += String.fromCodePoint(parseInt(u3, 16));
        } catch {
          throw new T$1("invalid unicode escape", { toml: s3, ptr: r2 });
        }
      } else if (i4 && (c3 === `
` || c3 === " " || c3 === "	" || c3 === "\r")) {
        if (e5 = B$3(s3, e5 - 1, true), s3[e5] !== `
` && s3[e5] !== "\r") throw new T$1("invalid escape: only line-ending whitespace may be escaped", { toml: s3, ptr: r2 });
        e5 = B$3(s3, e5);
      } else if (c3 in Ji) a3 += Ji[c3];
      else throw new T$1("unrecognized escape sequence", { toml: s3, ptr: r2 });
      l3 = e5;
    } else !n3 && c3 === "\\" && (r2 = e5 - 1, o2 = true, a3 += s3.slice(l3, r2));
  }
  return a3 + s3.slice(l3, t4 - 1);
}
function Wi(s3, e5, t4, n3) {
  if (s3 === "true") return true;
  if (s3 === "false") return false;
  if (s3 === "-inf") return -1 / 0;
  if (s3 === "inf" || s3 === "+inf") return 1 / 0;
  if (s3 === "nan" || s3 === "+nan" || s3 === "-nan") return NaN;
  if (s3 === "-0") return n3 ? 0n : 0;
  let i4 = Bl.test(s3);
  if (i4 || Fl.test(s3)) {
    if (jl.test(s3)) throw new T$1("leading zeroes are not allowed", { toml: e5, ptr: t4 });
    s3 = s3.replace(/_/g, "");
    let o2 = +s3;
    if (isNaN(o2)) throw new T$1("invalid number", { toml: e5, ptr: t4 });
    if (i4) {
      if ((i4 = !Number.isSafeInteger(o2)) && !n3) throw new T$1("integer value cannot be represented losslessly", { toml: e5, ptr: t4 });
      (i4 || n3 === true) && (o2 = BigInt(s3));
    }
    return o2;
  }
  let r2 = new Be$1(s3);
  if (!r2.isValid()) throw new T$1("invalid value", { toml: e5, ptr: t4 });
  return r2;
}
function Kl(s3, e5, t4) {
  let n3 = s3.slice(e5, t4), i4 = n3.indexOf("#");
  return i4 > -1 && (we$1(s3, i4), n3 = n3.slice(0, i4)), [n3.trimEnd(), i4];
}
function Fe$1(s3, e5, t4, n3, i4) {
  if (n3 === 0) throw new T$1("document contains excessively nested structures. aborting.", { toml: s3, ptr: e5 });
  let r2 = s3[e5];
  if (r2 === "[" || r2 === "{") {
    let [l3, c3] = r2 === "[" ? Xi(s3, e5, n3, i4) : Gi(s3, e5, n3, i4);
    if (t4) {
      if (c3 = B$3(s3, c3), s3[c3] === ",") c3++;
      else if (s3[c3] !== t4) throw new T$1("expected comma or end of structure", { toml: s3, ptr: c3 });
    }
    return [l3, c3];
  }
  let o2;
  if (r2 === '"' || r2 === "'") {
    o2 = vt(s3, e5);
    let l3 = At(s3, e5, o2);
    if (t4) {
      if (o2 = B$3(s3, o2), s3[o2] && s3[o2] !== "," && s3[o2] !== t4 && s3[o2] !== `
` && s3[o2] !== "\r") throw new T$1("unexpected character encountered", { toml: s3, ptr: o2 });
      o2 += +(s3[o2] === ",");
    }
    return [l3, o2];
  }
  o2 = Ui(s3, e5, ",", t4);
  let a3 = Kl(s3, e5, o2 - +(s3[o2 - 1] === ","));
  if (!a3[0]) throw new T$1("incomplete key-value declaration: no value specified", { toml: s3, ptr: e5 });
  return t4 && a3[1] > -1 && (o2 = B$3(s3, e5 + a3[1]), o2 += +(s3[o2] === ",")), [Wi(a3[0], s3, e5, i4), o2];
}
var Rl = /^[a-zA-Z0-9-_]+[ \t]*$/;
function Tt(s3, e5, t4 = "=") {
  let n3 = e5 - 1, i4 = [], r2 = s3.indexOf(t4, e5);
  if (r2 < 0) throw new T$1("incomplete key-value: cannot find end of key", { toml: s3, ptr: e5 });
  do {
    let o2 = s3[e5 = ++n3];
    if (o2 !== " " && o2 !== "	") if (o2 === '"' || o2 === "'") {
      if (o2 === s3[e5 + 1] && o2 === s3[e5 + 2]) throw new T$1("multiline strings are not allowed in keys", { toml: s3, ptr: e5 });
      let a3 = vt(s3, e5);
      if (a3 < 0) throw new T$1("unfinished string encountered", { toml: s3, ptr: e5 });
      n3 = s3.indexOf(".", a3);
      let l3 = s3.slice(a3, n3 < 0 || n3 > r2 ? r2 : n3), c3 = Et(l3);
      if (c3 > -1) throw new T$1("newlines are not allowed in keys", { toml: s3, ptr: e5 + n3 + c3 });
      if (l3.trimStart()) throw new T$1("found extra tokens after the string part", { toml: s3, ptr: a3 });
      if (r2 < a3 && (r2 = s3.indexOf(t4, a3), r2 < 0)) throw new T$1("incomplete key-value: cannot find end of key", { toml: s3, ptr: e5 });
      i4.push(At(s3, e5, a3));
    } else {
      n3 = s3.indexOf(".", e5);
      let a3 = s3.slice(e5, n3 < 0 || n3 > r2 ? r2 : n3);
      if (!Rl.test(a3)) throw new T$1("only letter, numbers, dashes and underscores are allowed in keys", { toml: s3, ptr: e5 });
      i4.push(a3.trimEnd());
    }
  } while (n3 + 1 && n3 < r2);
  return [i4, B$3(s3, r2 + 1, true, true)];
}
function Gi(s3, e5, t4, n3) {
  let i4 = {}, r2 = /* @__PURE__ */ new Set(), o2;
  for (e5++; (o2 = s3[e5++]) !== "}" && o2; ) {
    if (o2 === ",") throw new T$1("expected value, found comma", { toml: s3, ptr: e5 - 1 });
    if (o2 === "#") e5 = we$1(s3, e5);
    else if (o2 !== " " && o2 !== "	" && o2 !== `
` && o2 !== "\r") {
      let a3, l3 = i4, c3 = false, [u3, f3] = Tt(s3, e5 - 1);
      for (let g2 = 0; g2 < u3.length; g2++) {
        if (g2 && (l3 = c3 ? l3[a3] : l3[a3] = {}), a3 = u3[g2], (c3 = Object.hasOwn(l3, a3)) && (typeof l3[a3] != "object" || r2.has(l3[a3]))) throw new T$1("trying to redefine an already defined value", { toml: s3, ptr: e5 });
        !c3 && a3 === "__proto__" && Object.defineProperty(l3, a3, { enumerable: true, configurable: true, writable: true });
      }
      if (c3) throw new T$1("trying to redefine an already defined value", { toml: s3, ptr: e5 });
      let [d3, p3] = Fe$1(s3, f3, "}", t4 - 1, n3);
      r2.add(d3), l3[a3] = d3, e5 = p3;
    }
  }
  if (!o2) throw new T$1("unfinished table encountered", { toml: s3, ptr: e5 });
  return [i4, e5];
}
function Xi(s3, e5, t4, n3) {
  let i4 = [], r2;
  for (e5++; (r2 = s3[e5++]) !== "]" && r2; ) {
    if (r2 === ",") throw new T$1("expected value, found comma", { toml: s3, ptr: e5 - 1 });
    if (r2 === "#") e5 = we$1(s3, e5);
    else if (r2 !== " " && r2 !== "	" && r2 !== `
` && r2 !== "\r") {
      let o2 = Fe$1(s3, e5 - 1, "]", t4 - 1, n3);
      i4.push(o2[0]), e5 = o2[1];
    }
  }
  if (!r2) throw new T$1("unfinished array encountered", { toml: s3, ptr: e5 });
  return [i4, e5];
}
function Qi(s3, e5, t4, n3) {
  let i4 = e5, r2 = t4, o2, a3 = false, l3;
  for (let c3 = 0; c3 < s3.length; c3++) {
    if (c3) {
      if (i4 = a3 ? i4[o2] : i4[o2] = {}, r2 = (l3 = r2[o2]).c, n3 === 0 && (l3.t === 1 || l3.t === 2)) return null;
      if (l3.t === 2) {
        let u3 = i4.length - 1;
        i4 = i4[u3], r2 = r2[u3].c;
      }
    }
    if (o2 = s3[c3], (a3 = Object.hasOwn(i4, o2)) && r2[o2]?.t === 0 && r2[o2]?.d) return null;
    a3 || (o2 === "__proto__" && (Object.defineProperty(i4, o2, { enumerable: true, configurable: true, writable: true }), Object.defineProperty(r2, o2, { enumerable: true, configurable: true, writable: true })), r2[o2] = { t: c3 < s3.length - 1 && n3 === 2 ? 3 : n3, d: false, i: 0, c: {} });
  }
  if (l3 = r2[o2], l3.t !== n3 && !(n3 === 1 && l3.t === 3) || (n3 === 2 && (l3.d || (l3.d = true, i4[o2] = []), i4[o2].push(i4 = {}), l3.c[l3.i++] = l3 = { t: 1, d: false, i: 0, c: {} }), l3.d)) return null;
  if (l3.d = true, n3 === 1) i4 = a3 ? i4[o2] : i4[o2] = {};
  else if (n3 === 0 && a3) return null;
  return [o2, i4, l3.c];
}
function Ot(s3, { maxDepth: e5 = 1e3, integersAsBigInt: t4 } = {}) {
  let n3 = {}, i4 = {}, r2 = n3, o2 = i4;
  for (let a3 = B$3(s3, 0); a3 < s3.length; ) {
    if (s3[a3] === "[") {
      let l3 = s3[++a3] === "[", c3 = Tt(s3, a3 += +l3, "]");
      if (l3) {
        if (s3[c3[1] - 1] !== "]") throw new T$1("expected end of table declaration", { toml: s3, ptr: c3[1] - 1 });
        c3[1]++;
      }
      let u3 = Qi(c3[0], n3, i4, l3 ? 2 : 1);
      if (!u3) throw new T$1("trying to redefine an already defined table or value", { toml: s3, ptr: a3 });
      o2 = u3[2], r2 = u3[1], a3 = c3[1];
    } else {
      let l3 = Tt(s3, a3), c3 = Qi(l3[0], r2, o2, 0);
      if (!c3) throw new T$1("trying to redefine an already defined table or value", { toml: s3, ptr: a3 });
      let u3 = Fe$1(s3, l3[1], void 0, e5, t4);
      c3[1][c3[0]] = u3[0], a3 = u3[1];
    }
    if (a3 = B$3(s3, a3, true), s3[a3] && s3[a3] !== `
` && s3[a3] !== "\r") throw new T$1("each key-value declaration must be followed by an end-of-line", { toml: s3, ptr: a3 });
    a3 = B$3(s3, a3);
  }
  return n3;
}
var Hi = /^[a-z0-9-_]+$/i;
function je$1(s3) {
  let e5 = typeof s3;
  if (e5 === "object") {
    if (Array.isArray(s3)) return "array";
    if (s3 instanceof Date) return "date";
  }
  return e5;
}
function Yl(s3) {
  for (let e5 = 0; e5 < s3.length; e5++) if (je$1(s3[e5]) !== "object") return false;
  return s3.length != 0;
}
function $s(s3) {
  return JSON.stringify(s3).replace(/\x7f/g, "\\u007f");
}
function _s(s3, e5, t4, n3) {
  if (t4 === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
  if (e5 === "number") return isNaN(s3) ? "nan" : s3 === 1 / 0 ? "inf" : s3 === -1 / 0 ? "-inf" : n3 && Number.isInteger(s3) ? s3.toFixed(1) : s3.toString();
  if (e5 === "bigint" || e5 === "boolean") return s3.toString();
  if (e5 === "string") return $s(s3);
  if (e5 === "date") {
    if (isNaN(s3.getTime())) throw new TypeError("cannot serialize invalid date");
    return s3.toISOString();
  }
  if (e5 === "object") return Ul(s3, t4, n3);
  if (e5 === "array") return Jl(s3, t4, n3);
}
function Ul(s3, e5, t4) {
  let n3 = Object.keys(s3);
  if (n3.length === 0) return "{}";
  let i4 = "{ ";
  for (let r2 = 0; r2 < n3.length; r2++) {
    let o2 = n3[r2];
    r2 && (i4 += ", "), i4 += Hi.test(o2) ? o2 : $s(o2), i4 += " = ", i4 += _s(s3[o2], je$1(s3[o2]), e5 - 1, t4);
  }
  return i4 + " }";
}
function Jl(s3, e5, t4) {
  if (s3.length === 0) return "[]";
  let n3 = "[ ";
  for (let i4 = 0; i4 < s3.length; i4++) {
    if (i4 && (n3 += ", "), s3[i4] === null || s3[i4] === void 0) throw new TypeError("arrays cannot contain null or undefined values");
    n3 += _s(s3[i4], je$1(s3[i4]), e5 - 1, t4);
  }
  return n3 + " ]";
}
function Wl(s3, e5, t4, n3) {
  if (t4 === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
  let i4 = "";
  for (let r2 = 0; r2 < s3.length; r2++) i4 += `${i4 && `
`}[[${e5}]]
`, i4 += xs(0, s3[r2], e5, t4, n3);
  return i4;
}
function xs(s3, e5, t4, n3, i4) {
  if (n3 === 0) throw new Error("Could not stringify the object: maximum object depth exceeded");
  let r2 = "", o2 = "", a3 = Object.keys(e5);
  for (let l3 = 0; l3 < a3.length; l3++) {
    let c3 = a3[l3];
    if (e5[c3] !== null && e5[c3] !== void 0) {
      let u3 = je$1(e5[c3]);
      if (u3 === "symbol" || u3 === "function") throw new TypeError(`cannot serialize values of type '${u3}'`);
      let f3 = Hi.test(c3) ? c3 : $s(c3);
      if (u3 === "array" && Yl(e5[c3])) o2 += (o2 && `
`) + Wl(e5[c3], t4 ? `${t4}.${f3}` : f3, n3 - 1, i4);
      else if (u3 === "object") {
        let d3 = t4 ? `${t4}.${f3}` : f3;
        o2 += (o2 && `
`) + xs(d3, e5[c3], d3, n3 - 1, i4);
      } else r2 += f3, r2 += " = ", r2 += _s(e5[c3], u3, n3, i4), r2 += `
`;
    }
  }
  return s3 && (r2 || !o2) && (r2 = r2 ? `[${s3}]
${r2}` : `[${s3}]`), r2 && o2 ? `${r2}
${o2}` : r2 || o2;
}
function Bs(s3, { maxDepth: e5 = 1e3, numbersAsFloat: t4 = false } = {}) {
  if (je$1(s3) !== "object") throw new TypeError("stringify can only be called with an object");
  let n3 = xs(0, s3, "", e5, t4);
  return n3[n3.length - 1] !== `
` ? n3 + `
` : n3;
}
var yt = q$d(ja()), Eh = ["yaml", "xml", "json", "ini", "csv", "toml"], vh = ["yaml", "json", "xml", "ini", "csv", "toml"];
function Si(s3) {
  return typeof s3 == "string" && Eh.includes(s3);
}
function Ni(s3) {
  return typeof s3 == "string" && vh.includes(s3);
}
var Va = { inputFormat: "yaml", outputFormat: "yaml", raw: false, compact: false, prettyPrint: false, indent: 2, xmlAttributePrefix: "+@", xmlContentName: "+content", csvDelimiter: "", csvHeader: true };
function Ah(s3) {
  let e5 = s3.lastIndexOf("."), t4 = Math.max(s3.lastIndexOf("/"), s3.lastIndexOf("\\"));
  return e5 <= t4 + 1 ? "" : s3.slice(e5);
}
function Ka(s3) {
  switch (Ah(s3).toLowerCase()) {
    case ".yaml":
    case ".yml":
      return "yaml";
    case ".json":
      return "json";
    case ".xml":
      return "xml";
    case ".ini":
      return "ini";
    case ".csv":
    case ".tsv":
      return "csv";
    case ".toml":
      return "toml";
    default:
      return null;
  }
}
function Th(s3, e5, t4) {
  return wi.default.parse(s3, { delimiter: e5 || void 0, header: t4, dynamicTyping: true, skipEmptyLines: true }).data;
}
function Oh(s3, e5) {
  return Array.isArray(s3) || (s3 = [s3]), wi.default.unparse(s3, { delimiter: e5 || "," });
}
function Ei(s3, e5) {
  let t4 = s3.trim();
  if (!t4) return null;
  switch (e5.inputFormat) {
    case "yaml":
      return yt.default.parse(t4);
    case "json":
      return JSON.parse(t4);
    case "xml":
      return new be$1({ ignoreAttributes: false, attributeNamePrefix: e5.xmlAttributePrefix, textNodeName: e5.xmlContentName, parseAttributeValue: false, parseTagValue: false, trimValues: true, tagValueProcessor: (i4, r2) => r2 === "" ? null : r2 }).parse(t4);
    case "ini":
      return vs.parse(t4);
    case "csv":
      return Th(t4, e5.csvDelimiter, e5.csvHeader);
    case "toml":
      return Ot(t4);
    default: {
      let n3 = e5.inputFormat;
      throw new Error(`Invalid input format: ${n3}`);
    }
  }
}
function Ra(s3) {
  return yt.default.parseAllDocuments(s3).map((t4) => t4.toJSON());
}
function Ya(s3) {
  let e5 = s3.trimStart();
  if (e5.startsWith("---")) {
    let t4 = e5.slice(3).match(/\n---(\n|$)/);
    if (t4 && t4.index !== void 0) {
      let n3 = e5.slice(3, t4.index + 3), i4 = e5.slice(t4.index + 3 + t4[0].length);
      return { frontMatter: yt.default.parse(n3), content: i4 };
    }
  }
  if (e5.startsWith("+++")) {
    let t4 = e5.slice(3).match(/\n\+\+\+(\n|$)/);
    if (t4 && t4.index !== void 0) {
      let n3 = e5.slice(3, t4.index + 3), i4 = e5.slice(t4.index + 3 + t4[0].length);
      return { frontMatter: Ot(n3), content: i4 };
    }
  }
  if (e5.startsWith("{{{")) {
    let t4 = e5.slice(3).match(/\n}}}(\n|$)/);
    if (t4 && t4.index !== void 0) {
      let n3 = e5.slice(3, t4.index + 3), i4 = e5.slice(t4.index + 3 + t4[0].length);
      return { frontMatter: JSON.parse(n3), content: i4 };
    }
  }
  return null;
}
function Ua(s3, e5) {
  if (s3 === void 0) return "";
  switch (e5.outputFormat) {
    case "yaml":
      return yt.default.stringify(s3, { indent: e5.indent }).trimEnd();
    case "json":
      return e5.raw && typeof s3 == "string" ? s3 : e5.compact ? JSON.stringify(s3) : JSON.stringify(s3, null, e5.indent);
    case "xml":
      return new R$2({ ignoreAttributes: false, attributeNamePrefix: e5.xmlAttributePrefix, textNodeName: e5.xmlContentName, format: e5.prettyPrint || !e5.compact, indentBy: " ".repeat(e5.indent) }).build(s3);
    case "ini":
      return !s3 || typeof s3 != "object" || Array.isArray(s3) ? "" : vs.stringify(s3);
    case "csv":
      return Oh(s3, e5.csvDelimiter);
    case "toml":
      return !s3 || typeof s3 != "object" || Array.isArray(s3) ? "" : Bs(s3);
    default:
      throw new Error(`Unknown output format: ${e5.outputFormat}`);
  }
}
var kh = { name: "yq", summary: "command-line YAML/XML/INI/CSV/TOML processor", usage: "yq [OPTIONS] [FILTER] [FILE]", description: `yq uses jq-style expressions to query and transform data in various formats.
Supports YAML, JSON, XML, INI, CSV, and TOML with automatic format conversion.

EXAMPLES:
  # Extract a value from YAML
  yq '.name' config.yaml
  yq '.users[0].email' data.yaml

  # Filter arrays
  yq '.items[] | select(.active == true)' data.yaml
  yq '[.users[] | select(.age > 30)]' users.yaml

  # Transform data
  yq '.users | map({name, email})' data.yaml
  yq '.items | sort_by(.price) | reverse' products.yaml

  # Modify file in-place
  yq -i '.version = "2.0"' config.yaml

  # Read JSON, output YAML
  yq -p json '.' config.json

  # Read YAML, output JSON
  yq -o json '.' config.yaml
  yq -o json -c '.' config.yaml  # compact JSON

  # Parse TOML config files
  yq '.package.name' Cargo.toml
  yq -o json '.' pyproject.toml

  # Parse XML (attributes use +@ prefix, text uses +content)
  yq -p xml '.root.items.item[].name' data.xml
  yq -p xml '.root.user["+@id"]' data.xml  # XML attributes

  # Parse INI config files
  yq -p ini '.database.host' config.ini
  yq -p ini '.server' config.ini -o json

  # Parse CSV/TSV (auto-detects delimiter)
  yq -p csv '.[0].name' data.csv
  yq '.[0].name' data.tsv              # auto-detected as CSV
  yq -p csv '[.[] | select(.category == "A")]' data.csv

  # Extract front-matter from markdown/content files
  yq --front-matter '.title' post.md

  # Convert between formats
  yq -p json -o csv '.users' data.json   # JSON to CSV
  yq -p csv -o yaml '.' data.csv         # CSV to YAML
  yq -p ini -o json '.' config.ini       # INI to JSON
  yq -p xml -o json '.' data.xml         # XML to JSON
  yq -o toml '.' config.yaml             # YAML to TOML

  # Common jq functions work in yq:
  yq 'keys' data.yaml                    # get object keys
  yq 'length' data.yaml                  # array/string length
  yq '.items | first' data.yaml          # first element
  yq '.items | last' data.yaml           # last element
  yq '.nums | add' data.yaml             # sum numbers
  yq '.nums | min' data.yaml             # minimum
  yq '.nums | max' data.yaml             # maximum
  yq '.items | unique' data.yaml         # unique values
  yq '.items | group_by(.type)' data.yaml`, options: ["-p, --input-format=FMT   input format: yaml (default), xml, json, ini, csv, toml", "-o, --output-format=FMT  output format: yaml (default), json, xml, ini, csv, toml", "-i, --inplace            modify file in-place", "-r, --raw-output         output strings without quotes (json only)", "-c, --compact            compact output (json only)", "-e, --exit-status        set exit status based on output", "-s, --slurp              read entire input into array", "-n, --null-input         don't read any input", "-j, --join-output        don't print newlines after each output", "-f, --front-matter       extract and process front-matter only", "-P, --prettyPrint        pretty print output", "-I, --indent=N           set indent level (default: 2)", "    --xml-attribute-prefix=STR  XML attribute prefix (default: +@)", "    --xml-content-name=STR  XML text content name (default: +content)", "    --csv-delimiter=CHAR CSV delimiter (default: auto-detect)", "    --csv-header         CSV has header row (default: true)", "    --help               display this help and exit"] };
function Ih(s3) {
  let e5 = { ...Va, exitStatus: false, slurp: false, nullInput: false, joinOutput: false, inplace: false, frontMatter: false }, t4 = false, n3 = ".", i4 = false, r2 = [];
  for (let o2 = 0; o2 < s3.length; o2++) {
    let a3 = s3[o2];
    if (a3.startsWith("--input-format=")) {
      let l3 = a3.slice(15);
      if (!Si(l3)) return r$3("yq", `--input-format=${l3}`);
      e5.inputFormat = l3, t4 = true;
    } else if (a3.startsWith("--output-format=")) {
      let l3 = a3.slice(16);
      if (!Ni(l3)) return r$3("yq", `--output-format=${l3}`);
      e5.outputFormat = l3;
    } else if (a3.startsWith("--indent=")) e5.indent = Number.parseInt(a3.slice(9), 10);
    else if (a3.startsWith("--xml-attribute-prefix=")) e5.xmlAttributePrefix = a3.slice(23);
    else if (a3.startsWith("--xml-content-name=")) e5.xmlContentName = a3.slice(19);
    else if (a3.startsWith("--csv-delimiter=")) e5.csvDelimiter = a3.slice(16);
    else if (a3 === "--csv-header") e5.csvHeader = true;
    else if (a3 === "--no-csv-header") e5.csvHeader = false;
    else if (a3 === "-p" || a3 === "--input-format") {
      let l3 = s3[++o2];
      if (!Si(l3)) return r$3("yq", `${a3} ${l3}`);
      e5.inputFormat = l3, t4 = true;
    } else if (a3 === "-o" || a3 === "--output-format") {
      let l3 = s3[++o2];
      if (!Ni(l3)) return r$3("yq", `${a3} ${l3}`);
      e5.outputFormat = l3;
    } else if (a3 === "-I" || a3 === "--indent") e5.indent = Number.parseInt(s3[++o2], 10);
    else if (a3 === "-r" || a3 === "--raw-output") e5.raw = true;
    else if (a3 === "-c" || a3 === "--compact") e5.compact = true;
    else if (a3 === "-e" || a3 === "--exit-status") e5.exitStatus = true;
    else if (a3 === "-s" || a3 === "--slurp") e5.slurp = true;
    else if (a3 === "-n" || a3 === "--null-input") e5.nullInput = true;
    else if (a3 === "-j" || a3 === "--join-output") e5.joinOutput = true;
    else if (a3 === "-i" || a3 === "--inplace") e5.inplace = true;
    else if (a3 === "-f" || a3 === "--front-matter") e5.frontMatter = true;
    else if (a3 === "-P" || a3 === "--prettyPrint") e5.prettyPrint = true;
    else if (a3 === "-") r2.push("-");
    else {
      if (a3.startsWith("--")) return r$3("yq", a3);
      if (a3.startsWith("-")) for (let l3 of a3.slice(1)) if (l3 === "r") e5.raw = true;
      else if (l3 === "c") e5.compact = true;
      else if (l3 === "e") e5.exitStatus = true;
      else if (l3 === "s") e5.slurp = true;
      else if (l3 === "n") e5.nullInput = true;
      else if (l3 === "j") e5.joinOutput = true;
      else if (l3 === "i") e5.inplace = true;
      else if (l3 === "f") e5.frontMatter = true;
      else if (l3 === "P") e5.prettyPrint = true;
      else return r$3("yq", `-${l3}`);
      else i4 ? r2.push(a3) : (n3 = a3, i4 = true);
    }
  }
  return { options: e5, filter: n3, files: r2, inputFormatExplicit: t4 };
}
var ig = { name: "yq", async execute(s3, e5) {
  if (o$3(s3)) return s$1(kh);
  let t4 = Ih(s3);
  if ("exitCode" in t4) return t4;
  let { options: n3, filter: i4, files: r2, inputFormatExplicit: o2 } = t4;
  if (!o2 && r2.length > 0 && r2[0] !== "-") {
    let c3 = Ka(r2[0]);
    c3 && (n3.inputFormat = c3);
  }
  if (n3.inplace && (r2.length === 0 || r2[0] === "-")) return { stdout: "", stderr: `yq: -i/--inplace requires a file argument
`, exitCode: 1 };
  let a3, l3;
  if (n3.nullInput) a3 = "";
  else if (r2.length === 0 || r2.length === 1 && r2[0] === "-") a3 = e5.stdin;
  else try {
    l3 = e5.fs.resolvePath(e5.cwd, r2[0]), a3 = await e5.fs.readFile(l3);
  } catch {
    return { stdout: "", stderr: `yq: ${r2[0]}: No such file or directory
`, exitCode: 2 };
  }
  try {
    let c3 = te$3(i4), u3, f3 = { limits: e5.limits ? { maxIterations: e5.limits.maxJqIterations } : void 0, env: e5.env };
    if (n3.nullInput) u3 = m$1(null, c3, f3);
    else if (n3.frontMatter) {
      let y2 = Ya(a3);
      if (!y2) return { stdout: "", stderr: `yq: no front-matter found
`, exitCode: 1 };
      u3 = m$1(y2.frontMatter, c3, f3);
    } else if (n3.slurp) {
      let y2;
      n3.inputFormat === "yaml" ? y2 = Ra(a3) : y2 = [Ei(a3, n3)], u3 = m$1(y2, c3, f3);
    } else {
      let y2 = Ei(a3, n3);
      u3 = m$1(y2, c3, f3);
    }
    let d3 = u3.map((y2) => Ua(y2, n3)), p3 = n3.joinOutput ? "" : `
`, g2 = d3.filter((y2) => y2 !== "").join(p3), h3 = g2 ? n3.joinOutput ? g2 : `${g2}
` : "";
    if (n3.inplace && l3) return await e5.fs.writeFile(l3, h3), { stdout: "", stderr: "", exitCode: 0 };
    let m3 = n3.exitStatus && (u3.length === 0 || u3.every((y2) => y2 == null || y2 === false)) ? 1 : 0;
    return { stdout: h3, stderr: "", exitCode: m3 };
  } catch (c3) {
    if (c3 instanceof b$i) return { stdout: "", stderr: `yq: ${c3.message}
`, exitCode: b$i.EXIT_CODE };
    let u3 = c3.message;
    return u3.includes("Unknown function") ? { stdout: "", stderr: `yq: error: ${u3}
`, exitCode: 3 } : { stdout: "", stderr: `yq: parse error: ${u3}
`, exitCode: 5 };
  }
} };
const yqL665QPQU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  yqCommand: ig
});
var g = q$d(xe$2());
function j$2(n3) {
  let r2 = g.default.parse(n3.trim(), { header: true, dynamicTyping: true, skipEmptyLines: true });
  return { headers: r2.meta.fields || [], data: r2.data };
}
function C$1(n3, r2) {
  return r2.length === 0 ? `${n3.join(",")}
` : `${g.default.unparse(r2, { columns: n3 }).replace(/\r\n/g, `
`)}
`;
}
async function w$3(n3, r2) {
  let s3 = n3.find((p3) => !p3.startsWith("-")), i4;
  if (!s3 || s3 === "-") i4 = r2.stdin;
  else try {
    let p3 = r2.fs.resolvePath(r2.cwd, s3);
    i4 = await r2.fs.readFile(p3);
  } catch {
    return { headers: [], data: [], error: { stdout: "", stderr: `xan: ${s3}: No such file or directory
`, exitCode: 1 } };
  }
  let { headers: a3, data: d3 } = j$2(i4);
  return { headers: a3, data: d3 };
}
async function S$3(n3, r2) {
  let s3 = 0, i4 = [], a3 = [];
  for (let t4 = 0; t4 < n3.length; t4++) {
    let e5 = n3[t4];
    (e5 === "-l" || e5 === "--limit") && t4 + 1 < n3.length ? s3 = Number.parseInt(n3[++t4], 10) : (e5 === "-s" || e5 === "--select") && t4 + 1 < n3.length ? i4 = n3[++t4].split(",") : e5.startsWith("-") || a3.push(e5);
  }
  let { headers: d3, data: p3, error: h3 } = await w$3(a3, r2);
  if (h3) return h3;
  let l3 = i4.length > 0 ? i4.filter((t4) => d3.includes(t4)) : d3, c3 = s3 > 0 ? p3.slice(0, s3) : p3, f3 = Math.max(...l3.map((t4) => t4.length)), o2 = [], $5 = "".repeat(80);
  for (let t4 = 0; t4 < c3.length; t4++) {
    let e5 = c3[t4];
    o2.push(`Row n${t4}`), o2.push($5);
    for (let u3 of l3) {
      let m3 = e5[u3], v2 = m3 == null ? "" : String(m3);
      o2.push(`${u3.padEnd(f3)} ${v2}`);
    }
    t4 < c3.length - 1 && o2.push("");
  }
  return { stdout: `${o2.join(`
`)}
`, stderr: "", exitCode: 0 };
}
async function W$2(n3, r2) {
  let s3 = 0, i4 = [];
  for (let t4 = 0; t4 < n3.length; t4++) {
    let e5 = n3[t4];
    e5 === "-n" && t4 + 1 < n3.length ? s3 = Number.parseInt(n3[++t4], 10) : e5.startsWith("-") || i4.push(e5);
  }
  let { headers: a3, data: d3, error: p3 } = await w$3(i4, r2);
  if (p3) return p3;
  let h3 = s3 > 0 ? d3.slice(0, s3) : d3, l3 = a3.map((t4) => t4.length);
  for (let t4 of h3) for (let e5 = 0; e5 < a3.length; e5++) {
    let u3 = String(t4[a3[e5]] ?? "");
    l3[e5] = Math.max(l3[e5], u3.length);
  }
  let c3 = [], f3 = "", o2 = "";
  c3.push(`${l3.map((t4) => f3.repeat(t4 + 2)).join("")}`);
  let $5 = a3.map((t4, e5) => ` ${t4.padEnd(l3[e5])} `).join(o2);
  c3.push(`${o2}${$5}${o2}`), c3.push(`${l3.map((t4) => f3.repeat(t4 + 2)).join("")}`);
  for (let t4 of h3) {
    let e5 = a3.map((u3, m3) => ` ${String(t4[u3] ?? "").padEnd(l3[m3])} `).join(o2);
    c3.push(`${o2}${e5}${o2}`);
  }
  return c3.push(`${l3.map((t4) => f3.repeat(t4 + 2)).join("")}`), { stdout: `${c3.join(`
`)}
`, stderr: "", exitCode: 0 };
}
var V$2, je2 = n$4(() => {
  V$2 = class {
    input;
    pos = 0;
    tokens = [];
    constructor(n3) {
      this.input = n3;
    }
    tokenize() {
      for (; this.pos < this.input.length && (this.skipWhitespace(), !(this.pos >= this.input.length)); ) {
        let n3 = this.nextToken();
        n3 && this.tokens.push(n3);
      }
      return this.tokens.push({ type: "eof", value: "", pos: this.pos }), this.tokens;
    }
    skipWhitespace() {
      for (; this.pos < this.input.length; ) {
        let n3 = this.input[this.pos];
        if (n3 === " " || n3 === "	" || n3 === `
` || n3 === "\r") this.pos++;
        else if (n3 === "#") for (; this.pos < this.input.length && this.input[this.pos] !== `
`; ) this.pos++;
        else break;
      }
    }
    nextToken() {
      let n3 = this.pos, t4 = this.input[this.pos];
      if (t4 >= "0" && t4 <= "9") return this.readNumber();
      if (t4 === '"' || t4 === "'" || t4 === "`") return this.readString(t4);
      if (t4 === "b" && this.pos + 1 < this.input.length) {
        let r2 = this.input[this.pos + 1];
        if (r2 === '"' || r2 === "'" || r2 === "`") return this.pos++, this.readString(r2);
      }
      if (t4 === "/") {
        let r2 = this.tokens[this.tokens.length - 1];
        return r2 && (r2.type === "int" || r2.type === "float" || r2.type === "string" || r2.type === "ident" || r2.type === ")" || r2.type === "]") ? this.input[this.pos + 1] === "/" ? (this.pos += 2, { type: "//", value: "//", pos: n3 }) : (this.pos++, { type: "/", value: "/", pos: n3 }) : this.readRegex();
      }
      if (this.match("not in")) return { type: "not in", value: "not in", pos: n3 };
      if (this.match("=>")) return { type: "=>", value: "=>", pos: n3 };
      if (this.match("**")) return { type: "**", value: "**", pos: n3 };
      if (this.match("++")) return { type: "++", value: "++", pos: n3 };
      if (this.match("//")) return { type: "//", value: "//", pos: n3 };
      if (this.match("==")) return { type: "==", value: "==", pos: n3 };
      if (this.match("!=")) return { type: "!=", value: "!=", pos: n3 };
      if (this.match("<=")) return { type: "<=", value: "<=", pos: n3 };
      if (this.match(">=")) return { type: ">=", value: ">=", pos: n3 };
      if (this.match("&&")) return { type: "&&", value: "&&", pos: n3 };
      if (this.match("||")) return { type: "||", value: "||", pos: n3 };
      let s3 = { "(": "(", ")": ")", "[": "[", "]": "]", "{": "{", "}": "}", ",": ",", ":": ":", ";": ";", "+": "+", "-": "-", "*": "*", "%": "%", "<": "<", ">": ">", "!": "!", ".": ".", "|": "|", "=": "=" };
      if (t4 in s3) return this.pos++, { type: s3[t4], value: t4, pos: n3 };
      if (this.isIdentStart(t4)) return this.readIdentifier();
      throw new Error(`Unexpected character '${t4}' at position ${this.pos}`);
    }
    match(n3) {
      if (this.input.slice(this.pos, this.pos + n3.length) === n3) {
        if (/^[a-zA-Z]/.test(n3)) {
          let t4 = this.input[this.pos + n3.length];
          if (t4 && this.isIdentChar(t4)) return false;
        }
        return this.pos += n3.length, true;
      }
      return false;
    }
    isIdentStart(n3) {
      return n3 >= "a" && n3 <= "z" || n3 >= "A" && n3 <= "Z" || n3 === "_";
    }
    isIdentChar(n3) {
      return this.isIdentStart(n3) || n3 >= "0" && n3 <= "9";
    }
    readNumber() {
      let n3 = this.pos, t4 = false, s3 = false;
      for (; this.pos < this.input.length; ) {
        let o2 = this.input[this.pos];
        if (o2 >= "0" && o2 <= "9") this.pos++;
        else if (o2 === "_") this.pos++;
        else if (o2 === "." && !t4 && !s3) t4 = true, this.pos++;
        else if ((o2 === "e" || o2 === "E") && !s3) s3 = true, t4 = true, this.pos++, this.pos < this.input.length && (this.input[this.pos] === "+" || this.input[this.pos] === "-") && this.pos++;
        else break;
      }
      let r2 = this.input.slice(n3, this.pos).replace(/_/g, "");
      return { type: t4 ? "float" : "int", value: r2, pos: n3 };
    }
    readString(n3) {
      let t4 = this.pos;
      this.pos++;
      let s3 = "";
      for (; this.pos < this.input.length; ) {
        let r2 = this.input[this.pos];
        if (r2 === n3) return this.pos++, { type: "string", value: s3, pos: t4 };
        if (r2 === "\\") {
          if (this.pos++, this.pos < this.input.length) {
            let o2 = this.input[this.pos];
            switch (o2) {
              case "n":
                s3 += `
`;
                break;
              case "r":
                s3 += "\r";
                break;
              case "t":
                s3 += "	";
                break;
              case "\\":
                s3 += "\\";
                break;
              case '"':
                s3 += '"';
                break;
              case "'":
                s3 += "'";
                break;
              case "`":
                s3 += "`";
                break;
              case "0":
                s3 += "\0";
                break;
              default:
                s3 += o2;
            }
            this.pos++;
          }
        } else s3 += r2, this.pos++;
      }
      throw new Error(`Unterminated string starting at position ${t4}`);
    }
    readRegex() {
      let n3 = this.pos;
      this.pos++;
      let t4 = "", s3 = "";
      for (; this.pos < this.input.length; ) {
        let r2 = this.input[this.pos];
        if (r2 === "/") {
          for (this.pos++; this.pos < this.input.length && this.input[this.pos] === "i"; ) s3 += this.input[this.pos], this.pos++;
          return { type: "regex", value: t4 + (s3 ? `/${s3}` : ""), pos: n3 };
        }
        r2 === "\\" ? (t4 += r2, this.pos++, this.pos < this.input.length && (t4 += this.input[this.pos], this.pos++)) : (t4 += r2, this.pos++);
      }
      throw new Error(`Unterminated regex starting at position ${n3}`);
    }
    readIdentifier() {
      let n3 = this.pos;
      for (; this.pos < this.input.length && this.isIdentChar(this.input[this.pos]); ) this.pos++;
      let t4 = false;
      this.pos < this.input.length && this.input[this.pos] === "?" && (t4 = true, this.pos++);
      let s3 = this.input.slice(n3, t4 ? this.pos - 1 : this.pos);
      t4 && (s3 += "?");
      let r2 = { true: "true", false: "false", null: "null", and: "and", or: "or", eq: "eq", ne: "ne", lt: "lt", le: "le", gt: "gt", ge: "ge", in: "in", as: "as", _: "_" }, o2 = s3.replace(/\?$/, "");
      return o2 in r2 && !t4 ? { type: r2[o2], value: o2, pos: n3 } : { type: "ident", value: s3, pos: n3 };
    }
  };
});
var De = {};
p$d(De, { parseMoonblade: () => W$1, parseNamedExpressions: () => T2 });
function T2(e5) {
  let n3 = [], s3 = new V$2(e5).tokenize(), r2 = 0, o2 = () => s3[r2] || { type: "eof", value: "", pos: 0 }, a3 = () => s3[r2++];
  for (; o2().type !== "eof"; ) {
    if (o2().type === "," && n3.length > 0) {
      a3();
      continue;
    }
    let d3 = [], u3 = 0, p3 = r2;
    for (; o2().type !== "eof"; ) {
      let i4 = o2();
      if ((i4.type === "," || i4.type === "as") && u3 === 0) break;
      (i4.type === "(" || i4.type === "[" || i4.type === "{") && u3++, (i4.type === ")" || i4.type === "]" || i4.type === "}") && u3--, d3.push(a3());
    }
    d3.push({ type: "eof", value: "", pos: 0 });
    let h3 = new U$1(d3).parse(), c3;
    if (o2().type === "as") if (a3(), o2().type === "(") {
      a3();
      let i4 = [];
      for (; o2().type !== ")" && o2().type !== "eof"; ) (o2().type === "ident" || o2().type === "string") && (i4.push(o2().value), a3()), o2().type === "," && a3();
      o2().type === ")" && a3(), c3 = i4;
    } else if (o2().type === "ident" || o2().type === "string") c3 = o2().value, a3();
    else throw new Error(`Expected name after 'as', got ${o2().type}`);
    else c3 = e5.slice(s3[p3].pos, s3[r2 - 1]?.pos || e5.length).trim(), h3.type === "identifier" && (c3 = h3.name);
    n3.push({ expr: h3, name: c3 });
  }
  return n3;
}
function W$1(e5) {
  let t4 = new V$2(e5).tokenize();
  return new U$1(t4).parse();
}
var O$3, U$1, j$1 = n$4(() => {
  je2();
  O$3 = { PIPE: 1, OR: 2, AND: 3, EQUALITY: 4, COMPARISON: 5, ADDITIVE: 6, MULTIPLICATIVE: 7, POWER: 8, UNARY: 9, POSTFIX: 10 }, U$1 = class {
    pos = 0;
    tokens;
    constructor(n3) {
      this.tokens = n3;
    }
    parse() {
      let n3 = this.parseExpr(0);
      if (this.peek().type !== "eof") throw new Error(`Unexpected token: ${this.peek().value}`);
      return n3;
    }
    parseExpr(n3) {
      let t4 = this.parsePrefix();
      for (; ; ) {
        let s3 = this.peek(), r2 = this.getInfixPrec(s3.type);
        if (r2 < n3) break;
        t4 = this.parseInfix(t4, r2);
      }
      return t4;
    }
    parsePrefix() {
      let n3 = this.peek();
      switch (n3.type) {
        case "int":
          return this.advance(), { type: "int", value: Number.parseInt(n3.value, 10) };
        case "float":
          return this.advance(), { type: "float", value: Number.parseFloat(n3.value) };
        case "string":
          return this.advance(), { type: "string", value: n3.value };
        case "regex": {
          this.advance();
          let t4 = n3.value.split("/"), s3 = t4.length > 1 ? t4[t4.length - 1] : "";
          return { type: "regex", pattern: t4.slice(0, -1).join("/") || n3.value, caseInsensitive: s3.includes("i") };
        }
        case "true":
          return this.advance(), { type: "bool", value: true };
        case "false":
          return this.advance(), { type: "bool", value: false };
        case "null":
          return this.advance(), { type: "null" };
        case "_":
          return this.advance(), { type: "underscore" };
        case "ident": {
          let t4 = n3.value, s3 = t4.endsWith("?"), r2 = s3 ? t4.slice(0, -1) : t4;
          if (this.advance(), this.peek().type === "(") return this.parseFunctionCall(r2);
          if (this.peek().type === "=>") {
            this.advance();
            let o2 = this.parseExpr(0);
            return this.bindLambdaArgs({ type: "lambda", params: [r2], body: o2 }, [r2]);
          }
          return { type: "identifier", name: r2, unsure: s3 };
        }
        case "(": {
          this.advance();
          let t4 = [];
          if (this.peek().type === ")") {
            if (this.advance(), this.peek().type === "=>") {
              this.advance();
              let r2 = this.parseExpr(0);
              return { type: "lambda", params: [], body: r2 };
            }
            throw new Error("Empty parentheses not allowed");
          }
          if (this.peek().type === "ident") {
            let r2 = this.peek().value;
            if (this.advance(), this.peek().type === "," || this.peek().type === ")") {
              for (t4.push(r2); this.peek().type === "," && (this.advance(), this.peek().type === "ident"); ) t4.push(this.peek().value), this.advance();
              if (this.peek().type === ")" && (this.advance(), this.peek().type === "=>")) {
                this.advance();
                let o2 = this.parseExpr(0);
                return this.bindLambdaArgs({ type: "lambda", params: t4, body: o2 }, t4);
              }
              this.pos -= t4.length * 2, t4.length > 1 && (this.pos = this.pos);
            }
            this.pos--;
          }
          let s3 = this.parseExpr(0);
          return this.expect(")"), this.peek().type, s3;
        }
        case "[":
          return this.parseList();
        case "{":
          return this.parseMap();
        case "-": {
          this.advance();
          let t4 = this.parseExpr(O$3.UNARY);
          return t4.type === "int" ? { type: "int", value: -t4.value } : t4.type === "float" ? { type: "float", value: -t4.value } : { type: "func", name: "neg", args: [{ expr: t4 }] };
        }
        case "!":
          return this.advance(), { type: "func", name: "not", args: [{ expr: this.parseExpr(O$3.UNARY) }] };
        default:
          throw new Error(`Unexpected token: ${n3.type} (${n3.value})`);
      }
    }
    parseFunctionCall(n3) {
      this.expect("(");
      let t4 = [];
      if (this.peek().type !== ")") do {
        t4.length > 0 && this.peek().type === "," && this.advance();
        let s3;
        if (this.peek().type === "ident") {
          let o2 = this.peek().value, a3 = this.pos + 1;
          a3 < this.tokens.length && this.tokens[a3].type === "=" && (s3 = o2, this.advance(), this.advance());
        }
        let r2 = this.parseExpr(0);
        t4.push({ name: s3, expr: r2 });
      } while (this.peek().type === ",");
      return this.expect(")"), { type: "func", name: n3.toLowerCase(), args: t4 };
    }
    parseList() {
      this.expect("[");
      let n3 = [];
      if (this.peek().type !== "]") do
        n3.length > 0 && this.peek().type === "," && this.advance(), n3.push(this.parseExpr(0));
      while (this.peek().type === ",");
      return this.expect("]"), { type: "list", elements: n3 };
    }
    parseMap() {
      this.expect("{");
      let n3 = [];
      if (this.peek().type !== "}") do {
        n3.length > 0 && this.peek().type === "," && this.advance();
        let t4;
        if (this.peek().type === "ident") t4 = this.peek().value, this.advance();
        else if (this.peek().type === "string") t4 = this.peek().value, this.advance();
        else throw new Error(`Expected map key, got ${this.peek().type}`);
        this.expect(":");
        let s3 = this.parseExpr(0);
        n3.push({ key: t4, value: s3 });
      } while (this.peek().type === ",");
      return this.expect("}"), { type: "map", entries: n3 };
    }
    parseInfix(n3, t4) {
      let s3 = this.peek(), r2 = { "+": "add", "-": "sub", "*": "mul", "/": "div", "//": "idiv", "%": "mod", "**": "pow", "++": "concat", "==": "==", "!=": "!=", "<": "<", "<=": "<=", ">": ">", ">=": ">=", eq: "eq", ne: "ne", lt: "lt", le: "le", gt: "gt", ge: "ge", "&&": "and", and: "and", "||": "or", or: "or" };
      if (s3.type in r2) {
        this.advance();
        let o2 = this.parseExpr(t4 + (this.isRightAssoc(s3.type) ? 0 : 1));
        return { type: "func", name: r2[s3.type], args: [{ expr: n3 }, { expr: o2 }] };
      }
      if (s3.type === "|") {
        this.advance();
        let o2 = this.parseExpr(t4);
        return this.handlePipe(n3, o2);
      }
      if (s3.type === ".") return this.advance(), this.handleDot(n3);
      if (s3.type === "[") return this.advance(), this.handleIndexing(n3);
      if (s3.type === "in") return this.advance(), { type: "func", name: "contains", args: [{ expr: this.parseExpr(t4 + 1) }, { expr: n3 }] };
      if (s3.type === "not in") return this.advance(), { type: "func", name: "not", args: [{ expr: { type: "func", name: "contains", args: [{ expr: this.parseExpr(t4 + 1) }, { expr: n3 }] } }] };
      throw new Error(`Unexpected infix token: ${s3.type}`);
    }
    handlePipe(n3, t4) {
      if (t4.type === "identifier") return { type: "func", name: t4.name, args: [{ expr: n3 }] };
      if (t4.type === "func") {
        let s3 = this.countUnderscores(t4);
        return s3 === 0 ? t4 : s3 === 1 ? this.fillUnderscore(t4, n3) : { type: "pipeline", exprs: [n3, t4] };
      }
      return this.countUnderscores(t4) === 1 ? this.fillUnderscore(t4, n3) : t4;
    }
    handleDot(n3) {
      let t4 = this.peek();
      if (t4.type === "ident") {
        let s3 = t4.value;
        if (this.advance(), this.peek().type === "(") {
          let r2 = this.parseFunctionCall(s3);
          return r2.type === "func" && r2.args.unshift({ expr: n3 }), r2;
        }
        return { type: "func", name: "get", args: [{ expr: n3 }, { expr: { type: "string", value: s3 } }] };
      }
      if (t4.type === "int") {
        let s3 = Number.parseInt(t4.value, 10);
        return this.advance(), { type: "func", name: "get", args: [{ expr: n3 }, { expr: { type: "int", value: s3 } }] };
      }
      if (t4.type === "string") {
        let s3 = t4.value;
        return this.advance(), { type: "func", name: "get", args: [{ expr: n3 }, { expr: { type: "string", value: s3 } }] };
      }
      throw new Error(`Expected identifier, number, or string after dot, got ${t4.type}`);
    }
    handleIndexing(n3) {
      if (this.peek().type === ":") {
        if (this.advance(), this.peek().type === "]") return this.advance(), { type: "func", name: "slice", args: [{ expr: n3 }] };
        let s3 = this.parseExpr(0);
        return this.expect("]"), { type: "func", name: "slice", args: [{ expr: n3 }, { expr: { type: "int", value: 0 } }, { expr: s3 }] };
      }
      let t4 = this.parseExpr(0);
      if (this.peek().type === ":") {
        if (this.advance(), this.peek().type === "]") return this.advance(), { type: "func", name: "slice", args: [{ expr: n3 }, { expr: t4 }] };
        let s3 = this.parseExpr(0);
        return this.expect("]"), { type: "func", name: "slice", args: [{ expr: n3 }, { expr: t4 }, { expr: s3 }] };
      }
      return this.expect("]"), { type: "func", name: "get", args: [{ expr: n3 }, { expr: t4 }] };
    }
    countUnderscores(n3) {
      return n3.type === "underscore" ? 1 : n3.type === "func" ? n3.args.reduce((t4, s3) => t4 + this.countUnderscores(s3.expr), 0) : n3.type === "list" ? n3.elements.reduce((t4, s3) => t4 + this.countUnderscores(s3), 0) : n3.type === "map" ? n3.entries.reduce((t4, s3) => t4 + this.countUnderscores(s3.value), 0) : 0;
    }
    fillUnderscore(n3, t4) {
      return n3.type === "underscore" ? t4 : n3.type === "func" ? { ...n3, args: n3.args.map((s3) => ({ ...s3, expr: this.fillUnderscore(s3.expr, t4) })) } : n3.type === "list" ? { ...n3, elements: n3.elements.map((s3) => this.fillUnderscore(s3, t4)) } : n3.type === "map" ? { ...n3, entries: n3.entries.map((s3) => ({ ...s3, value: this.fillUnderscore(s3.value, t4) })) } : n3;
    }
    bindLambdaArgs(n3, t4) {
      return { ...n3, body: this.bindLambdaArgsInExpr(n3.body, t4) };
    }
    bindLambdaArgsInExpr(n3, t4) {
      return n3.type === "identifier" && t4.includes(n3.name) ? { type: "lambdaBinding", name: n3.name } : n3.type === "func" ? { ...n3, args: n3.args.map((s3) => ({ ...s3, expr: this.bindLambdaArgsInExpr(s3.expr, t4) })) } : n3.type === "list" ? { ...n3, elements: n3.elements.map((s3) => this.bindLambdaArgsInExpr(s3, t4)) } : n3.type === "map" ? { ...n3, entries: n3.entries.map((s3) => ({ ...s3, value: this.bindLambdaArgsInExpr(s3.value, t4) })) } : n3;
    }
    getInfixPrec(n3) {
      switch (n3) {
        case "|":
          return O$3.PIPE;
        case "||":
        case "or":
          return O$3.OR;
        case "&&":
        case "and":
          return O$3.AND;
        case "==":
        case "!=":
        case "eq":
        case "ne":
          return O$3.EQUALITY;
        case "<":
        case "<=":
        case ">":
        case ">=":
        case "lt":
        case "le":
        case "gt":
        case "ge":
        case "in":
        case "not in":
          return O$3.COMPARISON;
        case "+":
        case "-":
        case "++":
          return O$3.ADDITIVE;
        case "*":
        case "/":
        case "//":
        case "%":
          return O$3.MULTIPLICATIVE;
        case "**":
          return O$3.POWER;
        case ".":
        case "[":
          return O$3.POSTFIX;
        default:
          return -1;
      }
    }
    isRightAssoc(n3) {
      return n3 === "**";
    }
    peek() {
      return this.tokens[this.pos] || { type: "eof", value: "", pos: 0 };
    }
    advance() {
      return this.tokens[this.pos++];
    }
    expect(n3) {
      let t4 = this.peek();
      if (t4.type !== n3) throw new Error(`Expected ${n3}, got ${t4.type}`);
      return this.advance();
    }
  };
});
j$1();
function N$2(e5, n3) {
  return n3.length === 0 ? I$2(e5, []) : n3.length === 1 ? { type: "Pipe", left: n3[0], right: I$2(e5, []) } : { type: "Pipe", left: n3[0], right: I$2(e5, n3.slice(1)) };
}
var We = { add: (e5) => b$1("+", e5[0], e5[1]), sub: (e5) => b$1("-", e5[0], e5[1]), mul: (e5) => b$1("*", e5[0], e5[1]), div: (e5) => b$1("/", e5[0], e5[1]), mod: (e5) => b$1("%", e5[0], e5[1]), idiv: (e5) => I$2("floor", [b$1("/", e5[0], e5[1])]), pow: (e5) => N$2("pow", e5), neg: (e5) => ({ type: "UnaryOp", op: "-", operand: e5[0] }), "==": (e5) => b$1("==", e5[0], e5[1]), "!=": (e5) => b$1("!=", e5[0], e5[1]), "<": (e5) => b$1("<", e5[0], e5[1]), "<=": (e5) => b$1("<=", e5[0], e5[1]), ">": (e5) => b$1(">", e5[0], e5[1]), ">=": (e5) => b$1(">=", e5[0], e5[1]), eq: (e5) => b$1("==", L$1(e5[0]), L$1(e5[1])), ne: (e5) => b$1("!=", L$1(e5[0]), L$1(e5[1])), lt: (e5) => b$1("<", L$1(e5[0]), L$1(e5[1])), le: (e5) => b$1("<=", L$1(e5[0]), L$1(e5[1])), gt: (e5) => b$1(">", L$1(e5[0]), L$1(e5[1])), ge: (e5) => b$1(">=", L$1(e5[0]), L$1(e5[1])), and: (e5) => b$1("and", e5[0], e5[1]), or: (e5) => b$1("or", e5[0], e5[1]), not: (e5) => ({ type: "UnaryOp", op: "not", operand: e5[0] }), len: (e5) => N$2("length", e5), length: (e5) => N$2("length", e5), upper: (e5) => N$2("ascii_upcase", e5), lower: (e5) => N$2("ascii_downcase", e5), trim: (e5) => N$2("trim", e5), ltrim: (e5) => e5.length === 0 ? I$2("ltrimstr", [{ type: "Literal", value: " " }]) : { type: "Pipe", left: e5[0], right: I$2("ltrimstr", [{ type: "Literal", value: " " }]) }, rtrim: (e5) => e5.length === 0 ? I$2("rtrimstr", [{ type: "Literal", value: " " }]) : { type: "Pipe", left: e5[0], right: I$2("rtrimstr", [{ type: "Literal", value: " " }]) }, split: (e5) => N$2("split", e5), join: (e5) => e5.length === 1 ? I$2("join", [{ type: "Literal", value: "" }]) : N$2("join", e5), concat: (e5) => b$1("+", e5[0], e5[1]), startswith: (e5) => N$2("startswith", e5), endswith: (e5) => N$2("endswith", e5), contains: (e5) => N$2("contains", e5), replace: (e5) => N$2("gsub", e5), substr: (e5) => e5.length === 2 ? { type: "Slice", base: e5[0], start: e5[1] } : { type: "Slice", base: e5[0], start: e5[1], end: b$1("+", e5[1], e5[2]) }, abs: (e5) => N$2("fabs", e5), floor: (e5) => N$2("floor", e5), ceil: (e5) => N$2("ceil", e5), round: (e5) => N$2("round", e5), sqrt: (e5) => N$2("sqrt", e5), log: (e5) => N$2("log", e5), log10: (e5) => N$2("log10", e5), log2: (e5) => N$2("log2", e5), exp: (e5) => N$2("exp", e5), sin: (e5) => N$2("sin", e5), cos: (e5) => N$2("cos", e5), tan: (e5) => N$2("tan", e5), asin: (e5) => N$2("asin", e5), acos: (e5) => N$2("acos", e5), atan: (e5) => N$2("atan", e5), min: (e5) => N$2("min", e5), max: (e5) => N$2("max", e5), first: (e5) => e5.length === 0 ? { type: "Index", index: { type: "Literal", value: 0 } } : { type: "Index", index: { type: "Literal", value: 0 }, base: e5[0] }, last: (e5) => e5.length === 0 ? { type: "Index", index: { type: "Literal", value: -1 } } : { type: "Index", index: { type: "Literal", value: -1 }, base: e5[0] }, get: (e5) => e5.length === 1 ? { type: "Index", index: e5[0] } : { type: "Index", index: e5[1], base: e5[0] }, slice: (e5) => e5.length === 1 ? { type: "Slice", base: e5[0] } : e5.length === 2 ? { type: "Slice", base: e5[0], start: e5[1] } : { type: "Slice", base: e5[0], start: e5[1], end: e5[2] }, keys: "keys", values: "values", entries: (e5) => I$2("to_entries", e5), from_entries: "from_entries", reverse: "reverse", sort: "sort", sort_by: "sort_by", group_by: "group_by", unique: "unique", unique_by: "unique_by", flatten: "flatten", map: (e5) => ({ type: "Pipe", left: e5[0], right: { type: "Array", elements: e5[1] } }), select: (e5) => I$2("select", e5), empty: () => I$2("empty", []), count: () => I$2("length", []), sum: (e5) => e5.length === 0 ? I$2("add", []) : { type: "Pipe", left: { type: "Array", elements: e5[0] }, right: I$2("add", []) }, mean: (e5) => e5.length === 0 ? { type: "Pipe", left: { type: "Identity" }, right: b$1("/", I$2("add", []), I$2("length", [])) } : { type: "Pipe", left: { type: "Array", elements: e5[0] }, right: b$1("/", I$2("add", []), I$2("length", [])) }, avg: (e5) => e5.length === 0 ? { type: "Pipe", left: { type: "Identity" }, right: b$1("/", I$2("add", []), I$2("length", [])) } : { type: "Pipe", left: { type: "Array", elements: e5[0] }, right: b$1("/", I$2("add", []), I$2("length", [])) }, type: "type", isnull: (e5) => e5.length === 0 ? b$1("==", { type: "Identity" }, { type: "Literal", value: null }) : b$1("==", e5[0], { type: "Literal", value: null }), isempty: (e5) => e5.length === 0 ? b$1("==", { type: "Identity" }, { type: "Literal", value: "" }) : b$1("==", e5[0], { type: "Literal", value: "" }), tonumber: (e5) => e5.length === 0 ? I$2("tonumber", []) : I$2("tonumber", e5), tostring: (e5) => e5.length === 0 ? I$2("tostring", []) : I$2("tostring", e5), if: (e5) => Ve2(e5[0], e5[1], e5[2]), coalesce: (e5) => {
  if (e5.length === 0) return { type: "Literal", value: null };
  if (e5.length === 1) return e5[0];
  let [n3, ...t4] = e5, s3 = b$1("and", b$1("!=", n3, { type: "Literal", value: null }), b$1("!=", n3, { type: "Literal", value: "" }));
  return Ve2(s3, n3, t4.length === 1 ? t4[0] : We.coalesce(t4));
}, index: () => ({ type: "Field", name: "_row_index" }), now: () => I$2("now", []), fmt: (e5) => I$2("tostring", e5), format: (e5) => I$2("tostring", e5) };
function b$1(e5, n3, t4) {
  return { type: "BinaryOp", op: e5, left: n3, right: t4 };
}
function I$2(e5, n3) {
  return { type: "Call", name: e5, args: n3 };
}
var Ye = "then";
function Ve2(e5, n3, t4) {
  let s3 = { type: "Cond", cond: e5, elifs: [], else: t4 || { type: "Literal", value: null } };
  return s3[Ye] = n3, s3;
}
function L$1(e5) {
  return { type: "Pipe", left: e5, right: { type: "Call", name: "tostring", args: [] } };
}
function A$2(e5, n3 = true) {
  switch (e5.type) {
    case "int":
    case "float":
      return { type: "Literal", value: e5.value };
    case "string":
      return { type: "Literal", value: e5.value };
    case "bool":
      return { type: "Literal", value: e5.value };
    case "null":
      return { type: "Literal", value: null };
    case "underscore":
      return { type: "Index", base: { type: "Identity" }, index: { type: "Literal", value: "_" } };
    case "identifier":
      return n3 ? { type: "Field", name: e5.name } : { type: "VarRef", name: e5.name };
    case "lambdaBinding":
      return { type: "VarRef", name: e5.name };
    case "func": {
      let t4 = e5.args.map((r2) => A$2(r2.expr, n3)), s3 = We[e5.name];
      return typeof s3 == "function" ? s3(t4) : I$2(typeof s3 == "string" ? s3 : e5.name, t4);
    }
    case "list":
      return e5.elements.length === 0 ? { type: "Array" } : { type: "Array", elements: e5.elements.reduce((t4, s3, r2) => {
        let o2 = A$2(s3, n3);
        return r2 === 0 ? o2 : { type: "Comma", left: t4, right: o2 };
      }, null) };
    case "map":
      return { type: "Object", entries: e5.entries.map((t4) => ({ key: t4.key, value: A$2(t4.value, n3) })) };
    case "regex":
      return { type: "Literal", value: e5.pattern };
    case "slice":
      return { type: "Slice", start: e5.start ? A$2(e5.start, n3) : void 0, end: e5.end ? A$2(e5.end, n3) : void 0 };
    case "lambda":
      return A$2(e5.body, n3);
    case "pipeline":
      return { type: "Identity" };
    default:
      throw new Error(`Unknown moonblade expression type: ${e5.type}`);
  }
}
function K(e5) {
  let n3 = [], t4 = 0;
  for (; t4 < e5.length; ) {
    for (; t4 < e5.length && (e5[t4] === " " || e5[t4] === ","); ) t4++;
    if (t4 >= e5.length) break;
    let s3 = t4;
    for (; t4 < e5.length && /\w/.test(e5[t4]); ) t4++;
    let r2 = e5.slice(s3, t4);
    for (; t4 < e5.length && e5[t4] === " "; ) t4++;
    if (e5[t4] !== "(") break;
    t4++;
    let o2 = 1, a3 = t4;
    for (; t4 < e5.length && o2 > 0; ) e5[t4] === "(" ? o2++ : e5[t4] === ")" && o2--, o2 > 0 && t4++;
    let d3 = e5.slice(a3, t4).trim();
    for (t4++; t4 < e5.length && e5[t4] === " "; ) t4++;
    let u3 = "";
    if (e5.slice(t4, t4 + 3).toLowerCase() === "as ") {
      for (t4 += 3; t4 < e5.length && e5[t4] === " "; ) t4++;
      let p3 = t4;
      for (; t4 < e5.length && /\w/.test(e5[t4]); ) t4++;
      u3 = e5.slice(p3, t4);
    }
    u3 || (u3 = d3 ? `${r2}(${d3})` : `${r2}()`), n3.push({ func: r2, expr: d3, alias: u3 });
  }
  return n3;
}
function Ue(e5) {
  return /^\w+$/.test(e5);
}
function z(e5, n3, t4) {
  let s3 = A$2(W$1(n3)), r2 = m$1(e5, s3, t4);
  return r2.length > 0 ? r2[0] : null;
}
function G(e5, n3, t4 = {}) {
  let { func: s3, expr: r2 } = n3;
  if (s3 === "count" && !r2) return e5.length;
  let o2;
  switch (Ue(r2) ? o2 = e5.map((a3) => a3[r2]).filter((a3) => a3 != null) : o2 = e5.map((a3) => z(a3, r2, t4)).filter((a3) => a3 != null), s3) {
    case "count":
      return Ue(r2) ? o2.length : o2.filter((a3) => !!a3).length;
    case "sum":
      return o2.map((d3) => typeof d3 == "number" ? d3 : Number.parseFloat(String(d3))).reduce((d3, u3) => d3 + u3, 0);
    case "mean":
    case "avg": {
      let a3 = o2.map((d3) => typeof d3 == "number" ? d3 : Number.parseFloat(String(d3)));
      return a3.length > 0 ? a3.reduce((d3, u3) => d3 + u3, 0) / a3.length : 0;
    }
    case "min": {
      let a3 = o2.map((d3) => typeof d3 == "number" ? d3 : Number.parseFloat(String(d3)));
      return a3.length > 0 ? Math.min(...a3) : null;
    }
    case "max": {
      let a3 = o2.map((d3) => typeof d3 == "number" ? d3 : Number.parseFloat(String(d3)));
      return a3.length > 0 ? Math.max(...a3) : null;
    }
    case "first":
      return o2.length > 0 ? o2[0] : null;
    case "last":
      return o2.length > 0 ? o2[o2.length - 1] : null;
    case "median": {
      let a3 = o2.map((u3) => typeof u3 == "number" ? u3 : Number.parseFloat(String(u3))).filter((u3) => !Number.isNaN(u3)).sort((u3, p3) => u3 - p3);
      if (a3.length === 0) return null;
      let d3 = Math.floor(a3.length / 2);
      return a3.length % 2 === 0 ? (a3[d3 - 1] + a3[d3]) / 2 : a3[d3];
    }
    case "mode": {
      let a3 = /* @__PURE__ */ new Map();
      for (let p3 of o2) {
        let l3 = String(p3);
        a3.set(l3, (a3.get(l3) || 0) + 1);
      }
      let d3 = 0, u3 = null;
      for (let [p3, l3] of a3) l3 > d3 && (d3 = l3, u3 = p3);
      return u3;
    }
    case "cardinality":
      return new Set(o2.map((d3) => String(d3))).size;
    case "values":
      return o2.map((a3) => String(a3)).join("|");
    case "distinct_values":
      return [...new Set(o2.map((d3) => String(d3)))].sort().join("|");
    case "all": {
      if (e5.length === 0) return true;
      for (let a3 of e5) if (!z(a3, r2, t4)) return false;
      return true;
    }
    case "any": {
      for (let a3 of e5) if (z(a3, r2, t4)) return true;
      return false;
    }
    default:
      return null;
  }
}
function qe(e5, n3, t4 = {}) {
  let s3 = {};
  for (let r2 of n3) s3[r2.alias] = G(e5, r2, t4);
  return s3;
}
async function X$1(e5, n3) {
  let t4 = "", s3 = [];
  for (let l3 of e5) l3.startsWith("-") || (t4 ? s3.push(l3) : t4 = l3);
  if (!t4) return { stdout: "", stderr: `xan agg: no aggregation expression
`, exitCode: 1 };
  let { data: r2, error: o2 } = await w$3(s3, n3);
  if (o2) return o2;
  let a3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, d3 = K(t4), u3 = d3.map((l3) => l3.alias), p3 = qe(r2, d3, a3);
  return { stdout: C$1(u3, [p3]), stderr: "", exitCode: 0 };
}
async function Y$1(e5, n3) {
  let t4 = "", s3 = "", r2 = [];
  for (let f3 = 0; f3 < e5.length; f3++) {
    let m3 = e5[f3];
    m3 === "--sorted" || m3.startsWith("-") || (t4 ? s3 ? r2.push(m3) : s3 = m3 : t4 = m3);
  }
  if (!t4 || !s3) return { stdout: "", stderr: `xan groupby: usage: xan groupby COLS EXPR [FILE]
`, exitCode: 1 };
  let { data: o2, error: a3 } = await w$3(r2, n3);
  if (a3) return a3;
  let d3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, u3 = t4.split(","), p3 = K(s3), l3 = [], h3 = /* @__PURE__ */ new Map();
  for (let f3 of o2) {
    let m3 = u3.map((g2) => String(f3[g2])).join("\0");
    h3.has(m3) || (h3.set(m3, []), l3.push(m3)), h3.get(m3)?.push(f3);
  }
  let c3 = [...u3, ...p3.map((f3) => f3.alias)], i4 = [];
  for (let f3 of l3) {
    let m3 = h3.get(f3);
    if (!m3) continue;
    let g2 = {};
    for (let y2 of u3) g2[y2] = m3[0][y2];
    for (let y2 of p3) g2[y2.alias] = G(m3, y2, d3);
    i4.push(g2);
  }
  return { stdout: C$1(c3, i4), stderr: "", exitCode: 0 };
}
async function B$2(e5, n3) {
  let t4 = [], s3 = "", r2 = 10, o2 = false, a3 = [];
  for (let i4 = 0; i4 < e5.length; i4++) {
    let f3 = e5[i4];
    (f3 === "-s" || f3 === "--select") && i4 + 1 < e5.length ? t4 = e5[++i4].split(",") : (f3 === "-g" || f3 === "--groupby") && i4 + 1 < e5.length ? s3 = e5[++i4] : (f3 === "-l" || f3 === "--limit") && i4 + 1 < e5.length ? r2 = Number.parseInt(e5[++i4], 10) : f3 === "--no-extra" ? o2 = true : f3 === "-A" || f3 === "--all" ? r2 = 0 : f3.startsWith("-") || a3.push(f3);
  }
  let { headers: d3, data: u3, error: p3 } = await w$3(a3, n3);
  if (p3) return p3;
  let l3 = t4.length > 0 ? t4 : d3.filter((i4) => i4 !== s3);
  s3 && t4.length === 0 && (l3 = d3.filter((i4) => i4 !== s3));
  let h3 = [], c3 = s3 ? ["field", s3, "value", "count"] : ["field", "value", "count"];
  if (s3) {
    let i4 = /* @__PURE__ */ new Map();
    for (let f3 of u3) {
      let m3 = String(f3[s3] ?? "");
      i4.has(m3) || i4.set(m3, []), i4.get(m3)?.push(f3);
    }
    for (let f3 of l3) for (let [m3, g2] of i4) {
      let y2 = /* @__PURE__ */ new Map();
      for (let S3 of g2) {
        let k3 = S3[f3], C2 = k3 === "" || k3 === null || k3 === void 0 ? "" : String(k3);
        y2.set(C2, (y2.get(C2) || 0) + 1);
      }
      let x4 = [...y2.entries()].sort((S3, k3) => k3[1] !== S3[1] ? k3[1] - S3[1] : S3[0].localeCompare(k3[0]));
      o2 && (x4 = x4.filter(([S3]) => S3 !== "")), r2 > 0 && (x4 = x4.slice(0, r2));
      for (let [S3, k3] of x4) h3.push({ field: f3, [s3]: m3, value: S3 === "" ? "<empty>" : S3, count: k3 });
    }
  } else for (let i4 of l3) {
    let f3 = /* @__PURE__ */ new Map();
    for (let g2 of u3) {
      let y2 = g2[i4], x4 = y2 === "" || y2 === null || y2 === void 0 ? "" : String(y2);
      f3.set(x4, (f3.get(x4) || 0) + 1);
    }
    let m3 = [...f3.entries()].sort((g2, y2) => y2[1] !== g2[1] ? y2[1] - g2[1] : g2[0].localeCompare(y2[0]));
    o2 && (m3 = m3.filter(([g2]) => g2 !== "")), r2 > 0 && (m3 = m3.slice(0, r2));
    for (let [g2, y2] of m3) h3.push({ field: i4, value: g2 === "" ? "<empty>" : g2, count: y2 });
  }
  return { stdout: C$1(c3, h3), stderr: "", exitCode: 0 };
}
async function Z2(e5, n3) {
  let t4 = [], s3 = [];
  for (let l3 = 0; l3 < e5.length; l3++) {
    let h3 = e5[l3];
    h3 === "-s" && l3 + 1 < e5.length ? t4 = e5[++l3].split(",") : h3.startsWith("-") || s3.push(h3);
  }
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = t4.length > 0 ? t4 : r2, u3 = ["field", "type", "count", "min", "max", "mean"], p3 = [];
  for (let l3 of d3) {
    let h3 = o2.map((f3) => f3[l3]).filter((f3) => f3 != null), c3 = h3.map((f3) => typeof f3 == "number" ? f3 : Number.parseFloat(String(f3))).filter((f3) => !Number.isNaN(f3)), i4 = c3.length === h3.length && c3.length > 0;
    p3.push({ field: l3, type: i4 ? "Number" : "String", count: h3.length, min: i4 ? Math.min(...c3) : "", max: i4 ? Math.max(...c3) : "", mean: i4 ? Math.round(c3.reduce((f3, m3) => f3 + m3, 0) / c3.length * 1e10) / 1e10 : "" });
  }
  return { stdout: C$1(u3, p3), stderr: "", exitCode: 0 };
}
j$1();
function _e(e5) {
  let n3 = W$1(e5);
  return A$2(n3);
}
function Be2(e5) {
  let t4 = e5.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
  return new RegExp(`^${t4}$`);
}
function q$1(e5, n3) {
  let t4 = [], s3 = /* @__PURE__ */ new Set();
  for (let r2 of e5.split(",")) {
    let o2 = r2.trim();
    if (o2.startsWith("!")) {
      let p3 = o2.slice(1), l3 = q$1(p3, n3);
      for (let h3 of l3) s3.add(h3);
      continue;
    }
    if (o2 === "*") {
      for (let p3 of n3) t4.includes(p3) || t4.push(p3);
      continue;
    }
    if (o2.includes("*")) {
      let p3 = Be2(o2);
      for (let l3 of n3) p3.test(l3) && !t4.includes(l3) && t4.push(l3);
      continue;
    }
    let a3 = o2.match(/^([^:]*):([^:]*)$/);
    if (a3 && (a3[1] || a3[2])) {
      let p3 = a3[1], l3 = a3[2], h3 = p3 ? n3.indexOf(p3) : 0, c3 = l3 ? n3.indexOf(l3) : n3.length - 1;
      if (h3 !== -1 && c3 !== -1) {
        let i4 = h3 <= c3 ? 1 : -1;
        for (let f3 = h3; i4 > 0 ? f3 <= c3 : f3 >= c3; f3 += i4) t4.includes(n3[f3]) || t4.push(n3[f3]);
      }
      continue;
    }
    let d3 = o2.match(/^(\d+)-(\d+)$/);
    if (d3) {
      let p3 = Number.parseInt(d3[1], 10), l3 = Number.parseInt(d3[2], 10);
      for (let h3 = p3; h3 <= l3 && h3 < n3.length; h3++) t4.push(n3[h3]);
      continue;
    }
    let u3 = Number.parseInt(o2, 10);
    if (!Number.isNaN(u3) && u3 >= 0 && u3 < n3.length) {
      t4.push(n3[u3]);
      continue;
    }
    n3.includes(o2) && t4.push(o2);
  }
  return s3.size > 0 ? t4.filter((r2) => !s3.has(r2)) : t4;
}
async function Q$1(e5, n3) {
  let t4 = "", s3 = [];
  for (let p3 of e5) p3.startsWith("-") || (t4 ? s3.push(p3) : t4 = p3);
  if (!t4) return { stdout: "", stderr: `xan select: no columns specified
`, exitCode: 1 };
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = q$1(t4, r2), u3 = o2.map((p3) => {
    let l3 = {};
    for (let h3 of d3) l3[h3] = p3[h3];
    return l3;
  });
  return { stdout: C$1(d3, u3), stderr: "", exitCode: 0 };
}
async function ee(e5, n3) {
  let t4 = "", s3 = [];
  for (let l3 of e5) l3.startsWith("-") || (t4 ? s3.push(l3) : t4 = l3);
  if (!t4) return { stdout: "", stderr: `xan drop: no columns specified
`, exitCode: 1 };
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = new Set(q$1(t4, r2)), u3 = r2.filter((l3) => !d3.has(l3)), p3 = o2.map((l3) => {
    let h3 = {};
    for (let c3 of u3) h3[c3] = l3[c3];
    return h3;
  });
  return { stdout: C$1(u3, p3), stderr: "", exitCode: 0 };
}
async function te$1(e5, n3) {
  let t4 = "", s3 = "", r2 = [];
  for (let l3 = 0; l3 < e5.length; l3++) {
    let h3 = e5[l3];
    h3 === "-s" && l3 + 1 < e5.length ? s3 = e5[++l3] : h3.startsWith("-") || (t4 ? r2.push(h3) : t4 = h3);
  }
  if (!t4) return { stdout: "", stderr: `xan rename: no new name(s) specified
`, exitCode: 1 };
  let { headers: o2, data: a3, error: d3 } = await w$3(r2, n3);
  if (d3) return d3;
  let u3;
  if (s3) {
    let l3 = s3.split(","), h3 = t4.split(","), c3 = /* @__PURE__ */ new Map();
    for (let i4 = 0; i4 < l3.length && i4 < h3.length; i4++) c3.set(l3[i4], h3[i4]);
    u3 = o2.map((i4) => c3.get(i4) || i4);
  } else {
    let l3 = t4.split(",");
    u3 = o2.map((h3, c3) => c3 < l3.length ? l3[c3] : h3);
  }
  let p3 = a3.map((l3) => {
    let h3 = {};
    for (let c3 = 0; c3 < o2.length; c3++) h3[u3[c3]] = l3[o2[c3]];
    return h3;
  });
  return { stdout: C$1(u3, p3), stderr: "", exitCode: 0 };
}
async function ne(e5, n3) {
  let t4 = "index", s3 = [];
  for (let p3 = 0; p3 < e5.length; p3++) e5[p3] === "-c" && p3 + 1 < e5.length ? t4 = e5[++p3] : s3.push(e5[p3]);
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = [t4, ...r2], u3 = o2.map((p3, l3) => {
    let h3 = { [t4]: l3 };
    for (let c3 of r2) h3[c3] = p3[c3];
    return h3;
  });
  return { stdout: C$1(d3, u3), stderr: "", exitCode: 0 };
}
async function se2(e5, n3) {
  let t4 = e5.includes("-j") || e5.includes("--just-names"), { headers: s3, error: r2 } = await w$3(e5.filter((a3) => a3 !== "-j" && a3 !== "--just-names"), n3);
  return r2 || { stdout: t4 ? `${s3.map((a3) => a3).join(`
`)}
` : `${s3.map((a3, d3) => `${d3}   ${a3}`).join(`
`)}
`, stderr: "", exitCode: 0 };
}
async function re(e5, n3) {
  let { data: t4, error: s3 } = await w$3(e5, n3);
  return s3 || { stdout: `${t4.length}
`, stderr: "", exitCode: 0 };
}
async function oe(e5, n3) {
  let t4 = 10, s3 = [];
  for (let u3 = 0; u3 < e5.length; u3++) (e5[u3] === "-l" || e5[u3] === "-n") && u3 + 1 < e5.length ? t4 = Number.parseInt(e5[++u3], 10) : s3.push(e5[u3]);
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = o2.slice(0, t4);
  return { stdout: C$1(r2, d3), stderr: "", exitCode: 0 };
}
async function ie(e5, n3) {
  let t4 = 10, s3 = [];
  for (let u3 = 0; u3 < e5.length; u3++) (e5[u3] === "-l" || e5[u3] === "-n") && u3 + 1 < e5.length ? t4 = Number.parseInt(e5[++u3], 10) : s3.push(e5[u3]);
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = o2.slice(-t4);
  return { stdout: C$1(r2, d3), stderr: "", exitCode: 0 };
}
async function ae(e5, n3) {
  let t4, s3, r2, o2 = [];
  for (let c3 = 0; c3 < e5.length; c3++) {
    let i4 = e5[c3];
    (i4 === "-s" || i4 === "--start") && c3 + 1 < e5.length ? t4 = Number.parseInt(e5[++c3], 10) : (i4 === "-e" || i4 === "--end") && c3 + 1 < e5.length ? s3 = Number.parseInt(e5[++c3], 10) : (i4 === "-l" || i4 === "--len") && c3 + 1 < e5.length ? r2 = Number.parseInt(e5[++c3], 10) : i4.startsWith("-") || o2.push(i4);
  }
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  let p3 = t4 ?? 0, l3;
  r2 !== void 0 ? l3 = p3 + r2 : s3 !== void 0 ? l3 = s3 : l3 = d3.length;
  let h3 = d3.slice(p3, l3);
  return { stdout: C$1(a3, h3), stderr: "", exitCode: 0 };
}
async function le(e5, n3) {
  let { headers: t4, data: s3, error: r2 } = await w$3(e5, n3);
  if (r2) return r2;
  let o2 = [...s3].reverse();
  return { stdout: C$1(t4, o2), stderr: "", exitCode: 0 };
}
var ue = q$d(xe$2());
async function ce(e5, n3) {
  let t4 = e5.filter((p3) => !p3.startsWith("-")), { headers: s3, data: r2, error: o2 } = await w$3(t4, n3);
  if (o2) return o2;
  if (r2.length === 0) {
    let p3 = ["column"], l3 = s3.map((h3) => ({ column: h3 }));
    return { stdout: C$1(p3, l3), stderr: "", exitCode: 0 };
  }
  let a3 = s3[0], d3 = [a3, ...r2.map((p3, l3) => String(p3[a3] ?? `row_${l3}`))], u3 = [];
  for (let p3 = 1; p3 < s3.length; p3++) {
    let l3 = s3[p3], h3 = { [a3]: l3 };
    for (let c3 = 0; c3 < r2.length; c3++) h3[d3[c3 + 1]] = r2[c3][l3];
    u3.push(h3);
  }
  return { stdout: C$1(d3, u3), stderr: "", exitCode: 0 };
}
async function pe(e5, n3) {
  let t4 = null, s3 = [];
  for (let l3 = 0; l3 < e5.length; l3++) {
    let h3 = e5[l3];
    h3 === "--seed" && l3 + 1 < e5.length ? t4 = Number.parseInt(e5[++l3], 10) : h3.startsWith("-") || s3.push(h3);
  }
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = t4 !== null ? t4 : Date.now(), u3 = () => (d3 = d3 * 1103515245 + 12345 & 2147483647, d3 / 2147483647), p3 = [...o2];
  for (let l3 = p3.length - 1; l3 > 0; l3--) {
    let h3 = Math.floor(u3() * (l3 + 1));
    [p3[l3], p3[h3]] = [p3[h3], p3[l3]];
  }
  return { stdout: C$1(r2, p3), stderr: "", exitCode: 0 };
}
async function fe(e5, n3) {
  let t4 = null, s3 = "", r2 = [];
  for (let i4 = 0; i4 < e5.length; i4++) {
    let f3 = e5[i4];
    (f3 === "-l" || f3 === "--length") && i4 + 1 < e5.length ? t4 = Number.parseInt(e5[++i4], 10) : (f3 === "-d" || f3 === "--default") && i4 + 1 < e5.length ? s3 = e5[++i4] : f3.startsWith("-") || r2.push(f3);
  }
  let o2 = r2[0], a3;
  if (!o2 || o2 === "-") a3 = n3.stdin;
  else try {
    let i4 = n3.fs.resolvePath(n3.cwd, o2);
    a3 = await n3.fs.readFile(i4);
  } catch {
    return { stdout: "", stderr: `xan fixlengths: ${o2}: No such file or directory
`, exitCode: 1 };
  }
  let u3 = ue.default.parse(a3.trim(), { header: false, skipEmptyLines: true }).data;
  if (u3.length === 0) return { stdout: "", stderr: "", exitCode: 0 };
  let p3 = Math.max(...u3.map((i4) => i4.length)), l3 = t4 ?? p3, h3 = u3.map((i4) => i4.length === l3 ? i4 : i4.length < l3 ? [...i4, ...Array(l3 - i4.length).fill(s3)] : i4.slice(0, l3));
  return { stdout: `${ue.default.unparse(h3).replace(/\r\n/g, `
`)}
`, stderr: "", exitCode: 0 };
}
async function de(e5, n3) {
  let t4 = null, s3 = null, r2 = ".", o2 = [];
  for (let c3 = 0; c3 < e5.length; c3++) {
    let i4 = e5[c3];
    (i4 === "-c" || i4 === "--chunks") && c3 + 1 < e5.length ? t4 = Number.parseInt(e5[++c3], 10) : (i4 === "-S" || i4 === "--size") && c3 + 1 < e5.length ? s3 = Number.parseInt(e5[++c3], 10) : (i4 === "-o" || i4 === "--output") && c3 + 1 < e5.length ? r2 = e5[++c3] : i4.startsWith("-") || o2.push(i4);
  }
  if (!t4 && !s3) return { stdout: "", stderr: `xan split: must specify -c or -S
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  let p3 = [];
  if (t4) {
    let c3 = Math.ceil(d3.length / t4);
    for (let i4 = 0; i4 < t4; i4++) p3.push(d3.slice(i4 * c3, (i4 + 1) * c3));
  } else if (s3) for (let c3 = 0; c3 < d3.length; c3 += s3) p3.push(d3.slice(c3, c3 + s3));
  let l3 = p3.filter((c3) => c3.length > 0), h3 = o2[0]?.replace(/\.csv$/, "") || "part";
  try {
    let c3 = n3.fs.resolvePath(n3.cwd, r2);
    for (let i4 = 0; i4 < l3.length; i4++) {
      let f3 = `${h3}_${String(i4 + 1).padStart(3, "0")}.csv`, m3 = n3.fs.resolvePath(c3, f3);
      await n3.fs.writeFile(m3, C$1(a3, l3[i4]));
    }
    return { stdout: `Split into ${l3.length} parts
`, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: `${l3.map((i4, f3) => `Part ${f3 + 1}: ${i4.length} rows`).join(`
`)}
`, stderr: "", exitCode: 0 };
  }
}
async function he2(e5, n3) {
  let t4 = "", s3 = ".", r2 = [];
  for (let p3 = 0; p3 < e5.length; p3++) {
    let l3 = e5[p3];
    (l3 === "-o" || l3 === "--output") && p3 + 1 < e5.length ? s3 = e5[++p3] : l3.startsWith("-") || (t4 ? r2.push(l3) : t4 = l3);
  }
  if (!t4) return { stdout: "", stderr: `xan partition: usage: xan partition COLUMN [FILE]
`, exitCode: 1 };
  let { headers: o2, data: a3, error: d3 } = await w$3(r2, n3);
  if (d3) return d3;
  if (!o2.includes(t4)) return { stdout: "", stderr: `xan partition: column '${t4}' not found
`, exitCode: 1 };
  let u3 = /* @__PURE__ */ new Map();
  for (let p3 of a3) {
    let l3 = String(p3[t4] ?? "");
    u3.has(l3) || u3.set(l3, []), u3.get(l3)?.push(p3);
  }
  try {
    let p3 = n3.fs.resolvePath(n3.cwd, s3);
    for (let [l3, h3] of u3) {
      let i4 = `${l3.replace(/[^a-zA-Z0-9_-]/g, "_") || "empty"}.csv`, f3 = n3.fs.resolvePath(p3, i4);
      await n3.fs.writeFile(f3, C$1(o2, h3));
    }
    return { stdout: `Partitioned into ${u3.size} files by '${t4}'
`, stderr: "", exitCode: 0 };
  } catch {
    return { stdout: `${Array.from(u3.entries()).map(([l3, h3]) => `${l3}: ${h3.length} rows`).join(`
`)}
`, stderr: "", exitCode: 0 };
  }
}
async function me(e5, n3) {
  if (e5.length === 0) return { stdout: "", stderr: `xan to: usage: xan to <format> [FILE]
`, exitCode: 1 };
  let t4 = e5[0], s3 = e5.slice(1);
  return t4 === "json" ? Ze(s3, n3) : { stdout: "", stderr: `xan to: unsupported format '${t4}'
`, exitCode: 1 };
}
async function Ze(e5, n3) {
  let t4 = e5.filter((a3) => !a3.startsWith("-")), { data: s3, error: r2 } = await w$3(t4, n3);
  return r2 || { stdout: `${JSON.stringify(s3, null, 2)}
`, stderr: "", exitCode: 0 };
}
async function ge(e5, n3) {
  let t4 = "", s3 = [];
  for (let r2 = 0; r2 < e5.length; r2++) {
    let o2 = e5[r2];
    (o2 === "-f" || o2 === "--format") && r2 + 1 < e5.length ? t4 = e5[++r2] : o2.startsWith("-") || s3.push(o2);
  }
  return t4 ? t4 === "json" ? Qe(s3, n3) : { stdout: "", stderr: `xan from: unsupported format '${t4}'
`, exitCode: 1 } : { stdout: "", stderr: `xan from: usage: xan from -f <format> [FILE]
`, exitCode: 1 };
}
async function Qe(e5, n3) {
  let t4 = e5[0], s3;
  if (!t4 || t4 === "-") s3 = n3.stdin;
  else try {
    let r2 = n3.fs.resolvePath(n3.cwd, t4);
    s3 = await n3.fs.readFile(r2);
  } catch {
    return { stdout: "", stderr: `xan from: ${t4}: No such file or directory
`, exitCode: 1 };
  }
  try {
    let r2 = JSON.parse(s3.trim());
    if (!Array.isArray(r2)) return { stdout: "", stderr: `xan from: JSON input must be an array
`, exitCode: 1 };
    if (r2.length === 0) return { stdout: `
`, stderr: "", exitCode: 0 };
    if (Array.isArray(r2[0])) {
      let [a3, ...d3] = r2, u3 = d3.map((p3) => {
        let l3 = {};
        for (let h3 = 0; h3 < a3.length; h3++) l3[a3[h3]] = p3[h3];
        return l3;
      });
      return { stdout: C$1(a3, u3), stderr: "", exitCode: 0 };
    }
    let o2 = Object.keys(r2[0]).sort();
    return { stdout: C$1(o2, r2), stderr: "", exitCode: 0 };
  } catch {
    return { stdout: "", stderr: `xan from: invalid JSON input
`, exitCode: 1 };
  }
}
async function ye(e5, n3) {
  let t4 = false, s3 = 0, r2 = "", o2 = [];
  for (let c3 = 0; c3 < e5.length; c3++) {
    let i4 = e5[c3];
    if (i4 === "-v" || i4 === "--invert") t4 = true;
    else if ((i4 === "-l" || i4 === "--limit") && c3 + 1 < e5.length) s3 = Number.parseInt(e5[++c3], 10);
    else {
      if (i4 === "--help") return s$1({ name: "xan filter", summary: "Filter rows by expression", usage: "xan filter [OPTIONS] EXPR [FILE]", description: "Filter CSV rows using moonblade expressions.", options: ["-v, --invert    invert match", "-l, --limit N   limit output to N rows", "    --help      display help"] });
      i4.startsWith("-") || (r2 ? o2.push(i4) : r2 = i4);
    }
  }
  if (!r2) return { stdout: "", stderr: `xan filter: no expression specified
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  let p3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, l3 = _e(r2), h3 = [];
  for (let c3 of d3) {
    if (s3 > 0 && h3.length >= s3) break;
    let i4 = m$1(c3, l3, p3), f3 = i4.length > 0 && i4.some((m3) => !!m3);
    (t4 ? !f3 : f3) && h3.push(c3);
  }
  return { stdout: C$1(a3, h3), stderr: "", exitCode: 0 };
}
async function xe2(e5, n3) {
  let t4 = "", s3 = false, r2 = false, o2 = [];
  for (let l3 = 0; l3 < e5.length; l3++) {
    let h3 = e5[l3];
    h3 === "-N" || h3 === "--numeric" ? s3 = true : h3 === "-R" || h3 === "-r" || h3 === "--reverse" ? r2 = true : h3 === "-s" && l3 + 1 < e5.length ? t4 = e5[++l3] : h3.startsWith("-") || o2.push(h3);
  }
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  !t4 && a3.length > 0 && (t4 = a3[0]);
  let p3 = [...d3].sort((l3, h3) => {
    let c3 = l3[t4], i4 = h3[t4], f3;
    if (s3) {
      let m3 = typeof c3 == "number" ? c3 : Number.parseFloat(String(c3)), g2 = typeof i4 == "number" ? i4 : Number.parseFloat(String(i4));
      f3 = m3 - g2;
    } else f3 = String(c3).localeCompare(String(i4));
    return r2 ? -f3 : f3;
  });
  return { stdout: C$1(a3, p3), stderr: "", exitCode: 0 };
}
async function we2(e5, n3) {
  let t4 = "", s3 = [];
  for (let p3 = 0; p3 < e5.length; p3++) {
    let l3 = e5[p3];
    l3 === "-s" && p3 + 1 < e5.length ? t4 = e5[++p3] : l3.startsWith("-") || s3.push(l3);
  }
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let d3 = /* @__PURE__ */ new Set(), u3 = o2.filter((p3) => {
    let l3 = t4 ? String(p3[t4]) : JSON.stringify(p3);
    return d3.has(l3) ? false : (d3.add(l3), true);
  });
  return { stdout: C$1(r2, u3), stderr: "", exitCode: 0 };
}
async function ve(e5, n3) {
  let t4 = 10, s3 = "", r2 = false, o2 = [];
  for (let h3 = 0; h3 < e5.length; h3++) {
    let c3 = e5[h3];
    (c3 === "-l" || c3 === "-n") && h3 + 1 < e5.length ? t4 = Number.parseInt(e5[++h3], 10) : c3 === "-R" || c3 === "-r" || c3 === "--reverse" ? r2 = true : c3.startsWith("-") || (s3 ? o2.push(c3) : s3 = c3);
  }
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  !s3 && a3.length > 0 && (s3 = a3[0]);
  let l3 = [...d3].sort((h3, c3) => {
    let i4 = h3[s3], f3 = c3[s3], m3 = typeof i4 == "number" ? i4 : Number.parseFloat(String(i4)), g2 = typeof f3 == "number" ? f3 : Number.parseFloat(String(f3));
    return r2 ? m3 - g2 : g2 - m3;
  }).slice(0, t4);
  return { stdout: C$1(a3, l3), stderr: "", exitCode: 0 };
}
j$1();
async function Ce(e5, n3) {
  let t4 = "", s3 = false, r2 = false, o2 = [];
  for (let f3 = 0; f3 < e5.length; f3++) {
    let m3 = e5[f3];
    m3 === "-O" || m3 === "--overwrite" ? s3 = true : m3 === "--filter" ? r2 = true : m3.startsWith("-") || (t4 ? o2.push(m3) : t4 = m3);
  }
  if (!t4) return { stdout: "", stderr: `xan map: no expression specified
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  let l3 = T2(t4).map(({ expr: f3, name: m3 }) => ({ alias: typeof m3 == "string" ? m3 : m3[0], ast: A$2(f3) })), h3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, c3;
  if (s3) {
    c3 = [...a3];
    for (let f3 of l3) a3.includes(f3.alias) || c3.push(f3.alias);
  } else c3 = [...a3, ...l3.map((f3) => f3.alias)];
  let i4 = [];
  for (let f3 = 0; f3 < d3.length; f3++) {
    let m3 = d3[f3], g2 = { ...m3 }, y2 = false, x4 = { ...m3, _row_index: f3 };
    for (let S3 of l3) {
      let k3 = m$1(x4, S3.ast, h3), C2 = k3.length > 0 ? k3[0] : null;
      if (r2 && C2 == null) {
        y2 = true;
        break;
      }
      g2[S3.alias] = C2;
    }
    y2 || i4.push(g2);
  }
  return { stdout: C$1(c3, i4), stderr: "", exitCode: 0 };
}
async function be2(e5, n3) {
  let t4 = "", s3 = "", r2 = "", o2 = [];
  for (let m3 = 0; m3 < e5.length; m3++) {
    let g2 = e5[m3];
    (g2 === "-r" || g2 === "--rename") && m3 + 1 < e5.length ? r2 = e5[++m3] : g2.startsWith("-") || (t4 ? s3 ? o2.push(g2) : s3 = g2 : t4 = g2);
  }
  if (!t4 || !s3) return { stdout: "", stderr: `xan transform: usage: xan transform COLUMN EXPR [FILE]
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  let p3 = t4.split(",").map((m3) => m3.trim()), l3 = r2 ? r2.split(",").map((m3) => m3.trim()) : [];
  for (let m3 of p3) if (!a3.includes(m3)) return { stdout: "", stderr: `xan transform: column '${m3}' not found
`, exitCode: 1 };
  let h3 = A$2(T2(s3)[0]?.expr || (j$1(), r$4(De)).parseMoonblade(s3)), c3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, i4 = a3.map((m3) => {
    let g2 = p3.indexOf(m3);
    return g2 !== -1 && l3[g2] ? l3[g2] : m3;
  }), f3 = [];
  for (let m3 of d3) {
    let g2 = { ...m3 };
    for (let y2 = 0; y2 < p3.length; y2++) {
      let x4 = p3[y2], S3 = { ...m3, _: m3[x4] }, k3 = m$1(S3, h3, c3), C2 = k3.length > 0 ? k3[0] : null, E2 = l3[y2] || x4;
      E2 !== x4 && delete g2[x4], g2[E2] = C2;
    }
    f3.push(g2);
  }
  return { stdout: C$1(i4, f3), stderr: "", exitCode: 0 };
}
async function Se(e5, n3) {
  let t4 = "", s3 = "|", r2 = false, o2 = "", a3 = [];
  for (let i4 = 0; i4 < e5.length; i4++) {
    let f3 = e5[i4];
    (f3 === "-s" || f3 === "--separator") && i4 + 1 < e5.length ? s3 = e5[++i4] : f3 === "--drop-empty" ? r2 = true : (f3 === "-r" || f3 === "--rename") && i4 + 1 < e5.length ? o2 = e5[++i4] : f3.startsWith("-") || (t4 ? a3.push(f3) : t4 = f3);
  }
  if (!t4) return { stdout: "", stderr: `xan explode: usage: xan explode COLUMN [FILE]
`, exitCode: 1 };
  let { headers: d3, data: u3, error: p3 } = await w$3(a3, n3);
  if (p3) return p3;
  if (!d3.includes(t4)) return { stdout: "", stderr: `xan explode: column '${t4}' not found
`, exitCode: 1 };
  let l3 = o2 ? d3.map((i4) => i4 === t4 ? o2 : i4) : d3, h3 = o2 || t4, c3 = [];
  for (let i4 of u3) {
    let f3 = i4[t4], m3 = f3 == null ? "" : String(f3);
    if (m3 === "") {
      if (!r2) {
        let g2 = { ...i4 };
        o2 && (delete g2[t4], g2[h3] = ""), c3.push(g2);
      }
    } else {
      let g2 = m3.split(s3);
      for (let y2 of g2) {
        let x4 = { ...i4 };
        o2 && delete x4[t4], x4[h3] = y2, c3.push(x4);
      }
    }
  }
  return { stdout: C$1(l3, c3), stderr: "", exitCode: 0 };
}
async function Ie(e5, n3) {
  let t4 = "", s3 = "|", r2 = "", o2 = [];
  for (let g2 = 0; g2 < e5.length; g2++) {
    let y2 = e5[g2];
    (y2 === "-s" || y2 === "--sep") && g2 + 1 < e5.length ? s3 = e5[++g2] : (y2 === "-r" || y2 === "--rename") && g2 + 1 < e5.length ? r2 = e5[++g2] : y2.startsWith("-") || (t4 ? o2.push(y2) : t4 = y2);
  }
  if (!t4) return { stdout: "", stderr: `xan implode: usage: xan implode COLUMN [FILE]
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  if (!a3.includes(t4)) return { stdout: "", stderr: `xan implode: column '${t4}' not found
`, exitCode: 1 };
  let p3 = a3.filter((g2) => g2 !== t4), l3 = r2 ? a3.map((g2) => g2 === t4 ? r2 : g2) : a3, h3 = r2 || t4, c3 = [], i4 = null, f3 = [], m3 = null;
  for (let g2 of d3) {
    let y2 = p3.map((k3) => String(g2[k3] ?? "")).join("\0"), x4 = g2[t4], S3 = x4 == null ? "" : String(x4);
    if (y2 !== i4) {
      if (m3 !== null) {
        let k3 = { ...m3 };
        r2 && delete k3[t4], k3[h3] = f3.join(s3), c3.push(k3);
      }
      i4 = y2, f3 = [S3], m3 = g2;
    } else f3.push(S3);
  }
  if (m3 !== null) {
    let g2 = { ...m3 };
    r2 && delete g2[t4], g2[h3] = f3.join(s3), c3.push(g2);
  }
  return { stdout: C$1(l3, c3), stderr: "", exitCode: 0 };
}
async function ke(e5, n3) {
  let t4 = "", s3 = "", r2 = "", o2 = "", a3 = "inner", d3 = "", u3 = 0;
  for (let C2 = 0; C2 < e5.length; C2++) {
    let E2 = e5[C2];
    E2 === "--left" ? a3 = "left" : E2 === "--right" ? a3 = "right" : E2 === "--full" ? a3 = "full" : (E2 === "-D" || E2 === "--default") && C2 + 1 < e5.length ? d3 = e5[++C2] : E2.startsWith("-") || (u3++, u3 === 1 ? t4 = E2 : u3 === 2 ? s3 = E2 : u3 === 3 ? r2 = E2 : u3 === 4 && (o2 = E2));
  }
  if (!t4 || !s3 || !r2 || !o2) return { stdout: "", stderr: `xan join: usage: xan join KEY1 FILE1 KEY2 FILE2 [OPTIONS]
`, exitCode: 1 };
  let p3 = await w$3([s3], n3);
  if (p3.error) return p3.error;
  let l3 = await w$3([o2], n3);
  if (l3.error) return l3.error;
  let { headers: h3, data: c3 } = p3, { headers: i4, data: f3 } = l3;
  if (!h3.includes(t4)) return { stdout: "", stderr: `xan join: column '${t4}' not found in first file
`, exitCode: 1 };
  if (!i4.includes(r2)) return { stdout: "", stderr: `xan join: column '${r2}' not found in second file
`, exitCode: 1 };
  let m3 = /* @__PURE__ */ new Map();
  for (let C2 of f3) {
    let E2 = String(C2[r2] ?? "");
    m3.has(E2) || m3.set(E2, []), m3.get(E2)?.push(C2);
  }
  let g2 = new Set(h3), y2 = i4.filter((C2) => !g2.has(C2)), x4 = [...h3, ...y2], S3 = [], k3 = /* @__PURE__ */ new Set();
  for (let C2 of c3) {
    let E2 = String(C2[t4] ?? ""), R2 = m3.get(E2);
    if (R2 && R2.length > 0) {
      k3.add(E2);
      for (let F2 of R2) {
        let M4 = {};
        for (let D3 of h3) M4[D3] = C2[D3];
        for (let D3 of y2) M4[D3] = F2[D3];
        S3.push(M4);
      }
    } else if (a3 === "left" || a3 === "full") {
      let F2 = {};
      for (let M4 of h3) F2[M4] = C2[M4];
      for (let M4 of y2) F2[M4] = d3;
      S3.push(F2);
    }
  }
  if (a3 === "right" || a3 === "full") for (let C2 of f3) {
    let E2 = String(C2[r2] ?? "");
    if (!k3.has(E2)) {
      let R2 = {};
      for (let F2 of h3) R2[F2] = i4.includes(F2) ? C2[F2] : d3;
      for (let F2 of y2) R2[F2] = C2[F2];
      S3.push(R2);
    }
  }
  return { stdout: C$1(x4, S3), stderr: "", exitCode: 0 };
}
async function Ne(e5, n3) {
  let t4 = "", s3 = "", r2 = [], o2 = [];
  for (let y2 = 0; y2 < e5.length; y2++) {
    let x4 = e5[y2];
    (x4 === "-g" || x4 === "--groupby") && y2 + 1 < e5.length ? r2 = e5[++y2].split(",").map((S3) => S3.trim()) : x4.startsWith("-") || (t4 ? s3 ? o2.push(x4) : s3 = x4 : t4 = x4);
  }
  if (!t4 || !s3) return { stdout: "", stderr: `xan pivot: usage: xan pivot COLUMN AGG_EXPR [OPTIONS] [FILE]
`, exitCode: 1 };
  let { headers: a3, data: d3, error: u3 } = await w$3(o2, n3);
  if (u3) return u3;
  if (!a3.includes(t4)) return { stdout: "", stderr: `xan pivot: column '${t4}' not found
`, exitCode: 1 };
  let p3 = s3.match(/^(\w+)\((\w+)\)$/);
  if (!p3) return { stdout: "", stderr: `xan pivot: invalid aggregation expression '${s3}'
`, exitCode: 1 };
  let [, l3, h3] = p3;
  r2.length === 0 && (r2 = a3.filter((y2) => y2 !== t4 && y2 !== h3));
  let c3 = [];
  for (let y2 of d3) {
    let x4 = String(y2[t4] ?? "");
    c3.includes(x4) || c3.push(x4);
  }
  let i4 = /* @__PURE__ */ new Map(), f3 = [];
  for (let y2 of d3) {
    let x4 = r2.map((E2) => String(y2[E2] ?? "")).join("\0"), S3 = String(y2[t4] ?? ""), k3 = y2[h3];
    i4.has(x4) || (i4.set(x4, /* @__PURE__ */ new Map()), f3.push(x4));
    let C2 = i4.get(x4);
    C2 && (C2.has(S3) || C2.set(S3, []), C2.get(S3)?.push(k3));
  }
  let m3 = [...r2, ...c3], g2 = [];
  for (let y2 of f3) {
    let x4 = y2.split("\0"), S3 = i4.get(y2);
    if (!S3) continue;
    let k3 = {};
    for (let C2 = 0; C2 < r2.length; C2++) k3[r2[C2]] = x4[C2];
    for (let C2 of c3) {
      let E2 = S3.get(C2) || [];
      k3[C2] = et(l3, E2);
    }
    g2.push(k3);
  }
  return { stdout: C$1(m3, g2), stderr: "", exitCode: 0 };
}
function et(e5, n3) {
  let t4 = n3.filter((s3) => s3 != null).map((s3) => typeof s3 == "number" ? s3 : Number.parseFloat(String(s3))).filter((s3) => !Number.isNaN(s3));
  switch (e5) {
    case "count":
      return n3.length;
    case "sum":
      return t4.reduce((s3, r2) => s3 + r2, 0);
    case "mean":
    case "avg":
      return t4.length > 0 ? t4.reduce((s3, r2) => s3 + r2, 0) / t4.length : null;
    case "min":
      return t4.length > 0 ? Math.min(...t4) : null;
    case "max":
      return t4.length > 0 ? Math.max(...t4) : null;
    case "first":
      return n3.length > 0 ? String(n3[0] ?? "") : null;
    case "last":
      return n3.length > 0 ? String(n3[n3.length - 1] ?? "") : null;
    default:
      return null;
  }
}
async function Ee(e5, n3) {
  let t4 = "", s3 = [];
  for (let d3 = 0; d3 < e5.length; d3++) {
    let u3 = e5[d3];
    (u3 === "-s" || u3 === "--sort") && d3 + 1 < e5.length ? t4 = e5[++d3] : u3.startsWith("-") || s3.push(u3);
  }
  if (s3.length < 2) return { stdout: "", stderr: `xan merge: usage: xan merge [OPTIONS] FILE1 FILE2 ...
`, exitCode: 1 };
  let r2 = [], o2 = null;
  for (let d3 of s3) {
    let u3 = await w$3([d3], n3);
    if (u3.error) return u3.error;
    if (o2 === null) o2 = u3.headers;
    else if (JSON.stringify(o2) !== JSON.stringify(u3.headers)) return { stdout: "", stderr: `xan merge: all files must have the same headers
`, exitCode: 1 };
    r2.push({ headers: u3.headers, data: u3.data });
  }
  if (!o2) return { stdout: "", stderr: "", exitCode: 0 };
  let a3 = [];
  for (let { data: d3 } of r2) a3 = a3.concat(d3);
  if (t4) {
    if (!o2.includes(t4)) return { stdout: "", stderr: `xan merge: column '${t4}' not found
`, exitCode: 1 };
    a3.sort((d3, u3) => {
      let p3 = d3[t4], l3 = u3[t4], h3 = typeof p3 == "number" ? p3 : Number.parseFloat(String(p3)), c3 = typeof l3 == "number" ? l3 : Number.parseFloat(String(l3));
      return !Number.isNaN(h3) && !Number.isNaN(c3) ? h3 - c3 : String(p3 ?? "").localeCompare(String(l3 ?? ""));
    });
  }
  return { stdout: C$1(o2, a3), stderr: "", exitCode: 0 };
}
j$1();
async function Ae(e5, n3) {
  let t4 = e5.filter((u3) => !u3.startsWith("-")), { headers: s3, data: r2, error: o2 } = await w$3(t4, n3);
  return o2 || (r2.length === 0 ? { stdout: "", stderr: "", exitCode: 0 } : { stdout: r2.map((u3) => s3.map((p3) => u3[p3])).map((u3) => u3.map((p3) => tt(p3)).join(",")).join(`
`) + `
`, stderr: "", exitCode: 0 });
}
function tt(e5) {
  if (e5 == null) return "";
  let n3 = String(e5);
  return n3.includes(",") || n3.includes('"') || n3.includes(`
`) ? `"${n3.replace(/"/g, '""')}"` : n3;
}
async function Fe(e5, n3) {
  let t4 = null, s3 = null, r2 = [];
  for (let c3 = 0; c3 < e5.length; c3++) {
    let i4 = e5[c3];
    if (i4 === "--seed" && c3 + 1 < e5.length) s3 = Number.parseInt(e5[++c3], 10);
    else if (!i4.startsWith("-")) {
      let f3 = Number.parseInt(i4, 10);
      t4 === null && !Number.isNaN(f3) && f3 > 0 ? t4 = f3 : r2.push(i4);
    }
  }
  if (t4 === null) return { stdout: "", stderr: `xan sample: usage: xan sample <sample-size> [FILE]
`, exitCode: 1 };
  let { headers: o2, data: a3, error: d3 } = await w$3(r2, n3);
  if (d3) return d3;
  if (a3.length <= t4) return { stdout: C$1(o2, a3), stderr: "", exitCode: 0 };
  let u3 = s3 !== null ? s3 : Date.now(), p3 = () => (u3 = u3 * 1103515245 + 12345 & 2147483647, u3 / 2147483647), l3 = a3.map((c3, i4) => i4);
  for (let c3 = l3.length - 1; c3 > 0; c3--) {
    let i4 = Math.floor(p3() * (c3 + 1));
    [l3[c3], l3[i4]] = [l3[i4], l3[c3]];
  }
  let h3 = l3.slice(0, t4).sort((c3, i4) => c3 - i4).map((c3) => a3[c3]);
  return { stdout: C$1(o2, h3), stderr: "", exitCode: 0 };
}
async function Le(e5, n3) {
  let t4 = false, s3 = [];
  for (let u3 = 0; u3 < e5.length; u3++) {
    let p3 = e5[u3];
    p3 === "-p" || p3 === "--pad" ? t4 = true : p3.startsWith("-") || s3.push(p3);
  }
  if (s3.length === 0) return { stdout: "", stderr: `xan cat: no files specified
`, exitCode: 1 };
  let r2 = await y$e(n3, s3, { cmdName: "xan cat", stopOnError: true });
  if (r2.exitCode !== 0) return { stdout: "", stderr: r2.stderr, exitCode: r2.exitCode };
  let o2 = [], a3 = [];
  for (let { content: u3 } of r2.files) {
    let { headers: p3, data: l3 } = j$2(u3);
    o2.push({ headers: p3, data: l3 });
    for (let h3 of p3) a3.includes(h3) || a3.push(h3);
  }
  if (!t4) {
    let u3 = JSON.stringify(o2[0].headers);
    for (let p3 = 1; p3 < o2.length; p3++) if (JSON.stringify(o2[p3].headers) !== u3) return { stdout: "", stderr: `xan cat: headers do not match (use -p to pad)
`, exitCode: 1 };
    a3 = o2[0].headers;
  }
  let d3 = [];
  for (let { headers: u3, data: p3 } of o2) for (let l3 of p3) {
    let h3 = {};
    for (let c3 of a3) h3[c3] = u3.includes(c3) ? l3[c3] : "";
    d3.push(h3);
  }
  return { stdout: C$1(a3, d3), stderr: "", exitCode: 0 };
}
async function Oe(e5, n3) {
  let t4 = "", s3 = [], r2 = false, o2 = false, a3 = [];
  for (let i4 = 0; i4 < e5.length; i4++) {
    let f3 = e5[i4];
    (f3 === "-s" || f3 === "--select") && i4 + 1 < e5.length ? s3 = e5[++i4].split(",") : f3 === "-v" || f3 === "--invert" ? r2 = true : f3 === "-i" || f3 === "--ignore-case" ? o2 = true : f3 === "-r" || f3 === "--regex" || f3.startsWith("-") || (t4 ? a3.push(f3) : t4 = f3);
  }
  if (!t4) return { stdout: "", stderr: `xan search: no pattern specified
`, exitCode: 1 };
  let { headers: d3, data: u3, error: p3 } = await w$3(a3, n3);
  if (p3) return p3;
  let l3 = s3.length > 0 ? s3 : d3, h3;
  try {
    h3 = new RegExp(t4, o2 ? "i" : "");
  } catch {
    return { stdout: "", stderr: `xan search: invalid regex pattern '${t4}'
`, exitCode: 1 };
  }
  let c3 = u3.filter((i4) => {
    let f3 = l3.some((m3) => {
      let g2 = i4[m3];
      return g2 != null && h3.test(String(g2));
    });
    return r2 ? !f3 : f3;
  });
  return { stdout: C$1(d3, c3), stderr: "", exitCode: 0 };
}
async function Pe(e5, n3) {
  let t4 = "", s3 = [];
  for (let c3 of e5) c3.startsWith("-") || (t4 ? s3.push(c3) : t4 = c3);
  if (!t4) return { stdout: "", stderr: `xan flatmap: no expression specified
`, exitCode: 1 };
  let { headers: r2, data: o2, error: a3 } = await w$3(s3, n3);
  if (a3) return a3;
  let u3 = T2(t4).map(({ expr: c3, name: i4 }) => ({ alias: typeof i4 == "string" ? i4 : i4[0], ast: A$2(c3) })), p3 = { limits: n3.limits ? { maxIterations: n3.limits.maxJqIterations } : void 0 }, l3 = [...r2, ...u3.map((c3) => c3.alias)], h3 = [];
  for (let c3 of o2) {
    let i4 = [], f3 = 1;
    for (let m3 of u3) {
      let g2 = m$1(c3, m3.ast, p3), y2 = g2.length > 0 && Array.isArray(g2[0]) ? g2[0] : g2;
      i4.push(y2), f3 = Math.max(f3, y2.length);
    }
    for (let m3 = 0; m3 < f3; m3++) {
      let g2 = { ...c3 };
      for (let y2 = 0; y2 < u3.length; y2++) {
        let x4 = i4[y2][m3] ?? null;
        g2[u3[y2].alias] = x4;
      }
      h3.push(g2);
    }
  }
  return { stdout: C$1(l3, h3), stderr: "", exitCode: 0 };
}
async function Me(e5, n3) {
  let { cmdView: t4 } = await Promise.resolve().then(function() {
    return xanViewDMFUMZG7;
  });
  return t4(e5, n3);
}
var Je = /* @__PURE__ */ new Set(["fuzzy-join", "glob", "hist", "input", "parallel", "plot", "progress", "range", "scrape", "tokenize", "union-find"]), nt2 = /* @__PURE__ */ new Set(["agg", "behead", "cat", "count", "dedup", "drop", "enum", "explode", "f", "filter", "fixlengths", "flatmap", "flatten", "fmt", "frequency", "freq", "from", "groupby", "head", "headers", "implode", "join", "map", "merge", "partition", "pivot", "rename", "reverse", "sample", "search", "select", "shuffle", "slice", "sort", "split", "stats", "tail", "to", "top", "transform", "transpose", "view", ...Je]), He = { name: "xan", summary: "CSV toolkit for data manipulation", usage: "xan <COMMAND> [OPTIONS] [FILE]", description: `xan is a collection of commands for working with CSV data.
It provides a simple, ergonomic interface for common data operations.

COMMANDS:
  Core:
    headers    Show column names
    count      Count rows
    head       Show first N rows
    tail       Show last N rows
    slice      Extract row range
    reverse    Reverse row order
    behead     Remove header row
    sample     Random sample of rows

  Column operations:
    select     Select columns (supports glob, ranges, negation)
    drop       Drop columns
    rename     Rename columns
    enum       Add row index column

  Row operations:
    filter     Filter rows by expression
    search     Filter rows by regex match
    sort       Sort rows
    dedup      Remove duplicates
    top        Get top N by column

  Transformations:
    map        Add computed columns
    transform  Modify existing columns
    explode    Split column into multiple rows
    implode    Combine rows, join column values
    flatmap    Map returning multiple rows
    pivot      Reshape rows into columns
    transpose  Swap rows and columns

  Aggregation:
    agg        Aggregate values
    groupby    Group and aggregate
    frequency  Count value occurrences
    stats      Show column statistics

  Multi-file:
    cat        Concatenate CSV files
    join       Join two CSV files on key
    merge      Merge sorted CSV files
    split      Split into multiple files
    partition  Split by column value

  Data conversion:
    to         Convert CSV to other formats (json)
    from       Convert other formats to CSV (json)
    shuffle    Randomly reorder rows
    fixlengths Fix ragged CSV files

  Output:
    view       Pretty print as table
    flatten    Display records vertically (alias: f)
    fmt        Format output

EXAMPLES:
  xan headers data.csv
  xan count data.csv
  xan head -n 5 data.csv
  xan select name,email data.csv
  xan select 'vec_*' data.csv          # glob pattern
  xan select 'a:c' data.csv            # column range
  xan filter 'age > 30' data.csv
  xan search -r '^foo' data.csv
  xan sort -N price data.csv
  xan agg 'sum(amount) as total' data.csv
  xan groupby region 'count() as n' data.csv
  xan explode tags data.csv
  xan join id file1.csv id file2.csv
  xan pivot year 'sum(sales)' data.csv`, options: ["    --help    display this help and exit"] }, st = { headers: { name: "xan headers", summary: "Show column names", usage: "xan headers [OPTIONS] [FILE]", description: "Display column names from a CSV file.", options: ["-j, --just-names    show names only (no index)"] }, count: { name: "xan count", summary: "Count rows", usage: "xan count [FILE]", description: "Count the number of data rows (excluding header).", options: [] }, filter: { name: "xan filter", summary: "Filter rows by expression", usage: "xan filter [OPTIONS] EXPR [FILE]", description: "Filter CSV rows using moonblade expressions.", options: ["-v, --invert    invert match", "-l, --limit N   limit output rows"] }, search: { name: "xan search", summary: "Filter rows by regex", usage: "xan search [OPTIONS] PATTERN [FILE]", description: "Filter CSV rows by regex match on columns.", options: ["-s, --select COLS   search only these columns", "-v, --invert        invert match", "-i, --ignore-case   case insensitive"] }, select: { name: "xan select", summary: "Select columns", usage: "xan select COLS [FILE]", description: "Select columns by name, index, glob, or range.", options: ["Supports: col names, indices (0,1), ranges (a:c), globs (vec_*), negation (!col)"] }, explode: { name: "xan explode", summary: "Split column into rows", usage: "xan explode COLUMN [OPTIONS] [FILE]", description: "Split delimited column values into multiple rows.", options: ["-s, --separator SEP  separator (default: |)", "--drop-empty         drop empty values", "-r, --rename NAME    rename column"] }, implode: { name: "xan implode", summary: "Combine rows", usage: "xan implode COLUMN [OPTIONS] [FILE]", description: "Combine consecutive rows, joining column values.", options: ["-s, --sep SEP        separator (default: |)", "-r, --rename NAME    rename column"] }, join: { name: "xan join", summary: "Join CSV files", usage: "xan join KEY1 FILE1 KEY2 FILE2 [OPTIONS]", description: "Join two CSV files on key columns.", options: ["--left               left outer join", "--right              right outer join", "--full               full outer join", "-D, --default VAL    default for missing"] }, pivot: { name: "xan pivot", summary: "Reshape to columns", usage: "xan pivot COLUMN AGG_EXPR [OPTIONS] [FILE]", description: "Turn row values into columns.", options: ["-g, --groupby COLS   group by columns"] } }, en = { name: "xan", async execute(e5, n3) {
  if (e5.length === 0 || o$3(e5)) return s$1(He);
  let t4 = e5[0], s3 = e5.slice(1);
  if (o$3(s3)) {
    let r2 = st[t4];
    return r2 ? s$1(r2) : s$1(He);
  }
  if (Je.has(t4)) return { stdout: "", stderr: `xan ${t4}: not yet implemented
`, exitCode: 1 };
  switch (t4) {
    case "headers":
      return se2(s3, n3);
    case "count":
      return re(s3, n3);
    case "head":
      return oe(s3, n3);
    case "tail":
      return ie(s3, n3);
    case "slice":
      return ae(s3, n3);
    case "reverse":
      return le(s3, n3);
    case "behead":
      return Ae(s3, n3);
    case "sample":
      return Fe(s3, n3);
    case "select":
      return Q$1(s3, n3);
    case "drop":
      return ee(s3, n3);
    case "rename":
      return te$1(s3, n3);
    case "enum":
      return ne(s3, n3);
    case "filter":
      return ye(s3, n3);
    case "search":
      return Oe(s3, n3);
    case "sort":
      return xe2(s3, n3);
    case "dedup":
      return we2(s3, n3);
    case "top":
      return ve(s3, n3);
    case "map":
      return Ce(s3, n3);
    case "transform":
      return be2(s3, n3);
    case "explode":
      return Se(s3, n3);
    case "implode":
      return Ie(s3, n3);
    case "flatmap":
      return Pe(s3, n3);
    case "pivot":
      return Ne(s3, n3);
    case "agg":
      return X$1(s3, n3);
    case "groupby":
      return Y$1(s3, n3);
    case "frequency":
    case "freq":
      return B$2(s3, n3);
    case "stats":
      return Z2(s3, n3);
    case "cat":
      return Le(s3, n3);
    case "join":
      return ke(s3, n3);
    case "merge":
      return Ee(s3, n3);
    case "split":
      return de(s3, n3);
    case "partition":
      return he2(s3, n3);
    case "to":
      return me(s3, n3);
    case "from":
      return ge(s3, n3);
    case "transpose":
      return ce(s3, n3);
    case "shuffle":
      return pe(s3, n3);
    case "fixlengths":
      return fe(s3, n3);
    case "view":
      return W$2(s3, n3);
    case "flatten":
    case "f":
      return S$3(s3, n3);
    case "fmt":
      return Me(s3, n3);
    default:
      return nt2.has(t4) ? { stdout: "", stderr: `xan ${t4}: not yet implemented
`, exitCode: 1 } : { stdout: "", stderr: `xan: unknown command '${t4}'
Run 'xan --help' for usage.
`, exitCode: 1 };
  }
} };
const xanA6VPI4HJ = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  xanCommand: en
});
function $$1(e5, t4, o2) {
  switch (o2.mode) {
    case "list":
      return x3(e5, t4, o2);
    case "csv":
      return q(e5, t4, o2);
    case "json":
      return V$1(e5, t4);
    case "line":
      return k$1(e5, t4, o2);
    case "column":
      return A$1(e5, t4, o2);
    case "table":
      return O$2(e5, t4, o2);
    case "markdown":
      return R$1(e5, t4, o2);
    case "tabs":
      return N$1(e5, t4, o2);
    case "box":
      return M$1(e5, t4, o2);
    case "quote":
      return I$1(e5, t4, o2);
    case "html":
      return U(e5, t4, o2);
    case "ascii":
      return B$1(e5, t4, o2);
  }
}
function f2(e5, t4) {
  return e5 == null ? t4 : e5 instanceof Uint8Array || Buffer.isBuffer(e5) ? Buffer.from(e5).toString("utf8") : typeof e5 == "number" && !Number.isInteger(e5) ? e5.toPrecision(17).replace(/\.?0+$/, "") : String(e5);
}
function x3(e5, t4, o2) {
  let r2 = [];
  o2.header && e5.length > 0 && r2.push(e5.join(o2.separator));
  for (let a3 of t4) r2.push(a3.map((s3) => f2(s3, o2.nullValue)).join(o2.separator));
  return r2.length > 0 ? `${r2.join(o2.newline)}${o2.newline}` : "";
}
function q(e5, t4, o2) {
  let r2 = [];
  o2.header && e5.length > 0 && r2.push(e5.map(w$2).join(","));
  for (let a3 of t4) r2.push(a3.map((s3) => w$2(f2(s3, o2.nullValue))).join(","));
  return r2.length > 0 ? `${r2.join(`
`)}
` : "";
}
function w$2(e5) {
  return e5.includes(",") || e5.includes('"') || e5.includes("'") || e5.includes(`
`) ? `"${e5.replace(/"/g, '""')}"` : e5;
}
function j(e5) {
  return e5.toPrecision(17).replace(/\.?0+$/, "");
}
function L3(e5) {
  return e5 === null ? "null" : typeof e5 == "number" ? Number.isInteger(e5) ? String(e5) : j(e5) : JSON.stringify(e5);
}
function V$1(e5, t4) {
  return t4.length === 0 ? "" : `[${t4.map((r2) => `{${e5.map((s3, i4) => `${JSON.stringify(s3)}:${L3(r2[i4])}`).join(",")}}`).join(`,
`)}]
`;
}
function k$1(e5, t4, o2) {
  if (e5.length === 0 || t4.length === 0) return "";
  let r2 = Math.max(5, ...e5.map((s3) => s3.length)), a3 = [];
  for (let s3 of t4) for (let i4 = 0; i4 < e5.length; i4++) {
    let n3 = e5[i4].padStart(r2);
    a3.push(`${n3} = ${f2(s3[i4], o2.nullValue)}`);
  }
  return `${a3.join(`
`)}
`;
}
function A$1(e5, t4, o2) {
  if (e5.length === 0) return "";
  let r2 = e5.map((s3) => s3.length);
  for (let s3 of t4) for (let i4 = 0; i4 < s3.length; i4++) {
    let n3 = f2(s3[i4], o2.nullValue).length;
    n3 > r2[i4] && (r2[i4] = n3);
  }
  let a3 = [];
  o2.header && (a3.push(e5.map((s3, i4) => s3.padEnd(r2[i4])).join("  ")), a3.push(r2.map((s3) => "-".repeat(s3)).join("  ")));
  for (let s3 of t4) a3.push(s3.map((i4, n3) => f2(i4, o2.nullValue).padEnd(r2[n3])).join("  "));
  return a3.length > 0 ? `${a3.join(`
`)}
` : "";
}
function O$2(e5, t4, o2) {
  if (e5.length === 0) return "";
  let r2 = e5.map((i4) => i4.length);
  for (let i4 of t4) for (let n3 = 0; n3 < i4.length; n3++) {
    let l3 = f2(i4[n3], o2.nullValue).length;
    l3 > r2[n3] && (r2[n3] = l3);
  }
  let a3 = [], s3 = `+${r2.map((i4) => "-".repeat(i4 + 2)).join("+")}+`;
  a3.push(s3), o2.header && (a3.push(`| ${e5.map((i4, n3) => i4.padEnd(r2[n3])).join(" | ")} |`), a3.push(s3));
  for (let i4 of t4) a3.push(`| ${i4.map((n3, l3) => f2(n3, o2.nullValue).padEnd(r2[l3])).join(" | ")} |`);
  return a3.push(s3), `${a3.join(`
`)}
`;
}
function R$1(e5, t4, o2) {
  if (e5.length === 0) return "";
  let r2 = [];
  o2.header && (r2.push(`| ${e5.join(" | ")} |`), r2.push(`|${e5.map(() => "---").join("|")}|`));
  for (let a3 of t4) r2.push(`| ${a3.map((s3) => f2(s3, o2.nullValue)).join(" | ")} |`);
  return r2.length > 0 ? `${r2.join(`
`)}
` : "";
}
function N$1(e5, t4, o2) {
  let r2 = [];
  o2.header && e5.length > 0 && r2.push(e5.join("	"));
  for (let a3 of t4) r2.push(a3.map((s3) => f2(s3, o2.nullValue)).join("	"));
  return r2.length > 0 ? `${r2.join(o2.newline)}${o2.newline}` : "";
}
function M$1(e5, t4, o2) {
  if (e5.length === 0) return "";
  let r2 = e5.map((s3) => s3.length);
  for (let s3 of t4) for (let i4 = 0; i4 < s3.length; i4++) {
    let n3 = f2(s3[i4], o2.nullValue).length;
    n3 > r2[i4] && (r2[i4] = n3);
  }
  let a3 = [];
  a3.push(`${r2.map((s3) => "".repeat(s3 + 2)).join("")}`), a3.push(` ${e5.map((s3, i4) => s3.padEnd(r2[i4])).join("  ")} `), a3.push(`${r2.map((s3) => "".repeat(s3 + 2)).join("")}`);
  for (let s3 of t4) a3.push(` ${s3.map((i4, n3) => f2(i4, o2.nullValue).padEnd(r2[n3])).join("  ")} `);
  return a3.push(`${r2.map((s3) => "".repeat(s3 + 2)).join("")}`), `${a3.join(`
`)}
`;
}
function I$1(e5, t4, o2) {
  let r2 = [];
  o2.header && e5.length > 0 && r2.push(e5.map((a3) => `'${a3}'`).join(","));
  for (let a3 of t4) r2.push(a3.map((s3) => s3 == null ? "NULL" : typeof s3 == "number" ? Number.isInteger(s3) ? String(s3) : j(s3) : `'${String(s3)}'`).join(","));
  return r2.length > 0 ? `${r2.join(o2.newline)}${o2.newline}` : "";
}
function U(e5, t4, o2) {
  let r2 = [];
  o2.header && e5.length > 0 && (r2.push(`<TR>${e5.map((a3) => `<TH>${S$2(a3)}</TH>`).join("")}`), r2.push("</TR>"));
  for (let a3 of t4) r2.push(`<TR>${a3.map((s3) => `<TD>${S$2(f2(s3, o2.nullValue))}</TD>`).join("")}`), r2.push("</TR>");
  return r2.length > 0 ? `${r2.join(`
`)}
` : "";
}
function S$2(e5) {
  return e5.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
}
function B$1(e5, t4, o2) {
  let s3 = [];
  o2.header && e5.length > 0 && s3.push(e5.join(""));
  for (let i4 of t4) s3.push(i4.map((n3) => f2(n3, o2.nullValue)).join(""));
  return s3.length > 0 ? s3.join("") + "" : "";
}
var D2 = 5e3, Q3 = { name: "sqlite3", summary: "SQLite database CLI", usage: "sqlite3 [OPTIONS] DATABASE [SQL]", options: ["-list           output in list mode (default)", "-csv            output in CSV mode", "-json           output in JSON mode", "-line           output in line mode", "-column         output in column mode", "-table          output as ASCII table", "-markdown       output as markdown table", "-tabs           output in tab-separated mode", "-box            output in Unicode box mode", "-quote          output in SQL quote mode", "-html           output as HTML table", "-ascii          output in ASCII mode (control chars)", "-header         show column headers", "-noheader       hide column headers", "-separator SEP  field separator for list mode (default: |)", "-newline SEP    row separator (default: \\n)", "-nullvalue TEXT text for NULL values (default: empty)", "-readonly       open database read-only (no writeback)", "-bail           stop on first error", "-echo           print SQL before execution", "-cmd COMMAND    run SQL command before main SQL", "-version        show SQLite version", "--              end of options", "--help          show this help"], examples: ['sqlite3 :memory: "CREATE TABLE t(x); INSERT INTO t VALUES(1); SELECT * FROM t"', 'sqlite3 -json data.db "SELECT * FROM users"', 'sqlite3 -csv -header data.db "SELECT id, name FROM products"', 'sqlite3 -box data.db "SELECT * FROM users"'] };
function F$2(e5) {
  let t4 = { mode: "list", header: false, separator: "|", newline: `
`, nullValue: "", readonly: false, bail: false, echo: false, cmd: null }, o2 = null, r2 = null, a3 = false, s3 = false;
  for (let i4 = 0; i4 < e5.length; i4++) {
    let n3 = e5[i4];
    if (s3) {
      o2 === null ? o2 = n3 : r2 === null && (r2 = n3);
      continue;
    }
    if (n3 === "--") s3 = true;
    else if (n3 === "-version") a3 = true;
    else if (n3 === "-list") t4.mode = "list";
    else if (n3 === "-csv") t4.mode = "csv";
    else if (n3 === "-json") t4.mode = "json";
    else if (n3 === "-line") t4.mode = "line";
    else if (n3 === "-column") t4.mode = "column";
    else if (n3 === "-table") t4.mode = "table";
    else if (n3 === "-markdown") t4.mode = "markdown";
    else if (n3 === "-tabs") t4.mode = "tabs";
    else if (n3 === "-box") t4.mode = "box";
    else if (n3 === "-quote") t4.mode = "quote";
    else if (n3 === "-html") t4.mode = "html";
    else if (n3 === "-ascii") t4.mode = "ascii";
    else if (n3 === "-header") t4.header = true;
    else if (n3 === "-noheader") t4.header = false;
    else if (n3 === "-readonly") t4.readonly = true;
    else if (n3 === "-bail") t4.bail = true;
    else if (n3 === "-echo") t4.echo = true;
    else if (n3 === "-separator") {
      if (i4 + 1 >= e5.length) return { stdout: "", stderr: `sqlite3: Error: missing argument to -separator
`, exitCode: 1 };
      t4.separator = e5[++i4];
    } else if (n3 === "-newline") {
      if (i4 + 1 >= e5.length) return { stdout: "", stderr: `sqlite3: Error: missing argument to -newline
`, exitCode: 1 };
      t4.newline = e5[++i4];
    } else if (n3 === "-nullvalue") {
      if (i4 + 1 >= e5.length) return { stdout: "", stderr: `sqlite3: Error: missing argument to -nullvalue
`, exitCode: 1 };
      t4.nullValue = e5[++i4];
    } else if (n3 === "-cmd") {
      if (i4 + 1 >= e5.length) return { stdout: "", stderr: `sqlite3: Error: missing argument to -cmd
`, exitCode: 1 };
      t4.cmd = e5[++i4];
    } else {
      if (n3.startsWith("-")) return { stdout: "", stderr: `sqlite3: Error: unknown option: ${n3.startsWith("--") ? n3.slice(1) : n3}
Use -help for a list of options.
`, exitCode: 1 };
      o2 === null ? o2 = n3 : r2 === null && (r2 = n3);
    }
  }
  return { options: t4, database: o2, sql: r2, showVersion: a3 };
}
async function H$1() {
  let e5 = await E$d(), t4 = new e5.Database();
  try {
    let o2 = t4.exec("SELECT sqlite_version()");
    return o2.length > 0 && o2[0].values.length > 0 ? String(o2[0].values[0][0]) : "unknown";
  } finally {
    t4.close();
  }
}
function J$1(e5) {
  let t4 = e5.trim().toUpperCase();
  return t4.startsWith("INSERT") || t4.startsWith("UPDATE") || t4.startsWith("DELETE") || t4.startsWith("CREATE") || t4.startsWith("DROP") || t4.startsWith("ALTER") || t4.startsWith("REPLACE") || t4.startsWith("VACUUM");
}
function _3(e5) {
  let t4 = [], o2 = "", r2 = false, a3 = "";
  for (let i4 = 0; i4 < e5.length; i4++) {
    let n3 = e5[i4];
    if (r2) o2 += n3, n3 === a3 && (e5[i4 + 1] === a3 ? o2 += e5[++i4] : r2 = false);
    else if (n3 === "'" || n3 === '"') o2 += n3, r2 = true, a3 = n3;
    else if (n3 === ";") {
      let l3 = o2.trim();
      l3 && t4.push(l3), o2 = "";
    } else o2 += n3;
  }
  let s3 = o2.trim();
  return s3 && t4.push(s3), t4;
}
async function X2(e5) {
  let t4;
  try {
    let a3 = await E$d();
    e5.dbBuffer ? t4 = new a3.Database(e5.dbBuffer) : t4 = new a3.Database();
  } catch (a3) {
    return { success: false, error: a3.message };
  }
  let o2 = [], r2 = false;
  try {
    let a3 = _3(e5.sql);
    for (let i4 of a3) try {
      if (J$1(i4)) t4.run(i4), r2 = true, o2.push({ type: "data", columns: [], rows: [] });
      else {
        let n3 = t4.prepare(i4), l3 = n3.getColumnNames(), d3 = [];
        for (; n3.step(); ) d3.push(n3.get());
        n3.free(), o2.push({ type: "data", columns: l3, rows: d3 });
      }
    } catch (n3) {
      let l3 = n3.message;
      if (o2.push({ type: "error", error: l3 }), e5.options.bail) break;
    }
    let s3 = null;
    return r2 && (s3 = t4.export()), t4.close(), { success: true, results: o2, hasModifications: r2, dbBuffer: s3 };
  } catch (a3) {
    return t4.close(), { success: false, error: a3.message };
  }
}
async function Y(e5, t4) {
  try {
    let o2 = fileURLToPath(new URL("./worker.js", import.meta.url));
    return await new Promise((r2, a3) => {
      let s3 = new Worker(o2, { workerData: e5 }), i4 = setTimeout(() => {
        s3.terminate(), r2({ success: false, error: `Query timeout: execution exceeded ${t4}ms limit` });
      }, t4);
      s3.on("message", (n3) => {
        clearTimeout(i4), r2(n3);
      }), s3.on("error", (n3) => {
        clearTimeout(i4), a3(n3);
      }), s3.on("exit", (n3) => {
        clearTimeout(i4), n3 !== 0 && r2({ success: false, error: `Worker exited with code ${n3}` });
      });
    });
  } catch {
    return X2(e5);
  }
}
var te = { name: "sqlite3", async execute(e5, t4) {
  if (o$3(e5) || e5.includes("-help")) return s$1(Q3);
  let o2 = F$2(e5);
  if ("exitCode" in o2) return o2;
  let { options: r2, database: a3, sql: s3, showVersion: i4 } = o2;
  if (i4) return { stdout: `${await H$1()}
`, stderr: "", exitCode: 0 };
  if (!a3) return { stdout: "", stderr: `sqlite3: missing database argument
`, exitCode: 1 };
  let n3 = s3 || t4.stdin.trim();
  if (r2.cmd && (n3 = r2.cmd + (n3 ? `; ${n3}` : "")), !n3) return { stdout: "", stderr: `sqlite3: no SQL provided
`, exitCode: 1 };
  let l3 = a3 === ":memory:", d3 = "", m3 = null;
  try {
    l3 || (d3 = t4.fs.resolvePath(t4.cwd, a3), await t4.fs.exists(d3) && (m3 = await t4.fs.readFileBuffer(d3)));
  } catch (u3) {
    return { stdout: "", stderr: `sqlite3: unable to open database "${a3}": ${u3.message}
`, exitCode: 1 };
  }
  let C2 = t4.limits?.maxSqliteTimeoutMs ?? D2, T3 = { dbBuffer: m3, sql: n3, options: { bail: r2.bail, echo: r2.echo } }, c3;
  try {
    c3 = await Y(T3, C2);
  } catch (u3) {
    return { stdout: "", stderr: `sqlite3: worker error: ${u3.message}
`, exitCode: 1 };
  }
  if (!c3.success) return { stdout: "", stderr: `sqlite3: ${c3.error}
`, exitCode: 1 };
  let y2 = { mode: r2.mode, header: r2.header, separator: r2.separator, newline: r2.newline, nullValue: r2.nullValue }, h3 = "";
  r2.echo && (h3 += `${n3}
`);
  let p3 = false;
  for (let u3 of c3.results) if (u3.type === "error") {
    if (r2.bail) return { stdout: h3, stderr: `Error: ${u3.error}
`, exitCode: 1 };
    h3 += `Error: ${u3.error}
`, p3 = true;
  } else u3.columns && u3.rows && (u3.rows.length > 0 || r2.header) && (h3 += $$1(u3.columns, u3.rows, y2));
  if (c3.hasModifications && !r2.readonly && !l3 && d3 && c3.dbBuffer) try {
    await t4.fs.writeFile(d3, c3.dbBuffer);
  } catch (u3) {
    return { stdout: h3, stderr: `sqlite3: failed to write database: ${u3.message}
`, exitCode: 1 };
  }
  return { stdout: h3, stderr: "", exitCode: p3 && r2.bail ? 1 : 0 };
} };
const sqlite35QVZOGER = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  sqlite3Command: te
});
var a2 = { NOOP: 0, READ_FILE: 1, WRITE_FILE: 2, STAT: 3, READDIR: 4, MKDIR: 5, RM: 6, EXISTS: 7, APPEND_FILE: 8, SYMLINK: 9, READLINK: 10, LSTAT: 11, CHMOD: 12, REALPATH: 13, WRITE_STDOUT: 100, WRITE_STDERR: 101, EXIT: 102, HTTP_REQUEST: 200 }, n2 = { PENDING: 0, READY: 1, SUCCESS: 2, ERROR: 3 }, u$1 = { NONE: 0, NOT_FOUND: 1, IS_DIRECTORY: 2, NOT_DIRECTORY: 3, EXISTS: 4, PERMISSION_DENIED: 5, INVALID_PATH: 6, IO_ERROR: 7, TIMEOUT: 8, NETWORK_ERROR: 9, NETWORK_NOT_CONFIGURED: 10 }, i3 = { OP_CODE: 0, STATUS: 4, PATH_LENGTH: 8, DATA_LENGTH: 12, RESULT_LENGTH: 16, ERROR_CODE: 20, FLAGS: 24, MODE: 28, PATH_BUFFER: 32, DATA_BUFFER: 4128 }, p2 = { PATH_BUFFER: 4096, DATA_BUFFER: 1048576, TOTAL: 1052704 }, R = { NONE: 0, RECURSIVE: 1, FORCE: 2, MKDIR_RECURSIVE: 1 }, h$1 = { IS_FILE: 0, IS_DIRECTORY: 1, IS_SYMLINK: 2, MODE: 4, SIZE: 8, MTIME: 16, TOTAL: 24 };
function C() {
  return new SharedArrayBuffer(p2.TOTAL);
}
var w$1 = class w2 {
  int32View;
  uint8View;
  dataView;
  constructor(t4) {
    this.int32View = new Int32Array(t4), this.uint8View = new Uint8Array(t4), this.dataView = new DataView(t4);
  }
  getOpCode() {
    return Atomics.load(this.int32View, i3.OP_CODE / 4);
  }
  setOpCode(t4) {
    Atomics.store(this.int32View, i3.OP_CODE / 4, t4);
  }
  getStatus() {
    return Atomics.load(this.int32View, i3.STATUS / 4);
  }
  setStatus(t4) {
    Atomics.store(this.int32View, i3.STATUS / 4, t4);
  }
  getPathLength() {
    return Atomics.load(this.int32View, i3.PATH_LENGTH / 4);
  }
  setPathLength(t4) {
    Atomics.store(this.int32View, i3.PATH_LENGTH / 4, t4);
  }
  getDataLength() {
    return Atomics.load(this.int32View, i3.DATA_LENGTH / 4);
  }
  setDataLength(t4) {
    Atomics.store(this.int32View, i3.DATA_LENGTH / 4, t4);
  }
  getResultLength() {
    return Atomics.load(this.int32View, i3.RESULT_LENGTH / 4);
  }
  setResultLength(t4) {
    Atomics.store(this.int32View, i3.RESULT_LENGTH / 4, t4);
  }
  getErrorCode() {
    return Atomics.load(this.int32View, i3.ERROR_CODE / 4);
  }
  setErrorCode(t4) {
    Atomics.store(this.int32View, i3.ERROR_CODE / 4, t4);
  }
  getFlags() {
    return Atomics.load(this.int32View, i3.FLAGS / 4);
  }
  setFlags(t4) {
    Atomics.store(this.int32View, i3.FLAGS / 4, t4);
  }
  getMode() {
    return Atomics.load(this.int32View, i3.MODE / 4);
  }
  setMode(t4) {
    Atomics.store(this.int32View, i3.MODE / 4, t4);
  }
  getPath() {
    let t4 = this.getPathLength(), e5 = this.uint8View.slice(i3.PATH_BUFFER, i3.PATH_BUFFER + t4);
    return new TextDecoder().decode(e5);
  }
  setPath(t4) {
    let e5 = new TextEncoder().encode(t4);
    if (e5.length > p2.PATH_BUFFER) throw new Error(`Path too long: ${e5.length} > ${p2.PATH_BUFFER}`);
    this.uint8View.set(e5, i3.PATH_BUFFER), this.setPathLength(e5.length);
  }
  getData() {
    let t4 = this.getDataLength();
    return this.uint8View.slice(i3.DATA_BUFFER, i3.DATA_BUFFER + t4);
  }
  setData(t4) {
    if (t4.length > p2.DATA_BUFFER) throw new Error(`Data too large: ${t4.length} > ${p2.DATA_BUFFER}`);
    this.uint8View.set(t4, i3.DATA_BUFFER), this.setDataLength(t4.length);
  }
  getDataAsString() {
    let t4 = this.getData();
    return new TextDecoder().decode(t4);
  }
  setDataFromString(t4) {
    let e5 = new TextEncoder().encode(t4);
    this.setData(e5);
  }
  getResult() {
    let t4 = this.getResultLength();
    return this.uint8View.slice(i3.DATA_BUFFER, i3.DATA_BUFFER + t4);
  }
  setResult(t4) {
    if (t4.length > p2.DATA_BUFFER) throw new Error(`Result too large: ${t4.length} > ${p2.DATA_BUFFER}`);
    this.uint8View.set(t4, i3.DATA_BUFFER), this.setResultLength(t4.length);
  }
  getResultAsString() {
    let t4 = this.getResult();
    return new TextDecoder().decode(t4);
  }
  setResultFromString(t4) {
    let e5 = new TextEncoder().encode(t4);
    this.setResult(e5);
  }
  encodeStat(t4) {
    this.uint8View[i3.DATA_BUFFER + h$1.IS_FILE] = t4.isFile ? 1 : 0, this.uint8View[i3.DATA_BUFFER + h$1.IS_DIRECTORY] = t4.isDirectory ? 1 : 0, this.uint8View[i3.DATA_BUFFER + h$1.IS_SYMLINK] = t4.isSymbolicLink ? 1 : 0, this.dataView.setInt32(i3.DATA_BUFFER + h$1.MODE, t4.mode, true);
    let e5 = Math.min(t4.size, Number.MAX_SAFE_INTEGER);
    this.dataView.setFloat64(i3.DATA_BUFFER + h$1.SIZE, e5, true), this.dataView.setFloat64(i3.DATA_BUFFER + h$1.MTIME, t4.mtime.getTime(), true), this.setResultLength(h$1.TOTAL);
  }
  decodeStat() {
    return { isFile: this.uint8View[i3.DATA_BUFFER + h$1.IS_FILE] === 1, isDirectory: this.uint8View[i3.DATA_BUFFER + h$1.IS_DIRECTORY] === 1, isSymbolicLink: this.uint8View[i3.DATA_BUFFER + h$1.IS_SYMLINK] === 1, mode: this.dataView.getInt32(i3.DATA_BUFFER + h$1.MODE, true), size: this.dataView.getFloat64(i3.DATA_BUFFER + h$1.SIZE, true), mtime: new Date(this.dataView.getFloat64(i3.DATA_BUFFER + h$1.MTIME, true)) };
  }
  waitForReady(t4) {
    return Atomics.wait(this.int32View, i3.STATUS / 4, n2.PENDING, t4);
  }
  waitForReadyAsync(t4) {
    return Atomics.waitAsync(this.int32View, i3.STATUS / 4, n2.PENDING, t4);
  }
  async waitUntilReady(t4) {
    let e5 = Date.now();
    for (; ; ) {
      let s3 = this.getStatus();
      if (s3 === n2.READY) return true;
      let o2 = Date.now() - e5;
      if (o2 >= t4) return false;
      let l3 = t4 - o2, d3 = Atomics.waitAsync(this.int32View, i3.STATUS / 4, s3, l3);
      if (d3.async && await d3.value === "timed-out") return false;
    }
  }
  waitForResult(t4) {
    return Atomics.wait(this.int32View, i3.STATUS / 4, n2.READY, t4);
  }
  notify() {
    return Atomics.notify(this.int32View, i3.STATUS / 4);
  }
  reset() {
    this.setOpCode(a2.NOOP), this.setStatus(n2.PENDING), this.setPathLength(0), this.setDataLength(0), this.setResultLength(0), this.setErrorCode(u$1.NONE), this.setFlags(R.NONE), this.setMode(0);
  }
};
var A = class {
  fs;
  cwd;
  secureFetch;
  protocol;
  running = false;
  output = { stdout: "", stderr: "", exitCode: 0 };
  constructor(t4, e5, s3, o2 = void 0) {
    this.fs = e5, this.cwd = s3, this.secureFetch = o2, this.protocol = new w$1(t4);
  }
  async run(t4) {
    this.running = true;
    let e5 = Date.now();
    for (; this.running; ) {
      let s3 = Date.now() - e5;
      if (s3 >= t4) {
        this.output.stderr += `
python3: execution timeout exceeded
`, this.output.exitCode = 124;
        break;
      }
      let o2 = t4 - s3;
      if (!await this.protocol.waitUntilReady(o2)) {
        this.output.stderr += `
python3: execution timeout exceeded
`, this.output.exitCode = 124;
        break;
      }
      let d3 = this.protocol.getOpCode();
      await this.handleOperation(d3), this.protocol.notify();
    }
    return this.output;
  }
  stop() {
    this.running = false;
  }
  async handleOperation(t4) {
    try {
      switch (t4) {
        case a2.READ_FILE:
          await this.handleReadFile();
          break;
        case a2.WRITE_FILE:
          await this.handleWriteFile();
          break;
        case a2.STAT:
          await this.handleStat();
          break;
        case a2.LSTAT:
          await this.handleLstat();
          break;
        case a2.READDIR:
          await this.handleReaddir();
          break;
        case a2.MKDIR:
          await this.handleMkdir();
          break;
        case a2.RM:
          await this.handleRm();
          break;
        case a2.EXISTS:
          await this.handleExists();
          break;
        case a2.APPEND_FILE:
          await this.handleAppendFile();
          break;
        case a2.SYMLINK:
          await this.handleSymlink();
          break;
        case a2.READLINK:
          await this.handleReadlink();
          break;
        case a2.CHMOD:
          await this.handleChmod();
          break;
        case a2.REALPATH:
          await this.handleRealpath();
          break;
        case a2.WRITE_STDOUT:
          this.handleWriteStdout();
          break;
        case a2.WRITE_STDERR:
          this.handleWriteStderr();
          break;
        case a2.EXIT:
          this.handleExit();
          break;
        case a2.HTTP_REQUEST:
          await this.handleHttpRequest();
          break;
        default:
          this.protocol.setErrorCode(u$1.IO_ERROR), this.protocol.setStatus(n2.ERROR);
      }
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  resolvePath(t4) {
    return t4.startsWith("/mnt/host/") ? t4.slice(9) : t4.startsWith("/mnt/host") ? t4.slice(9) || "/" : this.fs.resolvePath(this.cwd, t4);
  }
  async handleReadFile() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.readFileBuffer(t4);
      this.protocol.setResult(e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleWriteFile() {
    let t4 = this.resolvePath(this.protocol.getPath()), e5 = this.protocol.getData();
    try {
      await this.fs.writeFile(t4, e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (s3) {
      this.setErrorFromException(s3);
    }
  }
  async handleStat() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.stat(t4);
      this.protocol.encodeStat(e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleLstat() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.lstat(t4);
      this.protocol.encodeStat(e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleReaddir() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.readdir(t4);
      this.protocol.setResultFromString(JSON.stringify(e5)), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleMkdir() {
    let t4 = this.resolvePath(this.protocol.getPath()), s3 = (this.protocol.getFlags() & R.MKDIR_RECURSIVE) !== 0;
    try {
      await this.fs.mkdir(t4, { recursive: s3 }), this.protocol.setStatus(n2.SUCCESS);
    } catch (o2) {
      this.setErrorFromException(o2);
    }
  }
  async handleRm() {
    let t4 = this.resolvePath(this.protocol.getPath()), e5 = this.protocol.getFlags(), s3 = (e5 & R.RECURSIVE) !== 0, o2 = (e5 & R.FORCE) !== 0;
    try {
      await this.fs.rm(t4, { recursive: s3, force: o2 }), this.protocol.setStatus(n2.SUCCESS);
    } catch (l3) {
      this.setErrorFromException(l3);
    }
  }
  async handleExists() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.exists(t4);
      this.protocol.setResult(new Uint8Array([e5 ? 1 : 0])), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleAppendFile() {
    let t4 = this.resolvePath(this.protocol.getPath()), e5 = this.protocol.getData();
    try {
      await this.fs.appendFile(t4, e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (s3) {
      this.setErrorFromException(s3);
    }
  }
  async handleSymlink() {
    let t4 = this.protocol.getPath(), e5 = this.protocol.getDataAsString(), s3 = this.resolvePath(t4);
    try {
      await this.fs.symlink(e5, s3), this.protocol.setStatus(n2.SUCCESS);
    } catch (o2) {
      this.setErrorFromException(o2);
    }
  }
  async handleReadlink() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.readlink(t4);
      this.protocol.setResultFromString(e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  async handleChmod() {
    let t4 = this.resolvePath(this.protocol.getPath()), e5 = this.protocol.getMode();
    try {
      await this.fs.chmod(t4, e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (s3) {
      this.setErrorFromException(s3);
    }
  }
  async handleRealpath() {
    let t4 = this.resolvePath(this.protocol.getPath());
    try {
      let e5 = await this.fs.realpath(t4);
      this.protocol.setResultFromString(e5), this.protocol.setStatus(n2.SUCCESS);
    } catch (e5) {
      this.setErrorFromException(e5);
    }
  }
  handleWriteStdout() {
    let t4 = this.protocol.getDataAsString();
    this.output.stdout += t4, this.protocol.setStatus(n2.SUCCESS);
  }
  handleWriteStderr() {
    let t4 = this.protocol.getDataAsString();
    this.output.stderr += t4, this.protocol.setStatus(n2.SUCCESS);
  }
  handleExit() {
    let t4 = this.protocol.getFlags();
    this.output.exitCode = t4, this.protocol.setStatus(n2.SUCCESS), this.running = false;
  }
  async handleHttpRequest() {
    if (!this.secureFetch) {
      this.protocol.setErrorCode(u$1.NETWORK_NOT_CONFIGURED), this.protocol.setResultFromString("Network access not configured. Enable network in Bash options."), this.protocol.setStatus(n2.ERROR);
      return;
    }
    let t4 = this.protocol.getPath(), e5 = this.protocol.getDataAsString();
    try {
      let s3 = e5 ? JSON.parse(e5) : {}, o2 = await this.secureFetch(t4, { method: s3.method, headers: s3.headers, body: s3.body }), l3 = JSON.stringify({ status: o2.status, statusText: o2.statusText, headers: o2.headers, body: o2.body, url: o2.url });
      this.protocol.setResultFromString(l3), this.protocol.setStatus(n2.SUCCESS);
    } catch (s3) {
      let o2 = s3 instanceof Error ? s3.message : String(s3);
      this.protocol.setErrorCode(u$1.NETWORK_ERROR), this.protocol.setResultFromString(o2), this.protocol.setStatus(n2.ERROR);
    }
  }
  setErrorFromException(t4) {
    let e5 = t4 instanceof Error ? t4.message : String(t4), s3 = u$1.IO_ERROR, o2 = e5.toLowerCase();
    o2.includes("no such file") || o2.includes("not found") || o2.includes("enoent") ? s3 = u$1.NOT_FOUND : o2.includes("is a directory") || o2.includes("eisdir") ? s3 = u$1.IS_DIRECTORY : o2.includes("not a directory") || o2.includes("enotdir") ? s3 = u$1.NOT_DIRECTORY : o2.includes("already exists") || o2.includes("eexist") ? s3 = u$1.EXISTS : (o2.includes("permission") || o2.includes("eperm") || o2.includes("eacces")) && (s3 = u$1.PERMISSION_DENIED), this.protocol.setErrorCode(s3), this.protocol.setResultFromString(e5), this.protocol.setStatus(n2.ERROR);
  }
};
var N = 3e4, V3 = { name: "python3", summary: "Execute Python code via Pyodide", usage: "python3 [OPTIONS] [-c CODE | -m MODULE | FILE] [ARGS...]", description: ["Execute Python code using Pyodide (Python compiled to WebAssembly).", "", "This command runs Python in a sandboxed environment with access to", "the virtual filesystem. Only Pyodide-bundled packages are available."], options: ["-c CODE     Execute CODE as Python script", "-m MODULE   Run library module as a script", "--version   Show Python version", "--help      Show this help"], examples: ['python3 -c "print(1 + 2)"', 'python3 -c "import sys; print(sys.version)"', "python3 script.py", "python3 script.py arg1 arg2", `echo 'print("hello")' | python3`], notes: ["Pyodide runs in WebAssembly, so execution may be slower than native Python.", "Only packages bundled with Pyodide are available (no pip install).", "First execution loads Pyodide (~30MB), subsequent calls are faster.", "Maximum execution time is 30 seconds by default."] };
function k2(r2) {
  let t4 = { code: null, module: null, scriptFile: null, showVersion: false, scriptArgs: [] };
  if (r2.length === 0) return t4;
  let e5 = r2.findIndex((s3) => !s3.startsWith("-") || s3 === "-" || s3 === "--");
  for (let s3 = 0; s3 < (e5 === -1 ? r2.length : e5); s3++) {
    let o2 = r2[s3];
    if (o2 === "-c") return s3 + 1 >= r2.length ? { stdout: "", stderr: `python3: option requires an argument -- 'c'
`, exitCode: 2 } : (t4.code = r2[s3 + 1], t4.scriptArgs = r2.slice(s3 + 2), t4);
    if (o2 === "-m") return s3 + 1 >= r2.length ? { stdout: "", stderr: `python3: option requires an argument -- 'm'
`, exitCode: 2 } : (t4.module = r2[s3 + 1], t4.scriptArgs = r2.slice(s3 + 2), t4);
    if (o2 === "--version" || o2 === "-V") return t4.showVersion = true, t4;
    if (o2.startsWith("-") && o2 !== "-") return { stdout: "", stderr: `python3: unrecognized option '${o2}'
`, exitCode: 2 };
  }
  if (e5 !== -1) {
    let s3 = r2[e5];
    s3 === "--" ? e5 + 1 < r2.length && (t4.scriptFile = r2[e5 + 1], t4.scriptArgs = r2.slice(e5 + 2)) : (t4.scriptFile = s3, t4.scriptArgs = r2.slice(e5 + 1));
  }
  return t4;
}
var c$1 = null, F$1 = null, S$1 = [], E$1 = null, M3 = fileURLToPath(new URL("./worker.js", import.meta.url));
function O$1() {
  if (E$1 || S$1.length === 0) return;
  let r2 = S$1.shift();
  if (!r2) return;
  E$1 = r2, b3().postMessage(E$1.input);
}
function b3() {
  return F$1 && (clearTimeout(F$1), F$1 = null), c$1 || (c$1 = new Worker(M3), c$1.on("message", (r2) => {
    E$1 && (E$1.resolve(r2), E$1 = null), S$1.length > 0 ? O$1() : B();
  }), c$1.on("error", (r2) => {
    E$1 && (E$1.resolve({ success: false, error: r2.message }), E$1 = null);
    for (let t4 of S$1) t4.resolve({ success: false, error: "Worker crashed" });
    S$1.length = 0, c$1 = null;
  }), c$1.on("exit", () => {
    c$1 = null;
  }), c$1);
}
function B() {
  F$1 = setTimeout(() => {
    c$1 && !E$1 && S$1.length === 0 && (c$1.terminate(), c$1 = null);
  }, 5e3);
}
async function v(r2, t4, e5, s3 = []) {
  let o2 = C(), l3 = new A(o2, t4.fs, t4.cwd, t4.fetch), d3 = t4.limits?.maxPythonTimeoutMs ?? N, f3 = { sharedBuffer: o2, pythonCode: r2, cwd: t4.cwd, env: t4.env, args: s3, scriptPath: e5 }, _4 = new Promise((T3) => {
    let P2 = setTimeout(() => {
      T3({ success: false, error: `Execution timeout: exceeded ${d3}ms limit` });
    }, d3), I2 = (U2) => {
      clearTimeout(P2), T3(U2);
    };
    S$1.push({ input: f3, resolve: I2 }), O$1();
  }), [m3, g2] = await Promise.all([l3.run(d3), _4.catch((T3) => ({ success: false, error: T3.message }))]);
  return !g2.success && g2.error ? { stdout: m3.stdout, stderr: `${m3.stderr}python3: ${g2.error}
`, exitCode: m3.exitCode || 1 } : m3;
}
var H = { name: "python3", async execute(r2, t4) {
  if (o$3(r2)) return s$1(V3);
  let e5 = k2(r2);
  if ("exitCode" in e5) return e5;
  if (e5.showVersion) return { stdout: `Python 3.12.1 (Pyodide)
`, stderr: "", exitCode: 0 };
  let s3, o2;
  if (e5.code !== null) s3 = e5.code, o2 = "-c";
  else if (e5.module !== null) s3 = `import runpy; runpy.run_module('${e5.module}', run_name='__main__')`, o2 = e5.module;
  else if (e5.scriptFile !== null) {
    let l3 = t4.fs.resolvePath(t4.cwd, e5.scriptFile);
    if (!await t4.fs.exists(l3)) return { stdout: "", stderr: `python3: can't open file '${e5.scriptFile}': [Errno 2] No such file or directory
`, exitCode: 2 };
    try {
      s3 = await t4.fs.readFile(l3), o2 = e5.scriptFile;
    } catch (d3) {
      return { stdout: "", stderr: `python3: can't open file '${e5.scriptFile}': ${d3.message}
`, exitCode: 2 };
    }
  } else if (t4.stdin.trim()) s3 = t4.stdin, o2 = "<stdin>";
  else return { stdout: "", stderr: `python3: no input provided (use -c CODE, -m MODULE, or provide a script file)
`, exitCode: 2 };
  return v(s3, t4, o2, e5.scriptArgs);
} }, J2 = { name: "python", async execute(r2, t4) {
  return H.execute(r2, t4);
} };
const python33OP7EKER = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  python3Command: H,
  pythonCommand: J2
});
function u2(s3) {
  let t4 = s3.indexOf("=");
  if (t4 >= 0) {
    let r2 = s3.slice(0, t4), e5 = s3.slice(t4 + 1);
    return r2 ? `${encodeURIComponent(r2)}=${encodeURIComponent(e5)}` : encodeURIComponent(e5);
  }
  return encodeURIComponent(s3);
}
function c2(s3) {
  let t4 = s3.indexOf("=");
  if (t4 < 0) return null;
  let r2 = s3.slice(0, t4), e5 = s3.slice(t4 + 1), i4, a3, o2 = e5.match(/;type=([^;]+)$/);
  o2 && (a3 = o2[1], e5 = e5.slice(0, -o2[0].length));
  let n3 = e5.match(/;filename=([^;]+)/);
  return n3 && (i4 = n3[1], e5 = e5.replace(n3[0], "")), (e5.startsWith("@") || e5.startsWith("<")) && (i4 = i4 ?? e5.slice(1).split("/").pop()), { name: r2, value: e5, filename: i4, contentType: a3 };
}
function w3(s3, t4) {
  let r2 = `----CurlFormBoundary${Date.now().toString(36)}`, e5 = [];
  for (let i4 of s3) {
    let a3 = i4.value;
    if (a3.startsWith("@") || a3.startsWith("<")) {
      let n3 = a3.slice(1);
      a3 = t4.get(n3) ?? "";
    }
    let o2 = `--${r2}\r
`;
    i4.filename ? (o2 += `Content-Disposition: form-data; name="${i4.name}"; filename="${i4.filename}"\r
`, i4.contentType && (o2 += `Content-Type: ${i4.contentType}\r
`)) : o2 += `Content-Disposition: form-data; name="${i4.name}"\r
`, o2 += `\r
${a3}\r
`, e5.push(o2);
  }
  return e5.push(`--${r2}--\r
`), { body: e5.join(""), boundary: r2 };
}
var O = { name: "curl", summary: "transfer a URL", usage: "curl [OPTIONS] URL", options: ["-X, --request METHOD  HTTP method (GET, POST, PUT, DELETE, etc.)", "-H, --header HEADER   Add header (can be used multiple times)", "-d, --data DATA       HTTP POST data", "    --data-raw DATA   HTTP POST data (no @ interpretation)", "    --data-binary DATA  HTTP POST binary data", "    --data-urlencode DATA  URL-encode and POST data", "-F, --form NAME=VALUE  Multipart form data", "-u, --user USER:PASS  HTTP authentication", "-A, --user-agent STR  Set User-Agent header", "-e, --referer URL     Set Referer header", "-b, --cookie DATA     Send cookies (name=value or @file)", "-c, --cookie-jar FILE Save cookies to file", "-T, --upload-file FILE  Upload file (PUT)", "-o, --output FILE     Write output to file", "-O, --remote-name     Write to file named from URL", "-I, --head            Show headers only (HEAD request)", "-i, --include         Include response headers in output", "-s, --silent          Silent mode (no progress)", "-S, --show-error      Show errors even when silent", "-f, --fail            Fail silently on HTTP errors (no output)", "-L, --location        Follow redirects (default)", "    --max-redirs NUM  Maximum redirects (default: 20)", "-m, --max-time SECS   Maximum time for request", "    --connect-timeout SECS  Connection timeout", "-w, --write-out FMT   Output format after completion", "-v, --verbose         Verbose output", "    --help            Display this help and exit", "", "Note: Network access must be configured via BashEnv network option.", "      curl is not available by default for security reasons."] };
function S2(s3) {
  let t4 = { method: "GET", headers: {}, dataBinary: false, formFields: [], useRemoteName: false, headOnly: false, includeHeaders: false, silent: false, showError: false, failSilently: false, followRedirects: true, verbose: false };
  for (let r2 = 0; r2 < s3.length; r2++) {
    let e5 = s3[r2];
    if (e5 === "-X" || e5 === "--request") t4.method = s3[++r2] ?? "GET";
    else if (e5.startsWith("-X")) t4.method = e5.slice(2);
    else if (e5.startsWith("--request=")) t4.method = e5.slice(10);
    else if (e5 === "-H" || e5 === "--header") {
      let i4 = s3[++r2];
      if (i4) {
        let a3 = i4.indexOf(":");
        if (a3 > 0) {
          let o2 = i4.slice(0, a3).trim(), n3 = i4.slice(a3 + 1).trim();
          t4.headers[o2] = n3;
        }
      }
    } else if (e5.startsWith("--header=")) {
      let i4 = e5.slice(9), a3 = i4.indexOf(":");
      if (a3 > 0) {
        let o2 = i4.slice(0, a3).trim(), n3 = i4.slice(a3 + 1).trim();
        t4.headers[o2] = n3;
      }
    } else if (e5 === "-d" || e5 === "--data" || e5 === "--data-raw") t4.data = s3[++r2] ?? "", t4.method === "GET" && (t4.method = "POST");
    else if (e5.startsWith("-d")) t4.data = e5.slice(2), t4.method === "GET" && (t4.method = "POST");
    else if (e5.startsWith("--data=")) t4.data = e5.slice(7), t4.method === "GET" && (t4.method = "POST");
    else if (e5.startsWith("--data-raw=")) t4.data = e5.slice(11), t4.method === "GET" && (t4.method = "POST");
    else if (e5 === "--data-binary") t4.data = s3[++r2] ?? "", t4.dataBinary = true, t4.method === "GET" && (t4.method = "POST");
    else if (e5.startsWith("--data-binary=")) t4.data = e5.slice(14), t4.dataBinary = true, t4.method === "GET" && (t4.method = "POST");
    else if (e5 === "--data-urlencode") {
      let i4 = s3[++r2] ?? "";
      t4.data = (t4.data ? `${t4.data}&` : "") + u2(i4), t4.method === "GET" && (t4.method = "POST");
    } else if (e5.startsWith("--data-urlencode=")) {
      let i4 = e5.slice(17);
      t4.data = (t4.data ? `${t4.data}&` : "") + u2(i4), t4.method === "GET" && (t4.method = "POST");
    } else if (e5 === "-F" || e5 === "--form") {
      let i4 = s3[++r2] ?? "", a3 = c2(i4);
      a3 && t4.formFields.push(a3), t4.method === "GET" && (t4.method = "POST");
    } else if (e5.startsWith("--form=")) {
      let i4 = e5.slice(7), a3 = c2(i4);
      a3 && t4.formFields.push(a3), t4.method === "GET" && (t4.method = "POST");
    } else if (e5 === "-u" || e5 === "--user") t4.user = s3[++r2];
    else if (e5.startsWith("-u")) t4.user = e5.slice(2);
    else if (e5.startsWith("--user=")) t4.user = e5.slice(7);
    else if (e5 === "-A" || e5 === "--user-agent") t4.headers["User-Agent"] = s3[++r2] ?? "";
    else if (e5.startsWith("-A")) t4.headers["User-Agent"] = e5.slice(2);
    else if (e5.startsWith("--user-agent=")) t4.headers["User-Agent"] = e5.slice(13);
    else if (e5 === "-e" || e5 === "--referer") t4.headers.Referer = s3[++r2] ?? "";
    else if (e5.startsWith("-e")) t4.headers.Referer = e5.slice(2);
    else if (e5.startsWith("--referer=")) t4.headers.Referer = e5.slice(10);
    else if (e5 === "-b" || e5 === "--cookie") t4.headers.Cookie = s3[++r2] ?? "";
    else if (e5.startsWith("-b")) t4.headers.Cookie = e5.slice(2);
    else if (e5.startsWith("--cookie=")) t4.headers.Cookie = e5.slice(9);
    else if (e5 === "-c" || e5 === "--cookie-jar") t4.cookieJar = s3[++r2];
    else if (e5.startsWith("--cookie-jar=")) t4.cookieJar = e5.slice(13);
    else if (e5 === "-T" || e5 === "--upload-file") t4.uploadFile = s3[++r2], t4.method === "GET" && (t4.method = "PUT");
    else if (e5.startsWith("--upload-file=")) t4.uploadFile = e5.slice(14), t4.method === "GET" && (t4.method = "PUT");
    else if (e5 === "-m" || e5 === "--max-time") {
      let i4 = parseFloat(s3[++r2] ?? "0");
      !Number.isNaN(i4) && i4 > 0 && (t4.timeoutMs = i4 * 1e3);
    } else if (e5.startsWith("--max-time=")) {
      let i4 = parseFloat(e5.slice(11));
      !Number.isNaN(i4) && i4 > 0 && (t4.timeoutMs = i4 * 1e3);
    } else if (e5 === "--connect-timeout") {
      let i4 = parseFloat(s3[++r2] ?? "0");
      !Number.isNaN(i4) && i4 > 0 && t4.timeoutMs === void 0 && (t4.timeoutMs = i4 * 1e3);
    } else if (e5.startsWith("--connect-timeout=")) {
      let i4 = parseFloat(e5.slice(18));
      !Number.isNaN(i4) && i4 > 0 && t4.timeoutMs === void 0 && (t4.timeoutMs = i4 * 1e3);
    } else if (e5 === "-o" || e5 === "--output") t4.outputFile = s3[++r2];
    else if (e5.startsWith("--output=")) t4.outputFile = e5.slice(9);
    else if (e5 === "-O" || e5 === "--remote-name") t4.useRemoteName = true;
    else if (e5 === "-I" || e5 === "--head") t4.headOnly = true, t4.method = "HEAD";
    else if (e5 === "-i" || e5 === "--include") t4.includeHeaders = true;
    else if (e5 === "-s" || e5 === "--silent") t4.silent = true;
    else if (e5 === "-S" || e5 === "--show-error") t4.showError = true;
    else if (e5 === "-f" || e5 === "--fail") t4.failSilently = true;
    else if (e5 === "-L" || e5 === "--location") t4.followRedirects = true;
    else if (e5 === "--max-redirs") r2++;
    else if (!e5.startsWith("--max-redirs=")) if (e5 === "-w" || e5 === "--write-out") t4.writeOut = s3[++r2];
    else if (e5.startsWith("--write-out=")) t4.writeOut = e5.slice(12);
    else if (e5 === "-v" || e5 === "--verbose") t4.verbose = true;
    else {
      if (e5.startsWith("--") && e5 !== "--") return r$3("curl", e5);
      if (e5.startsWith("-") && e5 !== "-") for (let i4 of e5.slice(1)) switch (i4) {
        case "s":
          t4.silent = true;
          break;
        case "S":
          t4.showError = true;
          break;
        case "f":
          t4.failSilently = true;
          break;
        case "L":
          t4.followRedirects = true;
          break;
        case "I":
          t4.headOnly = true, t4.method = "HEAD";
          break;
        case "i":
          t4.includeHeaders = true;
          break;
        case "O":
          t4.useRemoteName = true;
          break;
        case "v":
          t4.verbose = true;
          break;
        default:
          return r$3("curl", `-${i4}`);
      }
      else e5.startsWith("-") || (t4.url = e5);
    }
  }
  return t4;
}
function h2(s3) {
  return Object.entries(s3).map(([t4, r2]) => `${t4}: ${r2}`).join(`\r
`);
}
function E(s3) {
  try {
    return new URL(s3).pathname.split("/").pop() || "index.html";
  } catch {
    return "index.html";
  }
}
function m2(s3, t4) {
  let r2 = s3;
  return r2 = r2.replace(/%\{http_code\}/g, String(t4.status)), r2 = r2.replace(/%\{content_type\}/g, t4.headers["content-type"] || ""), r2 = r2.replace(/%\{url_effective\}/g, t4.url), r2 = r2.replace(/%\{size_download\}/g, String(t4.bodyLength)), r2 = r2.replace(/\\n/g, `
`), r2;
}
async function F(s3, t4) {
  if (s3.uploadFile) {
    let r2 = t4.fs.resolvePath(t4.cwd, s3.uploadFile);
    return { body: await t4.fs.readFile(r2) };
  }
  if (s3.formFields.length > 0) {
    let r2 = /* @__PURE__ */ new Map();
    for (let a3 of s3.formFields) if (a3.value.startsWith("@") || a3.value.startsWith("<")) {
      let o2 = t4.fs.resolvePath(t4.cwd, a3.value.slice(1));
      try {
        let n3 = await t4.fs.readFile(o2);
        r2.set(a3.value.slice(1), n3);
      } catch {
        r2.set(a3.value.slice(1), "");
      }
    }
    let { body: e5, boundary: i4 } = w3(s3.formFields, r2);
    return { body: e5, contentType: `multipart/form-data; boundary=${i4}` };
  }
  return s3.data !== void 0 ? { body: s3.data } : {};
}
function P(s3, t4) {
  let r2 = { ...s3.headers };
  if (s3.user) {
    let e5 = Buffer.from(s3.user).toString("base64");
    r2.Authorization = `Basic ${e5}`;
  }
  return t4 && !r2["Content-Type"] && (r2["Content-Type"] = t4), r2;
}
async function W3(s3, t4, r2) {
  if (!s3.cookieJar) return;
  let e5 = t4["set-cookie"];
  if (!e5) return;
  let i4 = r2.fs.resolvePath(r2.cwd, s3.cookieJar);
  await r2.fs.writeFile(i4, e5);
}
function $4(s3, t4, r2) {
  let e5 = "";
  if (s3.verbose) {
    e5 += `> ${s3.method} ${r2}
`;
    for (let [i4, a3] of Object.entries(s3.headers)) e5 += `> ${i4}: ${a3}
`;
    e5 += `>
`, e5 += `< HTTP/1.1 ${t4.status} ${t4.statusText}
`;
    for (let [i4, a3] of Object.entries(t4.headers)) e5 += `< ${i4}: ${a3}
`;
    e5 += `<
`;
  }
  return s3.includeHeaders && !s3.verbose && (e5 += `HTTP/1.1 ${t4.status} ${t4.statusText}\r
`, e5 += h2(t4.headers), e5 += `\r
\r
`), s3.headOnly ? s3.includeHeaders || s3.verbose || (e5 += `HTTP/1.1 ${t4.status} ${t4.statusText}\r
`, e5 += h2(t4.headers), e5 += `\r
`) : e5 += t4.body, s3.writeOut && (e5 += m2(s3.writeOut, { status: t4.status, headers: t4.headers, url: t4.url, bodyLength: t4.body.length })), e5;
}
var I = { name: "curl", async execute(s3, t4) {
  if (o$3(s3)) return s$1(O);
  let r2 = S2(s3);
  if ("exitCode" in r2) return r2;
  let e5 = r2;
  if (!e5.url) return { stdout: "", stderr: `curl: no URL specified
`, exitCode: 2 };
  if (!t4.fetch) return { stdout: "", stderr: `curl: internal error: fetch not available
`, exitCode: 1 };
  let i4 = e5.url;
  i4.match(/^https?:\/\//) || (i4 = `https://${i4}`);
  try {
    let { body: a3, contentType: o2 } = await F(e5, t4), n3 = P(e5, o2), l3 = await t4.fetch(i4, { method: e5.method, headers: Object.keys(n3).length > 0 ? n3 : void 0, body: a3, followRedirects: e5.followRedirects, timeoutMs: e5.timeoutMs });
    if (await W3(e5, l3.headers, t4), e5.failSilently && l3.status >= 400) return { stdout: "", stderr: e5.showError || !e5.silent ? `curl: (22) The requested URL returned error: ${l3.status}
` : "", exitCode: 22 };
    let d3 = $4(e5, l3, i4);
    if (e5.outputFile || e5.useRemoteName) {
      let p3 = e5.outputFile || E(i4), v2 = t4.fs.resolvePath(t4.cwd, p3);
      await t4.fs.writeFile(v2, e5.headOnly ? "" : l3.body), e5.verbose || (d3 = ""), e5.writeOut && (d3 = m2(e5.writeOut, { status: l3.status, headers: l3.headers, url: l3.url, bodyLength: l3.body.length }));
    }
    return { stdout: d3, stderr: "", exitCode: 0 };
  } catch (a3) {
    let o2 = n$5(a3), n3 = 1;
    return o2.includes("Network access denied") ? n3 = 7 : o2.includes("HTTP method") && o2.includes("not allowed") ? n3 = 3 : o2.includes("Redirect target not in allow-list") || o2.includes("Too many redirects") ? n3 = 47 : o2.includes("aborted") && (n3 = 28), { stdout: "", stderr: !e5.silent || e5.showError ? `curl: (${n3}) ${o2}
` : "", exitCode: n3 };
  }
} };
const curlXLP4VABU = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  curlCommand: I
});
const expansionRIGCFEMA = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  escapeGlobChars: U$8,
  escapeRegexChars: Et$3,
  expandRedirectTarget: cl$1,
  expandWord: wt$5,
  expandWordForPattern: ll$1,
  expandWordForRegex: ol$1,
  expandWordWithGlob: ul$1,
  getArrayElements: P$g,
  getVariable: v$b,
  hasQuotedMultiValueAt: Ms$1,
  isArray: ye$5,
  isWordFullyQuoted: al$1
});
const xanViewDMFUMZG7 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  cmdFlatten: S$3,
  cmdView: W$2
});
export {
  Pe$4 as P
};
